<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/images/manifest.json">




  <meta name="keywords" content="note," />





  <link rel="alternate" href="/atom.xml" title="Hong's Blog" type="application/atom+xml" />






<meta name="description" content="Python是完全面向对象的语言，函数，模块，数字，字符串都是对象。 Python的值不用定义类型，直接赋值即可使用。（因为任何数据都是对象，包括数字。所以变量赋值就是把对象关联起来。每一次变量重新赋值，并没有改变对象的值，只是新创建了一个新对象，并用变量指向它。）  布尔值为True，False。为False的情况： 数字0（包括0.0），空字符串，None（None是Python里的一个特殊值">
<meta property="og:type" content="article">
<meta property="og:title" content="Python学习笔记1">
<meta property="og:url" content="https://fzy-line.github.io/2020/02/17/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/index.html">
<meta property="og:site_name" content="Hong&#39;s Blog">
<meta property="og:description" content="Python是完全面向对象的语言，函数，模块，数字，字符串都是对象。 Python的值不用定义类型，直接赋值即可使用。（因为任何数据都是对象，包括数字。所以变量赋值就是把对象关联起来。每一次变量重新赋值，并没有改变对象的值，只是新创建了一个新对象，并用变量指向它。）  布尔值为True，False。为False的情况： 数字0（包括0.0），空字符串，None（None是Python里的一个特殊值">
<meta property="article:published_time" content="2020-02-17T03:12:38.000Z">
<meta property="article:modified_time" content="2020-02-17T06:18:56.256Z">
<meta property="article:author" content="Hong">
<meta property="article:tag" content="note">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://fzy-line.github.io/2020/02/17/Python学习笔记1/"/>





  <title>Python学习笔记1 | Hong's Blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hong's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Like life,like coding</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://fzy-line.github.io/2020/02/17/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/03.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python学习笔记1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-17T11:12:38+08:00">
                2020-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Python是完全面向对象的语言，函数，模块，数字，字符串都是对象。</p>
<p>Python的值不用定义类型，直接赋值即可使用。（因为任何数据都是对象，包括数字。所以变量赋值就是把对象关联起来。每一次变量重新赋值，并没有改变对象的值，只是新创建了一个新对象，并用变量指向它。）</p>
<p> 布尔值为True，False。为False的情况：</p>
<p>数字0（包括0.0），空字符串，None（None是Python里的一个特殊值，表示空值），</p>
<p>空集合,包括( ) , [ ] , { }    其他值都认为是True</p>
<p>变量名不能以 双下划线开头（这类标识符具有特殊意义，如： _<em>init_</em>( ) 代表类的构造函数）</p>
<p>同时只能由数字，字母，下划线组成。其他符号都不行。</p>
<a id="more"></a>

<p>算术运算符：</p>
<p>‘la ‘  *  3 =  ‘la la la ‘</p>
<p>10 / 3 = 3.3333(普通的除）        10 // 3 = 3(取整，跟java的一样）</p>
<p>3**2 = 3^2 = 9</p>
<p>关系运算符，对于字符串，从左到右比较字符。</p>
<p>‘z’ &gt; ‘a’ &gt; ‘Z’ &gt; ‘A’</p>
<p>逻辑运算符：not ， and， or</p>
<p>在字符串前面加u，表示Unicode编码。    u’asdczx’</p>
<p>id( )：输出变量的地址。</p>
<p>当x = y,二者就指向了同一个地址，此时  x is y  返回True。 x is not y 返回False</p>
<p>print可以有占位符。</p>
<p>例子：</p>
<p>“X’s address is : %d”    此时%d就是普通的字符串，但如同在后面增加value</p>
<p>“X’s address is : %d” %(id(x))        那么%d就会被  id(x) 所替换。</p>
<p>类型转换：</p>
<p>字符串转数字： int(x), long(x), float(x)    都有第二个可选参数，表进制。</p>
<p>eval(“..”)    计算字符串里的表达式。例子：eval(‘4+2’) 输出6</p>
<p>数字转字符串：str(x)</p>
<p>repr(obj)    将对象转换为可打印的字符串</p>
<p>chr(整数）将一个整数转换为ASCII字符。    ord（字符） 将一个ASCII字符进行转换为整数</p>
<p>hex（）整数转16进制        oct（） 转8进制</p>
<p>访问字符串某下标： [ ]</p>
<p>“asdefg”[3] = ‘e’    index从0开始。</p>
<p>截取子字段：[a : b]     获取index从a开始，到b-1的字串。</p>
<p>如果用 a - b，会将a - b计算出结果，然后再获取。如果是负数，则从后面算起。-1是最后一个。</p>
<p>范围是： [-length ~ length - 1]    a[-length]  ==  a[0]        [-1]  ==  a[length - 1]</p>
<p>in ， not in    某字符/字符串是否存在于该字符串中</p>
<p>r”asdzxc\nsdew” 使得\n这种转义符失效，成为普通字符串。R同理。这个例子要在print里生效。</p>
<p>-—</p>
<p>Python对于缩进是有限制的，错误的缩进会报错。</p>
<p>（CMD中写Python，tab第一次是4个空格，后面是8个空格，容易出错。）</p>
<p>例如if语句：</p>
<p>if a &gt; 10:    </p>
<p>print(“xxx”);        //如果不缩进，会报错</p>
<p>如果if中有多个语句，这些语句都要有相同的缩进。在cmd中，也要缩进，以一个空行结束if体。</p>
<p>elif    ：    相当于else if</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">15</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">20</span>:</span><br><span class="line">    print(<span class="string">"zz"</span>)</span><br><span class="line"><span class="keyword">elif</span> a &gt; <span class="number">15</span>:</span><br><span class="line">    print(<span class="string">"xx"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"cc"</span>)</span><br></pre></td></tr></table></figure>

<p>while语句:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    sum += i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">print(i)</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>

<p>for语句：   for i in range(start, end):    &lt;==&gt; for (int i = start; i &lt; end; i++) s</p>
<p>​        循环体</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">sum1 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">	sum1 += i</span><br><span class="line">print(i)		<span class="comment"># 100</span></span><br><span class="line">print(sum1)		<span class="comment"># 5050</span></span><br></pre></td></tr></table></figure>

<p>(这里前面i定义与否都可以，但不定义的话，print(i)里会有warning，但还是可以运行的。</p>
<p>try-except语句</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    i = <span class="number">10</span></span><br><span class="line">    print(<span class="number">30</span> / (i - <span class="number">10</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	print(<span class="string">"Finished execute!"</span>)</span><br></pre></td></tr></table></figure>

<p>raise 可以显式抛出异常（相当于throw）</p>
<p>——–数据结构</p>
<p>1.列表List    （跟数组差不多，index从0开始）</p>
<p>定义一个list：    a = [ ]</p>
<p>len( ) 输出长度    append添加到最后        index(i, element)    插入到index为i处</p>
<p>a1.extends(a2)    将a2的元素全部添加到a1中</p>
<p>效果等同于：  a1 = a1 + a2</p>
<p>PS:使用加号运算符，会导致a1的内存地址改变。（即a1指向了新的内存地址）</p>
<p>a1 = a2;      #二者都是list</p>
<p>当a2改变的时候，a1也会跟着改变。（二者指向同一个list）</p>
<p>（但如果a2的改变是改变了内存地址，如上面的加号运算符，那么a1还是指向a2原本的内存地址，而a2指向了新的内存地址。此时a1 is a2 返回False）例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">d = [<span class="number">2000</span>, <span class="number">3000</span>]</span><br><span class="line">c = b</span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))	<span class="comment"># if c == b True 2266036261960</span></span><br><span class="line">b.append(<span class="number">1000</span>)</span><br><span class="line">print(c)												<span class="comment"># [1, 2, 88, 99, 1000]</span></span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))	<span class="comment"># if c == b True 22660360261960</span></span><br><span class="line"></span><br><span class="line">b.extend(a)</span><br><span class="line">print(c)												<span class="comment"># [1, 2, 88, 99, 1000, 1, 3, 5, 7]</span></span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))	<span class="comment"># if c == b True 22660360261960</span></span><br><span class="line"></span><br><span class="line">b = b + d</span><br><span class="line">print(c)												<span class="comment"># [1, 2, 88, 99, 1000, 1, 3, 5, 7]</span></span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))	<span class="comment"># if c == b True 2266065942728</span></span><br><span class="line">print(b)												<span class="comment"># [1, 2, 88, 99, 1000, 1, 3, 5, 7, 2000, 3000]</span></span><br></pre></td></tr></table></figure>

<p>list也可以用str( )转换成字符串。否则print的时候与字符串连接会报错。需要：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"some strings here: "</span> + str(aList))</span><br></pre></td></tr></table></figure>

<p>删除元素，length也会改变。（感觉也就C,JAVA的数组还是不可变长度了）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> listName[index]</span><br></pre></td></tr></table></figure>

<p>相当于String的indexOf，找到第一个element 的index。如果不存在，抛出异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.index(element)</span><br></pre></td></tr></table></figure>

<p>遍历数组，for语句即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">" "</span>)		<span class="comment"># 1 3 3 3 5 7 3</span></span><br></pre></td></tr></table></figure>

<p>不换行print，第二个参数为 end=… 其中… 为每一次输出后面加到末尾的字符串，这里是一个空格。</p>
<p>同时for语句的range函数，如果省略掉一个参数，那么就是从0开始。</p>
<p>可以用for语句的同时，使用enumerate( )函数进行对 index跟value同时遍历，例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'csd'</span>, <span class="string">'we'</span>, <span class="string">'zca'</span>, <span class="string">'ert'</span>, <span class="string">'hnx'</span>]</span><br><span class="line"><span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    print(<span class="string">"第%d个元素是: %s"</span> % (i, val), end=<span class="string">"。。"</span>)</span><br><span class="line"><span class="comment"># 第0个元素是: a。。第1个元素是: we。。……</span></span><br></pre></td></tr></table></figure>

<p>（这个占位符的%后面要加空格，不然又有warning）</p>
<p>sort( ) ： 对list进行排序        a.sort( ) 才是正确的。   sort(a) 没有效果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'z'</span>, <span class="string">'A'</span>, <span class="string">'Z'</span>, <span class="string">'B'</span>]</span><br><span class="line">a.sort()</span><br><span class="line"><span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    print(val, end=<span class="string">"。。"</span>)	<span class="comment">#A。。B。。Z。。a。。z。。</span></span><br></pre></td></tr></table></figure>

<p>(z &gt; a &gt; Z &gt; A)</p>
<p>reverse( )： list倒转。如果希望倒序，应该先sort，再reverse</p>
<p>range(start, end)    （range函数实际上会生成一个list）</p>
<p>从start到end递增（到end的时候就结束循环），start 默认值为0</p>
<p>2.元组 tuple</p>
<p>与list很相似，</p>
<p>区别在于：一经定义，内容就不能改变（所以没有插入，删除等功能）。而且可以同时存储不同类似的数据，用圆括号，而不是中括号括起来。</p>
<p>各种方法都与list一致：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(a[<span class="number">0</span>])			<span class="comment"># 1</span></span><br><span class="line">print(a[<span class="number">3</span>])			<span class="comment"># 4</span></span><br><span class="line">print(len(a))		<span class="comment"># 4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">", "</span>)		<span class="comment"># 1, 2, 3, 4</span></span><br><span class="line">print()</span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    print(<span class="string">"a[%d] is : %s"</span> % (index, value), end=<span class="string">", "</span>)	<span class="comment"># a[0] is : 1, a[1] is 2, a[2] is 3, a[3] is 4,</span></span><br></pre></td></tr></table></figure>

<p>由于内容不能改变，所以没有sort函数，也没有reverse。可以先将tuple转换为list，然后再对list排序，再将结果赋值给tuple。</p>
<p>转换：</p>
<p>列表对象 = list(元组对象)</p>
<p>元组对象 = tuple(列表对象)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">31</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">14</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">","</span>)	<span class="comment"># 31, 12, 23, 14,</span></span><br><span class="line">print()</span><br><span class="line">b = list(a)</span><br><span class="line">b.sort()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)):</span><br><span class="line">    print(b[i], end=<span class="string">", "</span>)	<span class="comment"># 12, 14, 23, 31,</span></span><br><span class="line">print()</span><br><span class="line">a = tuple(b)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">", "</span>)	<span class="comment"># 12, 14, 23, 31,</span></span><br></pre></td></tr></table></figure>

<p>3.字典    directory</p>
<p>用{ }，就是键值对。    { key1: val1, key2: val2, … , keyn: valn}</p>
<p>len( ) 长度。    </p>
<p>a[keyx] = valx    添加</p>
<p>a1.update(a2)        合并两个字典，结果放入a1.（此处不可以用a1 = a1 + a2,会报错）</p>
<p>删除键： pop</p>
<p>判断是否存在： in</p>
<p>遍历keys，values：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">'name'</span>: <span class="string">'小明'</span>, <span class="string">'sex'</span>: <span class="string">'男'</span>&#125;</span><br><span class="line">d2 = &#123;<span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'score'</span>: <span class="string">'80'</span>&#125;</span><br><span class="line">d1.update(d2)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d1.keys():</span><br><span class="line">    print(key, end=<span class="string">", "</span>)	<span class="comment"># name, sex, age, score</span></span><br><span class="line">print()</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d1.values():</span><br><span class="line">    print(value, end=<span class="string">", "</span>)	<span class="comment"># 小明, 男, 18, 80,</span></span><br></pre></td></tr></table></figure>

<p>或者 ：   for (k, v) in dict.items( ):        # items( )，获取key-value结果集    (代码略)</p>
<p>清空字段：  a.clear( )</p>
<p>字典也可以嵌套，跟多维list一样。</p>
<p>{‘name’ : {‘first’: ‘Kevin’, ‘last’: ‘Seth’}, ‘age’: 40}</p>
<p>访问嵌套字典：字典[键] [键]        print(d[‘name’] [‘first’])</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">'name'</span>: &#123;<span class="string">'first'</span>: <span class="string">'Kevin'</span>, <span class="string">'last'</span>: <span class="string">'Seth'</span>&#125;, <span class="string">'age'</span>: <span class="number">24</span>&#125;</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d1.values():</span><br><span class="line">    print(value)	<span class="comment"># &#123;'first': 'Kevin', 'last': 'Seth'&#125;	\n	24</span></span><br><span class="line">print(d1[<span class="string">'name'</span>][<span class="string">'first'</span>])		<span class="comment"># Kevin</span></span><br></pre></td></tr></table></figure>

<p>4.集合    set</p>
<p>集合由一组无序排列的元素组成，同时集合里没有重复的元素。</p>
<p>分为可变集合（set） 和不可变集合（frozenset）</p>
<p>（可变集合 创建后，可以添加元素，修改元素，删除元素）</p>
<p>创建集合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = set(<span class="string">'python'</span>)</span><br><span class="line">print(type(s))		<span class="comment"># &lt;class 'set'&gt;</span></span><br><span class="line">print(s)			<span class="comment"># &#123;'o', 't', 'h', 'n', 'p', 'y'&#125; (无序,每一次都不相同)</span></span><br><span class="line"></span><br><span class="line">s1 = set(<span class="string">'apple'</span>)</span><br><span class="line">print(s)			<span class="comment"># &#123;'a', 'l', 'p', 'e'&#125;</span></span><br></pre></td></tr></table></figure>

<p>len( ) ：获取集合的长度</p>
<p>for e in s    遍历。</p>
<p>add 添加。添加后的元素也在随机位置</p>
<p>s1.update(s2) 添加集合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">41</span>, <span class="number">22</span>, <span class="number">13</span>, <span class="number">54</span>, <span class="number">19</span>, <span class="number">38</span>, <span class="number">77</span>, <span class="number">5</span>, <span class="number">6</span>])		<span class="comment"># 也可以直接&#123;41, 22, 13, ……&#125;</span></span><br><span class="line">print(len(s))</span><br><span class="line">s.update([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">print(s)		<span class="comment"># &#123;4, 5, 38, 6, 41, 13, 77, 19, 54, 22&#125;</span></span><br></pre></td></tr></table></figure>

<p>remove(value)    删除指定的集合元素</p>
<p>clear( )    清空</p>
<p>in：判断某个value是否存在于集合中    存在返回True。否则False</p>
<p>A &lt; B , 如果A是B的真子集，返回True。</p>
<p>A &lt;= B, A是B的子集。</p>
<p>A &gt; B, A是B的真超集        A &gt;= B    A是B的超集</p>
<p>|   : 并集，    s1  |  s2   ==   s1 ∪ s2</p>
<p>也可以用这个union方法：    s = s1.union(s2)</p>
<p>&amp;  : 交集        s1  &amp;  s2  ==  s1  ∩  s2</p>
<p>也可以用这个intersection方法：    s = s1.intersection(s2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s = s1.intersection(s2)</span><br><span class="line">ss = s1 &amp; s2</span><br><span class="line">print(s)		<span class="comment"># &#123;3&#125;</span></span><br><span class="line">print(ss)		<span class="comment"># &#123;3&#125;</span></span><br></pre></td></tr></table></figure>

<p>^    :差分集        即    （s1 ∪ s2） - (s1 ∩ s2)</p>
<p>也可以用这个symmetric_difference方法：    s = s1.symmetric_dirrerence(s2)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s = s1 ^ s2</span><br><span class="line">ss = s1.symmetric_difference(s2)</span><br><span class="line">print(s)		<span class="comment"># &#123;1, 2, 4&#125;</span></span><br><span class="line">print(ss)		<span class="comment"># &#123;1, 2, 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>按位运算：  &amp;与    |或    ^异或</p>
<p>-————————-</p>
<p>函数：</p>
<p>在函数里定义的变量是局部变量，作用域就是在函数体内。如果全局变量和局部变量同名，那么在函数体内只能访问局部变量。如果在定义局部变量之前调用了同名的“全局变量”，会报错。因为函数体内只能访问局部变量，会显示：UnboundLocalError: local variable ‘a’ referenced before assignment</p>
<p>Python的传值是按值传递的（但传的值都是对象，数字也是对象，这点跟java不一样）</p>
<p>（经过测试：传数值，字符串都不会随着函数而改变，但list，directory会发生改变！）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(list)</span>:</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(len(list)):</span><br><span class="line">        <span class="keyword">if</span> x != len(list) - <span class="number">1</span>:</span><br><span class="line">            print(list[x], end= <span class="string">' + '</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(list[x], end=<span class="string">' '</span>)</span><br><span class="line">        total += list[x]</span><br><span class="line">    print(<span class="string">"="</span>, total)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">list = [<span class="number">15</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">65</span>]</span><br><span class="line">sum(list)		<span class="comment"># 15 + 25 + 35 + 65 = 140</span></span><br><span class="line"><span class="comment"># 只是普通的函数演示,并不是演示list/directory会改变</span></span><br></pre></td></tr></table></figure>

<p>函数定义后面的参数可以指定默认值，（有默认值的参数只能出现在没默认值的参数的后面）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(message, times = <span class="number">1</span>)</span>:</span></span><br><span class="line">    print(message * times)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">say(<span class="string">'hello'</span>)			<span class="comment"># hello</span></span><br><span class="line">say(<span class="string">'Python'</span>, <span class="number">3</span>)		<span class="comment"># PythonPythonPython</span></span><br></pre></td></tr></table></figure>

<p>如果没有指定默认值，那么调用say(‘hello’)的时候参数个数就不对，会报错。当参数个数不一致的时候（或多或少），都会报错（不要跟JS混淆）</p>
<p>可变长参数（跟java不一样），这里是指参数可以是元组，或者是字典。</p>
<p>在形参前面加<em>，表示为 可变长参数。    <em>是元组，</em></em>是字典</p>
<p>例子：def f(*t):    此时调用可以是：f(1),f(1,2), f(5,756,234,23), f({‘a’: ‘111’, ‘b’: ‘324534’})</p>
<p>def f(**t):        此时调用可以是： f(a=1), f(a=1, b=2, c=3), f(a=1, b=12, c=543, d=765)</p>
<p>函数可以指定返回值，return。在函数体里用就行，定义上不用写什么。</p>
<p>Python预定义函数：</p>
<p>abs, pow(x, y), ound(x [, n]) 四舍五入，保留n位小数。 divmod(a,b) 返回 a / b , a % b</p>
<p>(这个四舍五入，-2.5的结果是-2，2.5的结果是2）</p>
<p>PS：Python2中，2.5的结果是3.0。但在python3中，2.5会返回2，2.5000000001才会返回3</p>
<p>字符串处理函数： lower, upper , swapcase(大写转小写，小写转大写）</p>
<p>capitalize 首字母大写。    title 首字母大写，其余为小写</p>
<p>title是每一个单词的首字母大写，例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'hello woRLd'</span>.title()</span><br><span class="line">print(s)					<span class="comment"># Hello World</span></span><br><span class="line">s = <span class="string">'hello woRLd'</span>.capitalize()</span><br><span class="line">print(s)					<span class="comment"># Hello world</span></span><br></pre></td></tr></table></figure>

<p>ljust，rjust， center        左对齐，右对齐，居中对齐，第一个参数为width表示字符串总长度，第二个参数可选，当长度不足时填充，默认是空格填充。</p>
<p>zfill， 用0填充到width长，右对齐。</p>
<p>搜索和替换：</p>
<p>str.find(substr)    查看字符串str中出现子串substr的第一个字母的位置，找不到则返回-1</p>
<p>index    与find函数相同，但找不到的时候会报错</p>
<p>rfind    从右侧开始find    （注意index的结果还是顺序来算的）</p>
<p>rindex            </p>
<p>count    计算子串的出现次数</p>
<p>（以上5个方法还有两个可选参数，start，end，表示搜索范围从start到end - 1）</p>
<p>str.replace(oldstr, newstr [,count])    替换。count为替换次数。</p>
<p>strip，lstrip，rstrip，把前后，前，后的[chars]字符去掉。默认为空白符。</p>
<p>expandtabs    把tab字符替换成空格，每个空格替换成[tabsize]个空格，默认是8个</p>
<p>分割和组合：</p>
<p>split（跟java一样），    splitlines 按照行分隔符划分    join把字符串序列用特定字符连接起来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="string">'214, '</span><span class="number">233</span><span class="string">', '</span><span class="number">532</span><span class="string">']</span></span><br><span class="line"><span class="string">str = '</span><span class="comment">##'</span></span><br><span class="line">s = str.join(list)</span><br><span class="line">print(s)			<span class="comment"># 214##233##532 </span></span><br><span class="line"><span class="comment"># 这里会有一个warning：shadows build_in names 'xx', 因为list, str这种变量名起得不好，容易引起歧义，应该取得更能表达意思的名字 （但这里只是简单的演示代码,str跟list其实就能表示清楚了。。)</span></span><br></pre></td></tr></table></figure>

<p>startwith，endswith，isalnum（是否全是字母或数字），isalpha 字母  isdigit</p>
<p>islower   isupper</p>
<p>help(obj)  输出这个对象的帮助信息（可能是命令，可能是list等等的对象）</p>
<p>（传入一个list，就能看到List列表对象的源码）</p>
<p>type(obj)    显示一个对象的数据类型</p>
<p>字符串会返回：    &lt;class ‘str’&gt;</p>
<p>数值会返回：        &lt;class ‘int’&gt;    &lt;class ‘float’&gt;</p>
<p>列表会返回：        &lt;class ‘list’&gt;</p>
<p>-——————————-</p>
<p>类</p>
<p>1.变量，构造函数，析构函数，调用等等：</p>
<p>PS： <strong>xxx</strong> 表示系统定义的名字    __xx:表示是类的私有变量名(类外不能直接访问)</p>
<p>直接在构造器里调用  self.str11 = ‘111’    也算是定义了一个成员变量str11（即使函数外部没有定义str11这个变量。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span>		<span class="comment"># constructor</span></span><br><span class="line">        self.__str = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(self)</span>:</span>				<span class="comment"># normal function</span></span><br><span class="line">        print(self.__str)</span><br><span class="line">    __str = <span class="string">'MyString'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span>				<span class="comment"># destructor</span></span><br><span class="line">        print(<span class="string">"bye~"</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">p = Person(<span class="string">'Hong'</span>)</span><br><span class="line">p.sayHello()				<span class="comment"># Hong</span></span><br><span class="line"><span class="keyword">del</span> p						<span class="comment"># bye~</span></span><br><span class="line">p1 = Person(<span class="string">'Kai'</span>)</span><br><span class="line">p1.sayHello()				<span class="comment"># Kai</span></span><br><span class="line"><span class="comment"># bye~		(at the end of the program, p1 will release)</span></span><br><span class="line"><span class="comment"># if no 'del p' exists ahead, it will print 'bye~' twice here!</span></span><br></pre></td></tr></table></figure>



<p>2.静态变量，静态方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span>:</span></span><br><span class="line">    str = <span class="string">"this is the static"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.str = <span class="string">'MyString111'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.str)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">staticMethod</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(cls.str + <span class="string">' , '</span> + str(cls))</span><br><span class="line">        print(<span class="string">'this is a static method'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = MyString()</span><br><span class="line">s.output()                  <span class="comment"># MyString111   the value of instance</span></span><br><span class="line">print(MyString.str)         <span class="comment"># MyString      the value of class, static variable</span></span><br><span class="line">s.str = <span class="string">'Hong'</span></span><br><span class="line">MyString.str = <span class="string">'qqq'</span></span><br><span class="line">s.output()                  <span class="comment"># Hong</span></span><br><span class="line">print(MyString.str)         <span class="comment"># qqq           the value of class, static variable</span></span><br><span class="line">MyString.staticMethod()     <span class="comment"># this is a static method</span></span><br><span class="line">s.staticMethod()            <span class="comment"># this is a static method</span></span><br></pre></td></tr></table></figure>

<p>定义静态方法需要在方法前加：@staticmethod    （而且参数列表里不能有self）    </p>
<p>而定义静态变量不需要任何东西，每一个变量都同时是实例变量和静态变量。只要是通过类名访问的就是静态变量（看上面的例子，str通过instance访问时，就是实例变量，通过类名访问时则是静态）</p>
<p>类方法：@classmethod，第一个参数是cls（表示当前的类）</p>
<p>（其实类方法跟静态方法区别不大，静态方法可以直接用类名表示当前类。但一般的区分是这样的：静态方法存放与类无关的逻辑代码，如单纯的表达式计算。而类方法存放与类属性相关的逻辑代码）</p>
<p>isinstance(对象名， 类名或类型名）</p>
<p>例子： isinstance(str, MyString)        isinstance(1, int)</p>
<p>继承：class B (A)   B继承A，同时构造器里需要显式调用一次父类构造器</p>
<p>子类会继承父类的属性跟方法（私有除外）但如果提供了访问私有函数的公共接口，那么子类通过继承了这个public方法，也是可以间接访问父类私有函数的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, propertyA)</span>:</span></span><br><span class="line">        self.propertyA = propertyA</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__functionA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(str(self.propertyA) + <span class="string">' ... in class A'</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__functionA()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, propertyA, propertyB)</span>:</span></span><br><span class="line">        A.__init__(self, propertyA)		<span class="comment"># call the father constructor</span></span><br><span class="line">        self.propertyB = propertyB</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionB</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(str(self.propertyB) + <span class="string">' ... in class B'</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">a1 = A(<span class="number">10</span>)</span><br><span class="line">a1.functionAA()		<span class="comment"># 10 ... in class A     access the private f by a public f</span></span><br><span class="line">b1 = B(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">b1.functionAA()		<span class="comment"># 5 ... in class A		the same as class A</span></span><br><span class="line">b1.functionB()		<span class="comment"># 10 ... in class B</span></span><br><span class="line">print(b1.propertyA)	<span class="comment"># 5</span></span><br><span class="line">print(b1.propertyB)	<span class="comment"># 10</span></span><br><span class="line"><span class="comment"># a1.__functionA()	# both a and b can't access the private atribute directly</span></span><br></pre></td></tr></table></figure>

<p>如果子类不调用父类的构造器，那么在父类构造器执行的语句就不会生效。比如，父类有属性a = 1，构造器里有赋值语句 a = 5.如果调用了父类构造器，那么子类继承的a属性值为5，如果没有调用，子类继承的属性值为1.如果父类的属性a仅仅定义在构造器里，那么调用父类构造器之后，子类成功继承属性a。如果没有调用父类构造器，则没有继承属性a，会报错（但其他构造器之外的成员都可继承）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        self.a = a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'method in class A'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, propertyA, propertyB)</span>:</span></span><br><span class="line">        A.__init__(self, propertyA)             <span class="comment"># call the father constructor</span></span><br><span class="line">        self.propertyB = propertyB</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'the method in class B'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b1 = B(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">b1.functionAA()          <span class="comment"># the method in class B</span></span><br><span class="line">b1.function1()</span><br><span class="line"><span class="comment"># print(b1.a)			error, B object has no attribute 'a'</span></span><br></pre></td></tr></table></figure>

<p>同时，子类和父类有同名函数，此时是多态，会调用子类的函数，而非父类。（类型是子类）</p>
<p>抽象类和抽象方法：</p>
<p>Python通过类库abc实现抽象类，所以需要先import</p>
<p>from  abc  import  ABCMeta,  abstractmethod</p>
<p>在抽象类的第一行写下：   _<em>metaclass_</em>  =  ABCMeta</p>
<p>在抽象方法前增加：    @abstractmethod</p>
<p>抽象方法的定义：    def  abs_method_name (self): pass</p>
<p>PS：亲测，不需要前面三个步骤，想定义抽象方法直接在函数体 改为 pass 即可！</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myabs</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># __metaclass__ = ABCMeta</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abcmethod</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normalmethod</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"method in myabs"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myimp1</span><span class="params">(myabs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abcmethod</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="number">1123</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sub_abs_method</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># print(234)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = myimp1()</span><br><span class="line">a1.func1()              <span class="comment"># 111</span></span><br><span class="line">a1.abcmethod()          <span class="comment"># doesn't call,but no error</span></span><br><span class="line">a1.sub_abs_method()     <span class="comment">#234</span></span><br><span class="line"></span><br><span class="line">a2 = myabs()            <span class="comment"># abstract class still can make an instance</span></span><br><span class="line">a2.normalmethod()       <span class="comment"># call the non-abstract function(method in myabs)</span></span><br><span class="line">a2.abcmethod()          <span class="comment"># doesn't call,but no error</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，抽象类是可以实例化的，也可以调用非抽象方法跟抽象方法。而且子类也会继承这个抽象方法。但调用没有实现的抽象方法（pass），不会产生任何结果。</p>
<p>而且抽象类可以实例化，跟普通的没有区别。想定义抽象方法直接定义为pass即可</p>
<p>（我觉得抽象方法的主要用途是定义一个公共的方法，但未提供实现。子类可以选择实现并且使用，可以不实现，这时候甚至还能调用这个方法，但没有结果。比直接报错要好）</p>
<p>至于抽象类，似乎目前没有用，可能后面配合 模块 可以实现抽象类禁止实例化？    //TODO</p>
<p>多态：在不同的子类，同名方法可以有不同的实现。（如果子类没有实现该方法，就调用父类方法）</p>
<p>对象复制：</p>
<p>直接a2 = a1，之后二者指向同一个对象。除非指向其他对象，否则仅仅改变属性，内存地址并不会发生变化。而且a1的属性值改变之后，a2也跟着改变（二者始终指向同一个对象）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    property = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(id(a))            <span class="comment"># 3035407383560</span></span><br><span class="line">a.property = <span class="number">234</span></span><br><span class="line">print(a.property)       <span class="comment"># 234</span></span><br><span class="line">print(id(a))            <span class="comment"># 3035407383560 address don't change</span></span><br><span class="line">a2 = a</span><br><span class="line">print(a2.property)      <span class="comment"># 234</span></span><br><span class="line">print(id(a2))           <span class="comment"># 3035407383560</span></span><br><span class="line">a.property = <span class="number">567</span></span><br><span class="line">print(a.property)       <span class="comment"># 567</span></span><br><span class="line">print(a2.property)      <span class="comment"># 567   a2 change its value too</span></span><br><span class="line">print(id(a2))           <span class="comment"># 3035407383560</span></span><br><span class="line">print(id(a))            <span class="comment"># 3035407383560</span></span><br></pre></td></tr></table></figure>

<p>当函数的参数是对象是自定义的类对象时，由于传入的参数并没有声明类型，所以这个时候应该先对参数进行类型判断。    if isinstance(str, MyString):   …</p>
<p>-——————————</p>
<p>模块module    相当于java里的jar包，有封装好的函数，变量可以使用。</p>
<p>import xxx    调用：xxx.f        xxx.val</p>
<p>常用模块：</p>
<p>1.sys</p>
<p>可以获取系统的信息，还可以获取运行时的命令行参数，用作输入等等，例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用命令:  python test.py 3, 4, 9, 1 (如果逗号后面没有空格,好像会把整个当作list)</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.platform)			<span class="comment"># win32</span></span><br><span class="line">print(<span class="string">"一共有%d个参数"</span> % len(sys.argv))		<span class="comment"># 5个, 包括 test.py</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(sys.argv)):</span><br><span class="line">    sum += int(sys.argv[i])</span><br><span class="line">print(sum)									<span class="comment"># 17</span></span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure>

<p>2.platform</p>
<p>可以获取操作系统的详细信息和与Python有关的信息</p>
<p>3.math</p>
<p>与数学有关的。</p>
<p>常量：e，pi</p>
<p>常用方法：</p>
<p>fabs：取绝对值</p>
<p>floor：返回小于等于x的最大整数</p>
<p>log（x，a）：返回loga(x)    如果不指定a，默认是e</p>
<p>log10</p>
<p>pow（x，y） ：    x^y</p>
<p>sqrt    :    根号x</p>
<p>trunc：    返回x的整数部分</p>
<p>4.random</p>
<p>生成随机数</p>
<p>random( )    :生成一个0到1的随机浮点数  0 &lt;= n &lt; 1.0</p>
<p>uniform(a, b)    :生成a~b范围内的随机浮点数 [a, b]  或者 [b, a] （看哪个比较大）</p>
<p>randint（a，b）：生成a~b之间的随机整数（a不能比b大）    [a, b]</p>
<p>randrange (a, b, c): </p>
<p>生成 [a, b)范围里的随机数，每次递增的间隔为c。即获取a, a+c, a+2c, a+3c ……（不包括b）</p>
<p>choice（sequence） ： 从sequence里随机获取一个元素。sequence可以是list，tuple，string</p>
<p>shuffle    打乱list</p>
<p>sample（sequence， k） ：    从sequence中随机获取长度为k的片段。原有sequence不会被修改</p>
<p>5.Decimal</p>
<p>导入： from decimal import Decimal  （用于浮点数计算，精度更高）</p>
<p>6.fractions</p>
<p>用于表现和处理分数。</p>
<p>x = fractions.Fractions(1, 3)</p>
<p>print(x)            #   1/3</p>
<p>对x计算之后，还会进行自动约分。如1/6 * 4会变成 2/3</p>
<p>\7. time模块    （常用）</p>
<p>struct_time数组，表示时间    或者时间戳（1970.1.1到现在的总毫秒数）</p>
<p>year，month，day，hours，minutes，seconds，weekday（星期一为0），yday一年一共几天</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">print(time.time())                          <span class="comment"># 1567835487.381137</span></span><br><span class="line">print(time.localtime(time.time()))</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2019, tm_mon=9, tm_mday=7, tm_hour=13, tm_min=51, tm_sec=56,</span></span><br><span class="line"><span class="comment"># tm_wday=5(星期六）, tm_yday=250（今年的第250天）, tm_isdst=0)</span></span><br><span class="line">print(time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>))   <span class="comment"># 2019-09-07 13:57:13</span></span><br><span class="line">print(time.ctime())                         <span class="comment"># Sat Sep  7 13:57:39 2019</span></span><br></pre></td></tr></table></figure>

<p>自定义模块：一个.py文件就是一个模块，外部可以通过import导入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> myPackage.m1.myMath</span><br><span class="line"></span><br><span class="line">a = myPackage.m1.myMath.sum(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">print(a)			<span class="comment"># 7</span></span><br></pre></td></tr></table></figure>



<p>-—————</p>
<p>函数式编程（感觉跟面向过程差不多，只是功能都封装到函数里）</p>
<p>lambda表达式， 可用作匿名函数</p>
<p>返回函数名   =   lambda  参数列表  ：  返回值表达式</p>
<p>还可以将lambda表达式作为数组里的value：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum1 = <span class="keyword">lambda</span> x, y, z: x + y + z		<span class="comment"># 输入参数是x, y, z,返回值是三个的和</span></span><br><span class="line">print(sum1(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>))					<span class="comment"># 9</span></span><br><span class="line">Arr = [(<span class="keyword">lambda</span> x: x**<span class="number">2</span>), (<span class="keyword">lambda</span> x: x**<span class="number">3</span>), (<span class="keyword">lambda</span> x: x**<span class="number">4</span>)]</span><br><span class="line">print(Arr[<span class="number">0</span>](<span class="number">5</span>), Arr[<span class="number">1</span>](<span class="number">4</span>), Arr[<span class="number">2</span>](<span class="number">5</span>))	<span class="comment"># 25, 64, 625</span></span><br></pre></td></tr></table></figure>

<p>(但PEP8标准觉得def比lambda要好。准确的是，lambda一般用于匿名函数，如果要把lambda赋值给一个变量作函数变量，那还是用def比较好）</p>
<p>map函数</p>
<p>result_sequence = map(function，sequence1 [，sequence2 …])</p>
<p>(function里有n个参数，那么就需要sequenceN）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">    print(e, end=<span class="string">", "</span>)      <span class="comment"># (0, 4), (1, 16), (2, 36), (3, 64), (4, 100),</span></span><br><span class="line">print()</span><br><span class="line">arr = map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>])</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">    print(e, end=<span class="string">", "</span>)      <span class="comment"># (0, 101), (1, 203), (2, 305), (3, 407), (4, 509),</span></span><br></pre></td></tr></table></figure>

<p>filter函数</p>
<p>filter（function，sequence）</p>
<p>对sequence里的每一个元素调用function，结果为true的返回。最终的结果序列成为filter的返回值</p>
<p>reduce函数</p>
<p>reduce（function，sequence）</p>
<p>function必须有2个参数。然后sequence里的前两个参数调用function，返回结果和第三个参数继续调用function，直到最后一个。</p>
<p>zip函数        压缩，解压(下面例子不能同时for，迭代器对象只能单向迭代一次，到了结尾之后，第二次迭代就像是迭代了一个空的list)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">zipped = zip(a, b)</span><br><span class="line"><span class="comment"># for element in zipped:</span></span><br><span class="line"><span class="comment">#     print(element, end=", ")        # (1, 4), (2, 5), (3, 6),</span></span><br><span class="line"></span><br><span class="line">unzipped = zip(*zipped)</span><br><span class="line"><span class="keyword">for</span> element1 <span class="keyword">in</span> unzipped:</span><br><span class="line">    print(element1, end=<span class="string">", "</span>)         <span class="comment"># (1, 2, 3), (4, 5, 6),</span></span><br></pre></td></tr></table></figure>



<p>闭包：即函数的嵌套。</p>
<p>在fun1里定义另一个fun2，然后fun1里的返回语句是return fun2，这时候就去调用fun2.</p>
<p>递归，一样的道理。</p>
<p>迭代器。</p>
<p>1.iter( )   可以获取一个sequence的迭代器。    next（Iterator）获取下一个元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">12</span>, <span class="number">345</span>, <span class="number">234</span>, <span class="number">65</span>, <span class="number">78</span>, <span class="number">54</span>]</span><br><span class="line">it = iter(list)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = next(it)</span><br><span class="line">        print(s, end=<span class="string">", "</span>)          <span class="comment"># 12, 345, 234, 65, 78, 54,</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>（原生迭代器竟然没有hasNext方法！辣鸡，建议自己实现一个Iterator）</p>
<p>2.enumerate（）   将列表或者元组生成一个有序号的序列（index，value）</p>
<p>生成器：</p>
<p>当存在迭代器的时候，比如for in，实际上每一次都会调用一次next（）函数，表示生成下一个对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addList</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> alist:</span><br><span class="line">        <span class="keyword">yield</span> i + <span class="number">1</span></span><br><span class="line">alist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> addList(alist):</span><br><span class="line">    print(x, end=<span class="string">', '</span>)      <span class="comment"># 2, 3, 4, 5,</span></span><br><span class="line">print()</span><br><span class="line">print(alist)                <span class="comment"># [1, 2, 3, 4]  alist的值并没有变化！</span></span><br><span class="line"></span><br><span class="line">x = addList(alist)</span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 2</span></span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 3</span></span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 4</span></span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p>用生成器 yield。<a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856" target="_blank" rel="noopener">https://blog.csdn.net/mieleizhi0522/article/details/82142856</a></p>
<p>yield相当于return，但下一次再进入到这个方法体的时候，会从yield这个语句后面开始执行。显式用next（generator）来调用相应的generator（有yield的方法），在for in的时候，实际上是每一次都隐式调用了next方法的。</p>
<p>同时如果要传值进行next，那么就用generator.send(value),这样就不会出现yield那一句的值丢失（因为return了之后，从下一个语句开始执行，当前语句在下一次是失效的。如a = yield 4，相当于return了4，但下次是从a的赋值才是进行，但右边的值实际上已经丢失，此时传值才可以让a有值，否则是None值。）</p>
<p>那么，生成器和普通的递归有什么区别？</p>
<p>首先，代码可以更加的简洁，看例子：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\83e1a372729240e29c855c809401023c\clipboard.png)</p>
<p>或者这个例子：<a href="https://blog.csdn.net/weixin_40581980/article/details/80986026" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40581980/article/details/80986026</a></p>
<p>（用了生成器语法，直接用1行代码替代了一整个class的功能）</p>
<p>同时，迭代器其实是隐式调用next，而每一步（+1）都会生成元素，开辟空间，添加元素到list</p>
<p>比如我们要获取10000000里的所有素数。如果用迭代器，那么就是 for i in range（2，100000000）</p>
<p>，这样会生成一个很大的list。虽然结果不会有那么多，但中间隐式调用next还是会生成一个临时是长度为10000000的list，极度消耗内存空间。（每一步都要调用next）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primes</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span></span><br><span class="line">        self.max = max</span><br><span class="line">        self.number = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.number += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.number &gt;= self.max:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">elif</span> check_prime(self.number):</span><br><span class="line">            <span class="keyword">return</span> self.number</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__next__()</span><br></pre></td></tr></table></figure>

<p>如果使用生成器呢，此时首先无须迭代，那么也就无须用class来实现，用函数即可。然后在循环里，是先进行check，然后check通过之后，才开始yield（生成），并且下一次next的时候，可以从这一步继续执行下去，生成下一个素数。即无须像迭代器一样，首先需要逐步生成所有的数，然后再check。（相当于比如1到1亿里面，有1000万个素数，那么迭代需要生成一个1亿长度的list，然后再查找，找到1000万个素数，再输出。而用生成器，则是找到一个素数，再添加元素到list里，最后的list长度就只有1000万，远小于1亿!）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Primes</span><span class="params">(max)</span>:</span></span><br><span class="line">    number = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> number &lt; max:</span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> check_prime(number):</span><br><span class="line">            <span class="keyword">yield</span> number</span><br><span class="line">            </span><br><span class="line">  </span><br><span class="line">primes = Primes1(<span class="number">100000000000</span>)</span><br></pre></td></tr></table></figure>



<p>Python的可移植性：先编译成字节码，然后将其转发到虚拟机(Python虚拟机)中运行（跟java一样）</p>
<p>生成的字节码文件：.pyc文件</p>
<p>Python的编译器总是在运行时出现，因为程序执行之前不需要预编译和链接等等的操作，使得开发周期大大缩短。（具备了更多的动态语言特性，可以在一个Python程序中执行另一个Python程序，即可以动态地修改代码，无须拥有或者编译整个系统的代码）</p>
<p>Python的实现，即编译器，PVM的实现方式：CPython，Jython，IronPython</p>
<p>执行优化工具：Psyco实时编译器（对PVM的增强工具）</p>
<p>print语句，在Python2不需要括号，在Python3需要（被视为一个函数调用）</p>
<p>模块：一个.py文件实际上就是一个模块</p>
<p>UNIX输入输出重定向（Python支持UNIX输入输出重定向）</p>
<p>例子：python xxx.py  &gt; saveit.txt    输出会输出到saveit.txt中，而非控制台</p>
<p>导入模块。</p>
<p>import a.b    &lt;==&gt;    from a import b</p>
<p>也可以用一个变量来赋值：import a.b.c.d    q = a.b.c.d</p>
<p>导入的时候，被导入的模块文件会从头执行一次（包括def，class的定义，还是简单的print，都会执行）同时由于导入消耗较大，因此运行两次import（即使在中途模块文件被修改了），也不会执行第二次import，这时候要使用reload（在Python2是内置，Python3里并没有）</p>
<p>exec( open(‘xxx.py’).read( ))</p>
<p>对于exec，代码都相当于粘贴到当前模块文件中，因此同名变量会产生冲突。    </p>
<p>而import跟from并不会。例子：</p>
<p>（我们在myMath.py里定义了一个ak变量，值为100）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ak = <span class="number">50</span></span><br><span class="line">exec(open(<span class="string">'myModule/myMath.py'</span>).read())</span><br><span class="line">print(ak)				<span class="comment"># 100</span></span><br></pre></td></tr></table></figure>

<p>（对于import和from，当我们要访问它的变量，我们需要使用myModule.myMath.ak, myMath.ak等）</p>
<p>Python是动态类型的（自动地跟踪类型，而不是要求声明代码），</p>
<p>但Python也是强类型语言（只能对一个对象进行适合该类型的有效的操作）</p>
<p>字符串截取（跟数组一样操作）：</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'python'</span></span><br><span class="line">print(s[<span class="number">2</span>])</span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">3</span>])		<span class="comment"># [start, end - 1] 'yt'</span></span><br><span class="line">print(s[<span class="number">1</span>:])		<span class="comment"># [start, -1]	'ython'</span></span><br><span class="line">print(s[:])			<span class="comment"># equals with s</span></span><br><span class="line">print(s[:<span class="number">-1</span>])		<span class="comment"># 'pytho'	[0, end - 1], that's [0, -2]</span></span><br><span class="line">print(s[:<span class="number">3</span>])		<span class="comment"># 'pyt'		[0, 2]</span></span><br></pre></td></tr></table></figure>

<p>字符串是不可变的，不能对单独一个字符进行改变等，只能重新赋值（指向另一个字符串对象！）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'python'</span></span><br><span class="line"><span class="comment"># s[0] = 'J'		error</span></span><br><span class="line">print(s)</span><br><span class="line">s = <span class="string">'J'</span> + s[<span class="number">1</span>:]</span><br><span class="line">print(s)			<span class="comment"># Jython</span></span><br></pre></td></tr></table></figure>

<p>实际上还有第三个参数，a[ i : j : k ]        k默认是1，表示每隔k个字符索引一次。</p>
<p>所以如果是’abcdefg’[::2]  ==  ‘aceg’</p>
<p>如果K为-1，表示反转字符串。    “hello”[::-1]    ==    “olleh”</p>
<p>如果是 [a : b : -1]    会将[b + 1, a]的字符串反转输出（b最小为0，因此不能获取第一个字符，只能通过index为0获取第一个字符）</p>
<p>slice( ) 切片函数。</p>
<p>dir(obj)    返回一个list，即该obj包含的所有方法（包括继承而来的各种方法，默认方法）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> textwrap</span><br><span class="line">s = <span class="string">'str'</span></span><br><span class="line">res = str(dir(s))</span><br><span class="line">print(textwrap.fill(res, width=<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\516fb192a01f4a4384d78e6724706a55\clipboard.png)</p>
<p>（textwrap是一个Python标准库的模块，可以用于格式化输出，这里使得每行输出长度最大为100）</p>
<p>help(obj)    返回obj的类定义。    help(obj.func)    返回obj该方法的定义，帮助信息</p>
<p>（因为Python一切皆对象，当然函数也是一个对象）    </p>
<p>关于len( )，转义符也属于长度1</p>
<p>len(‘A\nB\tC’)    ==    5</p>
<p>关于字符串匹配。</p>
<p>导入re模块，用match( reg, str)方法匹配，返回匹配的结果串，并且可以根据括号进行分组</p>
<p>PS：使用group可以获取分组内容，而且括号仅限小括号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">regexp = <span class="string">'Hello[ \t]*(.*)world'</span></span><br><span class="line">string = <span class="string">'Hello        Python world'</span></span><br><span class="line">match = re.match(regexp, string)</span><br><span class="line">print(match.group(<span class="number">1</span>))		<span class="comment"># 'Python ' 表示括号里的内容</span></span><br><span class="line"></span><br><span class="line">string = <span class="string">'/usr/home/lumberjack'</span></span><br><span class="line">regexp = <span class="string">'/(.*)/(.*)/(.*)'</span></span><br><span class="line">match = re.match(regexp, string)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    print(match.group(i))</span><br><span class="line"><span class="comment"># group(0)为整个string,group(n)为第n个括号的内容</span></span><br></pre></td></tr></table></figure>

<p>这些字符串操作都是一个真正的序列操作，所以很多对于list等等都是有效的。</p>
<p>比如list也可以用-1下标表示最后一个元素！</p>
<p>list的赋值不能超出边界。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># L[10] = 100		并不会把length提到10, 而是直接报错, 只能用append等</span></span><br></pre></td></tr></table></figure>

<p>Python的核心数据类型，都支持任意的嵌套。（同时list允许不同类型的元素）例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, [<span class="string">'fsd'</span>, <span class="number">4</span>], <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list))</span><br><span class="line">	print(list[i], end=<span class="string">", "</span>)		<span class="comment"># 1, 2, ['fsd', 4], 5, </span></span><br><span class="line">print()</span><br><span class="line">print(list[<span class="number">2</span>][<span class="number">0</span>] + <span class="string">', '</span> + str(list[<span class="number">2</span>][<span class="number">1</span>]))	<span class="comment"># fsd, 4</span></span><br></pre></td></tr></table></figure>

<p>列表解析表达式 list comprehension expression</p>
<p>语法:    [ result_expression   for   item   in   list   filter_expression]</p>
<p>（第一个的result_expression可以调用后面for item的item数组）</p>
<p>例子：[ [1, 2, 3], [4, 5, 6], [7, 8, 9]]    一个二维矩阵，现在要提取第二列，并且每个值加1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">col2 = [item[<span class="number">1</span>] + <span class="number">1</span> <span class="keyword">for</span> item <span class="keyword">in</span> list]</span><br><span class="line">print(col2)				<span class="comment"># [3, 6, 9]</span></span><br><span class="line">col2Doules = [row[<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> list <span class="keyword">if</span> row[<span class="number">1</span>] %  <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">print(col2Doubles)		<span class="comment"># 获取第二列的偶数元素, [2, 8]</span></span><br></pre></td></tr></table></figure>

<p>如果使用括号的解析语法，就变成了生成器generator：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">generator = (sum(row) <span class="keyword">for</span> row <span class="keyword">in</span> list1)</span><br><span class="line">print(next(generator))			<span class="comment"># 6</span></span><br><span class="line">print(next(generator))			<span class="comment"># 15</span></span><br><span class="line">print(next(generator))			<span class="comment"># 24</span></span><br><span class="line">print(list(map(sum, list1)))	<span class="comment"># [6, 15, 24]</span></span><br></pre></td></tr></table></figure>

<p>（直接用map函数，对列表的每一列进行sum操作，然后用list转换成列表）</p>
<p>ps：sum跟list都是标准模块里的函数，可以直接使用，平时不要覆盖掉</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mydir = &#123;<span class="string">'name'</span>: <span class="string">'hong'</span>, <span class="string">'jobs'</span>: [<span class="string">'student'</span>], <span class="string">'age'</span>: <span class="number">24</span>&#125;</span><br><span class="line">print(mydir)                <span class="comment"># &#123;'name': 'hong', 'jobs': ['student'], 'age': 24&#125;</span></span><br><span class="line">mydir[<span class="string">'sex'</span>] = <span class="string">'male'</span></span><br><span class="line">print(mydir)                <span class="comment"># &#123;'name': 'hong', 'jobs': ['student'], 'age': 24, 'sex': 'male'&#125;</span></span><br><span class="line">mydir[<span class="string">'jobs'</span>].append(<span class="string">'programmer'</span>)</span><br><span class="line">print(mydir)     <span class="comment"># &#123;'name': 'hong', 'jobs': ['student', 'programmer'], 'age': 24, 'sex': 'male'&#125;</span></span><br><span class="line">print(mydir[<span class="string">'jobs'</span>][<span class="number">-1</span>])    <span class="comment"># programmer</span></span><br></pre></td></tr></table></figure>

<p>Python也有GC机制，但我们也可以手动删除不再需要的对象（del），也可以赋值为0，引发GC</p>
<p>字典可以用in判断是否存在某个key，也可以get(key1, default_value)</p>
<p>如果存在key1，则返回，如果不存在，返回default_value</p>
<p>文件。    要调用open函数来生成file对象。</p>
<p>第一个参数是路径，第二个参数是权限。默认是’r’,只能是’r’或者’w’，不能是’rw’</p>
<p>同时还可以是’rb’，表示将读出来的数据改为二进制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'data.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">'Hello\n'</span>)</span><br><span class="line">f.write(<span class="string">'world\n'</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'data.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">text = f.read()</span><br><span class="line">print(text)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>判断类型，isinstance是最好的选择</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> type(list1) == type([]):</span><br><span class="line">    print(<span class="string">'yes'</span>)</span><br><span class="line"><span class="keyword">if</span> type(list1) == list:</span><br><span class="line">    print(<span class="string">'yep'</span>)</span><br><span class="line"><span class="keyword">if</span> isinstance(list1, list):</span><br><span class="line">    print(<span class="string">'yeah'</span>)</span><br></pre></td></tr></table></figure>

<p>Python操作符表达式：</p>
<p>yield  x                            生成器表达式</p>
<p>lambda  args  ：  expression            匿名函数</p>
<p>x  if  y  else  z                        y为真时，x。否则z</p>
<p>x  or  y，    x  and  y，  not  x</p>
<p>x  in  y，  x  not  in  y        （iterables，sets）</p>
<p>x  is  y，  x  is  not  y</p>
<p>&lt; , &gt; ,== , !=  |,  &amp; ,   ^（异或）,    &lt;&lt;左移    &gt;&gt;右移    /除，    //除，取整数结果</p>
<p>s[i: j: k]    数组切片，从[i, j)中，每隔k个数输出一个列表</p>
<p>……</p>
<p>当两个类型不一样的数字进行运算时，结果为更复杂的那个类型。</p>
<p>如：40 + 3.14 = 43.14    3.14 + （2+3j） = 5.14+3j</p>
<p>x &lt; y &gt; z，    x &gt; y &gt; z， x  &gt;  y  &lt; z 这种是可行的</p>
<p>math.floor( )    返回不大于x 的最大整数。所以x为2.5时，结果为2.为-2.5时候，结果为-3</p>
<p>//整除，实际上就是对获得的结果，再进行floor。</p>
<p>所以  5 // 2 == 2    5 // -2  == -3</p>
<p>如果真的只想要整数部分，应该用trunc</p>
<p>python的整数没有范围，支持无穷的大小</p>
<p>进制计数：</p>
<p>0o开头：八进制    （第一个是0，第二个是小写的o）</p>
<p>0x开头：十六进制</p>
<p>0b开头：二进制</p>
<p>oct(x)      十进制转八进制</p>
<p>hex(x)    十进制转十六进制</p>
<p>bin(x)    十进制转二进制</p>
<p>或者是  int( num, x)        第二个参数可选，表示进制，默认是10</p>
<p>eval函数，可以将字符串作为python代码执行，然后运行结果就是返回结果。一般的作用是将字符串对象转换成更具体的对象（比如数字，list，set，directory等等）。但由于eval实际上会将里面的字符串作为程序的一个小片段进行编译运行，所以可以做一些其他的工作。比如甚至可以偷偷地拿一个字符串，将电脑上的某个文件删除：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">eval(<span class="string">"os.remove('data.txt')"</span>)</span><br></pre></td></tr></table></figure>

<p>位运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">11</span> | <span class="number">0b1100</span>)      <span class="comment"># 0b1111 == 15  (11 == ob1011, 1011 | 1100 == 1111)</span></span><br><span class="line">print(<span class="number">11</span> | <span class="number">1100</span>)        <span class="comment"># 0b10001001100 | 00000001011 == 1100 + 3 == 1103</span></span><br><span class="line">print(bin(<span class="number">1100</span>))        <span class="comment"># 0b10001001100</span></span><br><span class="line">print(<span class="number">0b11</span> ^ <span class="number">0b1010</span>)        <span class="comment"># 1001 == 9</span></span><br></pre></td></tr></table></figure>

<p>buildins（Python的内建模块，预定义的功能函数）</p>
<p>max，min，sum都在此中。</p>
<p>decimal模块设置全局精度：</p>
<p>decimal.getcontext( ).prec = 4</p>
<p>获得运行环境</p>
<p>decimal.Decimal(1) </p>
<p>print(decimal.Decimal(1) / decimal.Decimal(<strong>‘7’</strong>))</p>
<p><em># 0.1428571428571428571428571429    (默认精度)</em></p>
<p>关于布尔值（bool）</p>
<p>原本只是一个数字，</p>
<p>如果要用==来判断，那么只有True == 1才会返回True。0 == False才会返回False</p>
<p>如果用if来判断，那么只有特定情况下是返回False。</p>
<p>返回False的情况：</p>
<p>数字0（包括0.0，0.00000等）</p>
<p>空字符串（仅限’’, “”）(前面是一对单引号，后面是一对双引号）</p>
<p>其他诸如：” “(一个空格),   ‘0’,  “‘’”(双引号里面再加一对单引号)等等，都是返回True的。</p>
<p>空值：None</p>
<p>空集合： [ ] , (  ),   {  }</p>
<p>(此外，由于python里的True跟False其实就是1跟0，所以甚至能跟数字进行运算。比如：</p>
<p>True + 3 + 5J  == 4 + 5J</p>
<p>False  + 7.4  ==  7.4        True  +  5.5  ==  6.5</p>
<p>(不过一般意义不大，omit it！）</p>
<p>多个字符串用空格分隔开赋值，相当于加号运算符。例子：</p>
<p>s = “Meaning “ ‘of’ ‘ the life’</p>
<p>s            # Meaning of the life</p>
<p>如果中间是用 逗号 分隔开，那么会生成元组。</p>
<p>s = “Meaning “ , ‘of’ “ the life’</p>
<p>s            # (‘Meaning ‘, ‘of the life’)</p>
<p>关于转义：</p>
<p>在cmd中直接输出，会变成自动带有转义效果的字符串。比如换行会变成\n，\会变成\</p>
<p>然后，如果赋值的时候，反斜杠后面跟的并不是转义的字符，那么反斜杠会直接写入，例子：</p>
<p>x = “C:\py\code”</p>
<p>print(x)    # C:\py\code    因为并没有\p,\c，但建议在使用反斜杠而非转义时，还是直接转义</p>
<p>即：    x = “C:\py\code”    结果会是一样的</p>
<p>同时，无论如何，print(x)，里面的反斜杠会是\，而直接x时候（在cmd），会是\</p>
<p>在字符串前面加一个r，表示不转义。例子：</p>
<p>c = r’c:\py\code’</p>
<p>print(c)        # c:\py\code</p>
<p>三重引号（无论单引号，双引号都可以），可以用于编写多行文本数据。</p>
<p>即’’’ asdzxc…………（包括各种换行）’’’    这时候里面所有行加起来成为一个字符串。</p>
<p>（cmd中换行会变成\n）</p>
<p>而多行文本中的引号都会直接输出，无须转义。（直到遇见三重引号结束的时候）</p>
<p>同时，可以利用三重引号来作为多行注释（对性能影响不大，一般应该还是用于调试阶段）</p>
<p>转换。int( ), str( ) , repr( )</p>
<p>repr函数能将一个对象转换成其字符串形式。</p>
<p>ord将字符转换成ASCII码，chr则将ASCII码转换成字符。</p>
<p>格式化字符串的两种方法：</p>
<p>1.用%d，%s等占位符</p>
<p>“That is %d %s bird!”% (1, ‘dead’)</p>
<p>2.使用占位数组</p>
<p>‘That is {0} {1} bird!’.format(1, ‘dead’)</p>
<p>显然，format紧接着的就是一个数组，从{0}开始慢慢对应替换。format方法是新的格式化方法。</p>
<p>一般除非要进行特殊的格式化，否则直接用%s就行了，因为每种类型的对象都可以转换为字符串。</p>
<p>PS：格式化的结果是一个新的字符串对象，而不是对原本的字符串进行的修改。</p>
<p>其他格式化代码    P194</p>
<p>字符串方法：P186，此处略</p>
<p>Python一共有3个主要类型（以及操作）：</p>
<p>1.数字（整数，浮点数，二进制，分数等）：</p>
<p>支持加法，乘法等等。</p>
<p>2.序列（字符串，列表，元组）：</p>
<p>支持索引，分片，合并等等。</p>
<p>3.映射（字典）：</p>
<p>支持通过键的索引等。</p>
<p>（集合是自成一体的一个分类，不在此中）</p>
<p>每种类型的操作都是相通的，比如：</p>
<p>对于字符串，乘法运算符* 的作用是创建一个字符串的N份拷贝。</p>
<p>s = ‘abc’</p>
<p>s = s * 3            # PS： s * 3  &lt;==&gt;  3 * s</p>
<p>s        # ‘abcabcabc’</p>
<p>那么对于其他的序列sequence来说，<em>的运算也是相同的。比如对于list，之前没对list用过</em>，实际上效果也是一样的：</p>
<p>x = [1, 2, 3] * 3</p>
<p>x            # [1, 2, 3, 1, 2, 3, 1, 2, 3]</p>
<p>可变类型：数字，字符串，元组，不可变集合。</p>
<p>可变类型：列表，字典，可变集合。</p>
<p>-———</p>
<p>list的append与extend：</p>
<p>append是添加一个元素，extend是添加一个iterable的元素（list，tuple等等,并且迭代展开来。</p>
<p>例子：</p>
<p>[1, 2, 3].append([4, 5, 6])        ==&gt;    [1, 2, 3, [4, 5, 6]]</p>
<p>[1, 2, 3].extend([4, 5, 6])        ==&gt;     [1, 2, 3, 4, 5, 6]</p>
<p>分片赋值：</p>
<p>L = [1, 2, 3, 4, 5, 6, 7, 8]</p>
<p>L[2: 4] = [100, 200, 300, 400, 500]</p>
<p>使得L的[2, 3]替换成右边的。结果：[1, 2, 100, 200, 300, 400, 500, 3, 4, 5, 6, 7, 8]</p>
<p>字典的key不一定要是字符串，整数也行。只要是不可变对象就行。</p>
<p>获取不存在的key的值时会报错，然后程序就会结束，避免程序结束：</p>
<p>1.if key1 in dir: … else: …            通过if判断是否存在该key</p>
<p>2.try: …… except KeyError: ……        如果出错就执行except里的语句，然后继续执行。</p>
<p>3.dir.get(key1, 0)                    get方法，获取key1的值，获取不到就返回第二个参数</p>
<p>创建字典的方法：</p>
<p>dir = {‘name’ : ‘xxx’ , ‘age’ : 45}</p>
<p>D = { }</p>
<p>D[‘name’] = ‘xxx’</p>
<p>D[‘age’] = 45</p>
<p>dir = dict(name = ‘mel’, age = 45)        # key必须都是字符串才行</p>
<p>dir = dict( [(‘name’, ‘mel’), (‘age’, 45)])    # 给dict传入一个list对象的时候比较适用</p>
<p>嵌套对象用&gt; , &lt;比较大小时，会一直递归，从左到右比较，走到最深的层次，逐步比较差值。</p>
<p>关于乘法运算符，是返回一个新的对象（重复n次连接起来的），这时即使是重复一个对象，也不会因为原对象引用改变而改变新的对象。但在嵌套可变序列（对象）时，情况会不一样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">x = L * <span class="number">4</span></span><br><span class="line">y = [L] * <span class="number">4</span></span><br><span class="line">y2 = [L[:]] * <span class="number">4</span></span><br><span class="line">print(x)            <span class="comment"># [4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]</span></span><br><span class="line">print(y)            <span class="comment"># [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]</span></span><br><span class="line">print(y2)           <span class="comment"># [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]</span></span><br><span class="line">L[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">print(x)            <span class="comment"># [4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]</span></span><br><span class="line">print(y)            <span class="comment"># [[4, 0, 6], [4, 0, 6], [4, 0, 6], [4, 0, 6]]</span></span><br><span class="line">print(y2)           <span class="comment"># [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]</span></span><br></pre></td></tr></table></figure>

<p>对于x = L * 4，是生成了一个新的list，不存在共享引用，因此L改变时，x并不会改变。</p>
<p>但是对于y = [L] * 4,相当于[ … ] * 4生成了一个新的list，而每个[ ]里面又引用了一个外部的list（共享引用），此时L改变时，y也会跟着改变。</p>
<p>解决方法就是拷贝，y2 = [L[:]] * 4,这样就不存在共享引用。</p>
<p>当复合对象包含指向自身的引用，称为循环对象，而这个自身的引用会打印成[…]，避免无限循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; [&#39;hong&#39;]</span><br><span class="line">x.append(x)</span><br><span class="line">print(x[0])         # hong</span><br><span class="line">print(x[1])         # [&#39;hong&#39;, [...]]</span><br><span class="line">print(x[1][0])      # hong</span><br><span class="line">print(x[1][1])      # [&#39;hong&#39;, [...]]</span><br></pre></td></tr></table></figure>

<p>对于sequence：假如 L = [0, 1, 2, 3, 4]    len = 5</p>
<p>1.索引值超过边界时，会发生error        （如L[5]）</p>
<p>2.但分片运算超出边界时，会把超出的数字限制回最大值。</p>
<p>如L[2: 100]    会自动改为L[2: 5]    不会报错</p>
<p>3.但左边界大于右边界时，会返回空sequence。</p>
<p>如：L[3: 1]     ==&gt;  [ ]</p>
<p>（以翻转的方式提取序列是行不通的（ 较低边界值比较高边界值更大， 例如，</p>
<p>L[3:1] ）。你会得到空分片（ [] ），因为Python会缩放分片限制值，以确定较低边</p>
<p>界永远比较高边界小或相等（例如， L[3:1] 会缩放成 L[3:3] ，空的插入点是在偏</p>
<p>移值3处））</p>
<p>但对这部分赋值是可行的，并且是以左边界处进行插入。</p>
<p>如： L[3: 1] = [‘10’, ‘20’, ‘30’, ‘40’, ‘50’]     但不等于L[3] = [‘10’, ‘20’, ‘30’, ‘40’, ‘50’]</p>
<p>结果会是： [0, 1, 2, 10, 20, 30, 40, 50, 3, 4]    (与有边界的数字无关）</p>
<p>如果是L[3]=。。。    则是直接更新list，更新list[3]的值了，而且L[3]的值会变成一个[。。 ] list</p>
<p>L[3] = [‘10’, ‘20’, ‘30’, ‘40’, ‘50’]        ==&gt;    L == [0, 1, 2, [‘10’, ‘20’, ‘30’, ‘40’, ‘50’], 4]</p>
<p>(如果分片赋值的时候，也超出边界，那么仍然按照第二条来执行：</p>
<p>L[10000:200]    = […]    这样就相当于append（超出时是append）</p>
<p>（这种反向（左边界不小于右边界）分片赋值在插入元素时是一个可行的选择）</p>
<p>4.L[2] = [ ]     那么L[2]的值就变成了[ ],即 L == [0, 1, [ ] , 3, 4]</p>
<p>但如果是分片赋值，L[2: 4] = [ ] ,则这里面的值会删除，最后：L == [0, 1, 4]</p>
<p>赋值空列表给一个分片，则会删除该分片</p>
<p>(但如果是第三条的情况下赋值[ ],则不会生效。如L[3: 1] = [ ] ，并不会删除L[3]，不会执行任何操作。</p>
<p>而只有当左边界小于右边界（即正常情况），才会删除）</p>
<p>if state:</p>
<p>state2</p>
<p>try:</p>
<p>statement1</p>
<p>except:</p>
<p>statement2</p>
<p>else:</p>
<p>statement3</p>
<p>finally:</p>
<p>statement4</p>
<p>else可以与if连用，也可以与try-except连用。上述语句else是与try连用，就近原则。</p>
<p>try-except-else-finally的意思是：</p>
<p>如果出现了错误，那么就执行except里的语句，如果没有错误，就执行else里的语句。finally一定执行</p>
<p>关于作用域，global和nonlocal：</p>
<p>（global用于在函数里访问全局同名变量，如果没global，按照LEGB原则，全局变量会被局部变量名覆盖，因而访问不到全局变量。）</p>
<p>（而nonlocal用于在嵌套函数里访问外部函数的同名变量，如果没global，按照LEGB，也是会先访问当前层次的局部变量，访问不到外部函数的同名变量）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">y, z = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x1 = <span class="number">123</span></span><br><span class="line">    x = y + z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x1</span><br><span class="line">        x1 = <span class="number">1234</span></span><br><span class="line">    f2()</span><br><span class="line">    print(x1)   <span class="comment"># 1234  f2通过nonlocal把f1的x1给修改了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line">print(x)    <span class="comment"># 3 f1通过global把全局的x给修改了</span></span><br><span class="line">x = <span class="number">100</span></span><br><span class="line">print(x)    <span class="comment"># 100</span></span><br></pre></td></tr></table></figure>

<p>Python的嵌套函数类似于JS的闭包，也可以保存已经结束了的外部函数的变量。如下面，就相当于可以视为一个工厂函数：（同时还能根据类型而做出不同的选择）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maker</span><span class="params">(N)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> X * N</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = maker(<span class="number">3</span>)</span><br><span class="line">print(f(<span class="string">'a'</span>))		<span class="comment"># aaa</span></span><br><span class="line">print(f(<span class="number">5</span>))			<span class="comment"># 15</span></span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/note/" rel="tag"># note</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/17/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="next" title="Linux常用命令">
                <i class="fa fa-chevron-left"></i> Linux常用命令
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/17/Swing%E7%AC%94%E8%AE%B0/" rel="prev" title="Swing笔记">
                Swing笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  

  




        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/03.jpeg"
                alt="Hong" />
            
              <p class="site-author-name" itemprop="name">Hong</p>
              <p class="site-description motion-element" itemprop="description">hong</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Hongscar" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:84363715@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '75d5d92e717eca3c6b03',
          clientSecret: '3ec3a4b9ee7baf1c9f4ec85b4ce8d2af9126edb3',
          repo: 'hongscar.github.io',
          owner: 'hongscar',
          admin: ['hongscar'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>


  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
