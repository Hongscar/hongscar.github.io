<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="dOjrq8WodF" />










<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/images/manifest.json">




  <meta name="keywords" content="interview," />





  <link rel="alternate" href="/atom.xml" title="Hong's Blog" type="application/atom+xml" />






<meta name="description" content="一. 前言：​        在准备面试的过程中，发现HashMap源码是很常见的考点，于是进行了仔细的学习。以前都说读源码是快速提高Java水平的好途径，在阅读了HashMap的部分重要源码之后真的是深有体会，于是写下此篇文章做记录。具体内容包括，HashMap的构造方法，put，get方法，以及put&amp;get所需要的hash方法，还有扩容时所需要的resize方法。我们将对这几个方法的">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap源码阅读">
<meta property="og:url" content="https://hongscar.cn/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html">
<meta property="og:site_name" content="Hong&#39;s Blog">
<meta property="og:description" content="一. 前言：​        在准备面试的过程中，发现HashMap源码是很常见的考点，于是进行了仔细的学习。以前都说读源码是快速提高Java水平的好途径，在阅读了HashMap的部分重要源码之后真的是深有体会，于是写下此篇文章做记录。具体内容包括，HashMap的构造方法，put，get方法，以及put&amp;get所需要的hash方法，还有扩容时所需要的resize方法。我们将对这几个方法的">
<meta property="og:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_1.png">
<meta property="og:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_2.png">
<meta property="og:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_3.png">
<meta property="og:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_4.png">
<meta property="og:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_5.png">
<meta property="og:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_6.png">
<meta property="og:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_7.png">
<meta property="og:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_8.png">
<meta property="og:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_9.png">
<meta property="og:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_10.png">
<meta property="og:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_11.png">
<meta property="og:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_12.png">
<meta property="og:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_13.png">
<meta property="og:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_14.png">
<meta property="article:published_time" content="2020-02-17T03:51:39.000Z">
<meta property="article:modified_time" content="2020-02-17T14:51:14.442Z">
<meta property="article:author" content="Hong">
<meta property="article:tag" content="interview">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hongscar.cn/HashMap源码阅读.html"/>





  <title>HashMap源码阅读 | Hong's Blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hong's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Like life,like coding</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongscar.cn/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/03.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">HashMap源码阅读</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-17T11:51:39+08:00">
                2020-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="一-前言："><a href="#一-前言：" class="headerlink" title="一. 前言："></a>一. 前言：</h3><p>​        在准备面试的过程中，发现HashMap源码是很常见的考点，于是进行了仔细的学习。以前都说读源码是快速提高Java水平的好途径，在阅读了HashMap的部分重要源码之后真的是深有体会，于是写下此篇文章做记录。具体内容包括，HashMap的构造方法，put，get方法，以及put&amp;get所需要的hash方法，还有扩容时所需要的resize方法。我们将对这几个方法的源码进行阅读，理解它的逻辑，以及一些巧妙的设计。</p>
<a id="more"></a>

<h3 id="二-HashMap原理："><a href="#二-HashMap原理：" class="headerlink" title="二. HashMap原理："></a>二. HashMap原理：</h3><p>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。<br><strong>常用的方法有</strong>：<br>构造方法，可以定义initialCapacity初始容量，factor负载因子。threshold = initialCapacity * factor<br>put，get，二者需要用到hash方法，也就是散列函数。<br>resize：放数组容量不足时，元素个数大于threshold时，就要扩容。<br>HashMap使用数组链表来存储数据（数组的每一项都是一个链表），JDK1.8开始，当链表的长度到达一定程度，就会把该链表转换成红黑树。</p>
<hr>
<h3 id="三-①-构造方法："><a href="#三-①-构造方法：" class="headerlink" title="三. ① 构造方法："></a>三. ① 构造方法：</h3><p>构造方法一共有4个：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_1.png" target="_blank" rel="noopener" title="HashMap构造方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_1.png" alt="HashMap构造方法" title="HashMap构造方法"></a><br>显然，第一个就是没有参数，此时会设置默认的负载因子factor。<br>对于第二个，实际上就是将float参数设置为默认的负载因子default_factor。<br>对于第四个，是传入一个Map对象进行初始化。我们重点看第三个构造方法：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_2.png" target="_blank" rel="noopener" title="第三个构造方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_2.png" alt="第三个构造方法" title="第三个构造方法"></a><br>前面的都是判断一下边界值，就省略了。<br>HashMap有几个关键的成员属性：<br><em>initialCapacity</em>：初始容量大小（数组大小，但后面会改变）<br><em>factor</em>：负载因子<br><em>threshold</em>：initialCapacity * factor（到达这个值的时候，哈希数组会扩容）<br>（初始化之后，后续用size表示哈希数组里的元素个数，当size超过threshold之后，扩容）<br>然后我们发现一行关键的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br></pre></td></tr></table></figure>

<p>点进入看<em>tableSizeFor</em>的函数逻辑：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_3.png" target="_blank" rel="noopener" title="tableSizeFor"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_3.png" alt="tableSizeFor" title="tableSizeFor"></a><br>可以看到这个方法的目的：<strong>returns a power of two size for the given target capacity</strong></p>
<p>也就是说，<strong>哈希数组的长度，永远是2的幂次方</strong>，至于为什么，请看后面的<strong>question1</strong>.<br>关于这个算法的逻辑，用下图可以说明：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_4.png" target="_blank" rel="noopener" title="tableSizeFor算法的逻辑"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_4.png" alt="tableSizeFor算法的逻辑" title="tableSizeFor算法的逻辑"></a><br>连续的n |= n &gt;&gt;&gt; 1, 2, 4, 8, 16，通过这样，最多可以让连续32位为1.不管capacity是多少，比如它是1011，减去1之后是1010，第一个不为0的位是第4位，那么这个算法会返回10000.<br>（这里的关键是<strong>或运算</strong>，因为第一位是1，1和任何数字进行或运算都为1，因此，n&gt;&gt;&gt;1，会使得n的前2位变为2，然后再执行n&gt;&gt;&gt;2，就是前4位，再执行n&gt;&gt;&gt;4，就是前8位。）如果数字没有那么高位，那么高位全是0，并且n&gt;&gt;&gt;x全部都为0，因而或运算为0，高位没有任何影响，看下图例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_5.png" target="_blank" rel="noopener" title="高位运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_5.png" alt="高位运算" title="高位运算"></a><br>这个算法，巧妙地通过了位运算，返回了一个不小于capacity 的最小2的幂次方。至于为什么要-1，是防止capacity已经是2的幂次方的情况，比如是10000，如果不减1，那么返回的将会是100000.减去1，使得初始的capacity改为1111（1111和1001，1101等都是一样的）。<br>以上的情况都是在capacity不为0的情况考虑的，而当capacity为0的时候，无论经过几次运算，都为0，那么最后的capacity将为1（最后有一个n+1的操作），所以也是符合预期结果的。<br>这样，我们就得到了一个2的幂次方的capacity，即哈希数组的长度（所以比如，当我们传入的capacity为12，最终生成的数组长度会是16.）<br>结果：<br> // 如果没有指定initialCapacity, 则不会给threshold赋值, 该值被初始化为0<br> // 如果指定了initialCapacity, 该值被初始化成不小于initialCapacity的最小的2的次幂</p>
<hr>
<h3 id="四-②put方法："><a href="#四-②put方法：" class="headerlink" title="四. ②put方法："></a>四. ②put方法：</h3><p>可以看到，put方法其实还有两个参数，但put方法并没有重载方法，所以如果我们需要改变后两个参数，应该使用putVal方法自己修改，但一般不需要，在下文看putVal的方法里我们就知道着两个参数是什么作用了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**接下来关键是看putVal的方法实现：（逐行分析，中文注释）</p>
<p>**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;			</span><br><span class="line"><span class="comment">//创建一些后面需要的变量，略</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;	</span><br><span class="line"><span class="comment">//如果哈希数组为空，即还没初始化，先resize一次，resize后面再看，这里只需要知道</span></span><br><span class="line"><span class="comment">//会创建一个默认长度的哈希数组即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)	</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//如果哈希数组该index没有元素，即没有发生碰撞，直接插入一个newNode即可。</span></span><br><span class="line"><span class="comment">//这里的(n - 1) &amp; hash的原理，查看后面的question2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;	<span class="comment">//说明已经有元素，发生了碰撞，然后我们就沿着链表/红黑树去插入Node</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">//我们首先会查看第一个元素（在第一个元素时就能确定它是链表还是数组）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;	</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"><span class="comment">//这里的p是上文的p = tab[i = (n - 1) &amp; hash]，即第一个元素，如果第一个元素跟待插入</span></span><br><span class="line"><span class="comment">//的元素是相同的，即key相同（hash肯定是已经相同的了），然后我们只需要更改p的值</span></span><br><span class="line"><span class="comment">//即可。这里的逻辑是，把p赋值给新创建的Node e，然后跳出整个循环之后，再判断e</span></span><br><span class="line"><span class="comment">//是否位null，如果e为null，那么直接进行value的替换即可，否则，往后看。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="comment">//判断该index项是链表还是红黑树，如果是红黑树再进入putTreeVal，此处略</span></span><br><span class="line">        <span class="keyword">else</span> &#123;	</span><br><span class="line"><span class="comment">//说明是链表，并且第一个元素也不相等，所以我们就遍历链表，然后插入到链表的最</span></span><br><span class="line"><span class="comment">//后，并且，如果链表长度过长，还会引起链表树化的操作。如果是整个数组的长度过</span></span><br><span class="line"><span class="comment">//大，那么还要对数组进行resize。（PS：这里的元素相等是指key，链表里的key都是互</span></span><br><span class="line"><span class="comment">//不相等的，只是它们发生hash冲突导致都放在数组的同一个index上。所以如果在中间</span></span><br><span class="line"><span class="comment">//发现了相同的key，那么就跟前面一样，其实也是e = p的逻辑，然后在后续直接覆盖</span></span><br><span class="line"><span class="comment">//value即可。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;		</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//p.next为null，那么直接将p.next新建一个newNode即可。即已经到达链表的最后。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line"><span class="comment">//这是指链表长度大于等于TREEIFY_THRESHOLD的时候，进行树化。默认是8.注意这</span></span><br><span class="line"><span class="comment">//里为什么是&gt;= THREIFY_THRESHOLD，看起来是7个就可以树化，但实际上还是8个</span></span><br><span class="line"><span class="comment">//的。具体的看后面的question4.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="comment">//如果遇到了相等的key，那么就是覆盖value。注意此时并未到链表的最后，所以这里的</span></span><br><span class="line"><span class="comment">//e不等于null。而上面的(e = p.next) == null，上面逻辑的e会是null。这个e后面马上用到</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line"><span class="comment">//这里的p = e实际上就是 p = p.next，因为并没有执行for循环里的两个if，如果执行了其</span></span><br><span class="line"><span class="comment">//中一个，都会直接break跳出循环。（个人觉得这个p = e放在for判定语句里可读性更好</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="comment">//这就是前面一直说的e，如果存在相同的key，那么e就不是null，此时直接覆盖value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">//这就是第三个参数，表示已有相同的key时是否更新。onlyIfAbsent默认是false，所以这</span></span><br><span class="line"><span class="comment">//里的if是一定会触发，即一定会覆盖value。如果手动将onlyIfAbsent改为true，那么就是</span></span><br><span class="line"><span class="comment">//只有当oldValue为null的时候，才能改变key的value，否则都不会改变。</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);	</span><br><span class="line"><span class="comment">//这个在HashMap是空方法，在LinkedHashMap的时候才会被重写并使用。</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="comment">//覆盖了value（或者不覆盖），就把oldValue返回，方法结束。因此插入一个相同key的</span></span><br><span class="line"><span class="comment">//元素，实际上是更新该key的value，方法的逻辑在这里已经完成，不会改变HashMap的</span></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	<span class="comment">//最外层的if-else循环结束</span></span><br><span class="line">    ++modCount;</span><br><span class="line"><span class="comment">//到达了这里，说明不存在相同的key，所以插入了一个新的key，改变modCount以及</span></span><br><span class="line"><span class="comment">//哈希数组的元素个数size</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line"><span class="comment">//如果改变了之后，哈希数组的元素个数大于threshold，此时发生碰撞的概率较大，因此</span></span><br><span class="line"><span class="comment">//进行resize，即对哈希数组进行扩容，后面会讲到。</span></span><br><span class="line">    afterNodeInsertion(evict);	<span class="comment">//同样是LinkedHashMap的东西，此处为空方法。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主要是这么几个步骤：</strong><br>如果当前table为空，先进行初始化<br>查找插入的键值对是否存在，存在的话，先进行赋值，后续将更新旧的键值对<br>不存在，插入链表尾部，如果链表长度大于一个阈值，进行链表转化树的操作<br>如果size大于一个阈值，进行扩容<br>PS：threshold在初始化的时候，值为2的幂次方（在tableForSize那里可以看到），但threshold应该是capacity * factor，当size大于threshold的时候才执行resize。那么会不会因此而导致初始化的时候threshold并不受factor的影响？<br>（比如我们初始化的时候，capacity传参是10，factor是0.75，在tableForSize里，我们知道threshold会被赋值为不小于10的2的幂次方，即16.然后根据put的逻辑，应当是++size &gt; threshold的时候才扩容，那么初始化的threshold是16，而不是预期的值16 * 0.75 = 12？）<br>实际上并不是的，上面的threshold实际上就不应该是哈希数组的长度（所以JDK源码在构造方法里，把2的幂次方赋值给threshold确实有迷惑的意思）。在put方法的第一个步骤，即“如果当前table为空，先进行初始化”。那么我们再看一下这一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">   		 n = (tab = resize()).length;</span><br></pre></td></tr></table></figure>

<p>当table为空，那么要先resize，即数组是在这里才进行建立的。在resize里面，是把threshold赋值给了另一个叫newCap的变量（看变量名可知，显然就是新的哈希数组的长度），然后threshold又会被改变为newCap * factor。所以threshold虽然确实是2的幂次方，但确实并不是代表哈希数组的长度，仍然是作为扩容的判断点（<strong>虽然是个无聊的问题，但感觉是JDK源码的变量具有迷惑性！</strong>）至于resize的源码，继续看。</p>
<hr>
<h3 id="五-③get"><a href="#五-③get" class="headerlink" title="五. ③get"></a>五. ③get</h3><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_6.png" target="_blank" rel="noopener" title="get方法的源码"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_6.png" alt="get方法的源码" title="get方法的源码"></a><br>get方法显然简单很多。首先判断是否存在该key，如果不存在，返回null。<br>getNode的逻辑体也是比较简单，先查找第一个元素，看key值是否相等。至于为什么需要“always check first node”，显然，因为<strong>JDK1.8可能是链表，可能是红黑树，需要进行判断</strong>。<br>如果当第一个first就是相等的，那么就直接返回。如果不在，判断是否是红黑树，如果是，使用另一套逻辑，如果不是，就是简单的链表遍历，对比，e = e.next，应该很好理解，此处略。</p>
<hr>
<h3 id="六-④hash"><a href="#六-④hash" class="headerlink" title="六. ④hash"></a>六. ④hash</h3><p>首先给出<strong>HashMap计算哈希码的整体步骤</strong>：<br><em>1.获取key的hashCode</em><br><em>2.对hashCode进行处理（hash方法），主要是高16位不变，而低16位与高16位进行异或操作</em><br><em>3.对capacity进行取模（使用了 hash &amp; (n - 1)进行优化）</em><br>在put和get方法中，可以看到都需要对key进行hash运算：</p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_7.png" target="_blank" rel="noopener" title="put方法的hash运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_7.png" alt="put方法的hash运算" title="put方法的hash运算"></a></p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_8.png" target="_blank" rel="noopener" title="get方法的hash运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_8.png" alt="get方法的hash运算" title="get方法的hash运算"></a></p>
<p>因为<strong>hashcode就是为了HashMap而生的</strong>，在学习重写equals时为何要重写hashCode的时候我们就已经知道了。那么HashMap里到底如何重写hashCode方法呢，如下：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_9.png" target="_blank" rel="noopener" title="HashMap中的hashCode方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_9.png" alt="HashMap中的hashCode方法" title="HashMap中的hashCode方法"></a><br>嗯。。。很简单的异或运算，结合了key和value的hashCode，没什么特别的。结合value同样是减少碰撞。这个就是步骤1.</p>
<p>那么接下来看一下步骤2，HashMap自定义的hash方法：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_10.png" target="_blank" rel="noopener" title="HashMap中自定义的hash方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_10.png" alt="HashMap中自定义的hash方法" title="HashMap中自定义的hash方法"></a><br>从逻辑上看，就是hash本身与hash右移16位的结果进行异或。<br>h &gt;&gt;&gt; 16的结果：高16位全部变成0，原本高16位的处于低16位。<br>h ^ ( h &gt;&gt;&gt; 16)的结果：<br>1.高16位不变。<strong>因为0与任何数进行异或，返回的都是那个数本身</strong>。0 ^ 1 = 1, 0 ^ 0 = 0<br>2.低16位于原本的高16位进行异或。<br>步骤3对capacity取模，很好理解，不能超出哈希数组的范围。第二步的意义何在？看<strong>question3</strong>.</p>
<hr>
<h3 id="七-⑤resize"><a href="#七-⑤resize" class="headerlink" title="七. ⑤resize"></a>七. ⑤resize</h3><p>在put的过程中，当size超出了threshold，那么就需要进行resize扩容。逻辑比较复杂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;		</span><br><span class="line"><span class="comment">//oldCap表明，table里原本已经存在key-value</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">//如果oldCap都已经扩容到最大了，那么就直接将threshold设为最大值，只好任你碰撞</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line"><span class="comment">//没有超出最大值，那么就安心扩容为原来的 2倍。值得注意的是newCap跟newThr都扩</span></span><br><span class="line"><span class="comment">//容为 2倍，仔细看 if 语句的判定。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line"><span class="comment">//这个就是我们前面所说的，当初始化的时候，会将threshold仅仅作为一个变量赋值给</span></span><br><span class="line"><span class="comment">//newCap，然后后面又把newCap*factor赋值给threshold</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line"><span class="comment">//这里就是调用new HashMap( )的情况，一个构造参数也没有的时候，直接赋默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//当上面第一个if里面没有执行里面的两个子if语句时，newThr仍然没有变化，即为0.需要在这里再对threshold进行修改。</span></span><br><span class="line"><span class="comment">//（比如上面的： else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span></span><br><span class="line"><span class="comment">//                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)，此时newCap可能超出了MAX，那么</span></span><br><span class="line"><span class="comment">//newThr就仍然为0.又或者是 else if (oldThr &gt; 0)  newCap = oldThr;中，即初始化带int参数的时</span></span><br><span class="line"><span class="comment">//候，这里仍然没有对threshold进行赋值。）</span></span><br><span class="line"> 	<span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"><span class="comment">//这段代码就是普通地判断threshold是否会超出MAX而已</span></span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"><span class="comment">//我们已经将新数组的各种参数（capacity，threshold等）都设置好了，接下来需要将原</span></span><br><span class="line"><span class="comment">//本的数组元素放入到新的哈希数组中。显然，因为这个操作，使得resize方法是一个极</span></span><br><span class="line"><span class="comment">//其耗费时间的方法，所以在大概知道元素个数的时候，不应该使用默认值16，而是显式</span></span><br><span class="line"><span class="comment">//定义HashMap的初始容量，减少resize次数，可以显著地提高效率</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//这里table中存放的只是Node的引用, 将oldTab[j]=null只是清除旧表的引用, 但是真正的</span></span><br><span class="line"><span class="comment">//node节点还在, 只是现在由e指向它。所以这里主要是提醒JVM，这里可以被GC清理了</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 如果该存储桶里面没有元素, 就直接将它放到新表的目标位置</span></span><br><span class="line">    </span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)	<span class="comment">//如果是树，则根据红黑树的逻辑拆分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line"><span class="comment">// 不是红黑树，那么就是链表。因此我们需要把该链表放入新的哈希数组的位置。</span></span><br><span class="line"><span class="comment">//主要是获取整条链表（即使只有 1个元素，结构仍然是链表）。</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//设置了两个链表，原因是根据不同情况，插入到不同的链表，最后再根据结果赋值</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;		<span class="comment">//第n位为0</span></span><br><span class="line"><span class="comment">// 我们知道hash &amp; (n - 1)就是原本的位置，那么hash &amp; n是什么？原本的哈希值为n - 1</span></span><br><span class="line"><span class="comment">//位，当它扩容之后，它的哈希值位n - 1或者n位，即第n位要么是0，要么是1，而</span></span><br><span class="line"><span class="comment">//hash &amp; n就是能获取第n位的值，在后面我们会解释为什么</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;						<span class="comment">//第n位为1</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);		<span class="comment">//此处do-while刚好使得循环至少执行1次</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;		<span class="comment">//根据0还是1决定赋值哪个</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于resize的最后那一部分：<br>在JDK1.7之前，都是直接再计算一次hash，然后放入新的哈希数组位置（index,bucket）。<br>但在JDK1.8中，代码得到了改进，看一下官方注释：<br><strong><em>Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</em></strong><br>大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。（n - 1位哈希码，变成n - 1位或 n位）<br>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_11.png" target="_blank" rel="noopener" title="resize时hash位置的变化"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_11.png" alt="resize时hash位置的变化" title="resize时hash位置的变化"></a><br>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_12.png" target="_blank" rel="noopener" title="resize后index的变化"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_12.png" alt="resize后index的变化" title="resize后index的变化"></a><br>因此，<strong>我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</strong>可以看看下图为16扩充为32的resize示意图：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_13.png" target="_blank" rel="noopener" title="resize整个示意图"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_13.png" alt="resize整个示意图" title="resize整个示意图"></a><br>那么，<strong>为什么 hash &amp; n就是可以获得第n位的值呢？</strong><br>首先我们必须知道，n是一个2的幂次方数，它的二进制i形式是00……1000……<br>易知，0 &amp; x = 0，1 &amp; x = x，而我们就是想要hash值的第n位的x值。<br>因此，hash &amp; n，刚好就是取到了新的hash值的第n位的x值。<br>故得出结论:    （最后的if，else判断）<br>如果 (e.hash &amp; oldCap) == 0 则该节点在新表的下标位置与旧表一致都为 j<br>如果 (e.hash &amp; oldCap) == 1 则该节点在新表的下标位置 j + oldCap</p>
<hr>
<hr>
<h3 id="八-中间遗留出来的questions："><a href="#八-中间遗留出来的questions：" class="headerlink" title="八. 中间遗留出来的questions："></a>八. 中间遗留出来的questions：</h3><p><strong>question1：哈希数组的长度为什么需要是2的幂次方？</strong><br>ans：因为在映射的时候，需要执行(n - 1) &amp; hash，当n不为2的幂次方的时候，n的个位为1，(n - 1)的个位则为0，又因为0 &amp; x = 0，因此使得最后一位必定是0，即浪费了1个位的空间，碰撞的几率也会增大。而如果n是2的幂次方，那么(n - 1)的个位必定是1，1 &amp; x = x，即根据hash的个位来决定，而不是一定返回0，因此能降低碰撞几率，充分利用每一个位。</p>
<hr>
<p><strong>question2： （n - 1 ) &amp; hash的原理？</strong><br>ans：因为n是2的幂次方，因而(n - 1)的值位000……1111（若干个1.(n - 1) &amp; hash，即返回hash的低<br>⌈log2(n - 1)⌉ （2为底）位的值，即hash &amp; n。如下图：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_14.png" target="_blank" rel="noopener" title="hash &amp; (n - 1)"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_14.png" alt="hash &amp; (n - 1)" title="hash &amp; (n - 1)"></a><br>使用(n - 1) &amp; hash而不使用hash % n的好处：<br>位运算是计算机最快的运算，因此效率更高。同样因为n是2的幂次方，因而该算法也不会出现超出取模范围的错误。</p>
<hr>
<p><strong>question3：为什么要将低16位与高16位进行异或操作？</strong><br>ans：先看一下源码的代码注释：<br><strong><em>Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don’t benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</em></strong><br>设计者认为<strong>(n - 1) &amp; hash很容易发生碰撞</strong>，因为如果不对hash进行其他处理，那么hash起作用的仅仅是⌈log2(n - 1)⌉，比如当n为16的时候，hashCode起作用的仅仅是低4bit的有效位，那么当然容易碰撞了。因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是<strong>把高16bit和低16bit异或了一下</strong>。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。（即通过h ^ (h &gt;&gt;&gt; 16)，<strong>间接让高16位也参与计算，从而让键值对分布均匀，降低hash碰撞</strong>）</p>
<p>如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞<strong><em>(we use trees to handle large sets of collisions in bins)</em></strong>，在JEP-180中，描述了这个问题：<br><strong><em>Improve the performance of java.util.HashMap under high hash-collision conditions by using balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class.</em></strong><br>之前已经提过，在获取HashMap的元素时，基本分两步：<br>首先根据hashCode()做hash，然后确定bucket的index；<br>如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。<br>在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是<strong>O(1)+O(n)</strong>。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。<br>因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了<strong>O(1)+O(logn)</strong>了，这样在n很大的时候，能够比较理想的解决这个问题。</p>
<hr>
<p><strong>question4：为什么判定条件是”binCount &gt;= TREEIFY_THRESHOLD - 1”，但树化的条件仍然是bitCount &gt;= TREEIFY_THRESHOLD - 1?</strong><br>ans：这里：binCount &gt;= TREEIFY_THRESHOLD - 1，看起来是大于等于7就会树化，但其实并不是的。因为在刚执行完p.next = newNode(…);此时binCount仍然还没有执行完++。所以仍然是链表中元素的个数大于等于TREEIFY_THRESHOLD（默认是8），才会树化。<br>举例：当元素个数为1的时候，即只有p，此时binCount为0，然后执行p.next = newNode(…)。if判断失效，然后才执行binCount++（即添加完p.next之后，里面已经有k个元素了，但if判断的时候的binCount值为k - 1，只有到下一轮循环才改成k。<br>当链表一共有6个元素的时候，此时binCount为6（已经是下一轮循环），执行p.next = newNode,一共有7个元素。if判断（6 &lt; = 7)，所以不会树化，循环结束，binCount为7.然后下一轮循环，添加元素，为8，此时 7 &lt;= 7，为真，树化。<br>PS：Hash冲突是指不同对象的hashCode通过hash算法后得出了相同定位的下标，这时候采用链地址法，会将此元素插入至此位置链表的最后一位，形成单链表。当存在位置的链表长度 大于等于 8 并且当前数组容量超过64时，HashMap会将链表 转变为 红黑树，这里要说明一点，往往后者的条件会被大多数人忽略，当桶数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长。这个时候应该优先扩容，而不是立马树化。毕竟高碰撞率是因为桶数组容量较小引起的，这个是主因。容量小时，优先扩容可以避免一些列的不必要的树化过程。</p>
<hr>
<h3 id="九-其他一些常见问题："><a href="#九-其他一些常见问题：" class="headerlink" title="九. 其他一些常见问题："></a>九. 其他一些常见问题：</h3><p><strong>1. 什么时候会使用HashMap？他有什么特点？</strong><br>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p>
<p><strong>2. 你知道HashMap的工作原理吗？</strong><br>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。HashMap是非线程安全的，在多线程的操作下会存在异常情况，可以使用HashTable或者ConcurrentHashMap进行代替</p>
<p><strong>3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</strong><br>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p>
<p><strong>4. 你知道hash的实现吗？为什么要这样实现？</strong><br>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p>
<p><strong>5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong><br>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p>
<p><strong>6. JDK1.8之前，HashMap在并发的情况下会出现问题，比如同时put的时候甚至会引起死循环，导致CPU使用率100%，为什么？</strong><br>因为JDK1.8之前的resize方法是需要rehash的，导致在旧链表迁移到新链表的时候，如果在新链表的数组索引相同，会导致链表元素倒置，在JDK1.8中不需要rehash，直接根据新增的1bit是0还是1，决定是在原本位置还是增加capacity的位置，不会倒置。<br>而JDK1.8之前的transfer，以JDK1.7为例，当两个线程同时resize的时候，由于链表倒置，有可能出现循环链表的情况，导致无限循环，耗尽CPU算力。具体看这里：<a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a><br>HashMap是非线程安全的，在多线程的操作下会存在异常情况，比如类似于数据库的更新丢失（两个线程同时put，可能会导致其中一个put失效）。可以使用Hashtable或者ConcurrentHashMap进行代替。（Hashtable的效率太低，不推荐使用）<br>PS：回到本题的主干：存放数据时发现正在扩容会怎么样。<br>对于JDK1.7，应该就是同时resize，导致死循环。对于JDK1.8，则不会出现死循环。（1.7是头插法，导致会倒置，形成循环链表。而<strong>1.8增加了tail指针，使用尾插法</strong>，时间复杂度仍然是O(1)，但不会倒置，因而不会出现死循环。）。1.8中hashmap的确不会因为多线程put导致死循环，但是依然有其他的弊端，比如数据丢失等等。因此多线程情况下还是建议使用concurrenthashmap。</p>
<p>参考网站：<br><a href="https://segmentfault.com/a/1190000015812438" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015812438</a><br><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a><br><a href="https://juejin.im/post/5a7719456fb9a0633e51ae14" target="_blank" rel="noopener">https://juejin.im/post/5a7719456fb9a0633e51ae14</a><br><a href="https://juejin.im/post/5c7f69dff265da2dea054fdc" target="_blank" rel="noopener">https://juejin.im/post/5c7f69dff265da2dea054fdc</a><br><a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="noopener">https://blog.csdn.net/fan2012huan/article/details/51097331</a><br><a href="https://blog.csdn.net/zhuqiuhui/article/details/51849692" target="_blank" rel="noopener">https://blog.csdn.net/zhuqiuhui/article/details/51849692</a></p>

      
    </div>
    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/interview/" rel="tag"><i class="fa fa-tag"></i> interview</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/MySQL%E9%94%81%E7%9A%84%E5%88%A4%E6%96%AD.html" rel="next" title="MySQL锁的判断">
                <i class="fa fa-chevron-left"></i> MySQL锁的判断
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/docker%E7%AC%94%E8%AE%B0.html" rel="prev" title="docker笔记">
                docker笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container"></div>

  

  




        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/03.jpeg"
                alt="Hong" />
            
              <p class="site-author-name" itemprop="name">Hong</p>
              <p class="site-description motion-element" itemprop="description">hong</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Hongscar" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:84363715@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-前言："><span class="nav-number">1.</span> <span class="nav-text">一. 前言：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-HashMap原理："><span class="nav-number">2.</span> <span class="nav-text">二. HashMap原理：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-①-构造方法："><span class="nav-number">3.</span> <span class="nav-text">三. ① 构造方法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-②put方法："><span class="nav-number">4.</span> <span class="nav-text">四. ②put方法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五-③get"><span class="nav-number">5.</span> <span class="nav-text">五. ③get</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六-④hash"><span class="nav-number">6.</span> <span class="nav-text">六. ④hash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七-⑤resize"><span class="nav-number">7.</span> <span class="nav-text">七. ⑤resize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八-中间遗留出来的questions："><span class="nav-number">8.</span> <span class="nav-text">八. 中间遗留出来的questions：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九-其他一些常见问题："><span class="nav-number">9.</span> <span class="nav-text">九. 其他一些常见问题：</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

      
<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
<div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div id="myCanvasContainer" class="widget tagcloud">
        <canvas width="250" height="250" id="resCanvas" style="width=100%">
            <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CentOS/" rel="tag">CentOS</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Debug/" rel="tag">Debug</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/" rel="tag">Github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDE/" rel="tag">IDE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSON/" rel="tag">JSON</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/" rel="tag">Spring Cloud</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/" rel="tag">blog</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deprecated/" rel="tag">deprecated</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/" rel="tag">interview</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/" rel="tag">life</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/note/" rel="tag">note</a><span class="tag-list-count">1</span></li></ul>
        </canvas>
    </div>
</div>



    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '75d5d92e717eca3c6b03',
          clientSecret: '3ec3a4b9ee7baf1c9f4ec85b4ce8d2af9126edb3',
          repo: 'hongscar.github.io',
          owner: 'hongscar',
          admin: ['hongscar'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>


  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

</body>
</html>
