<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>测试</title>
    <url>/2020/02/12/%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>chapter1.</p>
<p>Redis没有表和Schema（Schema就是数据库对象的集合，这个集合包含了各种对象如：表、视图、存储过程、索引等</p>
<p>Redis用 key-value存储数据，所有的key必须是string类型</p>
<p>Redis的命令不区分大小写，但存储的数据区分（包括key-value）</p>
<a id="more"></a>

<p>chapter2.</p>
<p><strong>数据类型：（一个key只对应一种类型的value）</strong></p>
<p>1.string        </p>
<p>（关于双引号，应该默认是字符串，加引号保证空格的存在。单引号也可以）</p>
<p>SET    执行成功返回OK</p>
<p>（如果键值已经存在，那么覆盖先前的值。可以用EXIST命令来测试key的存在性。也可以用SETNX，即当key不存在时set。 set if not exist。如果设置成功，SETNX返回1.否则返回0）</p>
<p>命令选项：NX，XX（存在时候才set）</p>
<p>从Redis 2.6.12版本开始，SET命令的行为可以通过一系列参数来修改：</p>
<p>EX second：设置键的过期时间为second秒。SET key value EX second效果等同于 SETEX second value</p>
<p>PX millisecond： 设置键的过期时间为millisecond毫秒。SET key value PX m == PSETEX m value</p>
<p>NX：只有在键不存在时，才对键进行设置操作。SET key value NX == SETNX key value</p>
<p>XX：只有在键存在时，才对键进行设置操作。</p>
<p>选项例子：</p>
<p>redis 127.0.0.1:6379&gt; SET not-exists-key “value” <strong>NX</strong> OK      # 键不存在，设置成功</p>
<p>redis 127.0.0.1:6379&gt; SET exists-key “value” <strong>XX</strong></p>
<p># EX 和 PX 可以同时出现，但后面给出的选项会覆盖前面给出的选项 redis 127.0.0.1:6379&gt; SET key “value” <strong>EX 1000 PX 5000000</strong> OK</p>
<p>redis 127.0.0.1:6379&gt; SET key-with-expire-and-NX <strong>“hello” EX 10086 NX</strong> OK            //我猜是EX时hello。NX时10086</p>
<p>GET    不存在时返回    (nil)</p>
<p>STRLEN    计算字符串长度</p>
<p>APPEND    向一个字符串末尾追加字符串。如果该字符串不存在，先新建一个空字符串，再append</p>
<p>SETRANGE     参数： stringA， int， stringB</p>
<p>对stringA从偏移量int开始，直到结尾，用stringB替换（偏移量从0开始）</p>
<p>同理，如果stringA不存在，也是先new一个空字符串。如果int为0，那么就是new。</p>
<p>如果int不为0，前面的字符为 \x00     (好像是C++里的空字符）</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\7edf3f2832d645dca2c218773e8e0077$5pwjcaa(}cs.png)</p>
<p>\xhh表示十六进制，\x00 == 0x00， \x77 == 0x77。代码的作用应该就是看一下res地址对应的起始两个字节的值是否为0x00和0x77，对应于ascii字符的NULL和w。</p>
<p>OBJECT命令：可以查看value的内部编码形式    使用形式：OBJECT ENCODING stringA</p>
<p>（OBJECT还有其他功能，略）</p>
<p>string的三种编码形式：</p>
<p>①<strong>int</strong>。存储64位有符号整数表示的字符串</p>
<p>②<strong>embstr</strong>。长度小于等于44子节点字符串（使得在内存使用和性能方面更有效率）</p>
<p>③<strong>raw</strong>。长度大于44字节的字符串</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\801aa6d8307c4dea977870465435f2f2\clipboard.png)</p>
<p>2.列表 list    （就是stack，queue，array等等的）</p>
<p>LPUSH     key1     value1    value2</p>
<p>往 key1中添加 value1，value2值。返回添加元素之后key1的值。</p>
<p>如果key1已经存在，就是在后面继续添加，反之新建再insert</p>
<p>RPUSH    (将value添加到list的右端）</p>
<p>LINSERT         key1     BRFORE / AFTER        value1</p>
<p>添加到value1的前面/后面</p>
<p>只有当list存在才添加。 LPUSHX, RPUSHX</p>
<p>LRANGE        获取一定范围里的value</p>
<p>LRANCE     key1    int1        int2</p>
<p>即获取int1 ~ int2中的元素。index从0开始（跟数组一样）</p>
<p>（如果int2为 -1，表明读到结尾。所以 [0, -1] 就是输出所有value。</p>
<p>[2, -1]就是从第3个元素开始，输出到结尾）</p>
<p>获取某个index下的value：</p>
<p>LRANCE     key1    index1        index1     即可。</p>
<p>也可以： LINDEX       key1    index    </p>
<p>LPOP        RPOP        删除一个元素</p>
<p>list的index定义：从左到右： 0 ~ N - 1    从右到左：    -1 ~ -N</p>
<p>（所以0 ~ -1 表示整个列表）</p>
<p>​    </p>
<p>LTRIM    key1    int1        int2</p>
<p>删除key1中int1 ~ int2 之外的value</p>
<p>例子：LTRIM    key1    1    -1</p>
<p>即删除index为1到结尾以外的所有元素，即，只删除index为0的元素</p>
<p>LSET     key1    int        value</p>
<p>设置index为int的值，更改为value</p>
<p>LPOP和RPOP有对应的阻塞版本，即当list为空时，阻塞版本会将客户端阻塞。</p>
<p>BLPOP        BRPOP</p>
<p>同时还要设置超时时间，如果为0，表示永久等待。（在任务调度场景十分有用）</p>
<p>例子：</p>
<p>worker1&gt;        BRPOP     que1    0</p>
<p>worker2&gt;        BRPOP     que1    0</p>
<p>两个终端，阻塞执行。</p>
<p>此时对que1添加一个value1，worker1先执行，解除阻塞，把value1删除。</p>
<p>然后再对que1添加value2，value3，此时worker2解除阻塞，把value2删除。</p>
<p>最后que1里剩下了value3(先添加value2，立即删除，所以是剩下value3）</p>
<p>3.哈希 HASH 类型</p>
<p>相当于Map类型，即key里面还存储了其他的key-value，但存储实现方式是hashing。</p>
<p>（Redis本身其实就相当于一个hash。Redis的数据对象也可以再次使用hash，只要字段和值都是string类型。为了与Redis的key区分，hash里的“key-value”应该说成    “field-value”）</p>
<p>HMSET    key1    field1    value1    field2    value2    ……</p>
<p>设置多个hash字段，以及属性。（其实field-value集就是key1的value）</p>
<p>HMGET    key1    field1    field2    ……</p>
<p>获取多个hash的value</p>
<p>HGET    HSET    （获取/设置单个）</p>
<p>HEXISTS        是否存在某个字段</p>
<p>HGETALL    获取所有field和value    （阻塞，hash特别大时会导致Redis阻塞）</p>
<p>HDEL    删除field</p>
<p>可以用HSCAN替代HGETALL，此处略。</p>
<p>4.集合    SET类型</p>
<p>集合，SET，与Java一样，唯一，无序。（可用于去重）</p>
<p>SADD    添加</p>
<p>SISMEMBER    测试一个value是否在SET中</p>
<p>SREM    删除</p>
<p>SCARD    获取集合中成员的数量</p>
<p>SMEMBERS    列出所有value</p>
<p>同理，SMEMBERS会导致阻塞，可以改用SSCAN。略</p>
<p>集合间的操作：     SINTER        KEY        [KEY …]    交集</p>
<p>​    SUNION    KEY        [KEY …]        并集</p>
<p>​     SDIFF        差集</p>
<p>将集合运算的结果保存到K中：SINTERSTORE  K   KEY  [KEY…]</p>
<p>SUNIONSTORE    SDIFFSTORE</p>
<p>SET的编码，有两种方式：</p>
<p>intset    ：    对于value全是整数，且元素个数小于set-max-intset-entries时(默认为512）</p>
<p>（可以节省占用空间）</p>
<p>hashtable：    intset不适用时的默认编码</p>
<p>5.有序集合    SORTED SET类型</p>
<p>有序。    实现方式为：每个value还要拥有一个用于排序的权重。</p>
<p>ZADD    key1    weight1    value1    weight2    value2 ……    添加。</p>
<p>（与SET命令类似，可以使用NX,XX等选项）</p>
<p>ZREVRANGE        key1    int1        int2        [WITHSCORES]</p>
<p>获取排序。int1 ~ int2的value，0 ~ -1 即整个，和list一样。</p>
<p>WITHSCORES可选，表示 是否要列出 weight权重。</p>
<p>ZINCRBY    key1    int    value1</p>
<p>给value1的权重增加int</p>
<p>ZREVRANK    key1    value1</p>
<p>获取value1的排名（第一为 0）</p>
<p>ZSCORE        key1    value1</p>
<p>获取value1的权重</p>
<p>ZUNIONSTORE    合并两个SORTED SET。略</p>
<p>ZRANGEBYSCORE   key   MIN   MAX(从小到大），    ZREVRANGEBYSCORE</p>
<p>ZCOUNT KEY MIN MAX（指定范围内的成员个数）</p>
<p>集合之间的操作：ZINTERSTORE, ZUNIONSTORE    (没有ZDIFFSTORE, ZUNION）</p>
<p>6.HyperLogLog （HLL）类型</p>
<p>唯一计数类型。虽然可以用SET来计数，但需要考虑内存消耗和性能下降问题。</p>
<p>如果我们不需要获取SET的内容，只想获得不同value的个数，就可以考虑用HLL</p>
<p>PFADD    添加</p>
<p>PFCOUNT     统计数量</p>
<p>PFMERGE    添加多个</p>
<p>HLL对象的两种存储方式：</p>
<p>Sparse（稀疏）：对于长度小于hll-sparse-max-bytes（默认为3000）的HLL，采用此。</p>
<p>（存储效率更高，但可能会消耗更多的CPU资源）</p>
<p>Dense（稠密）：当Sparse不适用时。</p>
<p>7.Geo类型</p>
<p>存储地理位置相关的数据类型</p>
<p>GEOADD,    GEOPOS（获取），    GEODIST(比较距离）</p>
<p>等等。略</p>
<p>key的管理。</p>
<p>DBSIZE:    显示数据库的size，即数据库一共有多少个key</p>
<p>获取所有的key：</p>
<p>KEYS *</p>
<p>scan 0</p>
<p>KEYS的后面的参数是 正则表达式，scan后面的参数是cursor，游标，不懂。</p>
<p>删除key：</p>
<p>DEL        UNLINK        </p>
<p>(二者都可以同时删除多个，并且返回删除的key数量）</p>
<p>UNLINK主要用于执行大KEY的异步删除（即非阻塞？）当删除string以外的数据类型，当数量很大时，很可能导致服务器延迟，此时应该用UNLINK（UNLINK会在另一个线程，而不是主事件循环线程中执行删除操作，因此不会阻塞事件的处理。）</p>
<p>EXISTS    判断是否存在某个key</p>
<p>TYPE    获取key的（值）数据类型</p>
<p>RENAME        former_name        new_name    重命名</p>
<p>迁移键      （其实这些比较复杂少用的，到时要用到肯定还是上网查的，目前还没用到死记硬背真的没必要！倒是几种基本类型的常用操作确实值得记忆一下！）</p>
<p>①MOVE  KEY  DB    （redis内部可以有多个DB，用于内部迁移。但一般一个数据库即可！</p>
<p>②dump + restore</p>
<p>③migrate</p>
<p>（只需知道②是非原子性的，而③是原子性的即可！）</p>
<p>遍历键：keys ，或者scan（渐进式，游标。。）</p>
<p>关于多数据库，实际上是一个废弃的功能。并不能实现0号数据库是正式数据库，而1号数据库是测试数据库等等的想法。Redis已经在逐渐弱化这个功能，例如Redis的分布式实现Redis Cluster只允许使用0号数据库，留着只为了向下兼容。而且因为Redis是单线程的，所以使用的还是一个CPU，如果其中一个存在慢查询，那么依然会影响其他数据库（甚至会导致业务问题的定位非常困难）</p>
<p>PS:如果真的要使用多个数据库的功能，完全可以在一台机器上部署多个Redis实例，彼此之间使用端口号来进行区分（计算机一般有多个CPU，这样既保证了业务之间不会受到影响，又合理地使用了CPU资源）</p>
<p>清除所有数据：flushdb，flushall（后者是清除所有数据库） 慎用，会把所有数据都删掉，而且会阻塞。别乱用。！！！</p>
<p>chapter3.</p>
<p>数据特性：</p>
<p>1.位图 bitmap</p>
<p>(也称位数组或位向量），是由比特位bit组成的数组（其值只有0或者1）可用于记录每个用户是否属于某个表（使用过某个功能）等等。</p>
<p>（bitmap并不是一种新的数据类型，它实际的底层数据是字符串。）</p>
<p>-————————–</p>
<p>bitmap vs SET</p>
<p>显然，bitmap用于计数，而SET也可以，那么二者有什么区别呢？</p>
<p>对于bitmap：无论用户是否使用过某个功能，每个用户都需要占用bitmap中的1个比特（0/1）</p>
<p>对于SET：假设另起一个8字节的整型来存储用户ID（表示使用过某个功能），那么只有当用户使用过该功能，才需要存储该用户ID（一个ID 8字节）</p>
<p>假设有20亿个用户，某功能有80%的用户使用过。那么：</p>
<p>对于bitmap：需要在内存中分配20亿个bit，即大约250MB</p>
<p>对于SET：需要 20e x  80%  x  8   大约是12.8G</p>
<p>结论：当一个功能比较流行，更密集，即如果使用bitmap，1的概率更大的时候，用bitmap更好。反之，如果一个功能比较稀疏，使用人数较少，那么直接使用SET会更好（比如上述例子改为1%）</p>
<p>-—————————</p>
<p>SETBIT     key1    value1    1 / 0</p>
<p>对key1的value1设置相应的bit值，0或者1</p>
<p>GETBIT    key1    value1</p>
<p>查询value1对应的bit值，返回0或者1</p>
<p>BITCOUNT    key1</p>
<p>查询key1中所有的value，bit为1的个数。</p>
<p>BITOP    [OPERATOR]        result    key1    key2</p>
<p>BITOP用于进行位操作，包括：AND,OR,XOR,NOT（NOT只需要指定1个key，其他2个）</p>
<p>即对key1和key2进行位操作，然后将结果存储在result键中。</p>
<p>2.设置key的过期时间</p>
<p>除了使用DEL或者UNLINK删除key，还可以通过设置key的超时时间让Redis自动地删除key</p>
<p>EXPIRE        key1    int</p>
<p>将键key1的超时时间设置为int</p>
<p>TTL        key1</p>
<p>查看key1在过期前的剩余时间。</p>
<p>如果该key并没有过期时间，那么将返回-1.</p>
<p>如果该key已经过期，那么将返回-2</p>
<p>当key过期之后是否立刻删除？</p>
<p>并不，但当客户端试图访问过期key时，Redis会立即将其从内存中删除。（被动过期）</p>
<p>而对于那些已经过期但还没被访问的key，有一个基于概率的算法来进行主动删除。（略）</p>
<p>当发现有太多已经过期的key没有被删除时，可以通过执行SCAN命令来触发被动过期</p>
<p>如何清除一个key的过期时间？</p>
<p>1.PERSIST        使一个key成为持久的key</p>
<p>2.当key的value被替换或者删除。包括SET,GETSET, *STORE等等的命令会清除过期时间</p>
<p>（但修改list，set，hash的元素并不会清除过期时间，因为修改元素的操作并不会替换key所关联的值对象）</p>
<p>3.被另一个没有过期时间的key重命名</p>
<p>3.SORT命令</p>
<p>当我们需要获取一个Redis列表或者集合的已排序副本，或者以某种非权重的顺序对SORTED SET中的元素进行排序时候，就需要用到SORT命令</p>
<p>SORT key1        对    list    /    set/    sorted set 进行排序</p>
<p>（默认只能对数字排序，int/ double）</p>
<p>对于字符串，需要加ALPHA修饰符。</p>
<p>SORT key1    ALPHA</p>
<p>SORT    key1    ALPHA    LIMIT    int1        int2</p>
<p>排序之后，获取int1 ~ int2的元素。（index从0开始）</p>
<p>除了默认数字排序以及ALPHA，还可以通过其他key的权重来进行排序。</p>
<p>SORT     key1    BY    key2~x（用通配符表示多个）</p>
<p>（此处key2的value，hong123_104 &gt; hong123_455 &gt; hong123_333 &gt; 200 &gt; 365）</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\ab95885bd2bc4ec9bbadda92013433f6\clipboard.png)</p>
<p>用处：</p>
<p>比如A_userid是一个用户的记录。 count_userid是一个用户的使用次数。（每一个userid都有对应）</p>
<p>那么当我们需要对A_userid的value进行排序（里面的value并不是使用次数，比如，是消费总额），而我们是希望通过“使用次数”这个属性来排序，那么就用到了 BY 修饰符。</p>
<p>SORT     key1     BY        key2*    DESC/ASC(默认ASC）GET    xxx        STORE    key3</p>
<p>GET选项：表示要获取哪一个类型的值，比如是key2，key1里的*，而不一定是value</p>
<p>（GET可使用多次）</p>
<p>STORE选项：把GET得到的结果存储到key3</p>
<p>4.管道    pipeline</p>
<p>Redis客户端与服务端使用RESP协议进行通信，大致的通信过程如下：</p>
<p>1，客户端向服务端发送一个命令</p>
<p>2，服务器接受该命令并放入执行队列（Redis是单线程的执行模型）</p>
<p>3，命令执行</p>
<p>4，服务器将命令执行的结果返回到客户端</p>
<p>第2，3步耗费的时间取决于Redis服务器（一般较短），主要的时延还是1，4步的网络传输。</p>
<p>使用pipeline好处：客户端将多个命令打包在一起，并将它们一次性发送，而不再等待每个单独命令的执行结果。同时，pipeline是在服务器执行完所有的命令后再返回结果。</p>
<p>因此即使是执行多个命令，第1，4步也只发生一次，所以总的执行时间会大大减少。</p>
<p>使用方法：在Redis-cli中加入    –pipe选项</p>
<p>5.Redis事务        transaction</p>
<p>关键命令：</p>
<p>MULTI：用于组装一个命令，表示命令的开始部分。</p>
<p>EXEC：用于执行一个事务</p>
<p>DISCARD：取消事务</p>
<p>WATCH：用于监视key。当这些key在事务执行之前发生改变，那么事务将被取消。</p>
<p>Redis事务与关系数据库事务的区别：Redis事务没有回滚。</p>
<p>所以当所有正确的命令入队列之后，如果在执行过程发生错误，位于发生错误命令之后的其他命令将继续执行，而不会回滚。</p>
<p>6.发布订阅    PubSub</p>
<p>即终端分为了发布者和订阅者。订阅者可以订阅指定的频道（发布者），当发布者发送信息时，会一次性发送给所有的订阅者，同时发布者也可以单独给某位订阅者发送信息（类似公众号的模式）</p>
<p>命令：</p>
<p>SUBSCRIBE    订阅        (如果该频道从未被订阅过，那么会自动创建该频道）</p>
<p>UNSUBSCRIBE    取消订阅</p>
<p>PUBLISH        发布信息（一个发布者可以是多个频道的所有者，因此需要选择发布到哪个频道）</p>
<p>7，Lua脚本</p>
<p>略</p>
<p>chapter4.</p>
<p>Redis常用场景：</p>
<p>1.存储Session。</p>
<p>Session一般存储在外部存储系统，如果一个web服务器宕机，其他服务器仍然可以从外部存储中获取Session并继续服务。而与关系数据库相比，Redis的访问延迟非常低（存储在内存），所以用于存储Session非常合适。同时Redis的对key过期机制非常契合Session的有效期。</p>
<p>2.分析，排行，队列，最新的N个记录等等</p>
<p>这些功能使用SQL也可以做到，但SQL查询要比Redis查询慢得多。</p>
<p>3.缓存</p>
<p>因为Redis是基于内存的数据存储系统，所以在关系数据库前面增加Redis作为缓存，通常能够加速数据库的查询过程。</p>
<p>例如，在查询关系数据库之前，先在Redis中查找记录。如果找到就直接使用，如果找不到就从关系数据库中查找，并将记录放置到Redis中。在向关系数据库写入时，我们也将记录写入Redis。同时为了限制缓存的大小，可以设置过期时间，或者LRU等等的收回策略。</p>
<p>Redis的缺点：</p>
<p>因为Redis默认将全部数据都放在内存中，所以Redis的容量有限，不能作为单一的数据库来存储大量的数据（虽然有一些基于云的Redis提供了使用SSD作为数据存储后端的选项）。</p>
<p>其次，因为Redis事务并不完全符合关系数据库的ACID规范。如果要使用完全符合ACID规范的事务，就不能使用Redis。</p>
<p>其他命令：</p>
<p>FLUSHALL：删除所有的数据库的所有keys。</p>
<p>CONFIG SET XXX XX    设置conf配置文件，将XXX的属性值改成XX</p>
<p>同理还有 CONFIG GET XXX</p>
<p>INFO MEMORY    查看Redis的内存使用情况</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\2d1e6c0c369b432aa5976bc06ebecf77\clipboard.png)</p>
<p>普通Java程序使用Redis：使用Jedis即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring程序使用Redis：<a href="https://blog.csdn.net/Evankaka/article/details/50396325" target="_blank" rel="noopener">https://blog.csdn.net/Evankaka/article/details/50396325</a></p>
<p>依赖包，除了redis.clients，还需要：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>chapter5：</p>
<p>Redis复制，从一个Redis服务器，将data全部复制到另一个。略    INFO REPLICATION</p>
<p>chapter6：</p>
<p>由于Redis是在内存中存储数据的，所以当服务器重新启动时，所有的数据都将丢失。所以我们需要：像上一章一样复制复制备份到另一个服务器，或者持久化到disk。</p>
<p>持久化到磁盘的机制：RDB, AOF</p>
<p>RDB：可以看做是Redis在某一个时间点上的快点（snapshot），适合于备份和错误恢复</p>
<p>AOF：一个写入操作的日志，将在服务器启动时被重新放。</p>
<p>使用RDB的操作：</p>
<p>CONFIG SET SAVE “900 1”    （还是使用CONFIG SET修改配置文件）</p>
<p>永久启用RDB：cat conf/redis.conf | grep “^save”</p>
<p>RDB的结果会生成yige.rdb文件。二进制形式。略</p>
<p>由于RDB并不能提供非常强的一致性，虽然可以定期将数据保存到RDB，但在崩溃时，保存的时刻到崩溃时刻中间的数据将会丢失。</p>
<p>AOF是一种只记录Redis写入命令的追加式文件，因为每个写入命令都会被追加到文件中，所以AOF的数据一致性更高。</p>
<p>启用AOF持久化：CONFIG SET APPENDONLY YES</p>
<p>永久启动： cat conf/dis.conf | grep “^appendonly”</p>
<p>二者可以同时使用。</p>
<p>chapter7：高可用和集群Redis</p>
<p>当Redis的数据越来越大的时候，安全性会受到损害（宕机的时候恢复的时间越来越长）同时key越来越多，内存的使用率越来越大，内存的大小成为了性能的瓶颈。因此配置多个node（多个Redis服务器的集群），可以增加安全性和可用性。</p>
<p>略</p>
<p>chapter8：生产环境部署</p>
<p>即在Linux上部署Redis，成为真正的服务器，可不仅仅是一个测试demo。这个时候还需要配置各种参数，如客户端连接参数，数据库本身参数，key的管理，LRU，LFU等等的算法策略，还有日志。</p>
<p>略</p>
<p>chapter9：管理Redis</p>
<p>即Redis服务上线之后，对日常的Redis进行运维操作。</p>
<p>查看参数，备份，监控内存使用情况，监控客户端等等。</p>
<p>chapter10：Redis的故障诊断</p>
<p>chapter11：使用Redis模块拓展Redis    略略略</p>
<p>————————–Redis Dev &amp; Ops</p>
<p>chap2：</p>
<p>keys *， dbsize：</p>
<p>dbsize直接获取Redis内置的一个变量，时间复杂度为1</p>
<p>而keys会遍历所有键，所以时间复杂度是n（当Redis保存了大量键的时候，就不应该使用）</p>
<p>exists key，    del key，        </p>
<p>expire key seconds（设置过期时间</p>
<p>ttl key ：返回剩余过期时间。  大于等于0就是剩余值，-1是没设置过期时间，-2是键不存在</p>
<p>type key，  object encoding key   ： type是返回键的类型，object encoding是返回内部编码实现类型</p>
<p>（根据具体情况计算性能，底层选择不同的类型：</p>
<p>string字符串： raw，    int，        embstr</p>
<p>hash哈希：    hashtable，        ziplist</p>
<p>list列表：        linkedlist，        ziplist</p>
<p>set集合：    hashtable，        intset</p>
<p>zset有序集合（Sorted Set）：    skiplist，    ziplist</p>
<p>incr key：使key自增1.（如果不是整数，会报错。如果不存在这个key，创建一个，默认值为0，incr后就是变成1。 必须是整数，浮点数也会报错）</p>
<p>Redis使用了单线程 + IO Multiplexing（多路复用）模型来实现高性能的内存数据库服务</p>
<p>（所谓的IO Multiplexing，指由N个client要访问，然后IO根据哪个client ready了，就选择那个（就像是一个电路图：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\1e1c5c3688d74413b43baa95057179b0\clipboard.png)</p>
<p>IO Multiplexing主要是可以提高连接数。但始终还是单线程，因此如果其中一个命令的执行时间特别长，那么就会造成其他命令的阻塞。所以Redis是面向快速执行场景的数据库。</p>
<p>（内存的处理速度是磁盘IO的10万倍，所以Redis的效率是很快的，能达到每秒万级别）</p>
<p>（内存是100ns， Disk seek是10 000 000ns）</p>
<p>①字符串类型  string：</p>
<p>key都是字符串类型，字符串可以是字符串，数字，二进制（图片，音频，视频</p>
<p>（所以 set  1  123也是可行的。key为1，value为123）</p>
<p>set 选项： ex秒级过期时间， px 毫秒级， nx：键必须不存在，才可以设置成功。 xx：与nx相反</p>
<p>例子：setnx hello redis    (nx可以用作分布式锁的一种实现方案，因为只有一个可以set成功）</p>
<p>mset ： 批量设置值            例子： mset key1 value1 [key2 value2 ……]</p>
<p>get,  mget同理。</p>
<p>批量命令可以提升开发效率。如n次get，需要n次网络时间+n次命令时间。</p>
<p>而mget只需要1次网络时间+n次命令时间</p>
<p>（批量操作发送的命令数是有节制的，否则可能造成Redis阻塞或者网络阻塞）</p>
<p>del key [key ……]    del可以删除多个。 </p>
<p>incr,decr</p>
<p>incrby  key  increment(指定自增数值，可为负数）        decrby  key  decrement    （不能为浮点数</p>
<p>incrbyfloat  key  increment（每次增加的值为浮点数，同时key也能为浮点数，不然执行一次就没了）</p>
<p>append key  value    在尾部追加值</p>
<p>strlen  key        字符串长度</p>
<p>getset        设置，并且返回原来的值</p>
<p>setrange    key    offset    value    设定offset偏移值的那一位，字符由value替代（从0开始</p>
<p>例子： set redis  pest        setrange  redis  0  b    get  redis   ==》  best</p>
<p>getrange  key  start  end    (偏移量从0开始。 [start,  end]        （没有-1）</p>
<p>总结：del，mset，mget这三个的时间复杂度为O(n)，getrange为O(n),n是字符串的长度，如果字符串不是很长，可以视为O(1)。其他都是O(1)</p>
<p>字符串内部编码:  int,  embstr(小于等于39个字节的字符串） ， raw（大于39个字节）</p>
<p>②哈希 hashing</p>
<p>即value本身又是一个键值对。</p>
<p>设置值： hset  key   field  value    （同样还有hsetnx。相当于set和setnx的区别</p>
<p>获取值： hget  key   field      （一个key存储多个  field - value）</p>
<p>删除field： hdel  key  field1  [field2 ……]    返回成功删除field的个数</p>
<p>计算field的个数：   hlen  key</p>
<p>批量set/get  :  hmget  key  field [ field …]    hmget  key field  value [ field  value……]</p>
<p>hexists  key  field    判断是否存在</p>
<p>hkeys  key    获取所有的field（感觉叫hfields更恰当，但确实是hkeys</p>
<p>hvals    key</p>
<p>hgetall     key        获取所有的field-value</p>
<p>（当哈希元素比较多，hgetall可能会阻塞。如果只需要获取部分，可以使用hmget。如果一定要获取全部field-value，可以使用hscan，该命令会渐进式地遍历哈希类型。）</p>
<p>hincrby   key   field   increment    给key.field增加increment（可以为负数）    hincrbyfloat</p>
<p>hstrlen    key   field</p>
<p>总结：hdel，hmget，hmset是O(k)，k是field的个数。hgetall，hkeys， hvals是O(n)，n是field的总数</p>
<p>其他都为O(1)</p>
<p>哈希内部编码：ziplist（压缩列表）：当元素个数小于hash-mmmax-ziplist-entries(默认是512），同时所有值都小于hash-max-ziplist-value(默认是64字节），就使用ziplist（结构更紧凑，节省内存）</p>
<p>hashtable（哈希表）：当无法满足ziplist时，ziplist的读写效率会下降，而hashtable的读写为O(1)</p>
<p>ps：对于一个用户的各种信息属性，可以单独用不同的key，但这样用户信息性差，一般不会使用这种方案。比较好的方案是使用哈希类型，提高内聚性，控制在ziplist之内，有效减少内存空间的使用。（必须的时候使用hashtable也不是不行）</p>
<p>哈希类型是稀疏的，而关系数据库是完全结构化的，当在关系数据库增加新的列，所有行都要设置值（如果没有指定就设置为NULL）。但可以做复杂的关系查询，而Redis比较困难。</p>
<p>③列表 list</p>
<p>rpush，lpush（二者都可以插入多个）    linsert key before | after  pivot  value</p>
<p>lrange key  start  end 查找</p>
<p>……</p>
<p>懒了，其实各种类型的操作就略过吧，上面已经看过一次了，把上面的复习一遍就好。主要看它举的实例并理解。</p>
<p>chap3：各种功能topic</p>
<p>①慢查询</p>
<p>Redis有一个表专门记录命令执行较长的命令（只包含执行时间，不包含客户端等待时间）</p>
<p>参数：slowlog-log-slower-than    (超出该值则记录，单位是微秒。）</p>
<p>1 秒 = 1000 毫秒 = 1000 000微秒    （即默认是10毫秒）</p>
<p>slowlog-max-len ：慢查询日志的最大记录，如果超出上限，则最早insert的那条删除。</p>
<p>（slowlog-max-len设置大一点，不会耗费很多内存空间的）</p>
<p>设置命令：config xx int        持久化到配置文件：    config  rewrite</p>
<p>获取日志： slowlog  get  [n]    // n表示指定条数</p>
<p>slowlog len  ： 获取慢查询日志列表的当前长度</p>
<p>slowlog reset：重置（即clear</p>
<p>②redis shell</p>
<p>redis-cli的各种参数：</p>
<p>-h  ： host    -p： port        -a： auth        </p>
<p>-r 重复执行n次：  redis-cli -r 3 ping    </p>
<p>(即重复执行3次ping命令，ping命令会测试服务器的连通性，如果连通，返回PONG）</p>
<p>-i 表示每隔几秒执行一次命令（与-r连用，单位是秒）</p>
<p>例子：redis-cli -a xxx -r 10 -i 1 info | grep used_memory_human    每隔1秒输出内存的使用量</p>
<p>-x：将stdin读取，作为redis-cli的最后一个参数，例如；</p>
<p>echo “gogogo” | redis-cli -a xxx -x set hello    # 之后hello的值就被设置为”gogogo\n”</p>
<p>值得注意的是，echo输入，会存在一个换行符，进入redis-cli里再set才不会有换行符。</p>
<p>–scan和–pattern ：扫描指定模式的keys，相当于使用scan命令</p>
<p>–slave：将当前客户端模拟成一个子节点，然后获取当前Redis结点的更新操作。</p>
<p>（可以用于记录当前连接Redis结点的一些更新操作）</p>
<p>（在一个客户端中使用redis-cli –slave -a xxx，然后其他客户端的更新，当前都会有命令记录）</p>
<p>–rdb：请求Redis实例生成并发送RDB持久化文件，保存在本地。</p>
<p>–pipe：把批量的命令一次发送到一个管道中，一次执行</p>
<p>–bigkeys：使用scan命令获取占用内存比较大的键值。（这些键可能是系统的瓶颈）</p>
<p>–eval ： 执行指定的Lua脚本</p>
<p>–latency :测试到目标Redis的网络延迟   redis-cli  -h  {另一台机器的host IP}  –latency</p>
<p>–latency-history :上面的只有一条记录，而这个是每执行15秒就生成另一条记录（可以用作对比），同时也可以使用-i参数来控制间隔时间。</p>
<p>-latency-dist   使用统计图表的形式从控制台输出信息</p>
<p>info  ： redis-cli  info    输出redis的所有信息（很长，配合| grep使用）</p>
<p>redis-cli –stat：实时获取Redis的重要统计信息（比info少很多，但可以实时查看一些增量的数据）</p>
<p>–raw ， –no-raw    使得返回的结果是原始格式 / 不是原始格式</p>
<p>当存储中文时，保存在redis里的中文会被转义成16进制。此时无论是命令行时get还是进入redis-cli之后get，返回的结果都是二进制格式，如： \xe4\xbd\xa0\xe5\xa5\xbd</p>
<p>如果使用–raw，则返回原始格式，即中文： redis-cli –raw get hello (–raw必须在get前面）</p>
<p>PS:但是在进入redis-cli之后的get好像无法指定参数，所以不能返回raw，只能在命令行时指定–raw</p>
<p>③redis-server</p>
<p>redis-server是Redis的启动脚本。可选参数只有：–test-memory，用于检测当前的OS能否稳定地分配指定容量的内存给Redis（防止因为内存问题造成Redis崩溃）</p>
<p>（检测时间较长，但输出passed this test表示检测完毕。 单位是MB，所以1024就是1G）</p>
<p>一般只是用于调试跟测试，快速沾满机器内存做一些边界测试</p>
<p>④redis-benchmark</p>
<p>用于为Redis做基准性能测试</p>
<p>-c：表示客户端的并发数量（默认50）</p>
<p>-n：表示客户端的请求总量（默认是100000）</p>
<p>例子：redis-benchmark  -c  100  -n  20000，代表100个客户端同时请求Redis，一共执行20000次。</p>
<p>-q：只显示 requests per second信息。</p>
<p>-r：插入更多的键。如-r 10000，插入10000个随机的键（仅作测试使用）</p>
<p>-P：表示每个请求的pipeline的数据量（默认是1）</p>
<p>（我发现恰当指定pipeline的值，比默认是1要快。）</p>
<p>-k：表示客户端使用使用keepalive，1为使用，0为不使用，默认是1</p>
<p>-t 指定命令测试</p>
<p>–csv：按照csv格式输出，可以到处到excel等（注意是两条杠）</p>
<p>⑤Pipeline</p>
<p>Redis客户端的一条命令的4个过程：发送命令，命令排队，命令执行，返回结果。</p>
<p>（第一步跟第四步称为Round Trip Time，RTT，往返时间）</p>
<p>虽然有部分批量操作的命令，但大部分命令都没有批量命令，此时需要使用pipeline，一次过发送多个命令，减少RTT的次数（由于Redis的处理速度很快，只要Pipeline包含的命令数不是太多，就能有效提升效率）</p>
<p>（高级语言的客户端中基本都支持Pipeline。比如Jedis。）</p>
<p>提升的结论：</p>
<p>1.一般Pipleline的执行速度会比逐条执行要快（Redis的性能瓶颈是网络，即RTT）</p>
<p>2.客户端和服务端的网络时延越大（即RTT越大），那么Pipeline的提升效果越明显。</p>
<p>原生批量命令与Pipeline的区别：</p>
<p>1.原生批量命令是原子的，而Pipeline是非原子的。</p>
<p>2.原生批量是一个命令对应多个key，而Pipeline是支持多个命令的</p>
<p>3.原生批量是Redis服务端支持实现的，而Pipeline需要服务端和客户端的共同实现。</p>
<p>Ps：Pipeline一次组装的命令个数不能太多，否则会增加客户端的等待时间，以及网络阻塞，可以将一次包含大量命令的Pipeline拆分成多次较小的Pipeline来完成。</p>
<p>Pipeline虽然只能操作1个Redis实例，但即使在分布式Redis的场景中，也可以作为批量操作的重要优化手段。</p>
<p>⑥事务</p>
<p>Redis提供了简单的事务功能，但又跟关系数据库的事务不太一样。它无法保证很多方面的数据一致性，因为需要复杂事务的业务不应该放在Redis中实现。</p>
<p>multi：开启一个事务（事务里不可以嵌套事务</p>
<p>……中间执行的各种命令都会输出QUEUED，即存储在事务里，但还没开始执行。</p>
<p>exec：执行事务。        discard：取消事务</p>
<p>Redis的事务不提供回滚功能，如果执行出错，那么会出现问题：</p>
<p>1.当命令出现语法错误</p>
<p>此时Redis在执行每一条命令之前就已经发现了，因而这时候执行exec会显示错误。然后每一条语句都会失效。（因为根本就没有去执行，并不是回滚）</p>
<p>2.当命令出现运行时错误</p>
<p>有一些语句，不存在语法错误，但在运行时才会出现错误，这时Redis在检查语句的时候是不能发现的，只能在执行的时候才发现。比如对于SET跟SORTED SET，对一个SET使用SSET的ZADD操作，并不属于语法错误，但在运行时会出错。这时候事务不会回滚，因而在出错之前的语句，仍然已经执行成功，而且出错之后的语句也会执行！无论如何，这种问题只能靠程序员自己避免。</p>
<p>watch： 使得客户端监控1个或者多个键，有效期直到执行了unwatch或者exec。</p>
<p>当客户端A监控的这些keys，只要有其中一个被修改了(除非是在A的事务中进行修改的），那么该客户端A下的第一个事务不会执行。（返回nil）</p>
<p>小细节点：</p>
<p>1.如果是在当前客户端A的事务中修改了被监控的值，那么是可以成功执行的，因为要保证的是，在执行事务的时候，该值不会在事务在之外发生了变化。</p>
<p>2.如果是在当前客户端A的事务之外修改了被监控的值，那么也是不可以执行的。如果是在其他客户端B中修改，那么一定不能执行（即使是在B的事务环境中执行，也不行）</p>
<p>3.准确地说，并不是执行exec会取消，而是当事务（即multi）结束的时候，watch的键会取消。所以，如果执行了multi……discard，这时候其实watch已经失效了。后面如果继续使用multi，是可以执行事务的。所以单独地使用exec / discard(即在没有multi的前提下运行这两条命令），watch是仍然存在的。</p>
<p>⑦Lua</p>
<p>语法省略。</p>
<p>Redis使用Lua的方法：eval，evalsha</p>
<p>eval当作命令的时候：  eval  脚本内容  key个数  key列表  参数列表</p>
<p>例子：eval ‘return “hello “ .. KEYS[1] .. ARGV[1] ‘  1  redis  world</p>
<p>输出：”hello redisworld”</p>
<p>如果Lua脚本较长，可以使用–eval直接执行文件</p>
<p>evalsha：将Lua加载到Redis，得到该脚本的SHA1检验和，之后evalsha使用SHA1作为参数就可以直接执行对应的Lua脚本，避免每次都发送Lua脚本的开销，而且脚本也能常驻在服务端了。</p>
<p>script load：将脚本内容加载到Redis内存中：redis-cli script load “xxx”        返回SHA1值。</p>
<p>执行脚本： evalsha  脚本SHA1值  key个数  key列表  参数列表</p>
<p>Lua的redis.call可以实现对Redis的访问：</p>
<p>redis.call(“set”, “hello”, “world”)        redis.call(“get”, ”hello”)</p>
<p>pcall也可以调用Redis，但如果call执行失败，脚本会直接结束，而pcall会忽略错误继续执行（根据具体的情况进行函数的选择）</p>
<p>Lua对于Redis的好处：</p>
<p>1.Lua在Redis中的原子执行的，执行中途不会插入其他命令</p>
<p>2.Lua可以自定制命令，并且可以将这些命令常驻在Redis内存中，达到复用的效果</p>
<p>3.Lua可以将多条命令一次性打包，有效地减少网络开销。</p>
<p>举一个Lua的例子：</p>
<p>假设有user1,user2,user3,user4这几个键，分别对应一个数字。</p>
<p>如get user1 =》 123    ，user2 = 444 , user3 = 743 , user4 = 814</p>
<p>有一个列表，存储了这几个键：</p>
<p>lpush  hot  user1, user2, user3, user4</p>
<p>现在我们需要对列表内所有的键对应的值进行+1操作，并且保证是原子执行，返回操作的个数。</p>
<p>Lua脚本：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\a8de5b73eb2142e490223c07e13bee29\clipboard.png)</p>
<p>执行Lua脚本： redis-cli  -a  xxx  –eval  my.lua  hot（即执行my.lua脚本，第一个key参数是hot列表）</p>
<p>Redis管理Lua脚本：</p>
<p>script load：将Lua脚本加载到Redis</p>
<p>script exists sha1 [sha1 …]：判断sha1是否已经加载到内存</p>
<p>script flush：清除Redis内存以及加载的所有Lua脚本（此时需要重新load</p>
<p>script  kill：杀掉正在执行的Lua脚本（如果Lua比较耗时，或者存在死循环等问题，就可以考虑kill</p>
<p>ps：Redis提供了一个参数，是Lua脚本的超时时间，但仅仅是当Lua脚本超过该时间之后，向其他命令发出BUSY的信号，但并不会停止掉服务端和客户端的脚本执行。其他命令会收到“Busy Redis is busy running a script”的错误。</p>
<p>但是，如果Lua脚本正在执行写操作，那么script kill将不能生效，此时只能使用shutdown save停掉Redis服务。（如果是死循环的重复写操作，那么只能shutdown save了）</p>
<p>⑧bitmap，HyprtLogLog，订阅，GEO等等（上面的笔记有</p>
<p>chap4：客户端</p>
<p>Redis的CS模型：</p>
<p>Redis制定了RESP（Redis Serialization Protocol，Redis序列化协议），实现客户端与服务端的正常交互。这种协议简单高效，能被机器解析，同时也容易理解。</p>
<p>发送命令的格式：先指定参数个数（前面加一个*，然后每一个参数前面用$加数字，表示该参数的长度。）</p>
<p>例子：SET hello world</p>
<p>底层发送的命令格式：(下面的各种参数与\r\n之间是没有空格的，只是这里增加以下可读性</p>
<p>*3 \r\n $3 \r\n SET \r\n $5 \r\n hello \r\n $5 \r\n world \r\n</p>
<p>上面的每一部分解释：</p>
<p>首先，每一part都是单独的一行(\r\n就是换行了），然后*3表示有3个参数， $3表示第一个参数的长度3，第一个参数是SET。$5表示第二个参数长度5，第二个参数是hello.第三个的长度也是$5,值为world</p>
<p>返回结果的格式：</p>
<p>有5种：</p>
<p>1.状态回复： 在RESP中，第一个字节是 +</p>
<p>2.错误回复：在RESP中，第一个字节是 -</p>
<p>3.整数回复：在RESP中，第一个字节是  :</p>
<p>4.字符串回复：在RESP中，第一个字节是 $</p>
<p>5.多条字符串回复：在RESP中，第一个字节是  *</p>
<p>从redis-cli.c的源码的 cliFormatReplyTTY方法，可以看到一共有这几种执行结果：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\8cc4710fe2404a6582bb758a14fd3161\clipboard.png)</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\a3fbdf67f35f4db3a293a700bf15f534\clipboard.png)</p>
<p>一共有REDIS_REPLY_ERROR,  STATUS,  INTEGER,  STRING, NIL, ARRAY</p>
<p>Jedis的重要类，重要方法，重要功能等等：</p>
<p>1.基本连接： Jedis</p>
<p>但默认是直连，于是每一次都要新建/关闭TCP的开销，资源无法控制（无法限制Jedis对象的个数)，Jedis线程不安全。而使用连接池，可以事先初始化好Jedis连接，降低TCP的开销。而且借用和归还到连接池的操作都是在本地进行的，只有少量的并发同步开销。</p>
<p>2.Jedis连接池：JedisPool</p>
<p>一般还有它的配置类GenericObjectPoolConfig类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"poolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"1000"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（此处的JedisPoolConfig是GenericObjectPoolConfig的子类，只有一个默认构造方法，初始化一下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolConfig</span> <span class="keyword">extends</span> <span class="title">GenericObjectPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JedisPoolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setTestWhileIdle(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setMinEvictableIdleTimeMillis(<span class="number">60000L</span>);</span><br><span class="line">        <span class="keyword">this</span>.setTimeBetweenEvictionRunsMillis(<span class="number">30000L</span>);</span><br><span class="line">        <span class="keyword">this</span>.setNumTestsPerEvictionRun(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS:书上列了一堆GenericObjectPoolConfig的属性，因为BaseObjectPoolConfig还有很多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericObjectPoolConfig</span> <span class="keyword">extends</span> <span class="title">BaseObjectPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericObjectPoolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseObjectPoolConfig</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_LIFO = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_FAIRNESS = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_MAX_WAIT_MILLIS = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFALUT_MIN_EVICTABLE_IDLE_TIME_MILLIS = <span class="number">1800000L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NUM_TESTS_PER_EVICTION_RUN = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_TEST_ON_CREATE = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_TEST_ON_BORROW = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_TEST_ON_RETURN = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFALUT_TEST_WHILE_IDLE = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_BLOCK_WHEN_EXHAUSTED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_JMX_ENABLE = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_JMX_NAME_PREFIX = <span class="string">"pool"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_JMX_NAME_BASE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_EVICTION_POLICY_CLASS_NAME = <span class="string">"org.apache.commons.pool2.impl.DefaultEvictionPolicy"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lifo = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> fairness = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxWaitMillis = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> minEvictableIdleTimeMillis = <span class="number">1800000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> softMinEvictableIdleTimeMillis = <span class="number">1800000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numTestsPerEvictionRun = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> String evictionPolicyClassName = <span class="string">"org.apache.commons.pool2.impl.DefaultEvictionPolicy"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnCreate = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnBorrow = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnReturn = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testWhileIdle = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeBetweenEvictionRunsMillis = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> blockWhenExhausted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> jmxEnabled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> String jmxNamePrefix = <span class="string">"pool"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.看一下当时在Spring下自己的项目的Redis完整配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"poolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"300"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"1000"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"poolConfig"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6379"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"xxx.xx.xx.xxx"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"xxxx"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"100000"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"database"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- org.springframework.data.redis.core.RedisTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisTemplate"</span> <span class="attr">class</span>=<span class="string">"com.hong.utils.redis.MyRedisTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashKeySerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"keySerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"valueSerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashValueSerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"methodCacheInterceptor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.support.SimpleCacheManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"caches"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.hong.utils.redis.RedisUtil"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"redisTemplate"</span> <span class="attr">ref</span>=<span class="string">"redisTemplate"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"common"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisUtil"</span> <span class="attr">class</span>=<span class="string">"com.hong.utils.redis.RedisUtil"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"redisTemplate"</span> <span class="attr">ref</span>=<span class="string">"redisTemplate"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- name属性的值,是用于等会的注解当中 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"common"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还是很好理解的，首先JedisPoolConfig是连接池的配置。</p>
<p>然后JedisConnectionFactory就是连接的配置（连接池要预先创建连接，那么自然需要一个Factory去创建连接，而至于hostName，password，timeout，port等等的，确实就应该写在factory里了，同时还传入了poolConfig配置，database就是默认是第一个数据库吧，也没什么好说的）</p>
<p>然后是RedisTemplate，这个也很显然，就跟JdbcTemplate，就是封装了原生的Redis API，然后提供了更易操作的方法接口罢了。我们看一下方法：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\3e927f8193dc487b9d462e096537527a\clipboard.png)</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\a5493d3d73cb441ca0a50ab95ad2323f\clipboard.png)</p>
<p>方法确实很多哈，这里也没必要截完了，反正都是封装好了的Redis原生API，不妨随意选择一个方法去查看？就选keys方法吧，返回所有的键，很简单的方法逻辑，这里重在理解方法的主要构成，没必要选择太复杂的方法逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keys</span><span class="params">(K pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(pattern);</span><br><span class="line">    Set&lt;<span class="keyword">byte</span>[]&gt; rawKeys = (Set)<span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;Set&lt;<span class="keyword">byte</span>[]&gt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Set&lt;<span class="keyword">byte</span>[]&gt; doInRedis(RedisConnection connection) &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.keys(rawKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.keySerializer != <span class="keyword">null</span> ? SerializationUtils.deserialize(rawKeys, <span class="keyword">this</span>.keySerializer) : rawKeys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看不出什么，但感觉关键就是把具体的参数传到execute方法，然后再执行，再看几个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Object&gt; <span class="title">execRaw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (List)<span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;List&lt;Object&gt;&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">List</span><span class="params">(Object)</span> <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> connection.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">    <span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> </span>&#123;</span><br><span class="line">            connection.del(<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;rawKey&#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，都是把不同的参数传到了execute方法。所以说就是对execute方法进行重载咯！我们查一下，确实，一堆的execute重载方法：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\bf4ed38156ac4f6f811fff3169568859\clipboard.png)</p>
<p>那我们还是继续拿keys指向的那个execute来看一下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; action, <span class="keyword">boolean</span> exposeConnection, <span class="keyword">boolean</span> pipeline)</span> </span>&#123;</span><br><span class="line">		Assert.isTrue(initialized, <span class="string">"template not initialized; call afterPropertiesSet() before using it"</span>);</span><br><span class="line">		Assert.notNull(action, <span class="string">"Callback object must not be null"</span>);</span><br><span class="line"></span><br><span class="line">		RedisConnectionFactory factory = getConnectionFactory();</span><br><span class="line">		RedisConnection conn = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (enableTransactionSupport) &#123;</span><br><span class="line">				<span class="comment">// only bind resources in case of potential transaction synchronization</span></span><br><span class="line">				conn = RedisConnectionUtils.bindConnection(factory, enableTransactionSupport);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				conn = RedisConnectionUtils.getConnection(factory);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">boolean</span> existingConnection = TransactionSynchronizationManager.hasResource(factory);</span><br><span class="line"></span><br><span class="line">			RedisConnection connToUse = preProcessConnection(conn, existingConnection);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">boolean</span> pipelineStatus = connToUse.isPipelined();</span><br><span class="line">			<span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">				connToUse.openPipeline();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			RedisConnection connToExpose = (exposeConnection ? connToUse : createRedisConnectionProxy(connToUse));</span><br><span class="line">			T result = action.doInRedis(connToExpose);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// close pipeline</span></span><br><span class="line">			<span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">				connToUse.closePipeline();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> any other connection processing?</span></span><br><span class="line">			<span class="keyword">return</span> postProcessResult(result, connToUse, existingConnection);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!enableTransactionSupport) &#123;</span><br><span class="line">				RedisConnectionUtils.releaseConnection(conn, factory);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>前面两行Assert，普通的断言语句。然后后面的几行就很显然了，先获取ConnectionFactory，然后再在try-catch块里获取connection。具体的怎么getConnectionFactory这种是涉及到比较复杂的很多类的跳转的，但本质上都只是设计模式的运用，此处可以不管。接下来的就是Redis的操作了，先判断一下事务同步管理器，连接预处理等等的，最后再放入pipeline执行（因为keys是一个批处理操作，原子性的）。最后再返回postProcessResult。话说再刷新了一下，这段代码更新了，这个var11确实没有存在的必要，直接return postPro…即可。但总体来说，确实也是获取到ConnectionFactory，然后生成连接，再操作。那么，RedisTemplate的作用确实也跟我们预期的一样。</p>
<p>除此之外，网上也有提到，Redis可以直接存储Java对象，那么就需要序列化跟反序列化。    在Spring中，是通过StringRedisSerializer跟JdkSerializationRedisSerializer实现的。那么，RedisTemplate下面传入的两个蜜汁property也是可以理解了。至于传入connectionFactory，那是当然的了，我们上面看源码也已经看到了，RedisTemplate是需要调用connectionFactory生成连接的）</p>
<p>接下来最后这两个，MethodCacheInterceptor跟RedisUtil。我第一次使用的时候，直接拿RedisUtil当作RedisTemplate使用了，只是简单的set，get，那确实是足够的（RedisUtil是我的自定义类，只有最简单的set，get，remove）。其实认真一点看类名，就知道它的作用了，MethodCacheInterceptor，Redis的作用是什么？就是Cache。那么Method，Interceptor？显然，就是对方法进行拦截，确定哪些属性要考虑缓存的问题。如果需要，那么就要用到RedisUtil（基本就是最简单的set，get，remove，所以使用一个迷你版的RedisUtil就可以满足RedisTemplate的功能了）</p>
<p>至于MethodCacheInterceptor，是自己写的方法，我们看一下这份网上cv的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodCacheInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = Logger.getLogger(MethodCacheInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; targetNamesList; <span class="comment">// 不加入缓存的service名称</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; methodNamesList; <span class="comment">// 不加入缓存的方法名称</span></span><br><span class="line">    <span class="keyword">private</span> Long defaultCacheExpireTime; <span class="comment">// 缓存默认的过期时间</span></span><br><span class="line">    <span class="keyword">private</span> Long xxxRecordManagerTime; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> Long xxxSetRecordManagerTime; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodCacheInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File f = <span class="keyword">new</span> File(<span class="string">"D:\\cacheConf.properties"</span>);</span><br><span class="line">            <span class="comment">//配置文件位置直接被写死，有需要自己修改下</span></span><br><span class="line">            InputStream in = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="comment">//			InputStream in = getClass().getClassLoader().getResourceAsStream(</span></span><br><span class="line"><span class="comment">//					"D:\\lunaJee-workspace\\msm\\msm_core\\src\\main\\java\\com\\mucfc\\msm\\common\\cacheConf.properties");</span></span><br><span class="line">            Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">            p.load(in);</span><br><span class="line">            <span class="comment">// 分割字符串</span></span><br><span class="line">            String[] targetNames = p.getProperty(<span class="string">"targetNames"</span>).split(<span class="string">","</span>);</span><br><span class="line">            String[] methodNames = p.getProperty(<span class="string">"methodNames"</span>).split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加载过期时间设置</span></span><br><span class="line">            defaultCacheExpireTime = Long.valueOf(p.getProperty(<span class="string">"defaultCacheExpireTime"</span>));</span><br><span class="line">            xxxRecordManagerTime = Long.valueOf(p.getProperty(<span class="string">"com.service.impl.xxxRecordManager"</span>));</span><br><span class="line">            xxxSetRecordManagerTime = Long.valueOf(p.getProperty(<span class="string">"com.service.impl.xxxSetRecordManager"</span>));</span><br><span class="line">            <span class="comment">// 创建list</span></span><br><span class="line">            targetNamesList = <span class="keyword">new</span> ArrayList&lt;String&gt;(targetNames.length);</span><br><span class="line">            methodNamesList = <span class="keyword">new</span> ArrayList&lt;String&gt;(methodNames.length);</span><br><span class="line">            Integer maxLen = targetNames.length &gt; methodNames.length ? targetNames.length</span><br><span class="line">                    : methodNames.length;</span><br><span class="line">            <span class="comment">// 将不需要缓存的类名和方法名添加到list中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; targetNames.length) &#123;</span><br><span class="line">                    targetNamesList.add(targetNames[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; methodNames.length) &#123;</span><br><span class="line">                    methodNamesList.add(methodNames[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object value = <span class="keyword">null</span>;</span><br><span class="line">        String targetName = invocation.getThis().getClass().getName();</span><br><span class="line">        String methodName = invocation.getMethod().getName();</span><br><span class="line">        <span class="keyword">if</span> (!isAddCache(targetName, methodName))       <span class="comment">// 不需要缓存的内容</span></span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();               <span class="comment">// 执行方法返回结果</span></span><br><span class="line">        Object[] arguments = invocation.getArguments();</span><br><span class="line">        String key = getCacheKey(targetName, methodName, arguments);</span><br><span class="line">        System.out.println(key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (redisUtil.exists(key))             <span class="comment">// 判断是否有缓存</span></span><br><span class="line">                <span class="keyword">return</span> redisUtil.get(key);</span><br><span class="line"></span><br><span class="line">            value = invocation.proceed();                       <span class="comment">// 写入缓存</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> String tkey = key;</span><br><span class="line">                <span class="keyword">final</span> Object tvalue = value;</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (tkey.startsWith(<span class="string">"com.service.impl.xxxRecordManager"</span>)) &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, xxxRecordManagerTime);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tkey.startsWith(<span class="string">"com.service.impl.xxxSetRecordManager"</span>)) &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, xxxSetRecordManagerTime);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, defaultCacheExpireTime);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否加入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAddCache</span><span class="params">(String targetName, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetNamesList.contains(targetName)</span><br><span class="line">                || methodNamesList.contains(methodName)) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建缓存key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCacheKey</span><span class="params">(String targetName, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Object[] arguments)</span> </span>&#123;</span><br><span class="line">        StringBuffer sbu = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sbu.append(targetName).append(<span class="string">"_"</span>).append(methodName);</span><br><span class="line">        <span class="keyword">if</span> ((arguments != <span class="keyword">null</span>) &amp;&amp; (arguments.length != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                sbu.append(<span class="string">"_"</span>).append(arguments[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sbu.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRedisUtil</span><span class="params">(RedisUtil redisUtil)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先第一个是构造方法，里面就是对Interceptor的配置，比如过期时间啊，要拦截哪部分的方法啊等等的。这段代码显然有点糙（毕竟上面的都是优雅的源码，这个虽然也是网上大佬写的，但还是有差距哈）。然后invoke方法，这个是最关键的方法。我们的这个类实现了MethodInterceptor接口，这个接口就是只有这么1个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implement this method to perform extra treatments before and</span></span><br><span class="line"><span class="comment">     * after the invocation. Polite implementations would certainly</span></span><br><span class="line"><span class="comment">     * like to invoke &#123;<span class="doctag">@link</span> Joinpoint#proceed()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation the method invocation joinpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result of the call to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Joinpoint#proceed()&#125;, might be intercepted by the</span></span><br><span class="line"><span class="comment">     * interceptor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable if the interceptors or the</span></span><br><span class="line"><span class="comment">     * target-object throws an exception.  */</span></span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从注释也可以看得出来，用于对方法在before或者after进行加强（此处有点像AOP）。而对于invoke方法，前面首先是要读取配置辣，然后try-catch也是比较显然的，判断是否有缓存，如果有，直接return，如果没有，写入缓存（其实这里的interceptor的invoke方法写得不够好，应该要分情况去缓存的，这个大概只是一个demo，还要修改很多，但这里暂时不讨论）。后面的这个Thread我没看懂是为何，既然用到了RedisUtil，应该跟它demo的逻辑有关系，但跟整体的Cache关系不大，略。至于其他的方法，都是辅助这个invoke方法的，比如判断是否要写入缓存，是否存在键等等，关键还是invoke。</p>
<p>至此，对当时Spring整合Redis的全部配置文件，每一个导入的类作用是什么，为什么要有这些property，应该是能有比较清晰的认知了。</p>
<p>4.Jedis的一些重要方法</p>
<p>其实最关键的框架也就是上面的第3点了。这一部分还有的就是Pipeline，调用Lua脚本等等，也是直接调用就行（看着方法名，方法参数来就行，只要对Redis的原生操作足够熟悉）。</p>
<p>Pipeline就直接使用Pipeline类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pipeline</span> <span class="keyword">extends</span> <span class="title">MultiKeyPipelineBase</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pipeline.MultiResponseBuilder currentMulti;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Response&lt;T&gt; <span class="title">getResponse</span><span class="params">(Builder&lt;T&gt; builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.currentMulti != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">super</span>.getResponse(BuilderFactory.STRING);</span><br><span class="line">            Response&lt;T&gt; lr = <span class="keyword">new</span> Response(builder);</span><br><span class="line">            <span class="keyword">this</span>.currentMulti.addResponse(lr);</span><br><span class="line">            <span class="keyword">return</span> lr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getResponse(builder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClient</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Client <span class="title">getClient</span><span class="params">(<span class="keyword">byte</span>[] key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Client <span class="title">getClient</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isInMulti()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.discard();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.sync();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用Lua是在Jedis下的方法：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\60fbd8249e904bc3a36241008b228f76\clipboard.png)</p>
<p>看了一下，RedisTemplate搜eval竟然没有相关方法。然后再搜了一下script，就出来了：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\c46dfa03d3e647adb313655d32a4e859\clipboard.png)</p>
<p>显然，这个就是调用脚本的总方法了。原来没有eval是因为，RedisTemplate还有更大的野心，它要一个方法来执行所有的跟Redis兼容的脚本。。那么看来Jedis也有其他的调用脚本的方法，此处就不再赘述。</p>
<p>客户端管理的API</p>
<p>client list：列出与Redis服务端相连的所有客户端连接信息。下面的客户端的属性：</p>
<p>标识：id，addr，name，fd（socket的文件描述符，如果fd=-1，表示客户端不是外部客户端，而是Redis内部的伪装客户端）</p>
<p>输入缓冲区： qbuf， qbuf-free。缓冲区会动态调整，只是要求每个客户端缓冲区的大小不能超过1G。如果超过了，客户端将会被关闭。而且缓冲区不受maxmomory控制，假设一个Redis实例设置了maxmemory为4G，已经存储了2G，但是如果此时输入缓冲区使用了3G，加起来就超过了maxmemory的限制，可能会产生数据丢失，键值淘汰，OOM等情况。</p>
<p>导致输入缓冲区过大的主要原因：Redis的处理速度跟不上输入缓冲区的输入速度，并且每次进入输入缓冲区的命令包含了大量的bigkey，从而造成了输入缓冲区过大的情况。或者是Redis发生了阻塞，短期内不能处理命令，造成客户端输入的命令积压在了输入缓冲区。</p>
<p>监控输入缓冲区的方法：</p>
<p>1.client  list（收集qbuf和qbuf-free，找到可能出现问题的客户端）</p>
<p>2.info clients，找到最大的输入缓冲区，设置client_biggest_input_buf参数，超过一定值告警</p>
<p>输出缓冲区：obl，oll，omem。与输入缓冲区不一样，输出区可以通过参数设置。输出区根据客户端的不同分为3种：普通客户端，发布订阅客户端，slave客户端（子客户端）。包含：固定缓冲区（16KB，用于返回比较小的执行结果0，动态缓冲区（返回比较大的结果）</p>
<p>客户端的存活状态：age：连接时间    idle：最近一次空闲时间</p>
<p>通过设置参数来控制客户端： config set maxclients（最大客户端连接数，默认10000）</p>
<p>config set timeout（客户端空闲时间超过这个值，就会被关闭，默认是0，即不关闭）</p>
<p>（一般开发的时候用默认的就行，实际发布和运维的时候，idle是必须大于0的）</p>
<p>flag：参数：表示客户端的类型。</p>
<p>N：普通客户端。M：master。S：slave。O：正在执行monitor命令。x：正在执行事务</p>
<p>b：正在等待阻塞事件     u：客户端未被阻塞        d：一个被watch的键已被修改，无法exec事务</p>
<p>c：回复完整的输出后，关闭连接        A：尽可能快地关闭连接</p>
<p>其他诸如：client setName/getName , kill port, pause timeout(毫秒），不再赘述</p>
<p>monitor：可以监控其他客户端的命令调用（在哪个时间，调用了哪个命令）。但在并发量过大的时候，monitor客户端的输出缓冲会暴涨，可能会瞬间占用大量内存。</p>
<p>tcp-keepalive:检测TCP连接活性的周期，默认是0.防止大量的死连接占用系统资源。</p>
<p>tcp-backlog：是一个队列，用于接受的TCP连接。此参数就是队列的大小，默认511，一般不修改。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2020/02/12/test/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
