<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode-二分查找</title>
    <url>/LeetCode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</url>
    <content><![CDATA[<h3 id="一-二分查找"><a href="#一-二分查找" class="headerlink" title="一. 二分查找"></a>一. 二分查找</h3><p>​        二分查找是算法里很常见的一道题目。有的题目直接就是要求二分查找，有的题目是子步骤需要用到查找，而这一块也可以用到二分法进行查找。同时二分法具备的时间复杂度为O(logN)，是一个非常高效的算法。概念很简单，对于<strong><em>有序</em></strong> 的数组，就是一直使用<strong><em>中点mid</em></strong> 进行筛选，<strong><em>逐步缩小区间大小</em></strong>，最后得到答案。但是概念大家都懂，实际操作的时候却发现总是会出现问题，比如判定条件到底是<code>left &lt; right</code>还是<code>left &lt;= right</code>？里面的else if到底是<code>left = mid</code>还是<code>left = mid + 1</code>等等？最后返回的是<code>left</code>还是<code>left + 1</code>？这使得原本觉得二分法很简单的我们，渐渐地发现：原来我们只会做最基本的那个二分查找，只要稍微加一点变动，就很容易出现纰漏。所以这里就是要好好总结二分查找的<strong><em>真实框架</em></strong>，真正地掌握二分查找的精髓，而不是只会做那道最简单的二分查找。</p>
<p>​        本文参考链接：《<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">二分查找算法细节详解</a>》，《<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md" target="_blank" rel="noopener">Leetcode题解 - 二分查找</a>》</p>
<a id="more"></a>



<h3 id="二-LeetCode-704-二分查找"><a href="#二-LeetCode-704-二分查找" class="headerlink" title="二.  LeetCode 704. 二分查找"></a>二.  LeetCode 704. 二分查找</h3><p><strong><em>题目描述</em></strong>：给定一个升序的整型数组nums和一个目标值target，假设nums中所有的元素是不重复的，使用二分法找到目标值的index。如果不存在，返回-1。        <a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener"><strong><em>题目链接</em></strong></a></p>
<p><strong><em>分析</em></strong>：这就是最简单的二分查找题，升序，元素不重复，目标就是找到target值。很容易就能写出代码。</p>
<p><strong><em>代码</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;	<span class="comment">// 可以防止int溢出</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码分析</em></strong>：</p>
<p>①首先是赋值，为什么是<code>nums.length - 1</code>？因为我们要寻找的是具体的数组元素，这个是最后一个元素的index。</p>
<p>②循环结束条件为什么是 <code>left &lt;= right</code>？这时候直接思考，循环什么时候才该结束？如果找到了target值，也就是<code>nums[mid == target]</code>，毫无疑问就直接return了。那如果没有找到呢？也就是<strong><em>搜索区间为空</em></strong>。最开始的搜索范围是[0, nums.length - 1]，那么当<code>left == right</code>的时候，此时搜索范围为[left, left]，也就是搜索区间非空，因此等于的时候，循环还未结束。（最简单的思路，如果只有一个元素，此时left == right，直接跳出循环，导致稳定返回-1，而没有考虑那个唯一的元素是否等于target值）</p>
<p>③为什么else if里面是<code>right = mid - 1</code>，<code>left = mid + 1</code>？有的代码却是直接<code>right = mid</code>，或者<code>left = mid</code>。最关键的就是要明确<strong><em>搜索空间</em></strong>，最开始我们的搜索空间是[left, right]，既然都已经知道了<code>nums[mid] != target</code>，那么下一个的搜索区间应该是什么？显然，完全不用再考虑mid这个位置，所以下一步的搜索空间应该为[left, mid - 1]，或者[mid + 1, right]。只要明确这个搜索空间的变化，那么left跟right的变化就会很清晰。</p>
<p>④这个算法很容易写出来，哪怕把判定条件去掉等号，只要在最后return的时候再加一个特殊处理也可以。那么这个算法的局限性是什么，当我们的二分查找稍微改变一下，这个代码就不能work。比如，如果数组里存在重复的元素，而且我们想要找到target值的第一个index，或者是最右边的index，这时候应该怎么做？如果继续套用这个最简单的二分模板而不加以改动，我们能做的只是，找到一个target，然后再向左向右进行线性查找。这确实是最容易想到的办法，但是在特定的情况下，也会导致二分查找的时间复杂度从O(logN)退化成O(N)，这并不可取。所以这段代码并不是银弹，也因此二分查找并不是不需要思考就能随便解决的问题，根据不同的情况，初始化，循环条件，left跟right的改变，都是会发生变化的。</p>
<h3 id="三-LeetCode-34-寻找左-amp-右侧边界的二分搜索"><a href="#三-LeetCode-34-寻找左-amp-右侧边界的二分搜索" class="headerlink" title="三. LeetCode 34. 寻找左&amp;右侧边界的二分搜索"></a>三. LeetCode 34. 寻找左&amp;右侧边界的二分搜索</h3><h4 id="Ⅰ-题目描述："><a href="#Ⅰ-题目描述：" class="headerlink" title="Ⅰ. 题目描述："></a><strong><em>Ⅰ. 题目描述：</em></strong></h4><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]</p>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener"><strong><em>题目链接</em></strong></a></p>
<hr>
<h4 id="Ⅱ-分析："><a href="#Ⅱ-分析：" class="headerlink" title="Ⅱ. 分析："></a><strong><em>Ⅱ. 分析：</em></strong></h4><p>根据上一题最后的代码分析，我们知道，上一题的代码在这里行不通。从上一题得知，二分查找的关键是：清晰<strong><em>搜索区间</em></strong>，以及<strong><em>搜索区间</em></strong> 的变化。这道题最关键的一点，我们不能直接在找到target之后结束，而是应该继续缩小搜索空间。</p>
<p>正如我们上一题所提到的二分查找的各种要点，它们之间也是会互相影响的（根据逻辑而驱动）。</p>
<p>①right的赋值是nums.length - 1还是nums.length，实际上right并不只是一个简单的初始值，它代表的是右区间，决定了我们是<strong><em>搜索区间</em></strong> 是<strong><em>[left, right]</em></strong> 还是<strong><em>[left, right)</em></strong>。</p>
<p>②if，else if的逻辑中，left，right的调整，是由题意以及第①点所一起影响的。如果是像第一题一样简单，那么如果匹配到target，显然就直接return，而如果是找左边界右边界，就要继续缩小搜索空间。else if中left跟right的改变，也与搜索空间的全闭区间还是左闭右开区间有关（主要体现在是否+1，-1）。</p>
<p>③循环条件的结束，也是根据搜索区间的开闭情况，具体情况来决定，返回值则要根据if，else的逻辑判断。</p>
<hr>
<h4 id="Ⅲ-二分法的关键："><a href="#Ⅲ-二分法的关键：" class="headerlink" title="Ⅲ. 二分法的关键："></a><strong><em>Ⅲ. 二分法的关键：</em></strong></h4><p>如果你直接去看上面的LeetCode题解，看了labuladong的题解，你会有一种豁然开朗的感觉，原来二分法有这么多details，原来这就是为什么二分法看似简单，实际上总是容易出错。而且也许你还会自豪地认为：原来搜索target的第一个位置跟最后一个位置是这样解决的，感觉自己对于二分法已经了如指掌。我一开始也是这么想的，直到我自己亲手写这篇文章，我才发现了<strong>更多的问题</strong>。labuladong的题解，清楚地阐述了：<strong><em>搜索区间</em></strong>，<strong><em>循环结束条件</em></strong>，<strong><em>初始化导致的开闭区间</em></strong>，<strong><em>if跟else if的变化</em></strong>，看着标准的代码，然后进行解释，确实很有效，也很好理解。那么问题来了，当我们最开始写的代码的时候，如何确定初始化是<code>nums.length</code>还是<code>nums.length - 1</code>?到底搜索区间是<strong>闭区间</strong>还是<strong>开区间</strong>？if跟else if一定要这样写吗，有没有其他的写法？因为我们的目标是生成代码，写出正确的代码，而不是看懂答案。</p>
<p>答案很简单，labuladong大佬的题解，也已经提到了，但没有明确地说出来。实际上结果就是，赋值成<code>nums.length</code>是可行的，赋值成<code>nums.length - 1</code>也同样可行，开区间，闭区间，<strong><em>都是可行的</em></strong>，只是在不同的情况下，会导致你if跟else的变化也不一样（可能+1，可能-1，可能不加不减）。所以关键就是：<strong><em>明确搜索区间的意义</em></strong>。接下来用具体的例子来阐述不同题目中搜索区间的意义，以及变化，紧接着如何编码。</p>
<hr>
<h4 id="Ⅳ-左边界的情况（-target的第一个位置"><a href="#Ⅳ-左边界的情况（-target的第一个位置" class="headerlink" title="Ⅳ. 左边界的情况（ target的第一个位置 )"></a><strong><em>Ⅳ. 左边界的情况（ target的第一个位置 )</em></strong></h4><p>①right赋值成<code>nums.length</code>，区间的实质意义是左闭右开的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>right初始化为nums.length，表明它代表的区间是左闭右开，也就是[left, right)。那么循环条件是否有等号？假设<code>left == right</code>，此时的搜索区间是[left, left)，为空区间，显然应该已经结束，所以循环结束的判定条件是<code>left &lt; right</code>。</p>
<p>而第一个if语句，因为我们要继续往左边搜索（搜索左边界），所以就是<code>right = mid</code>（因为右区间是开区间，所以不需要-1）。然后第一个else if语句，如果mid的元素比target小，<code>left = mid + 1</code>，搜索区间往右边搜索，同时要排除mid，很好理解。接着是第二个else if语句（实际上写成else也可以，理解就行），mid的元素比target大，那么就是要区间往左边搜索，实际上情况是跟相等的时候一样的，也是因为开区间，所以无须考虑-1。</p>
<p>最后循环结束的时候，<code>left == right</code>，所以返回left还是right都是一样的。那么到底要不要+1，-1？在我们<strong><em>最后一次</em></strong> 执行<code>nums[mid] &gt;= target</code>的时候，实际上也就是<code>nums[mid] == target</code>，所以这时候的mid就已经是answer，而且<code>right == answer</code>，后面一直修改的都是left的值，直到<code>left == right</code>，循环结束。所以最后直接返回left或者right即可。</p>
<p>②right赋值为<code>nums.length - 1</code>，也就是两边都是闭区间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;	<span class="comment">// 可以防止int溢出</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right + <span class="number">1</span> &gt;= nums.length || nums[right + <span class="number">1</span>] != target)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>因为是闭区间，所以循环判定条件是<code>left &lt;= right</code>，否则当<code>left == right</code>的时候，搜索区间为[left, left]，并非空区间，这样搜索毫无意义，而且如果在if跟else语句的判定中有问题，那么还会出现死循环的情况。</p>
<p>第一个if语句，跟①的开区间有什么区别？<code>right = mid - 1</code>，因为它是闭区间，而非开区间，所以要把mid给pass掉。而当mid元素大于target的时候，同样如此，因为要把搜索区间往左边逼近，那么就是修改right。而当mid元素小于target时，是往右边逼近，则修改left，+1同样是为了排除掉mid。</p>
<p>循环结束，为什么是right + 1？其实最后的循环结束条件是<code>left == right + 1</code>，所以这里<code>return left</code>也是完全可行的。同样地，在<strong><em>最后一次</em></strong> 执行<code>nums[mid]  &gt;= target</code>的时候，也必定是在执行<code>nums[mid] == target</code>，所以这时候的mid就是answer，即<code>right == mid - 1</code>，后续都是对left进行修改，直到循环结束。所以最后返回的值是right + 1，或者left。</p>
<hr>
<h4 id="Ⅴ-右边界的情况-（-target的最后一个位置-）"><a href="#Ⅴ-右边界的情况-（-target的最后一个位置-）" class="headerlink" title="Ⅴ. 右边界的情况 （ target的最后一个位置 ）"></a><strong><em>Ⅴ. 右边界的情况 （ target的最后一个位置 ）</em></strong></h4><p>其实跟左边界是一样的，关键都是理清楚搜索区间的实质含义。</p>
<p>①right赋值为<code>nums.length</code>，也就是区间为左闭右开的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们要找右边界，所以<code>nums[mid] &lt;= target</code>的时候，都是要向右逼近区间，因为左区间是闭区间，所以要去掉mid，也就是<code>left = mid + 1</code>。而当<code>nums[mid] &gt; target</code>，要向左逼近区间，因为右区间是开区间，所以直接<code>right = mid</code>就已经去掉了mid。</p>
<p>循环结束条件是<code>left == right</code>，而在我们最后一次执行<code>nums[mid] &lt;= target</code>逻辑的时候，这时候左区间left，实际上就已经是右边界的右一位，之后的操作都是操作right，直到循环结束。所以执行<strong><em>最后一次</em></strong> <code>left = mid + 1</code>，实际上就是执行最后一次<code>nums[mid] == target</code>，这时候的mid就是最终的答案，而left一直没有变化，也就是<code>left == answer + 1</code>，后面修改的都是right。所以最后返回的就是<code>left - 1</code>。当然，因为最后的时候<code>left == right</code>，所以返回<code>right - 1</code>也是完全一样的。</p>
<p>②right赋值为<code>nums.length - 1</code>，也就是左右区间均为闭区间的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchRange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;	<span class="comment">// 可以防止int溢出</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">if</span> (right &gt;= nums.length || nums[right] != target)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>因为是闭区间，所以循环结束条件是<code>left &lt;= right</code>，不再赘述。而当<code>nums[mid] &lt;= target</code>的时候，区间向右逼近，并且要把mid排除在外，所以操作是<code>left = mid + 1</code>。而当<code>nums[mid] &gt; target</code>的时候，区间向左逼近，并且要把mid排除在外，因为右区间也是闭区间，所以操作是<code>right = mid - 1</code>。</p>
<p>最后的返回值，在我们<strong><em>最后一次</em></strong> 执行<code>nums[mid] &lt;= target</code>的时候，最后一次一定是<code>nums[mid] ==target</code>，也就是这时候的mid就是answer，即left = answer + 1，后面修改的都是right的值，直到循环结束。循环结束的时候，<code>left = right + 1</code>，所以我们可以返回<code>left - 1</code>，也可以返回<code>right</code>。</p>
<h4 id="Ⅵ-总结"><a href="#Ⅵ-总结" class="headerlink" title="Ⅵ. 总结"></a><strong><em>Ⅵ. 总结</em></strong></h4><p>​        通过这一题的分析，可以很清晰地体会到二分法的解法关键。搜索区间的变法是二分法的关键，我们首先要确定定义的搜索区间究竟是<strong><em>开区间还是闭区间</em></strong>，进而在不同的情况下，<strong><em>修改 left跟 right的情况也有所不同</em></strong>（开区间与闭区间，会决定是否需要+1，-1等）。而最后的<strong><em>返回值</em></strong>，关键就是最后一次执行<code>nums[mid] == target</code>，实际上这时候的mid就是最后的返回值，只要清晰这一点，返回值就能直接得出来，而不是靠猜测。</p>
<hr>
<h3 id="四-LeetCode-69-求x的平方根"><a href="#四-LeetCode-69-求x的平方根" class="headerlink" title="四. LeetCode 69. 求x的平方根"></a>四. LeetCode 69. 求x的平方根</h3><p>69.Sqrt(x) (Easy)</p>
<p><a href="https://leetcode.com/problems/sqrtx/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/sqrtx/description/" target="_blank" rel="noopener">力扣</a></p>
<p><strong><em>题目描述</em></strong>：实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><strong><em>分析</em></strong>：这道题可以直接暴力法解决，因为Integer.MAX_VALUE的平方根是46340，所以直接寻找0~46340即可，但要注意的是小心int溢出导致的死循环。不过这是因为这道题的范围比较小，如果范围较大，那么这个O(n)的解法并不算特别好。实际上这道题也可以转换成标准的二分法题目：“一个有序数组，数值0 ~ 46341，寻找一个值x，使得x的平方等于target，此时返回x。或者x`的平方大于target，此时返回最小的x`。</p>
<p><strong><em>代码</em></strong>：</p>
<p>①暴力法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp &lt;= <span class="number">46340</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; temp * temp)</span><br><span class="line">                <span class="keyword">return</span> temp - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x == temp * temp)</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS:对于46340这个数，如果我们不知道Integer.MAX_VALUE的平方根，也可以换一种写法，循环条件变成true，也就是无限循环，而当temp * temp &lt; 0，也就是数值溢出的时候，跳出循环即可。改法很简单，不再赘述。这一题使用暴力法的执行用时为22ms，可以看到是很慢的。</p>
<p>②二分法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = mid * mid;</span><br><span class="line">            <span class="keyword">if</span> (tmp == x)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmp &gt; x || tmp &lt; <span class="number">0</span>)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS:二分法因为时间复杂度很低，为O(logN)，所以右边界为100000，还是46341，区别可以忽略不计。二分的逻辑也不难，关键是最后<code>tmp &gt; x || tmp &lt; 0</code>处，这时候表明mid是最后（也是最左）使得mid的平方大于x的数，所以此时的mid - 1就是answer1，即<code>right == mid- 1 == answer</code>，之后的所有操作都是对left进行操作，或者直接出现<code>tmp == x</code>的逻辑使得直接返回真正的answer。无论如何，当后续没有进入<code>tmp == x</code>的逻辑，说明就是只对left进行修改，而right并没有修改，所以<code>right = answer</code>，所以可以返回right。当然，循环结束时，<code>left == right + 1</code>，所以返回left - 1也是一样的。此题使用二分法的执行用时为1ms。</p>
<h3 id="五-LeetCode-744-大于给定元素的最小元素"><a href="#五-LeetCode-744-大于给定元素的最小元素" class="headerlink" title="五.  LeetCode 744. 大于给定元素的最小元素"></a>五.  LeetCode 744. 大于给定元素的最小元素</h3><p>744.Find Smallest Letter Greater Than Target (Easy)</p>
<p><a href="https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;d&quot;</span><br><span class="line">Output: &quot;f&quot;</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">letters &#x3D; [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]</span><br><span class="line">target &#x3D; &quot;k&quot;</span><br><span class="line">Output: &quot;c&quot;</span><br></pre></td></tr></table></figure>

<p><strong><em>题目描述</em></strong>：给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。</p>
<p>数组里字母的顺序是循环的。举个例子，如果目标字母target = ‘z’ 并且有序数组为 letters = [‘a’, ‘b’]，则答案返回 ‘a’。</p>
<p><strong><em>分析</em></strong>：有序数组中找target，标准的二分法套路可以解决。这道题的评论里存在钻牛角尖的情况，关于“数组里字母的顺序是循环的。”这句话，英语原文是“Letters also wrap around. ”，实际上意思是指，<strong><em>当 target比数组里最大的元素还要大（或者相等），那就直接返回数组里最小的元素，而并不是 z &lt; a &lt; b有序</em></strong>。</p>
<p>如果你真的想这么排，那么还叫什么有序数组呢？[z, a, b, c, z, b, a]也是一个“有序数组”，因为z &lt; a &lt; b &lt; … &lt; z。而为什么b又小于a？b &lt; c &lt; d &lt; … &lt; z &lt; a。如果你把这称为有序，那这个有序又有什么意义呢。如果拿33题来类比，33题是说一个有序数组，旋转了一次变成了“Rotated Sorted Array”，但这个数组并不是有序数组。总而言之，这道题就是简单的二分法，不用想太多warp around。</p>
<p><strong><em>代码</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = letters.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (letters[mid] &lt;= target)</span><br><span class="line">                left = mid + <span class="number">1</span>;         <span class="comment">// 区间向右寻找</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;        <span class="comment">// 区间向左寻找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left &lt; letters.length &amp;&amp; letters[right + <span class="number">1</span>] &gt; target ?</span><br><span class="line">            letters[right + <span class="number">1</span>] : letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>代码分析</em></strong>：直接选择闭区间（开闭区间只影响了一下±1，只要清晰搜索区间的变化即可，不再赘述！），然后<code>letters[mid] &lt;= target</code>的时候，区间都是向右缩小，所以可以写在一起，当然最开始不熟练的时候可以写成if跟else if，逻辑更加清晰。而<code>letters[mid] &gt; target</code>的时候，区间向左缩小。循环结束的时候，<code>left = right + 1</code>，所以最后的返回，使用left或者right + 1都是一样的，这里为了演示，也是直接在return语句里同时使用了这两个变量，可以随意更改。至于为什么最后是return这个值？同样的，最后一次执行<code>right = mid + 1</code>的时候，此时的mid就是answer，即right = answer - 1，后续都是对left进行改变，所以最后的asnwer就是right + 1。同时题目里还有其他要求，如果数组里没有比target更大的元素，则返回最小的元素，所以还加了一些判定。</p>
<h3 id="六-LeetCode-540-有序数组的唯一元素"><a href="#六-LeetCode-540-有序数组的唯一元素" class="headerlink" title="六.  LeetCode 540. 有序数组的唯一元素"></a>六.  LeetCode 540. 有序数组的唯一元素</h3><p>540.Single Element in a Sorted Array (Medium)</p>
<p><a href="https://leetcode.com/problems/single-element-in-a-sorted-array/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1, 1, 2, 3, 3, 4, 4, 8, 8]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong><em>题目描述</em></strong>：给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。</p>
<p><strong><em>分析</em></strong>：在有序数组里寻找元素，同时要求时间复杂度为O(logN)，显然就是需要使用二分法。二分法依然是对搜索区间的缩小逼近，最后找出结果。而这道题跟前面的题有点不一样，如果想直接套用前面的思路，都无法通过。其实这道题还有一个信息：我们要找的是只出现一次的元素，并且其他的元素都会出现两次。我们很容易会忽略掉这个信息：”<strong><em>其他元素都会出现两次。</em></strong>“，而这就是这道题使用二分法的关键。</p>
<p>当我们使用mid对数组一分为二之后，之后的第一步操作很容易想到，看mid是否与mid - 1或者mid + 1相等，如果都不相等，那么显然就是直接返回nums[mid]，同时还要注意一下边界情况，以防数组边界溢出。那么当确定mid不是唯一元素之后，应该如何缩小搜索区间？这时候就要用到<strong><em>其他元素都会出现两次</em></strong> 这个信息，通过判定左右区间的元素数量是<strong><em>奇数还是偶数</em></strong> 来判断唯一元素的位置。同时还要考虑<strong><em>与 mid相等的值，到底是mid - 1，还是mid + 1</em></strong>。使用变量isLeft来记录与mid相等的值，true表示nums[mid - 1],false表示nums[mid + 1]。使用变量leftEven来记录左边区间的数量奇偶情况，true表示偶数，false表示奇数。</p>
<p>①相等的值是nums[mid - 1]，左区间数量是偶数，即 <code>isLeft == true &amp;&amp; leftEven == true</code></p>
<p>左边数量是偶数，但左边有一个与mid相同的值，去掉这个，剩下的是奇数，显然，唯一值就在左边的区间。</p>
<p>②相等的值是nums[mid + 1]，左区间数量是奇数，即<code>isLeft == false &amp;&amp; leftEven == false</code></p>
<p>左边数量是奇数，并且与mid相同的值在右边，说明唯一值就在左边的区间。</p>
<p>③其他情况</p>
<p>不在左区间，又不是mid，当然就在右区间。</p>
<p>除此之外，left跟right的变化也不是简单的<code>left = mid - 1</code>或者<code>right = mid + 1</code>，比如情况①，如果是简单的<code>right = mid - 1</code>，会出现什么错误？这时候的搜索区间是[left, mid - 1]，而右区间已经被我们丢弃掉，此时的nums[mid - 1]，显然不是正确答案，但在这一块区间里，它只有一个值，这会成为后续二分的一个误导项。所以正确的修改搜索区间的方法应该是：当要搜索左区间，并且与mid相等的值在左边（即mid - 1），那么此时应该是<code>right = mid - 2</code>，而与mid相等的值在右边才是<code>right = mid - 1</code>。右区间同理，不再赘述。</p>
<p><strong><em>代码</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || mid == nums.length - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            <span class="keyword">boolean</span> isLeft = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] == nums[mid])</span><br><span class="line">                isLeft = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid + <span class="number">1</span>] == nums[mid])</span><br><span class="line">                isLeft = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            <span class="keyword">boolean</span> leftEven = (mid - left) % <span class="number">2</span> == <span class="number">0</span>;    <span class="comment">// 不考虑mid</span></span><br><span class="line">            <span class="keyword">if</span> (isLeft &amp;&amp; leftEven)</span><br><span class="line">                right = mid - <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!isLeft &amp;&amp; !leftEven)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isLeft)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="七-LeetCode-153-寻找旋转排序数组中的最小数字"><a href="#七-LeetCode-153-寻找旋转排序数组中的最小数字" class="headerlink" title="七.  LeetCode 153. 寻找旋转排序数组中的最小数字"></a>七.  LeetCode 153. 寻找旋转排序数组中的最小数字</h3><p><strong><em>题目描述</em></strong>：假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">力扣</a></p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p><strong><em>分析</em></strong>：虽然旋转了一次之后，数组不再是有序数组，但是还是具备相当多的”有序特征“，所以依然可以使用二分法来快速寻找数字。关键是mid元素应该如何判断进而改变搜索区间？mid元素跟谁比较，left还是right？</p>
<p>我们先尝试将nums[mid]与nums[left]比较，原本的有序数组中，nums[left] &lt; nums[mid]，因此如果旋转后依然如此，也不能看出任何特别（到底是nums[left]还是nums[mid + X]更小？无法判断），因此这个方案pass。</p>
<p>接着尝试将nums[mid]与nums[right]比较，原本的有序数组中，nums[mid] &lt; nums[right]，所以如果旋转后依然如此应该怎么办？答案是直接把区间向左缩小，同时要保留这个mid，因为有可能它就是最小数，即<code>right = mid</code>。所以即使跟原来的情况相同，依然能缩小区间，合理可行。（而与nums[left]比较，无法对区间优化）</p>
<p>然后如果旋转后的情况是<code>nums[mid] &gt; nums[right]</code>，此时应该怎么办？显然，这时候右区间就是存在被旋转的数字，而最小数字一定在被旋转的部分上，所以这时候就可以把区间向右逼近，并且毫无疑问地，nums[mid]不是最小数，所以此时的操作应该是<code>left = mid + 1</code>。如此反复，区间越来越小，同时最小的数字并不会被排除在搜索区间之外（因为<code>right = mid</code>，我们没有把比较小的数排除掉）。直到最后，区间留下的最后一个数就是最小数，也就是搜索区间此时为[left, right],并且left == right，所以循环结束条件为<code>left &lt; right</code>。</p>
<p><strong><em>代码</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];      <span class="comment">// left == right</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="八-LeetCode-33-搜索旋转排序数组"><a href="#八-LeetCode-33-搜索旋转排序数组" class="headerlink" title="八.  LeetCode 33. 搜索旋转排序数组"></a>八.  LeetCode 33. 搜索旋转排序数组</h3><hr>
<p><strong><em>题目描述</em></strong>：假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener"><strong><em>题目链接</em></strong></a></p>
<p><strong><em>分析</em></strong>：跟上一题一样，虽然不完全是完整的有序数组，但也可以使用二分法来进行搜索。先判断nums[mid]是否就是target，然后再进行讨论，如果<code>nums[mid] &lt; target</code>，正常情况下，可以直接向右区间进行逼近，但这时候其实还有一种情况，这个nums[mid]是旋转部分，这时候target有可能在左，也有可能在右，即下一个搜索区间可能是[left, mid - 1]，也可能是[mid + 1, right]。而当<code>nums[mid] &gt; target</code>，同样也是两个区间都有可能，即[left, mid - 1]或者[mid + 1, right]。可以看到下面的第一版代码，我还考虑什么情况下一定是在其中一个区间，不用考虑另一个区间。但由于二分法的效率非常高，所以直接一刀切也可以，代码也会变得非常简便。</p>
<p><strong><em>代码</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, target, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) </span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; nums[left])</span><br><span class="line">                    left = mid + <span class="number">1</span>;     <span class="comment">// 右区间</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> Math.max(helper(nums, target, left, mid - <span class="number">1</span>),</span><br><span class="line">                                    helper(nums, target, mid + <span class="number">1</span>, right));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> Math.max(helper(nums, target, left, mid - <span class="number">1</span>),</span><br><span class="line">                                helper(nums, target, mid + <span class="number">1</span>, right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>简化后的代码</em></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, target, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) </span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">return</span> Math.max(helper(nums, target, left, mid - <span class="number">1</span>),</span><br><span class="line">                            helper(nums, target, mid + <span class="number">1</span>, right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="九-总结"><a href="#九-总结" class="headerlink" title="九. 总结"></a>九. 总结</h3><p>​         二分法一开始会觉得很难，但只要你仔细地推导完上面的题目，那么基本就能理解二分法的要义。二分法的关键是<strong><em>搜索区间</em></strong>，而有时候初始的赋值可能是nums.length - 1，也可能是nums.length，这会导致区间到底是开区间还是闭区间，实际上只要明确<strong><em>搜索区间的含义</em></strong> 即可。至于后面是否+1，-1，只要你清晰是否要排除mid，开区间还是闭区间，导致的<strong><em>下一个搜索区间</em></strong> 到底是什么，这样就能明确是否要±1，而不是混乱不清。循环结束条件也不是一成不变的，并不是说开区间就没有等号，而闭区间就有等号，还是要具体题目具体分析。而最后的返回值，一开始可能会觉得很麻烦，实际上<strong><em>搜索区间的变化</em></strong> 是有迹可循的，前面可能是left跟right都会变化，而在某一次循环，就会导致left或者right发生变化，这时候的mid基本就与answer有关，而后续都是另一个变量一直变化，无限缩小区间，直到循环结束。然后根据那次<strong><em>某变量最后的变化</em></strong> ，得出answer与left / right的关系，那就是最后的结果。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>interview</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-贪心算法</title>
    <url>/LeetCode-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h3 id="一-贪心算法"><a href="#一-贪心算法" class="headerlink" title="一. 贪心算法"></a>一. 贪心算法</h3><p>​          贪心算法的实质就是，直接解决问题太难，于是寻找一个看起来比较tricky的解法，核心思想是先寻找<strong><em>局部最优解</em></strong>，进而整合起来的结果仍然是<strong><em>整体最优解</em></strong>。因为寻找局部最优解的过程，可以忽略很多情况条件（因为它考虑的是局部，而非整体），因此才显得比较“贪心”。但要注意的是，每一个地方都是局部最优解，最终的全局并不一定是整体的最优解，所以贪心算法只有在特定的题目才可以使用。</p>
<p>​          那么什么题目才可以使用贪心算法？自然是具体问题具体分析。贪心算法有点像直觉上的不成形算法，关键在于这个局部最优解最后是否能演变成整体最优解，一般可以通过反证法来判断是否能得到整体最优解。接下来，我们通过几道LeetCode的题目来进行操作。</p>
<a id="more"></a>



<h3 id="二-LeetCode-455-分配饼干"><a href="#二-LeetCode-455-分配饼干" class="headerlink" title="二. LeetCode 455. 分配饼干"></a>二. LeetCode 455. 分配饼干</h3><p>455.Assign Cookies (Easy)</p>
<p><a href="https://leetcode.com/problems/assign-cookies/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/assign-cookies/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: grid[1,3], size[1,2,4]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p><strong><em>题目描述</em></strong>：每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p>
<p><strong><em>分析</em></strong>：一个饼干只能分配给一个小孩子。这道题，直觉上的思路：优先分配给满足度最小的孩子，并且给一个小孩子分配饼干的时候，应该分配尽量小但又能满足那个小孩子的饼干，留着更大的饼干用于给满足度比较大的孩子。这个思想应该很好理解，其实这就已经是<strong><em>贪心算法</em></strong>，为什么？因为优先给当前满足度最小的孩子分配尽量小的饼干，这就是一个<strong><em>局部最优解</em></strong> 的情况。那么，虽然直觉上是认为这样就是正确答案，也就是这个局部最优解，最后会演化成<strong><em>整体最优解</em></strong>，但如果要专业的证明，如何证明？答案就是开头所说的，<strong><em>反证法</em></strong>。</p>
<p><strong><em>证明</em></strong>：假设在某次选择中，我们的贪心策略选择：给当前满足度最小的孩子分配第m个饼干，并且第m个饼干是可以满足该孩子的最小饼干。假设这并不一定是全局最优解，也就是存在一种更优的策略，可以给该孩子分配第n个饼干，并且m &lt; n。我们可以发现，经过这一轮的分配，贪心策略可以剩下一个饼干n，而假设的更优策略，留下的是饼干m。又由于m &lt; n，所以在后续的分配中，贪心策略一定能满足更多的孩子。所以不存在比贪心策略更优的策略，即贪心策略是最优策略。</p>
<p><strong><em>总结</em></strong>：贪心算法看起来确实就是一种直觉上的算法，根据具体问题分析，得出局部最优解，进而获得全局最优解。所以后续的题目直接忽略证明，讲述贪心算法的思路即可。(这道题还用到了双指针)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 优先给满足度最小的分配尽量小的饼干，局部最优达到全局最优</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="keyword">int</span> gIndex = <span class="number">0</span>, sIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (gIndex &lt; g.length &amp;&amp; sIndex &lt; s.length) </span><br><span class="line">            <span class="keyword">if</span> (g[gIndex] &lt;= s[sIndex++])</span><br><span class="line">                gIndex++;</span><br><span class="line">        <span class="keyword">return</span> gIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三-LeetCode-435-不重叠的区间个数"><a href="#三-LeetCode-435-不重叠的区间个数" class="headerlink" title="三. LeetCode 435. 不重叠的区间个数"></a>三. LeetCode 435. 不重叠的区间个数</h3><p>\435. Non-overlapping Intervals (Medium)</p>
<p><a href="https://leetcode.com/problems/non-overlapping-intervals/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [ [1,2], [1,2], [1,2] ]</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [ [1,2], [2,3] ]</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: You don&#39;t need to remove any of the intervals since they&#39;re already non-overlapping.</span><br></pre></td></tr></table></figure>

<p><strong><em>题目描述</em></strong>：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p><strong><em>分析</em></strong>：给数组排序，然后从左到右逐个选择，如果重叠（冲突）就去掉。记录选择的区间个数，最后得到的就是结果。那么这个排序的逻辑是什么？答案是：根据右区间进行排序。试想存在两个区间，[1, 2], [1, 3]，应该选择哪个？显然是[1, 2]，因为它右区间更小，进而后面能容纳的范围也更大。那么左区间不需要考虑吗？虽然左区间比自己的右区间更小，但并不一定比其他的左区间更小，比如[0, 2], [1, 3]。这时候我们可能会钻牛角尖，这种情况肯定是选[0, 2]，但如果前面还有一个区间怎么样？比如： [-2, 1], [0, 2], [1, 3]。实际上“如果前面还有一个区间”，这种假设是不可能存在的，因为我们是<strong><em>从左到右</em></strong> 进行选择的。所以不存在我们先选取了[0, 2]，再因为前面还有区间而导致出错的情况。我们只会先选择[-2, 1]，然后读到[0, 2]的时候，发现冲突，继续向前。读到[1, 3]，没有冲突，于是最后的答案就是2。所以这种排序得到的确实是最优解。</p>
<p><strong><em>总结</em></strong>：贪心算法最关键的是寻找局部最优解，并且要确保这是否真的为局部最优解。在验证的过程中，我们会使用测试用例，但不能忘记自己算法的规则（比如上面的从左到右，依次选择右区间最小的元素，如果忽略了从左到右，那么可能会在一些测试用例上浪费时间）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 排序, 取右区间最小的区间，可以确保后续能容纳更多区间</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; prev) &#123;</span><br><span class="line">                <span class="comment">// 这些不符合的，重叠的，都需要去掉</span></span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = intervals[i][<span class="number">1</span>];		<span class="comment">// 记录当前的最右区间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四-LeetCode-452-投飞镖刺破气球"><a href="#四-LeetCode-452-投飞镖刺破气球" class="headerlink" title="四. LeetCode 452. 投飞镖刺破气球"></a>四. LeetCode 452. 投飞镖刺破气球</h3><p>452.Minimum Number of Arrows to Burst Balloons (Medium)</p>
<p><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong><em>题目描述</em></strong>：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。</p>
<p><strong><em>分析</em></strong>：其实跟上一题很相似，就是选择一定数量的数字，使得这些数字一起覆盖上面的区间。同理，进行排序，从左到右进行覆盖（也就是题目中的投飞镖刺气球）。同样是根据右区间排序，然后从左到右选择右区间的位置进行投飞镖。比如区间[1, 6]，到底是在1~6哪个位置投最合适？答案是6，也就是右区间，因为更容易同时刺中后面的气球。如果你又要问“如果前面还有一个[3,4]的区间怎么办，建议回看上一题。。）所以这一题的思路跟上一题是一模一样的，只是处理的逻辑稍微有一点区别。</p>
<p><strong><em>总结</em></strong>： 跟上一题一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current &gt;= points[i][<span class="number">0</span>] &amp;&amp; current &lt;= points[i][<span class="number">1</span>])	<span class="comment">// 同时刺破的气球</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res++;</span><br><span class="line">            current = points[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="五-LeetCode-406-根据身高和序号重组队列"><a href="#五-LeetCode-406-根据身高和序号重组队列" class="headerlink" title="五. LeetCode 406. 根据身高和序号重组队列"></a>五. LeetCode 406. 根据身高和序号重组队列</h3><p>406.Queue Reconstruction by Height(Medium)</p>
<p><a href="https://leetcode.com/problems/queue-reconstruction-by-height/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br></pre></td></tr></table></figure>

<p><strong><em>题目描述</em></strong>：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。</p>
<p><strong><em>分析</em></strong>：首先，毫无疑问重组的队列是一个一个身高insert进去的，不可能一下全部丢进去，然后再重排。如果重排，那就是暴力法，把所有情况都列出来，毫无疑问，时间复杂度很高，而且不推荐。那么关键就是这个依次添加的每一个学生，如何不受后面的学生影响，或者说，后面的学生如何insert到恰当的位置？这就是每一步都寻求的最优解，也就是局部最优，所以也属于贪心算法的范畴。思考了之后，最不容易受影响的学生，就是最高的学生，因为比它们矮的学生，无论怎么排，都不会影响第二个数字（排在前面比它们高或者一样高的学生数量）。所以排序的第一个规则，h越大，就排在越前。那么如果h相同的情况应该怎么处理？答案是，先考虑k较小的情况，只要把该h，放在队列里的第k个位置，那么前面的学生就不会受到影响。拿这里举例：[7, 0], [6, 1], [7, 1]。[7, 0]先入队，放在队列的第0个位置，此时队列为{7}。然后[7, 1]进队，放在队列的第1个位置，此时队列为{7，7}。然后关键的[6, 1]来了，应该放在哪个位置？就是放在队列的第1个位置，这样队列为{7，6，7}。为什么是第0个位置？看起来很巧妙，很难思考，其实也是局部最优的原因。因为前面的放法都是局部最优，所以后面这样加的位置也是正确解。比如前面放置[7, 0]和[7, 1]的时候，不会怀疑这个放法，因为它前面也是局部最优（初始化当然是最优，只加一个的时候当然也是最优）。所以，关键是：身高h降序，个数k升序。</p>
<p><strong><em>总结</em></strong>：贪心算法的核心是寻找局部最优，并非找到合适的排序就已经结束，以哪种顺序insert，这些都是要考虑的方面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        <span class="comment">// 排序, h降序, k升序, 使得后续的insert不会改变先前的相对位置</span></span><br><span class="line">        Arrays.sort(people, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = o2[<span class="number">0</span>] - o1[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (tmp != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> tmp;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 按顺序insert, 每一个都insert到当前people[i][1]的位置</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] p: people)</span><br><span class="line">            list.add(p[<span class="number">1</span>], p);</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[list.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六-LeetCode-121-买卖股票最大的利益"><a href="#六-LeetCode-121-买卖股票最大的利益" class="headerlink" title="六.  LeetCode 121. 买卖股票最大的利益"></a>六.  LeetCode 121. 买卖股票最大的利益</h3><p>121.Best Time to Buy and Sell Stock (Easy)</p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">力扣</a></p>
<p><strong><em>题目描述</em></strong>：一次股票交易包含买入和卖出，只进行一次交易，求最大收益。</p>
<p><strong><em>分析</em></strong>：假设我们要在第i天出售，此时的最大利润是什么？是在前面(i - 1)天寻找一个最小值，然后用prices[i]减去第i天之前的最小值。这就是每一天的最优解（每一天出售时候的最大利益），全部取max，就是答案。</p>
<p><strong><em>总结</em></strong>：一开始觉得这题跟贪心算法没联系，其实这题再翻译一下就是，在n天内，可以买卖股票，只进行一次交易，那么最大的利益是多少？里面隐含了一个条件，n天之内。实际上，我们只需要求出每一天出售时候的最大利益，最后就能通过每一天出售的最大利益，求得n天之内买卖的最大利益，也就是局部最优到全局最优。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];    <span class="comment">// 记录当前的min</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = prices[i] - min;  <span class="comment">// 今天卖, 与min的差价</span></span><br><span class="line">            <span class="keyword">if</span> (tmp &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res &gt;= tmp ? res : tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="七-LeetCode-122-买卖股票的最大利益Ⅱ"><a href="#七-LeetCode-122-买卖股票的最大利益Ⅱ" class="headerlink" title="七. LeetCode 122.买卖股票的最大利益Ⅱ"></a>七. LeetCode 122.买卖股票的最大利益Ⅱ</h3><p>122.Best Time to Buy and Sell Stock II (Easy)</p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<p><strong><em>题目描述</em></strong>：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易。</p>
<p><strong><em>分析</em></strong>：因为可以多次交易，所以上一题的方法无效。这道题很容易让人想太多，比如到底应该什么时候买，什么时候卖（<del>仿佛就回到了现实的纠结当中</del>）。其实有一个最关键的点：对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。正确的做法应该是，第一天的时候买进a，第四天的时候以d的价格卖出去，所以中间的b和c都是干扰项，这么想就会把问题复杂化。而实际上，<strong><em>d - a = (d - c) + (c - b) + (b - a)</em></strong>，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。如果是c &lt;= a &lt;= b &lt;= d应该怎么办？同样的： <strong><em>d - a  = (d - b) + ( b - a)</em></strong>。一天只能买，或者卖，其实这就是干扰项，你第二天可以以b的价格卖掉，此时利润为（b - a），就当做是，你又以b的价格拿回来了，随时可以出售（<del>当然这个现实做不到</del>）。当后面没有比b更好的情况，你的利润就是(b - a)，如果有更好的，那么就是继续上面的<strong><em>d - a = (d - c) + (c - b) + (b - a)</em></strong>。所以核心的关键是，只要prices[i] &gt; prices[i - 1]，这一部分的利润就可以赚取。这就是这道题的局部最优。</p>
<p><strong><em>总结</em></strong>：局部最优解并不容易想，但只要想出来，并且能达到整体最优，那么贪心算法很把问题迅速解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">                profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="八-LeetCode-605-种植花朵"><a href="#八-LeetCode-605-种植花朵" class="headerlink" title="八.  LeetCode 605. 种植花朵"></a>八.  LeetCode 605. 种植花朵</h3><p>605.Can Place Flowers (Easy)</p>
<p><a href="https://leetcode.com/problems/can-place-flowers/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/can-place-flowers/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>

<p><strong><em>题目描述</em></strong>：flowerbed 数组中 1 表示已经种下了花朵。花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。</p>
<p><strong><em>分析</em></strong>：这道题很显然，只要从左到右种，那么就一定是最优（只要当前的格子符合要求，就可以种）。应该很直观吧，不会有人觉得在某些特定的情况，左边不能种，应该种在稍右的地方吧。这个用反证法也很好证明，过程估计就跟第一题的证明一样，种在最左，右边能遗留的空间会更多。</p>
<p><strong><em>总结</em></strong>：即使不知道这是贪心算法，也知道是这么回事，但确实这也是局部最优到整体最优的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; flowerbed.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">boolean</span> flag1 = (left &lt; <span class="number">0</span>) || flowerbed[left] == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> flag2 = (right == flowerbed.length) || flowerbed[right] == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag1 &amp;&amp; flag2) &#123;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="九-总结"><a href="#九-总结" class="headerlink" title="九. 总结"></a>九. 总结</h3><p>​          只要是找局部最优解，进而演变成整体最优解，那么就是贪心算法。但是贪心算法的适用性其实并不广，所以并不能频繁考虑。可是贪心算法比较像直观上思考的算法，所以只要直观上觉得可行，就该考虑这是不是局部最优，是不是属于贪心算法，进而再进行解题。值得注意的是，局部最优解虽然暂时不用考虑整体，但有些情况下也并不容易找到，如果当前的局部解并不是最优解，最后的结果自然也是错的。总而言之，这是一个在特定情况下很好用的方法。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>interview</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-双指针</title>
    <url>/LeetCode-%E5%8F%8C%E6%8C%87%E9%92%88.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.  前言"></a>一.  前言</h3><p>​        LeetCode的题目还是挺多的，但漫无目的地刷题其实意义不大，更多的还是需要在适量的题目之后，进行归纳总结，比如这篇文章就是对“双指针”相关的题目进行归纳总结。</p>
<p>​        参考：①<a href="https://github.com/CyC2018/CS-Notes/tree/master/notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/tree/master/notes</a></p>
<p>​                    ②<a href="https://leetcode-cn.com/circle/article/GMopsy/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/GMopsy/</a></p>
<a id="more"></a>

<h3 id="二-什么是双指针？"><a href="#二-什么是双指针？" class="headerlink" title="二. 什么是双指针？"></a>二. 什么是双指针？</h3><p>​        在Java里并不像C++那样具备完全的“pointer”功能，但实际上把它当作index就差不多了。采用最简单的暴力法，通常都只有一个指针（想想那两层甚至是三层的for循环，实际上就只有一个指针指向一个确切的数据）。有的时候只要多增加一个变量（指针），那么就能很好的优化算法效率。</p>
<p>​        双指针通常有两种。①左右指针。通常用于数组，字符串的问题，比如二分查找，查找回文串，子序列等等。②快慢指针。通常用于链表的问题，使用快慢指针有时候可以巧妙地解决很多链表问题。</p>
<p>​        理论应该很好理解，尤其只要在leetcode上刷过一定数量题目的朋友都应该大致了解了。那么现在就拿几道实际的题目进行操作。</p>
<h3 id="三-LeetCode-167-有序数组的Two-Sum"><a href="#三-LeetCode-167-有序数组的Two-Sum" class="headerlink" title="三. LeetCode 167. 有序数组的Two Sum"></a>三. LeetCode 167. 有序数组的Two Sum</h3><p><strong><em>167. Two Sum II - Input array is sorted (Easy)</em></strong></p>
<p><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: numbers&#x3D;&#123;2, 7, 11, 15&#125;, target&#x3D;9</span><br><span class="line">Output: index1&#x3D;1, index2&#x3D;2</span><br></pre></td></tr></table></figure>

<p><strong>题目描述</strong>：在有序数组中找出两个数，使它们的和为 target。</p>
<p><strong>分析</strong>: 这里需要注意的是，题目的一个条件是“有序数组”，一般这种<strong><em>有序的数组</em></strong>，都可以采用双指针来进行解决。</p>
<p>使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
<ul>
<li>如果两个指针指向元素的和 sum == target，那么得到要求的结果；</li>
<li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li>
<li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li>
</ul>
<p>数组中的元素最多遍历一次，时间复杂度为 <strong><em>O(N)</em></strong>。只使用了两个额外变量，空间复杂度为 <strong><em>O(1)</em></strong>。</p>
<p><strong>总结</strong>：这题没什么难度，即使直接暴力法也能解决，或者使用额外的哈希表作为存储空间都可以，双指针也不难想到。下面是双指针的示意图：</p>
<p><img src="https://camo.githubusercontent.com/98b3f53b56644b038cddd17fb1f6b4d5d1546989/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34333763623534632d353937302d346261392d623265662d3235343166376436633831652e676966" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span> (tmp == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmp &lt; target)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四-LeetCode-633-两数的平方和"><a href="#四-LeetCode-633-两数的平方和" class="headerlink" title="四. LeetCode 633. 两数的平方和"></a>四. LeetCode 633. 两数的平方和</h3><p><strong><em>633.Sum of Square Numbers (Easy)</em></strong></p>
<p><a href="https://leetcode.com/problems/sum-of-square-numbers/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: True</span><br><span class="line">Explanation: 1 * 1 + 2 * 2 &#x3D; 5</span><br></pre></td></tr></table></figure>

<p><strong>题目描述</strong>：判断一个非负整数是否为两个整数的平方和。</p>
<p><strong>分析</strong>：可以看成是在元素为 0~target 的有序数组中查找两个数，使得这两个数的平方和为 target，如果能找到，则返回 true，表示 target 是两个整数的平方和。</p>
<p>本题和 167. Two Sum II - Input array is sorted 类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。本题同样可以使用双指针得到两个数，使其平方和为 target。</p>
<p>本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 02 + x2 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。</p>
<p>因为最多只需要遍历一次 0~sqrt(target)，所以时间复杂度为 <strong><em>O(sqrt(target))</em></strong>。又因为只使用了两个额外的变量，因此空间复杂度为 <strong><em>O(1)</em></strong>。</p>
<p><strong>总结</strong>：像这种可行解是全体整数的时候（如果严谨一点应该是sqrt(Integer.MAX_VALUE))，暴力法显然会超时，哪怕你提前把上界限定为sqrt(n),可是在暴力法的时间复杂度为O(n^2)的情况下，需要的时间依然很长导致超时（n可能会很大）。这时候第一想法可能会是使用额外的空间，使用数据结构来存储，确实能比暴力法优化很多。如果是使用List，那么就需要用到contains方法，也就是O(n)，所以这时候的效率提升并不明显，仍然会超时。而如果使用Set，Set的contains方法使用的是哈希表，理论上是O(1)，所以时间复杂度为O(sqrt(target)) * O(1)。这时候可以AC，并不会超时，但是随着target比较大的时候，哈希表的时间不能完全忽略，所以效率还是比双指针低。</p>
<p>哈希表方法：    77ms</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> temp = (<span class="keyword">int</span>)Math.floor(Math.sqrt(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= temp; i++) </span><br><span class="line">            set.add(i * i);</span><br><span class="line">        Iterator it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(c - (<span class="keyword">int</span>)it.next()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针方法：    2ms</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = (<span class="keyword">int</span>)Math.sqrt(c);</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = left * left + right * right;</span><br><span class="line">            <span class="keyword">if</span> (tmp == c)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmp &lt; c)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="五-LeetCode-345-反转字符串中的元音字母"><a href="#五-LeetCode-345-反转字符串中的元音字母" class="headerlink" title="五.  LeetCode 345. 反转字符串中的元音字母"></a>五.  LeetCode 345. 反转字符串中的元音字母</h3><p><strong><em>345.Reverse Vowels of a String (Easy)</em></strong></p>
<p><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given s &#x3D; &quot;leetcode&quot;, return &quot;leotcede&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>题目描述</strong>：把字符串里的所有元音字符倒转，即第一个元音字符与最后一个倒转，第二个与倒数第二个倒转。元音字母包括大小写，所以不能只考虑小写。</p>
<p><strong>分析</strong>: 使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。</p>
<p>为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。</p>
<ul>
<li>时间复杂度为 <strong><em>O(N)</em></strong>：只需要遍历所有元素一次</li>
<li>空间复杂度 <strong><em>O(1)</em></strong>：只需要使用两个额外变量</li>
</ul>
<p><strong>总结</strong>：最直观的方法，应该是直接创建一个List，把所有元音字符的indexs存储起来，然后逐个反转。经过测试，效率跟双指针方法差不多。但是这里要明白，双指针并非只能用于数组链表，对于字符串也是很有效的工具，因为字符串可以很容易地转换成字符数组。而且双指针还有一个优势是，消耗的空间较少。如果要存储indexs，需要一个额外的List，而双指针只需要两个简单的变量。（而这道题的HashSet，任何方法都要用到）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(</span><br><span class="line">            Arrays.asList(<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];	<span class="comment">// 使用char数组存储临时数据</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(l))</span><br><span class="line">                result[left++] = l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!set.contains(r))</span><br><span class="line">                result[right--] = r;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result[left++] = r;</span><br><span class="line">                result[right--] = l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六-LeetCode-680-回文字符串"><a href="#六-LeetCode-680-回文字符串" class="headerlink" title="六. LeetCode 680. 回文字符串"></a>六. LeetCode 680. 回文字符串</h3><p> <strong><em>680.Valid Palindrome II (Easy)</em></strong></p>
<p><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/valid-palindrome-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;abca&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: You could delete the character &#39;c&#39;.</span><br></pre></td></tr></table></figure>

<p><strong>题目描述</strong>：给定一个非空字符串 s，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p>
<p><strong>分析</strong>：所谓的回文字符串，是指具有左右对称特点的字符串，例如 “abcba” 就是一个回文字符串。</p>
<p>使用双指针可以很容易判断一个字符串是否是回文字符串：令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。</p>
<p>本题的关键是处理删除一个字符。在使用双指针遍历字符串时，如果出现两个指针指向的字符不相等的情况，我们就试着删除一个字符，再判断删除完之后的字符串是否是回文字符串。</p>
<p>在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。</p>
<p>在试着删除字符时，我们<strong><em>既可以删除左指针指向的字符，也可以删除右指针指向的字符</em></strong>。</p>
<p><strong>总结</strong>：接着上一题，双指针在字符串题型里很有效，而对于回文这个定义，双指针更是非常适合用于检测回文。因而这道理最应该直接想到的方法便是双指针法。除此之外，这种要考虑不止1种情况的情形（删左/删右），最好就直接新建一个helper方法，直接同时调用，将结果取或即可。如果直接用for循环，那么还得慢慢考虑如果改变left，right指针值的变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">            <span class="keyword">char</span> r= s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (l != r)</span><br><span class="line">                <span class="keyword">return</span> helper(s, left + <span class="number">1</span>, right) || helper(s, left, right - <span class="number">1</span>);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">char</span> l = s.charAt(left++);</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right--);</span><br><span class="line">            <span class="keyword">if</span> (l != r)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="七-LeetCode-524-最长子序列"><a href="#七-LeetCode-524-最长子序列" class="headerlink" title="七. LeetCode 524. 最长子序列"></a>七. LeetCode 524. 最长子序列</h3><p><strong><em>524.Longest Word in Dictionary through Deleting (Medium)</em></strong></p>
<p><a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;abpcplea&quot;, d &#x3D; [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;apple&quot;</span><br></pre></td></tr></table></figure>

<p><strong>题目描述</strong>：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。</p>
<p><strong>分析</strong>：通过删除字符串 s 中的一个字符能得到字符串 t，可以认为 t 是 s 的子序列，我们可以使用双指针来判断一个字符串是否为另一个字符串的子序列。</p>
<p><strong>总结</strong>：除了回文串，字符串子序列的相关问题也很适合使用双指针解决。（不一定要左右指针，这里用的是同向指针，当两个指针指向的字符相同，则同时移动两个指针。如果不相同，则移动指向s的指针，这样可以检测t是否为s的子序列subsequence。时间复杂度为<strong><em>O(n)</em></strong>,空间复杂度为<strong><em>O(1)</em></strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">        String longestWord = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str: d) &#123;</span><br><span class="line">            <span class="keyword">int</span> longLength = longestWord.length();</span><br><span class="line">            <span class="keyword">int</span> currentLength = str.length();</span><br><span class="line">            <span class="keyword">if</span> (longLength &gt; currentLength || (longLength == currentLength &amp;&amp;</span><br><span class="line">                longestWord.compareTo(str) &lt;= <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">continue</span>;	<span class="comment">// 不符合题目要找的最长要求，直接pass</span></span><br><span class="line">            <span class="keyword">if</span> (isSequence(s, str))</span><br><span class="line">                longestWord = str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSequence</span><span class="params">(String s, String current)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = s.length() - <span class="number">1</span>, j = current.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;			<span class="comment">// 双指针检测是否为subsequence</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == current.charAt(j)) </span><br><span class="line">                j--;			<span class="comment">// 二者相同，j指针移动</span></span><br><span class="line">            i--;				<span class="comment">// 不管相同与否，i指针都要向前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j &lt; <span class="number">0</span>;		<span class="comment">// 如果i，j从0开始，这里的判定就是 j == current.length()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="八-LeetCode-88-归并两个有序数组"><a href="#八-LeetCode-88-归并两个有序数组" class="headerlink" title="八. LeetCode 88. 归并两个有序数组"></a>八. LeetCode 88. 归并两个有序数组</h3><p><strong><em>88.Merge Sorted Array (Easy)</em></strong></p>
<p><a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>

<p><strong>题目描述</strong>：把归并结果存到第一个数组上。</p>
<p><strong>分析</strong>：这道题的难点在于，不适用额外的存储空间，直接存储到nums1数组上。虽然可以直接偷懒，偏要用额外空间，那么题目也能很快完成，只是这样失去了很多意义，毕竟如果只为了AC，直接一句System.arraycopy，然后Arrays.sort就可以AC了，但这又何必。这道题的核心思想首先是归并，归并实际上就是对两个数组同时操作，也就是使用双指针操作。同时关键又是有序数组，更没有理由放弃双指针了。值得注意的是，需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。(从m + n - 1开始存放数据，这样刚好可以存放m + n个数据，避免了多余的0影响了结果。虽然LeetCode的所有测试用例都没有考虑0数量大于n的情况，默认等于n，但显然题目并没有这个意思。总而言之，严谨一点~)</p>
<p><strong>总结</strong>：归并，有序数组，双指针很合适。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从尾部开始进行遍历即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span> || index2 &gt;= <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">if</span> (index1 &lt; <span class="number">0</span>) </span><br><span class="line">                nums1[current--] = nums2[index2--];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (index2 &lt; <span class="number">0</span>) </span><br><span class="line">                nums1[current--] = nums1[index1--];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt;= nums2[index2]) </span><br><span class="line">                nums1[current--] = nums1[index1--];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums1[current--] = nums2[index2--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="九-LeetCode-141-判定链表中是否含有环"><a href="#九-LeetCode-141-判定链表中是否含有环" class="headerlink" title="九. LeetCode 141. 判定链表中是否含有环"></a>九. LeetCode 141. 判定链表中是否含有环</h3><p><strong><em>141.Linked List Cycle (Easy)</em></strong></p>
<p><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">力扣</a></p>
<p><strong>题目描述</strong>：RT</p>
<p><strong>分析</strong>：直接循环查看是否到达null，肯定不行，因为会超时。当然，如果你能解决传说中的停机问题，你可以试试。这道题应该是大部分人第一次接触到”双指针“概念的题，快慢指针。使用双指针，一个slow指针每次移动一个节点，一个fast指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。证明应该很直观，如果存在环，两个指针最后一定会在环里同时移动，一个快一个慢，最后一定会在某个时刻二者相遇。如果没有环，slow指针永远不会追上fast指针，并且fast指针会到达end，结束循环。</p>
<p><strong>总结</strong>：链表的快慢指针，也是巧妙解决链表问题的好办法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123; <span class="comment">// fast只要不为null, slow一定不为null</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="十-LeetCode-142-判定链表中是否含有环，如果有，返回环的入口"><a href="#十-LeetCode-142-判定链表中是否含有环，如果有，返回环的入口" class="headerlink" title="十.  LeetCode 142. 判定链表中是否含有环，如果有，返回环的入口"></a>十.  LeetCode 142. 判定链表中是否含有环，如果有，返回环的入口</h3><p><strong><em>142.Linked List Cycle Ⅱ (Medium)</em></strong></p>
<p><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">力扣</a></p>
<p><strong>题目描述</strong>：RT</p>
<p><strong>分析</strong>：这题仍然是用快慢双指针解决。只是当我们判断二者相遇的时候，如何获得环的入口？答案是，把其中一个指针放到head处，然后两个指针以同样的速度（每次行走1个单位）前进。当它们第二次相遇的时候，所在的地方就是环的入口。因为这样并不直观，因此我们可以给出一个证明。</p>
<p><strong>证明</strong>：假设链表在进入环之前的长度为<strong><em>a</em></strong>，环的长度为<strong><em>b</em></strong>。（<strong><em>a</em></strong>，<strong><em>b</em></strong>均为未知数）</p>
<p>假设当<strong><em>slow指针</em></strong> 走了<strong><em>s</em></strong> 距离的时候，二者<strong><em>相遇</em></strong>，此时显然可得：</p>
<p><strong><em>fast指针</em></strong> 走的距离：<strong><em>f = 2s</em></strong></p>
<p>又易知，<strong><em>fast指针</em></strong> 肯定比<strong><em>slow指针</em></strong> 多走了<strong><em>n圈环</em></strong> 的距离，所以可得： <strong><em>f = s + nb</em></strong>    （<strong><em>n</em></strong> 为正整数）</p>
<p>两式结合可得： <strong><em>s = nb</em></strong></p>
<p>同时由定义可得，当指针处于<strong><em>环入口</em></strong>，那么此时指针一定走了 <strong><em>a + mb</em></strong> 的距离 （<strong><em>m</em></strong>为非负整数），所以现在<strong><em>slow指针</em></strong> 已经走了<strong><em>nb</em></strong> 的距离，只要它再走<strong><em>a</em></strong> 距离，便能到达环入口。但在a是未知数的情况下，如何确定<strong><em>slow</em></strong> 再走<strong><em>a</em></strong> 距离？</p>
<p>答案是：<code>将fast指针重置在head处，因为head距离环入口的距离就是a，此时fast指针跟slow指针距离环入口的距离相同，那么只要二者以相同的速度（1个单位）前进，再次相遇的地方就是环入口。</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)  <span class="comment">// 无环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        fast = head;            <span class="comment">// 将fast重置在head</span></span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;    <span class="comment">// fast与slow同等速度前进，再次相遇则为环入口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="十一-寻找链表的中点，寻找链表的倒数第k个元素"><a href="#十一-寻找链表的中点，寻找链表的倒数第k个元素" class="headerlink" title="十一. 寻找链表的中点，寻找链表的倒数第k个元素"></a>十一. 寻找链表的中点，寻找链表的倒数第k个元素</h3><p>寻找中点： <a href="https://leetcode.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">LeetCode</a> | <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">力扣</a></p>
<p>寻找倒数第k个元素： <a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/" target="_blank" rel="noopener">力扣</a></p>
<p><strong>题目描述</strong>：RT。因为比较简单，就放在一起</p>
<p><strong>分析</strong>：寻找中点直接使用快慢指针，显然当fast指针到达结尾，slow指针就是指向中点。如果链表的长度是奇数，那么slow就停在中点位置。如果链表的长度是偶数，slow停在两个中间元素的后者，同样符合中点的含义。</p>
<p>对于寻找链表的倒数第k个元素，同样可以用双指针。先让其中一个指针走k步，然后两个指针同时移动，当第一个指针到达结尾，第二个指针便到达了倒数第k个元素的位置。</p>
<p>寻找中点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>寻找倒数第k个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            fast = fast.next;       <span class="comment">// 先让fast走k步</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow.val;      <span class="comment">// 当fast到达end(此时fast为null), slow到达倒数第k个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="十二-滑动窗口Sliding-Windows类题目"><a href="#十二-滑动窗口Sliding-Windows类题目" class="headerlink" title="十二. 滑动窗口Sliding Windows类题目"></a>十二. 滑动窗口Sliding Windows类题目</h3><p><strong><em>简述</em></strong>：LeetCode有一类题型叫<strong><em>Sliding Windows</em></strong>，实际上就是用双指针维护一个范围的数据，然后按照需要移动两个指针，就像一个大小变化的窗口。这类题目也是典型的双指针题目。这类题目在LeetCode有一个非常好的讲解，这里就不讲述滑动窗口的具体思路，可以到这个<a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-suan-fa-tong-yong-si-xiang-by-/" target="_blank" rel="noopener"><strong><em>参考链接</em></strong></a> 阅读。这里直接给出Java代码。</p>
<p><strong><em>题目①： LeetCode 76. 最小覆盖字串</em></strong>           <a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener"><strong><em>题目链接</em></strong></a></p>
<p><strong><em>题目描述</em></strong>：给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。</p>
<p><strong><em>分析</em></strong>：双指针的典例。值得注意的是，如果使用HashMap，Integer在大于127之后，不能使用 ”==“来判定，简单地说，就是Integer范围只有在[-128, 127]，才从常量池里拿，否则就是一个对象，需要使用equals方法来判定。具体可以参考<a href="https://my.oschina.net/miwang/blog/730343" target="_blank" rel="noopener"><strong>这篇文章</strong></a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;</span><br><span class="line">输出: &quot;BANC&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] map1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">58</span>];		<span class="comment">// 字母包含大小写，中间还有6个特殊符号</span></span><br><span class="line">        <span class="keyword">int</span>[] map2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">58</span>];</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;			<span class="comment">// 用于check最后是否整个字符串s都无法覆盖</span></span><br><span class="line">        String current = s;				<span class="comment">// 表示当前的最小覆盖子串，初始化为s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: t.toCharArray())</span><br><span class="line">            map2[c - <span class="string">'A'</span>]++;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;		<span class="comment">// 滑动窗口双指针</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            map1[s.charAt(right) - <span class="string">'A'</span>]++;</span><br><span class="line">            right++;					<span class="comment">// 先移动right指针</span></span><br><span class="line">            <span class="keyword">boolean</span> flag1 = <span class="keyword">false</span>;		<span class="comment">// 用于判断是否到达了内层while，再改变current的值</span></span><br><span class="line">            <span class="keyword">while</span> (helper(map1, map2)) &#123;	<span class="comment">// 直到满足覆盖，开始移动left指针</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                flag1 = <span class="keyword">true</span>;</span><br><span class="line">                map1[s.charAt(left++) - <span class="string">'A'</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag1 &amp;&amp; current.length() &gt; (right - left + <span class="number">1</span>))</span><br><span class="line">                current = s.substring(left - <span class="number">1</span>, right);	<span class="comment">// 更小的覆盖字串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)			<span class="comment">// 如果flag为false，说明一次也没有进入内层while，无法覆盖</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] m1, <span class="keyword">int</span>[] m2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m1.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (m1[i] &lt; m2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong><em>题目②：LeetCode 438. 找到字符串中所有字母异位词</em></strong>        <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener"><strong><em>题目链接</em></strong></a></p>
<p><strong><em>题目描述</em></strong>：给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p>
<p><strong><em>分析</em></strong>： 这题比上一题简单很多，因为它无须“滑动”，窗口的大小是固定的，我们只需要同时移动双指针即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] s1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];			<span class="comment">// 小写字母，直接数组就可以替代HashMap</span></span><br><span class="line">        <span class="keyword">int</span>[] s2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = p.length(), length = s.length();</span><br><span class="line">        <span class="keyword">if</span> (length &lt; p.length())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right; i++) &#123;</span><br><span class="line">            s1[s.charAt(i) - <span class="string">'a'</span>]++;	<span class="comment">// 初始化，二者都是前right个字符</span></span><br><span class="line">            s2[p.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &lt;= length) &#123;	<span class="comment">// 因为循环里的break条件是 right + 1，所以这里有等号</span></span><br><span class="line">            <span class="keyword">if</span> (check(s1, s2))</span><br><span class="line">                res.add(left);</span><br><span class="line">            s1[s.charAt(left++) - <span class="string">'a'</span>]--;	<span class="comment">// 移动过程，减去第一个字符</span></span><br><span class="line">            <span class="keyword">if</span> (right + <span class="number">1</span> &gt; length)			<span class="comment">// 提前考虑是否有下一个字符</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            s1[s.charAt(right++) - <span class="string">'a'</span>]++;	<span class="comment">// 移动过程，加上下一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] s1, <span class="keyword">int</span>[] s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (s1[i] != s2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong><em>题目③：无重复字符的最长子串</em></strong>            <strong><em><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">题目链接</a></em></strong></p>
<p><strong><em>题目描述</em></strong>：给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong><em>分析</em></strong>：这题跟第一题很像，也是典型的滑动窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right++);			<span class="comment">// 移动right指针,直到有重复</span></span><br><span class="line">            <span class="keyword">while</span> (set.contains(c)) </span><br><span class="line">                set.remove(s.charAt(left++));	<span class="comment">// 移动left指针,直到无重复</span></span><br><span class="line">            set.add(c);</span><br><span class="line">            res = res &gt;= (right - left) ? res : right - left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="十三-其他"><a href="#十三-其他" class="headerlink" title="十三. 其他"></a>十三. 其他</h3><p>双指针还有一个很重要的应用，就是二分查找。但二分查找也是一个专门的题型，所以决定在二分查找篇章再写。</p>
]]></content>
      <categories>
        <category>algorithm</category>
        <category>interview</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud笔记(六)</title>
    <url>/Spring-Cloud%E7%AC%94%E8%AE%B0-%E5%85%AD.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​        上一部分添加了网关Zuul，这时候微服务架构已经基本成型，后续要增加其他功能就添加其他服务组件。但是随着微服务的数量越来越多，配置文件就越需要管理。尽管目前项目只有5-6个配置文件，都已经感觉到有点乱了。所以这部分讲述的是<strong><em>Spring Cloud Config</em></strong>，以及最后<strong><em>docker</em></strong> 简要的部署。</p>
<a id="more"></a>



<h3 id="二-使用Spring-Cloud-Config"><a href="#二-使用Spring-Cloud-Config" class="headerlink" title="二.  使用Spring Cloud Config"></a>二.  使用Spring Cloud Config</h3><p>使用Spring Cloud Config的好处：集中管理配置，可以实现不同环境不同配置，可以在运行时动态调整配置。</p>
<p>组成：一个Config Server，一个Config Client。很好理解，Server集中管理所有配置，然后Client调用</p>
<p><strong><em>使用步骤:</em></strong></p>
<h4 id="构建Server："><a href="#构建Server：" class="headerlink" title="构建Server："></a>构建Server：</h4><p><em>①在git仓库创建一些配置文件（作为server的仓库）</em></p>
<p><em>②新建module，添加依赖：</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>③编写启动类，使用注解<code>@EnableConfigServer</code>，声明为Config Server</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>④编写配置文件yml：</em></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">microservice-config-server</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">config:</span></span><br><span class="line">			<span class="attr">server:</span></span><br><span class="line">				<span class="attr">git:</span></span><br><span class="line">					<span class="attr">uri:</span> <span class="string">https://gitee.com/itmuch/spring-cloud-config-repo</span></span><br><span class="line">					<span class="attr">search-paths:</span> <span class="string">config-repo</span></span><br><span class="line">					<span class="attr">username:</span></span><br><span class="line">					<span class="attr">password:</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">		<span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>之后可以通过Config Server的端点来获取配置文件的内容，端点与配置文件的规则如下：</p>
<p><strong><em>The HTTP service has resources in the following form:</em></strong></p>
<p><code>/ {application} / {profile} [/{label}]</code></p>
<p><code>/ {application} - {profile}.yml</code></p>
<p><code>/ {label} / {application} - {profile}.yml</code></p>
<p><code>/ {application} - {profile}.properties</code></p>
<p><code>/ {label} / {application} - {profile}.properties</code></p>
<p>不知所以，仔细记录一下：</p>
<p>application：项目名，仓库名</p>
<p>profile：属性名    （默认是default）</p>
<p>label：分支名（默认是master）</p>
<p>关于端点如何分割：localhost:8080/xxx/yyy/zzz</p>
<p>yyy/zzz，表示yyy微服务里的zzz属性。</p>
<p>那么有一个疑惑，一个配置文件名为：aaa-bbb-ccc.properties，如何区分微服务名为aaa，</p>
<p>还是aaa-bbb？测试了一下，并不需要区分。如果找不到，也不会报错，此时会返回：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_46.png" alt="sb_46"></p>
<p>也就是说，会默认生成一个名为default的profile，属性值为1。</p>
<p>接着我们分别测试其余的情况，比如，我们的配置文件之一叫：microservice-foo-test.properties，那:</p>
<p>①localhost:8080/microservice-foo-test.properties</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_47.png" alt="sb_47"></p>
<p>②<a href="http://localhost:8080/microservice-foo/test：" target="_blank" rel="noopener">http://localhost:8080/microservice-foo/test：</a></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_48.png" alt="sb_48"></p>
<p>可以看到，就是name为“microservice-foo”，profile名为test，属性值为default-1.0。除此之外，还有自动生成的属性值名为default的profile。</p>
<p>③<a href="http://localhost:8080/microservice/foo-test" target="_blank" rel="noopener">http://localhost:8080/microservice/foo-test</a></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_49.png" alt="sb_49"></p>
<p>name为microservice，profile名为foo-test。但因为这个是不存在的，所以只有default属性。</p>
<p>④给②，③增加other branch。发现此时label要放在最后，而不是最前面。如：</p>
<p><a href="http://localhost:8080/microservice-foo/dev/config-label-v2.0" target="_blank" rel="noopener">http://localhost:8080/microservice-foo/dev/config-label-v2.0</a></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_50.png" alt="sb_50"></p>
<p>这也印证了官方文档前面那晦涩难懂的rules：</p>
<p><strong>对于第2，第5点，表示配置文件的具体后缀，yml，properties，yaml都是等价的（yaml等同yml）</strong></p>
<p><strong>对于第4点，表明label是可以缺省的，此时默认为master分支。</strong></p>
<p><strong>对于第3点，和第2点一比较就可以发现，当我们指定了具体的文件（xxx.yml,xxx.properties)，此时会把第一个/后的值视为label。</strong></p>
<p><strong>对于第1点，我们没有指定具体的文件，只是表明获取微服务名为{application}的属性名为{profile}的值，此时会把最后一个/的值视为label。</strong></p>
<p>中间遇到的问题：<strong><em>Read Time out</em></strong>。使用GitHub地址的时候，可能会出现Read Time out的情况，过一段时间又可以。然后可能再放了几天又无法读取，再过几个小时又可以读取。而Gitee不会存在这个错误。目前比较合理的解释，就是<strong><em>墙</em></strong>的问题了。</p>
<h4 id="构建Client："><a href="#构建Client：" class="headerlink" title="构建Client："></a>构建Client：</h4><p>步骤：</p>
<p><em>①导入依赖包</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>②普通的启动类，@SpringBootApplication即可</em></p>
<p><em>③编写application.yml，包括端口号即可。</em></p>
<p><em>④编写 <code>bootstrap.yml</code>配置文件：</em></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">microservice-foo</span>	<span class="comment"># 对应config server所获取配置文件的&#123;application&#125;</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">config:</span></span><br><span class="line">			<span class="attr">uri:</span> <span class="string">http://localhost:8080/</span></span><br><span class="line">			<span class="attr">profile:</span> <span class="string">dev</span>	<span class="comment"># 对应config server所获取配置文件的&#123;profile&#125;</span></span><br><span class="line">			<span class="attr">label:</span> <span class="string">master</span>	<span class="comment"># git repository的branch</span></span><br></pre></td></tr></table></figure>

<p>这个bootstrap叫<strong><em>引导上下文</em></strong>。具体为什么要写在这里，而不是application.yml，以后再细看，可参考：<a href="https://www.cnblogs.com/niechen/p/8968204.html" target="_blank" rel="noopener">https://www.cnblogs.com/niechen/p/8968204.html</a></p>
<p><em>⑤ Controller</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;profile&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String profile;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/profile"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> profile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现得还是很顺利的，通过localhost:8081/profile就能调用8080端口的server的dev属性。</p>
<p>唯一中间出现过的问题是，maven导入包没有写版本号，然后IDEA又不懂得报错，于是yml里就无法识别出这些配置。<strong><em>记得出错的时候先去看一下maven包有没有导入失败，IDEA很多时候都不会显示。</em></strong></p>
<p>Spring Cloud Config自带了一个health结点，用于查询当前的健康状态。</p>
<p>例子：<a href="http://localhost:8080/health/microservice-config-server/config-label-v2.0" target="_blank" rel="noopener">http://localhost:8080/health/microservice-config-server/config-label-v2.0</a></p>
<p>xxx / health / {application} / {label}            (profile默认是default，label是master）</p>
<p>加密相关：可以安装JCE，使用<strong><em>对称加密和非对称加密</em></strong>。</p>
<p><strong><em>Symmetric-key algorithm</em></strong>     <strong><em>asymmetric cryptography</em></strong></p>
<p>关于这两者到底是什么，二者的区别，有一篇比较通俗的文章：<a href="https://segmentfault.com/a/1190000004461428" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004461428</a></p>
<p><strong><em>对称加密的步骤：</em></strong></p>
<p>安装好JCE，创建bootstrap.yml（只有一个encrypt-key的属性，推测根据这个来进行hash）</p>
<p>加密，解密的命令：</p>
<p>curl <a href="http://localhost:8080/encrypt" target="_blank" rel="noopener">http://localhost:8080/encrypt</a> -d mysecret</p>
<p>会返回一串<strong><em>神秘代码</em></strong>：例如：sd23u89yw8fywe9823u92u9</p>
<p>解密：</p>
<p>curl <a href="http://localhost:8080/decrypt" target="_blank" rel="noopener">http://localhost:8080/decrypt</a> -d sd23u89yw8fywe9823u92u9</p>
<p>然后就会返回mysecret。（为什么不截图，因为写的时候已经改写为非对称了，懒得搞）</p>
<p>存储加密内容到git仓库：</p>
<p>创建一个配置文件<code>encryption.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">datasource:</span></span><br><span class="line">		<span class="attr">username:</span> <span class="string">dbuser</span></span><br><span class="line">		<span class="attr">password:</span> <span class="string">'&#123;cipher&#125;a69cfa909cbbb012b9a09c41ddf428463'</span>  <span class="comment"># 只是举例</span></span><br></pre></td></tr></table></figure>

<p><strong>单引号，{cipher}都是必不可少的，如果是使用properties文件则不能加单引号。</strong></p>
<p>之后使用  localhost:8080/encryption-default.yml 就可以获取明文解密后的结果。</p>
<p>如果不想返回明文，那么就配置： <code>spring.cloud.config.server.encrypt.enabled = false</code></p>
<p><strong><em>非对称加密：</em></strong></p>
<p>使用keytool生成一个<em>Key Store</em>：    （右边的图省略了）</p>
<p><code>keytool -genkeypair -alias mytestkey -keyalg RSA -dname &quot;CN=Web    Server, OU=Unit, O=Organization, L=City,S=State,C=US&quot; -keypass change me -keystore server.jks -storepass letmein</code></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_51.png" alt="sb_51"></p>
<p>创建bootstrap.yml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">	<span class="attr">key-store:</span></span><br><span class="line">		<span class="attr">location:</span> <span class="string">classpath:server.jks</span>	<span class="comment"># jks文件的路径</span></span><br><span class="line">		<span class="attr">password:</span> <span class="string">letmein</span>				<span class="comment"># storepass</span></span><br><span class="line">		<span class="attr">alias:</span> <span class="string">mytestkey</span>				<span class="comment"># alias</span></span><br></pre></td></tr></table></figure>

<p>然后理论上调用curl url -d xx就可以获取加密后的结果，但一直报错，是500错误，<strong>“message”:”Cannot load keys from store: class path resource [server.jks]”。</strong>仔细看了一下，应该是因为上面图中写的忽略-keypass的原因，于是就把secret注释掉，确实就可以了：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_52.png" alt="sb_52"></p>
<p>可以看到，每一次返回的结果都不一样，非对称的安全性更强。</p>
<hr>
<p>使用refresh端点。</p>
<p>在server对配置文件进行改变之后，client并不会更新（更过分的是，即使重启client，也不会更新）。所以需要刷新操作。一种方法是手动刷新，通过导入<code>spring-boot-starter-actuator</code>依赖，使用refresh端点进行刷新。</p>
<p>当配置文件发生改变之后，使用curl命令发送POST请求到client，进行刷新（是client）</p>
<p>例如：   curl  -X POST <a href="http://localhost:8081/actuator/refresh" target="_blank" rel="noopener">http://localhost:8081/actuator/refresh</a></p>
<p>遇到的问题：一直显示404，也就是没有这个端点。</p>
<p>解决：其实404就应该想到，应该是路径的问题，因为没有这个端点路径。然后最先想到了2.x开始的actuator路径改变：从/xxx变成  /actuator/xxx，于是把书上的/refresh改成了/actuator/refresh，发现仍然不行。接着继续想到了2.x开始并不是所有端点都会exposure出来，于是还要在yml里配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">	<span class="attr">endpoints:</span></span><br><span class="line">		<span class="attr">web:</span></span><br><span class="line">			<span class="attr">exposure:</span></span><br><span class="line">				<span class="attr">include:</span> <span class="string">'*'</span></span><br><span class="line"><span class="comment"># 2.x只暴露很有限的端点，需要手动配置暴露，才能使用refresh端点。</span></span><br></pre></td></tr></table></figure>

<p>由于手动刷新比较麻烦，尤其当微服务数量增加的时候，所以需要自动刷新，也就是需要</p>
<p>spring-cloud-bus，也就是加入一个RabbitMQ作为消息队列，当其中一个client发生refresh操作时，其他client也会进行refresh。但这增加了耦合度，因为client本身不应该考虑配置刷新的职责。于是应该将bus编织到server，使得server发现变化时，相应的client就像是接收广播一样，进行改变。</p>
<p>PS：但是这部分没有实现，因为RabbitMQ又各种错误，回头再看吧。</p>
<p>Spring Cloud Config与Eureka配合使用。</p>
<p>由于前面都是直接在Client里硬编码server的URI，这失去了微服务的灵活性，因此应该将二者都注册到Eureka，然后进行服务发现。本来应该不难，二者先增加eureka-client-serviceUrl-defaultZone属性，然后唯一特别一点的就是client的cloud-config-uri去掉，改成 <code>cloud-config-discovery</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">microservice-foo</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">config:</span></span><br><span class="line">			<span class="attr">uri:</span> <span class="string">http://localhost:8080/</span></span><br><span class="line">			<span class="attr">profile:</span> <span class="string">dev</span></span><br><span class="line">			<span class="attr">label:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>可是却一直无法发现到Server实例，只好先注释回原来的版本了。</p>
<p>（对于application.yml和bootstrap.yml的理解还没有，然后这些配置属性应该都写好在代码 / 文档里的，还是需要慢慢看一遍源码&amp;文档，不然这个能解决，还会有很多不懂。）</p>
<p>碎碎念，毕竟也快结束了：</p>
<p>感觉学微服务的时候一直这样，因为版本的变更，各种配置，url，包名都发现了改变，于是也就有了很多的坑。有时候也在想是否就应该直接跳过了？确实很费时间，可是，在当中也学到了很多。比如，现在一看到无法注册到Eureka，就能立刻想到是认证的问题，然后就知道去启动类那里添加那个认证方法。还有，对于yml的各种配置，也是越来越熟悉，不再是只敢抄书，稍微做一点改动这种。更重要的是，对微服务架构的认知真的是深刻了很多。虽说微服务确实就是一个项目分成多个，但到底怎么分，为什么要这样分，各个之间的作用，如何连接？这些是只看知乎那个回答所不能解答的。总而言之，并不是说一定要把书中的每一个遗留的问题都解决，毕竟不可能，最后都一定要看文档跟源码才能弄懂的。但还是要尽量努力吧，实在搞了很久也不行就算了，时间宝贵。over。</p>
<h3 id="三-其他"><a href="#三-其他" class="headerlink" title="三. 其他"></a>三. 其他</h3><p>依赖下载不完整的解决方法：使用<code>mvn clean package -Dmaven.test.skip=true</code>，可以确保依赖的完整性。 （那个参数是为了跳过单元测试，不然有一些module会报错。。但确实可以运行）</p>
<p><strong><em>最后：把项目用Docker布置。</em></strong></p>
<p>书中最后的一部分，确实也是很实用且重要的部分，项目是以前面Spring Cloud为例的。首先，需要为每个module分别制作成image。可选的方法有多种，包括：</p>
<p>①分别通过<code>mvn clean package</code>命令，把module打包成jar，然后传输到服务器，通过Dockerfile和这个jar文件来制作image。（主要用到了ADD命令，ADD在添加jar文件的时候，会自动解压，所以项目就被解压到了image中）优点是比较清晰简单，缺点是当微服务数量较多的时候，比较繁琐。</p>
<p>②使用maven的plugin进行<strong><em>image-build</em></strong>操作。但遇到了问题，也没有时间仔细研究。</p>
<p>所以最终就直接使用方法一了。方法一也出现了问题，就是Provider服务跟Consumer服务，因为之前我在Consumer的pom.xml中设置了依赖Provider，希望能简化配置。但这就导致了打包成jar的时候还需要一些额外的操作，否则它提示无法找到依赖包。这个问题也暂时没有解决，直接取消了依赖，然后在Consumer服务里单独添加了部分依赖，于是打包就成功了。然后在Linux服务器里，编写了Dockerfile，以此来制作image，Dockerfile如下（三个服务，Eureka，Provider，Consumer，我都用了同样的代码)</p>
<p>启动的时候，看到不仅是Consumer，而且Provider服务也无法连接到Eureka。其实当时就觉得localhost肯定要改，一看书，确实如此。首先在Dockerfile里，代码是给Eureka取了一个<strong><em>Alias</em></strong>，然后Provider这些服务，直接把<strong><em>localhost</em></strong>改成那个<strong><em>Alias</em></strong>即可。然后测试了一下，确实再Eureka就检测到Provider服务了。至于外网连通Eureka，同样也是在腾讯云开通8761端口即可。可是我再在腾讯云开通8001端口（Provider服务的端口），却无法访问。这是因为Docker的容器网络机制默认是<strong><em>bridge</em></strong>，所以每一个服务的IP地址是不相同的。</p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud笔记(五)</title>
    <url>/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%BA%94.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​        随着微服务的数量越来越多，外部客户端调用起来也就越来越麻烦。一个大型的项目一般都有上百个微服务，如果像我们之前的调用方法去调用，对于客户来说是很难接受的。所以这时候需要一个微服务的网关，作为一个中间层，简化这些操作。这部分讲述的是Zuul。</p>
<a id="more"></a>



<h3 id="二-使用Zuul构建微服务网关"><a href="#二-使用Zuul构建微服务网关" class="headerlink" title="二. 使用Zuul构建微服务网关"></a>二. 使用Zuul构建微服务网关</h3><p>由于不同的微服务会有不同的网络地址/端口号（比如上面的各种微服务，虽然有相同的地址，但端口号各不相同），当微服务数量很多时，外部客户端调用起来就比较麻烦。所以这时候需要一个<strong>网关</strong>，作为客户端与服务端的中间层，由网关层负责转发，这样客户端就只需要记住网关一个地址。同时网关还有其他的作用，比如统一认证（上面的Security都是东一个西一个，比较杂乱）。下面是具体的Zuul的作用列表：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_33.png" alt="sb_33"></p>
<p>可以看到，<strong><em>它整合了Ribbon实现了负载均衡，也整合了Hystrix实现了监控，同时也具备Security，Spring MVC（Dynamic Routing）的作用。</em></strong></p>
<hr>
<p><strong><em>使用Zuul微服务网关的步骤：</em></strong></p>
<p>（Zuul作为一个新的子module）</p>
<p><strong><em>①导入依赖：</em></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong><em>②启动类上加上<code>@EnableZuulProxy</code></em></strong></p>
<p>（这里还有的两个方法，一个是添加hystrix.stream结点，一个是用于注册到Eureka的认证，都是前面的内容了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DiscoveryClient.<span class="function">DiscoveryClientOptionalArgs <span class="title">discoveryClientOptionalArgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>③编写yml（都是端口号，服务名，注册到哪个Eureka等等的基础）</em></strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">8040</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">microservice-gateway-zuul</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">service-url:</span></span><br><span class="line">			<span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<p>这时候理应就完成了，确实很简单，唯一特别的就是一个注解<code>@EnableZuulProxy</code>。该注解是声明一个Zuul代理，该代理会使用Ribbon来定位注册在Eureka上的所有微服务。所以，使用该注解的Zuul，如果不添加其他配置，就是默认监控所有的其他注册在Eureka的服务。</p>
<p>但是还是出现了bugs，也进行了很长时间的排查。遇到的问题：</p>
<p>Zuul理应是已经代理了所有的微服务，这时候直接使用Zuul的地址，然后加上被代理的服务名，还有后面的路径应该就可以成功，比如： localhost:8040/micro…/user/1。但是显示<strong><em>404错误</em></strong>。</p>
<p>这个错误表明没有注册成功，可是@EnableZuulProxy是默认注册的，根本不需要手动配置。一开始猜想是不是又是版本的原因？所以还尝试了一下比较含糊不清的手动配置。但由于一键配置都没搞好，于是手动配置也出错，也可能是因为这个注册就是一键配置的，手动配置的都会被discard。然后到了最后，发现错误竟然是！</p>
<p><strong><em>①url区分大小写。</em></strong>其实直到目前为止，我都没有配置url大小写敏感的问题。这个并不是在zuul里配置，而是在整个的Spring boot，Spring MVC里配置，因为url一只是case sensitive的。</p>
<p><strong><em>②我把服务名字记错了。。</em></strong>类名是……movie，结果yml里写成了……user</p>
<p>把这个问题解决之后，确实就不再是404，而是<strong><em>401，也就是认证的问题。</em></strong>关于认证，也存在一个很严重的问题。无论我如何配置security，如何配置Configuration类，都无法通过认证。具体表现为，打开8040端口（Zuul端口），这时候会弹出认证框，因为我需要访问8011（Consumer服务端口）。我可以传递一次参数给8011，使得它通过认证，但是8011后续访问8001（Provider服务端口）也需要认证，而<strong>这个参数是不会继续传递的</strong>。这也很好理解，如果8011需要访问多个端口的集成，那么参数该如何传递？所以不继续传递参数应该是一个正确的设定。那么问题来了，应该如何解决这个问题？</p>
<p>最后的解决方案是，直接把provider里的Security内容去掉。看起来很tricky，但其实很合理。因为上面就已经提到了，<strong><em>Zuul的作用之一便是Authentication。所以服务的安全性问题，应该放在Zuul里处理，而Eureka仍然是特殊独立的存在，不需要更改。所以去掉 Service的 Security是合理的。</em></strong></p>
<p>自此，就可以通过Zuul端口来访问其他服务了。据说整合了Ribbon，但懒得测试负载均衡了。而Hystrix，应该是版本问题了，所以还是要自己手动添加了hystrix.stream端点，然后跟Dashboard等等的整合也是可以，唯一奇怪的点是，使用Dashboard的时候，Circuit的显示数据都是正常的，但Thread Pools没有数据（之前使用Turbine都有的）,看了一下书，刚好图只截到了Circuit，到了Thread Pools就没了，但这部分在后面的部分会解决，这里暂时不考虑.</p>
<p>由于Zuul作为一个网关，管理了比较多的服务，所以使用actuator管理端点就比较重要了。</p>
<p>导入了依赖之后，在ymll直接暴露所有的端点：（<strong>注意，不能直接用*，也不能用双引号</strong>）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">	<span class="attr">endpoints:</span></span><br><span class="line">		<span class="attr">web:</span></span><br><span class="line">			<span class="attr">exposure:</span></span><br><span class="line">				<span class="attr">include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure>

<p>还可以添加exclude，此处略。</p>
<p>比较重要的端点都有routes，filters，caches等等。同时还能自定义endpoints。具体的可以参考这篇文章：<a href="https://www.cnblogs.com/baidawei/p/9183531.html" target="_blank" rel="noopener">https://www.cnblogs.com/baidawei/p/9183531.html</a></p>
<p>关于routing的一些配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">	<span class="attr">routes:</span></span><br><span class="line">		<span class="attr">microservice-simple-consumer-user:</span> <span class="string">/user111/**</span></span><br><span class="line">	<span class="attr">ignored-services:</span> <span class="string">microservice-simple-consumer-user</span></span><br><span class="line">	<span class="attr">ignored-patterns:</span> <span class="string">/**/user/**</span>		<span class="comment"># 忽略所有包含user的路径</span></span><br></pre></td></tr></table></figure>



<p>此处就是， /user111 就相当于 /microservice-simple-consumer-user。/**是指可能有多个路径。值得注意的是，虽然ignored了consumer，但其实只是ignored了这个默认的映射，而我们手动配置了它的映射路径别名，所以仍然可以通过user111来映射到consumer服务。而且可以通过<code>ignored_patterns</code>，忽略掉包含xxx的路径，比如把敏感信息放到admin，这样忽略掉之后，就无法通过zuul访问该admin路径了。这里我用的是忽略user，可以看到下面的效果图，对于访问user1没有影响，却无法访问user。如图：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_34.png" alt="sb_34"></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_35.png" alt="sb_35"></p>
<p>还有一些关于actuator的端点：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_36.png" alt="sb_36"></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_37.png" alt="sb_37"></p>
<p>filters端点包含了error，post，pre，route四种类型的过滤器，并且包含执行顺序order，可以用于定位Zuul问题。</p>
<p>关于routes，还可以通过<code>/routes/details</code>来获取更具体的信息</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_38.png" alt="sb_38"></p>
<h3 id="三-Zuul的一些其他配置"><a href="#三-Zuul的一些其他配置" class="headerlink" title="三. Zuul的一些其他配置"></a>三. Zuul的一些其他配置</h3><p>Zuul的安全与Header。由于Zuul是一个代理网关，因而它可以使得同一个系统的服务之间共享Header。但有一些敏感的Header不应该外泄，因此需要指定敏感的Header列表，下面是默认的配置：（users是一个服务名）所有的服务都默认将Cookie，Set-Cookie，Authorization设为敏感。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">	<span class="attr">routes:</span></span><br><span class="line">		<span class="attr">users:</span></span><br><span class="line">			<span class="attr">path:</span> <span class="string">/myusers/**</span></span><br><span class="line">			<span class="attr">sensitiveHeaders:</span> <span class="string">Cookie,Set-Cookie,Authorization</span></span><br><span class="line">			<span class="attr">url:</span> <span class="string">https://downstream</span></span><br></pre></td></tr></table></figure>

<p>如果需要取消所有敏感Header，比如服务只在内部传递，为了共享所有的Header，包括Cookie，可以将sensitiveHeaders设为空。    （之前看过这种写法，还以为是错误的写法）</p>
<p>上面的是对单个服务的配置，可以直接用 zuul-sensitiveHeaders 来进行全局配置。</p>
<p><code>zuul-ignored-headers</code>。忽略Header。</p>
<p><strong><em>ignored-headers与sensitive-headers的区别：</em></strong></p>
<p>一个很清晰的答案：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_39.png" alt="sb_39"></p>
<p><code>sensitive-headers</code>是指明敏感headers，避免数据泄漏。而<code>ignored-headers</code>是直接指明要忽略的headers，使得不仅是zuul传递到下游服务的request，还是下游服务的response，都会忽略掉该headers（作用不同，目的也不同，但据说sensitive也会默认添加到ignored，所以区别不大）</p>
<p>多层路由：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">	<span class="attr">routes:</span></span><br><span class="line">		<span class="attr">first:</span></span><br><span class="line">			<span class="attr">path:</span> <span class="string">/first/**</span></span><br><span class="line">			<span class="attr">url:</span> <span class="string">https://first.example.com</span></span><br><span class="line">		<span class="attr">second:</span></span><br><span class="line">			<span class="attr">path:</span> <span class="string">/second/**</span></span><br><span class="line">			<span class="attr">url:</span> <span class="string">forward:/second</span></span><br><span class="line">		<span class="attr">third:</span></span><br><span class="line">			<span class="attr">path:</span> <span class="string">/third/**</span></span><br><span class="line">			<span class="attr">url:</span> <span class="string">forward:/3rd</span></span><br><span class="line">		<span class="attr">legacy:</span></span><br><span class="line">			<span class="attr">path:</span> <span class="string">/**</span></span><br><span class="line">			<span class="attr">url:</span> <span class="string">https://legacy.example.com</span></span><br></pre></td></tr></table></figure>

<p>看起来legacy会跟另外三个冲突，但由于另外三个更complex，所以当第一个url为first/second/third，就会优先调用前三个，其他的url才会调用legacy，很好理解。官方文档称之为：<strong><em>strangle patterns</em></strong></p>
<hr>
<p>实现上传文件功能：</p>
<p><strong><em>①Controller：</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/upload"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">handleFileUpload</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @RequestParam(value = <span class="string">"file"</span>)</span> MultipartFile file) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = file.getBytes();</span><br><span class="line">        File fileToSave = <span class="keyword">new</span> File(file.getOriginalFilename());</span><br><span class="line">        FileCopyUtils.copy(bytes, fileToSave);</span><br><span class="line">        <span class="keyword">return</span> fileToSave.getAbsolutePath();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>② yml：</em></strong>（不加单位默认是KB，单位必须两个都大写，当前版本2.2.0.RELEASE）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">8050</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">service-url:</span></span><br><span class="line">			<span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line">	<span class="attr">instance:</span></span><br><span class="line">		<span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">microservice-file-upload</span></span><br><span class="line">	<span class="attr">servlet:</span></span><br><span class="line">		<span class="attr">multipart:</span></span><br><span class="line">			<span class="attr">max-file-size:</span> <span class="string">200MB</span>		<span class="comment"># default 1M</span></span><br><span class="line">			<span class="attr">max-request-size:</span> <span class="string">300MB</span>		<span class="comment"># default 10M</span></span><br></pre></td></tr></table></figure>

<p>需要用到的依赖包是netflix-eureka-client，启动类需要的是@SpringBootApplication, @EnableEurekaClient注解。</p>
<p><strong><em>③使用curl测试：</em></strong></p>
<p>（1）直接通过FileUpload服务的端口调用</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_40.png" alt="sb_40"></p>
<p>（2）使用Zuul代理：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_41.png" alt="sb_41"></p>
<p>值得注意的是，使用Zuul代理时，当传输超过1MB（默认）的文件时，需要增加zuul路径，否则会报错（即使没有超过yml里设定的大小）。而无论是否使用zuul，传输的文件都不能超过yml里设定的大小。而直接调用FileUpload服务时，则不需要该路径。</p>
<p><strong><em>关于为什么要这个zuul路径，官方文档的解释：</em></strong></p>
<p><strong><em>If you use @EnableZuulProxy, you can use the proxy paths to upload files and it should work, so long as the files are small. For large files there is an alternative path that bypasses the Spring DispatcherServlet (to avoid multipart processing) in “/zuul/</em>“. In other words, if you have zuul.routes.customers=/customers/**, then you can POST large files to /zuul/customers/<em>. The servlet path is externalized via zuul.servletPath. If the proxy route takes you through a Ribbon load balancer, extremely large files also require elevated timeout settings, as shown in the following example:</em></strong></p>
<p>意思就是，使用zuul代理时，传递大文件时的路径会转换为<code>/zuul/xxx</code>，所以就需要/zuul路径了。</p>
<p><strong><em>Zuul is implemented as a Servlet.For the general cases,Zuul is embedded into the Spring Dispatch mechanism.This lets Spring MVC be in control of the routing.In this case,Zuul buffers requests.If there is a need to go through Zuul without buffering requests (for example,for large file uploads), the Servlet is also installed outside of the Spring Dispatcher.By default,the servlet has an address of <code>/zuul</code>.This path can be changed with the <code>zuul.servlet-path</code>property.</em></strong></p>
<p>关于<strong><em>查询参数的编码和解码</em></strong>，直接看官方文档:</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_42.png" alt="sb_42"></p>
<p>简单的说就是，使用Zuul传递参数的时候，参数可能会发生变化（比如使用了JS的encodeURIComponent方法），这可能会导致一些奇怪的错误。如果需要禁止参数变化，保持查询参数不会在传递时发生改变，就需要设定<code>forceOriginalQueryStringEncoding</code>参数为true。</p>
<p>关于这个参数，默认是false的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> forceOriginalQueryStringEncoding = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p>GitHub上有人提出了issue，认为应该默认是true，否则容易出现奇怪的问题。管理员也认同这个观点，但项目已经进入了<strong>Maintenance Mode</strong>，所以基本不会再维护了。所以只能手动配置参数。</p>
<p>（同理的还有Request URI Encoding，是否对URI进行decode，默认是true。而URI包含“/”的时候，decode会出现意想不到的错误，此时可以设定zuul-decodeUrl为false，避免decode。）</p>
<p><strong><em>关于@EnableZuulServer与@EnableZuulProxy</em></strong></p>
<p>二者区别：</p>
<p>Spring Cloud Netflix installs a number of filters,depending on which annotation was used to enabled Zuul.<strong>@EnableZuulProxy</strong> is a superset of <strong>@EnableZuulServer</strong>.In other words,<strong>@EnableZuulProxy *<em>contains all the filters installed by *</em>@EnableZuulServer</strong>.The additional filters in the “proxy” enable routing functionality.If you want a “blank” Zuul,you should use <strong>@EnableZuulServer</strong>.</p>
<p>二者都可以启用Zuul，并且都会包含以下过滤器：</p>
<p><strong><em>① Pre filters：</em></strong></p>
<p><strong>ServletDetectionFilter</strong>: Detects whether the request is through the Spring Dispatcher.Sets a boolean with a key of <code>FilterConstants.IS_DISPATCHER_SERVLET_REQUEST_KEY</code>.</p>
<p><strong>FormBodyWrapperFilter</strong>: Parses form data and re-encodes it for downstream requests.</p>
<p><strong>DebugFilter</strong>: If the debug request parameter is set,sets<code>RequestContext.setDebugRouting()</code>and <code>RequestContext.setDebugRequest()</code>to true.</p>
<p><strong><em>② Route filters:</em></strong></p>
<p><strong>SendForwardFilter</strong>: Forwards requests by using the Servlet <code>RequestDispatcher</code>.The forwarding location is stored in the <code>RequestContext</code> attribute,<code>FilterConstants.FORWARD_TO_KEY</code>.This is useful for forwarding to endpoints in the current application.</p>
<p><strong><em>③ Post filters:</em></strong></p>
<p><strong>SendResponseFilter</strong>: Writes responses from proxied requests to the current response.</p>
<p><strong><em>④ Error filters:</em></strong></p>
<p><strong>SendErrorFilter</strong>: Forward to <code>/error</code> (by default) if <code>RequestContext.getThrowable()</code>is not null.You can change the default forwarding path (<code>/error</code>) by setting the ``error.path` property.</p>
<p><strong><em>而EnableZuulProxy还包含以下过滤器：</em></strong></p>
<p><strong><em>① Pre filters：</em></strong></p>
<p><strong>PreDecorationFilter</strong>: Determines where and how to route,depending on the supplied <code>RouteLocator</code>.It also sets various proxy-related headers for downstream requests.</p>
<p><strong><em>② Route filters:</em></strong></p>
<p><strong>RibbonRoutingFilter</strong>: User Ribbon,Hystrix,and pluggable HTTP clients to send requests.Service IDs are found in the <code>RequestContext</code> attribute,<code>FilterConstants.SERVICE_ID_KEY</code>.This filter can user different HTTP clients:</p>
<p>​    (1) Apache <code>HttpClient</code>: The default client.</p>
<p>​    (2) Squareup <code>OkHttpClient</code> v3: Enable by having the <code>com.squareup.okhttp3:okhttp</code> library on the classpath and setting<code>ribbon.okhttp.enabled = true</code>.</p>
<p>​    (3) Netflix Ribbon HTTP client: Enabled by setting <code>ribbon.restclient.enabled=true</code>.This client has limitations,including that it does not support the PATCH method,but also has built-in retry.</p>
<p><strong>SimpleHostRoutingFilter</strong>: Sends requests to predetermined URLs through an Apache HttpClient.URLs are found in <code>RequestContext.getRouteHost( )</code>.</p>
<p>测试，本来想把@EnableZuulProxy注解换成@EnableZuulServer的，理论上项目不会有任何出错，确实也没有出错，但是却找不到filters端点。一开始以为是没有启动actuator端点，但实际上其他的各种env，health，caches，beans等等的都有，唯独只少了一个filters端点。而且我在yml里是有配置具体的URL映射的：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">	<span class="attr">routes:</span></span><br><span class="line">		<span class="attr">microservice-simple-consumer-user:</span> <span class="string">/user111/**</span></span><br></pre></td></tr></table></figure>

<p>使用EnableZuulServer的时候，没有报错，如果映射失败，应该会出现404错误。但是没有报错，也没有任何界面。所以还是用Proxy吧。</p>
<hr>
<p>禁用filters：</p>
<p>Zuul for Spring Cloud comes with a number of <strong>ZuulFilter</strong> beans enabled by default in both proxy and server mode.See the Zuul filters package for the list of filters that you can enable.If you want to disable one,set<code>zuul.\&lt;SimpleClassName&gt;.\&lt;filterType&gt;.disable=true</code>.By convention,thepackage after <code>filters</code>is the Zuul filter type.For exapmple to disable <code>org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter</code>,set <code>zuul.SendResponseFilter.post.disable=true</code>.</p>
<p>包括自定义的filters和系统预定义的filters都可以，类型就是pre，post，route，error。</p>
<p>（PS：具体的过滤器内容，还是得看源码才能更清晰，现在大概直到是什么个情况就好。关于过滤器这一块，还能配合Spring的过滤器机制一起看，毕竟像BeanPostProcessor等等的，一直没有去研究，到时可以专门再写一个叫做《阅读Spring&amp;Spring boot的interceptor机制源码》）</p>
<p>关于Zuul的高可用：创建多个Zuul实例，并且使用Nginx，F5等等的负载均衡器来实现负载均衡。</p>
<p>给Zuul的hystrix添加fallback方法：</p>
<p>创建一个FallbackProvider的Bean（也就是这个接口/抽象类的具体类），然后注入（@Component)即可。书上1.5用的是ZuulFallbackProvider，2.x应该是没有这个东西了，直接换成<code>FallbackProvder</code>。</p>
<p><strong><em>Providing Hystrix Fallbacks For Routes</em></strong></p>
<p>When a circuit for a given route in Zuul is tripped,you can provide a fallback response by creating a bean of type <strong>FallbackProvider</strong>.Within this bean,you need to specify the route ID the fallback is for and provide a <strong>ClientHttpResponse</strong> to return as a fallback.The following example shows a relatively simple <strong>FallbackProvider</strong> implementation.</p>
<p>需要指明要为哪个/哪些服务进行fallback功能，以及回退的逻辑。这里就是简单地几个文字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFallbackProvider</span> <span class="keyword">implements</span> <span class="title">FallbackProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"*"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">(String route, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientHttpResponse() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> HttpStatus.OK;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getStatusCode().value();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getStatusCode().getReasonPhrase();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(<span class="string">"用户微服务不可使用"</span>.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">                MediaType mt = <span class="keyword">new</span> MediaType(<span class="string">"application"</span>, <span class="string">"json"</span>, Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">                headers.setContentType(mt);</span><br><span class="line">                <span class="keyword">return</span> headers;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子之后，当调用的service出现问题，会显示：用户微服务不可使用。</p>
<p>关于Dashboard监控Zuul的Hystrix。</p>
<p>前面有提到Zuul的Hystrix，在Dashboard并没有Thread pools的数据，一开始还以为是作者偷懒，其实是把坑留到后面了。因为Zuul里的Hystrix的隔离策略默认是SEMAPHORE，所以自然就没有Thread pools的数据了。可以使用：<code>zuul.ribbon-isolation-strategy = thread</code>设置为THREAD。</p>
<p>（PS：这样默认会所有的服务都公用一个线程池，需要额外的配置来使得每一个路由/服务使用一个独立的线程池，<code>zuul.threadPool.useSeparateThreadPools : true</code></p>
<p>关于Zuul整合非JVM服务。上文提到的Zuul管理的服务，都是基于JVM的服务，在一些特定的情况可能不太方便，比如我们可能需要一些其他的诸如python，node.js等等的webservice。然而Zuul是可以整合非JVM服务的，只需要使用Sidecar，这样除了JVM服务，还能注册非JVM服务。</p>
<p>步骤：</p>
<p>①先写一个非JVM微服务，这里用<strong>Node.js</strong>为例。(即使不懂Node，也能大致看懂功能)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 创建Server</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求的路径</span></span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(req.url).pathname;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span> : <span class="string">'application/json; charset=utf-8'</span>&#125;);</span><br><span class="line">    <span class="comment">// 访问http://localhost:8060/, 将会返回&#123;"index": "欢迎来到首页"&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (pathname === <span class="string">'/'</span>) &#123;</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="string">"index"</span> : <span class="string">"欢迎来到首页"</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问http://localhost:8060/health,将会返回&#123;"status": "UP"&#125;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pathname === <span class="string">'/health.json'</span>) &#123;</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="string">"status"</span> : <span class="string">"UP"</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">"404"</span>);		<span class="comment">// 其他情况返回404</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 创建监听，并打印日志</span></span><br><span class="line">server.listen(<span class="number">8060</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listening on localhost:8060'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>②给Zuul添加<strong>Sidecar</strong>的依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-sidecar<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>③启动类添加<strong>@EnableSidecar</strong>注解。<strong><em>This annotation includes @EnableCircuitBreaker, @EnableDiscoveryClient, and @EnableZuulProxy。</em></strong></p>
<p>④yml里配置sidecar参数，表示要代理的sidecar（非JVM）的uri地址和端口号等等：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sidecar:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">8060</span></span><br><span class="line">	<span class="attr">health-uri:</span> <span class="string">http://localhost:8060/health.json</span></span><br></pre></td></tr></table></figure>

<p>⑤controller里写一下调用该sidecar服务的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">testController</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test/&#123;string&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findById</span><span class="params">(@PathVariable string string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://localhost:8060/"</span> + string,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test11/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">test</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://localhost:8001/"</span> + id, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑥启动node.js的微服务，启动Eureka，Zuul等等，使用：localhost:8040/test/health.json，调用成功.</p>
<p>中途遇到的问题：其实对于web的基本架构都很了解了，所以虽然书上是在IDEA里一起写的非JVM服务，但我确信在cmd也是一样的，结果却不行。后来发现只是controller的注解，不小心写成了@Controller，导致无法处理JSON数据，因为Node.js里写的返回数据类型是JSON。所以一切其实都很顺理成章。虽然这里调用的是简单的非JVM微服务，但调用其他的webservice其实也是如此罢了。</p>
<p>关于使用Zuul整合多个微服务，其实就是客户端一次调用，然后Zuul端会调用多个微服务。书上使用了RxJava，但我现在还不会，先搁置吧。其实我觉得这个需求直接在service层里编写逻辑也可以完成。当然，至于RxJava的异步优势，后面再考虑。</p>
<p>最后还学习了一下<strong>OkHttp3。OkHttp3是一个优秀的HTTP客户端，可以更加高效地使用HTTP。</strong></p>
<p>写了两个简单的GET例子和POST例子，感觉都可行。</p>
<p>依赖包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>GetExample:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder().url(url).build();</span><br><span class="line">        <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.requireNonNull(response.body()).string();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        GetExample example = <span class="keyword">new</span> GetExample();</span><br><span class="line">        String response = </span><br><span class="line">            example.run(<span class="string">"https://github.com/Hongscar/blog/blob/master/README.md"</span>);</span><br><span class="line">        System.out.println(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PostExample:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType JSON = MediaType.get(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">post</span><span class="params">(String url, String json)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RequestBody body = RequestBody.create(JSON, json);</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder().url(url).post(body).build();</span><br><span class="line">        <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.requireNonNull(response.body()).string();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bowlingJson</span><span class="params">(String player1, String player2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;'winCondition':'HIGH_SCORE',"</span></span><br><span class="line">                + <span class="string">"'name':'Bowling',"</span></span><br><span class="line">                + <span class="string">"'round':4,"</span></span><br><span class="line">                + <span class="string">"'lastSaved':1367702411696,"</span></span><br><span class="line">                + <span class="string">"'dateStarted':1367702378785,"</span></span><br><span class="line">                + <span class="string">"'players':["</span></span><br><span class="line">                + <span class="string">"&#123;'name':'"</span> + player1 + <span class="string">"','history':</span></span><br><span class="line"><span class="string">            [10,8,6,7,8],'color':-13388315,'total':39&#125;,"</span></span><br><span class="line">                + <span class="string">"&#123;'name':'"</span> + player2 + <span class="string">"','history':</span></span><br><span class="line"><span class="string">        [6,10,5,10,10],'color':-48060,'total':41&#125;"</span></span><br><span class="line">                + <span class="string">"]&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PostExample example = <span class="keyword">new</span> PostExample();</span><br><span class="line">        String json = example.bowlingJson(<span class="string">"Jesse"</span>, <span class="string">"Jake"</span>);</span><br><span class="line">        String response = example.post(<span class="string">"http://www.roundsapp.com/post"</span>, json);</span><br><span class="line">        System.out.println(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑也是很清晰，GET方法就是最简单的，获取指定URL的内容，然后把Response的body转换成字符串作为return值。POST方法，需要先传递一个RequestBody到服务端，可以看到在post方法里是先构造了一个RequestBody，再把这个body设置到Request当中，最后再返回Response。服务端获取到了RequestBody之后（在这里是一个JSON字符串），它会根据这个JSON字符串进行生成页面操作（这里的代码是在服务端完成的），生成的结果就作为Response返回。GET方法就是获取了哪个github的README.md的内容，POST方法的结果如下:（可以看到内容就是根据RequestBody生成的</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_43.png" alt="sb_43"></p>
<p>中间还遇到了一个比较麻烦的问题（一开始认为是strange error）。</p>
<p>在使用OkHttp3的时候，其实Maven仓库的最新版本是4.2.2，理应使用最新版本。下载也没有问题，写代码也不会报错。但是当我写代码看到new Request.Builder ……其实我大概也知道这是一个内部类，但我就是很想去看一下它的代码，可是跳转过去之后的class文件，并没有代码。它每一个方法的内容都是complied code，还有open等我不认识的关键字，如下：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_44.png" alt="sb_44"></p>
<p>当时显示了一个错误，我没有在意，但后面问题就很大了。我点了run项目，然后项目右下角说没有找到xxx文件（其实就是Request.class文件），但console处没有任何输出，就像是run键没有任何反应。这时候更关键的是，其他的module也无法run。当时以为是IDEA抽风了，还打算从GitHub重新把项目导入一遍。结果不小心点到了debug，发现其他module的debug可用，而run不可用，其实这时候我大概就应该猜到是什么原因了。后面过了许久，其他项目的run也可行了。我再次对GetExample进行run，又是一样的毫无反应，然后其他项目也变得无法run，但可以debug。紧接着我对GetExample进行debug，也是毫无反应。这时候其他的项目不仅无法run，而且无法debug。那么这个看似是“IDEA抽风”的问题就找到了，<strong><em>这个Maven导入的依赖包有问题，虽然没有任何报错，但就是会出错，而且甚至把整个run / debug功能都会卡住。以往如果是项目卡住，好歹还是会有红色的running的显示符，这次真的就像是完全没有反应，不得不说确实还是算IDEA跟Maven的bug吧，但至少知道了是什么原因造成的。</em></strong>于是我就把OkHttp3的版本换成了3.11.0，因为网上有文章的源码解读是使用这个版本的。确实，改了版本之后，跳转到Request就有具体的代码了：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_45.png" alt="sb_45"></p>
<p>然后就不再出现问题，而且也成功运行。那么<strong><em>为什么4.2.2版本不可用？因为OkHttp是适用于Android，Kotlin和Java的HTTP客户端，而且在4.x版本开始，使用了Kotlin重写，从上面的4.2.2的源码其实就可以看到有Kotlin的字样。那么到底Java中能否使用Kotlin编写的OkHttp4.x？估计是可以的，但要配置一些其他东西，但已经超出太远的范围了，所以这里还是就用OkHttp3吧。而且看起来，3跟4的区别好像就只是用Kotlin重新写了一遍而已，并没有什么新的特性，只是更适用于Android开发而已，所以这里不需要考虑了。</em></strong></p>
<p>至此，Zuul章节完毕。</p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud笔记(四)</title>
    <url>/Spring-Cloud%E7%AC%94%E8%AE%B0-%E5%9B%9B.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​        上一部分添加了熔断器Hystrix，并且了Dashboard和Turbine进行可视化。但是Turbine直接硬编码在yml上，与服务代码高度耦合，所以并不是一个良好的设计，还需要进行改进。</p>
<a id="more"></a>



<h3 id="二-使用RabbitMQ作为消息中间件"><a href="#二-使用RabbitMQ作为消息中间件" class="headerlink" title="二. 使用RabbitMQ作为消息中间件"></a>二. 使用RabbitMQ作为消息中间件</h3><p>使用Hystrix.stream可以让使用了Hystrix功能的Service得到监控，而Turbine与Dashboard可以很好地收集和可视化这些监控数据。但有一个问题是，Dashboard还好，与Hystrix.stream没有任何耦合，只需要输入待定URL即可。而Turbine在上文是直接硬编码到yml中，指定要获取哪个或者哪些Service的监控信息，已经属于高度耦合了。即使不考虑性能，这也会出现问题，当Service与Turbine网络不通，此时就无法进行工作。<strong><em>而增加一个MQ，可以使得Service只需把数据丢给MQ，然后Turbine从MQ上获取数据即可。</em></strong>如果出现问题，可以很好地定位到：Hystrix端的问题？Turbine端的问题？MQ的问题？Hystrix与MQ的连通问题？Turbine与MQ的连通问题？</p>
<hr>
<h4 id="RabbitMQ简要知识"><a href="#RabbitMQ简要知识" class="headerlink" title="RabbitMQ简要知识"></a>RabbitMQ简要知识</h4><p><code>RabbitMQ</code>是一个基于<code>Erlang</code>的消息队列，遵从<code>AMQP</code>协议（消息队列的一个协议）</p>
<p>Erlang是一种面向并发的编程语言。</p>
<p>RabbitMQ的管理方法有很多种，修改配置文件，命令行CTL，可视化管理界面。</p>
<p>常用的命令就是：<code>rabbitmqctl</code></p>
<p>顺手把rabbitmq也配置到了环境变量里，记录一下，是要配置到Path里，而不是ClassPath。。然后好像是用户变量跟系统变量是差不多的，反正这台电脑就一个用户。</p>
<p>使用可视化管理界面，先安装该插件：</p>
<p><code>rabbitmq-plugins enable rabbitmq_management</code></p>
<p>之后这个插件就会默认注册到15672端口，打开localhost:15672就可以看到。而且rabbitmq服务是自动启动的，无须自己手动启动，然后再使用。效果图：（默认账号密码： guest , guest）</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_21.png" alt="sb_21"></p>
<p>点一下Node：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_22.png" alt="sb_22"></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_23.png" alt="sb_23"></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_24.png" alt="sb_24"></p>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><p><strong><em>①改写微服务Service</em></strong></p>
<p>之前的做法是，给Service添加一个Hystrix.stream结点，使用<code>@EnableCircuitBreaker</code>表示启动监控，并且把监控数据存储到Hystrix.stream结点。但现在我们要把数据存储到MQ，所以先导入MQ的依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-hystrix-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-binder-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.integration<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-integration-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rtifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">rtifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为什么需要导入这么多个依赖？书上跟网上的教程都只写了2~3个依赖。这也是最困惑我的地方，只能解释为版本的问题了。其实上面有一些依赖我认为是可以去掉的，但我去掉了之后会导致项目无法启动，所以就懒得去深究如何简化导入依赖了。</p>
<p>依赖这一块我排错了很久，一开始也只是导入了2~3个依赖，然后maven也没有报错，代码也没有报错，此时启动却失败，先看大概的错误信息：</p>
<p><strong><em>Fail to parse configuration class： xxxx/xxx/xx/RabbitAutoConfiguration …</em></strong></p>
<p>一开始没把这个当回事，其实一长串的错误，这个是第一个，应该好好研究一下的。最后找到了这个类，一点进去：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_25.png" alt="sb_25"></p>
<p>原来是<strong><em>还有一些包没导入完全</em></strong>，所以这个类当然会出错了，于是也就无法加载了。这时点进本地的maven仓库看了一下，这个包并没有下载完全（连完整的jar包都没有，只有.jar.part这种）。当时其实挺无语的，竟然还能偷懒？于是把它删了重下，才下好了完整的jar包。这时候依然报错，于是把依赖删掉了再写回去，就好了（算是认识到了，这就是IDEA的一个bug，当你的maven下载jar包的时候出现问题，但它可能会误以为你已经成功下载好了。然后你重新下载了之后，它还是无法识别，会显示错误，这时候把依赖去掉，再重写，可能就会解决）。</p>
<p>之后，关于依赖包这一块，感觉调用轮子最复杂的步骤估计就是依赖包的处理的。一个依赖包其实内嵌依赖了其他的包，并不仅仅是那一个包的。然后不同的包之间可能依赖版本不同，这时候就会导致冲突而报错。所以依赖包与版本管理确实是很麻烦的一个事情。</p>
<p>依赖包的版本冲突问题处理好之后，启动依然报错：</p>
<p><strong><em>A default binder has been requested, but there is no binder available</em></strong></p>
<p>然后网上都说要加依赖包<code>spring-cloud-stream-binder-rabbit</code>，可是查看maven管理，会发现它其下一个类也不需要用到。结果加上之后启动成功又用到了。。所以，IDEA的bug真的挺多的，有时候确实是代码存在问题，但也有可能是IDEA本身有问题。</p>
<p>依赖包问题彻底解决之后，启动类加上：</p>
<p><code>@EnableAutoConfiguration(exclude = RabbitAutoConfiguration.class)</code>启动成功。</p>
<p>（这个exclude可以不需要）</p>
<p><strong><em>②改写Turbine</em></strong></p>
<p>之前的Turbine也是硬编码来表示要监控哪些Service，然后通过配置也是指明要监控它的哪些结点，比如是hystrix.stream.为了解耦，需要给Turbine连接到MQ，作为Consumer的角色。</p>
<p>先导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-turbine-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>记住要去掉<code>spring-cloud-starter-netflix-turbine</code>，因为<code>turbine</code>与<code>turbine-stream</code>不兼容。</p>
<p>启动类的@EnableTurbine改成<code>@EnableTurbineStream</code>。</p>
<p>yml关于turbine的配置去掉（因为现在是使用TurbineStream，而非Turbine）</p>
<p>启动成功。</p>
<p>③测试，turbineStream确实在打印信息，但并没有任何有意义信息。再到RabbitMQ的管理界面一看，确实是Producer成功把信息提交到了MQ，但Consumer（也就是这里的TurbineStream）却没有读取，可以看到一共有3个Connections跟Channels（不明白为什么Producer的Connections的数量有两个），Queue有1个（就是用于存放和获取信息的队列），但显示是idle，因为Consumer没有去获取数据。</p>
<p>解决方法：显式指明Producer要提交到哪个Queue（可以自定义），然后显式指明Consumer要到哪个Queue去获取数据。可能是以前的版本都有一个默认，而新版本去掉了默认，或者二者默认不一致了（毕竟Turbine已经没有维护，而RabbitMQ还在维护），导致了失败。</p>
<p>Producer的yml：（关键在于增加一个<code>spring-cloud-stream-bindings-hystrixStreamOutput-destination</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">microservice-simple-consumer-user</span></span><br><span class="line">	<span class="attr">rabbitmq:</span></span><br><span class="line">		<span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">		<span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">		<span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">		<span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">stream:</span></span><br><span class="line">			<span class="attr">bindings:</span></span><br><span class="line">				<span class="attr">hystrixStreamOutput:</span></span><br><span class="line">					<span class="attr">destination:</span> <span class="string">sixfly</span></span><br></pre></td></tr></table></figure>

<p>Consumer的yml:    (对应的，turbineStreamInput。 一开始错写成hystrixStreamInput。。。）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">microservice-hystrix-turbine</span></span><br><span class="line">	<span class="attr">rabbitmq:</span></span><br><span class="line">		<span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">		<span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">		<span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">		<span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">	<span class="attr">cloud:</span></span><br><span class="line">		<span class="attr">stream:</span></span><br><span class="line">			<span class="attr">bindlings:</span></span><br><span class="line">				<span class="attr">turbineStreamInput:</span></span><br><span class="line">					<span class="attr">destination:</span> <span class="string">sixfly</span></span><br></pre></td></tr></table></figure>

<p>启动，看到RabbitMQ的queque状态不再是idle，而是running。再看turbine，确实已经获取到了Producer提交到MQ上的数据。完成。</p>
<h4 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h4><p><strong>Turbine启动就已经看到，连接到了RabbitMQ，且连接到了具体的Queue，获取到了数据：</strong></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_26.png" alt="sb_26"></p>
<p><strong>查看RabbitMQ Management UI：</strong></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_27.png" alt="sb_27"></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_28.png" alt="sb_28"></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_29.png" alt="sb_29"></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_30.png" alt="sb_30"></p>
<p><strong>Turbine获取到了数据：</strong></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_31.png" alt="sb_31"></p>
<p><strong>Dashboard没有任何更改，可以获取Turbine的信息并可视化：</strong></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_32.png" alt="sb_32"></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Boot</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud笔记(三)</title>
    <url>/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%B8%89.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​        上一部分添加了Ribbon实现了负载均衡，并且使用了Feign实现声明式的REST调用。微服务架构中还有很多其他组件，让我们继续学习其他有用的微服务架构的组件。</p>
<a id="more"></a>



<h3 id="二-使用熔断器Hystrix"><a href="#二-使用熔断器Hystrix" class="headerlink" title="二.  使用熔断器Hystrix"></a>二.  使用熔断器Hystrix</h3><p>微服务架构是由多个微服务组成的系统。虽然架构更加清晰，分工更加明确，但也存在相应的问题：出现问题难以排查（到底是哪个服务出现问题？）。而且还会存在微服务所特有的问题：<strong><em>雪崩效应</em></strong>。当其中一个微服务出现故障时，由于微服务之间会存在依赖关系，所以其他服务也会渐渐地受到影响，最后影响到整个系统。如果这时候放任不管，那么请求就会堆积，导致系统彻底瘫痪。（有理论分析，即使每个系统的正常运行时间是99.9%，仍然会因为雪崩效应导致很严重的效果）所以我们需要一个组件来管理微服务，监控微服务，当组件发现（认为）服务出现故障，会把系统调到<strong><em>降级模式</em></strong>，拒绝继续接受请求，避免请求堆积。等到一定时间之后再申请一个请求，如果请求通过，解除降级模式，否则，继续拒绝。这个就是Hystrix，熔断器。逻辑也很简单，其实就相当于电路里的断路器。</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_11.png" alt="sb_11"></p>
<p><strong><em>正常情况下，断路器关闭，可正常请求依赖的服务。</em></strong></p>
<p><strong><em>当一段时间内，请求失败率达到一定阈值（例如错误率达到50%，或100次/分钟等），断路器就会打开。此时，不会再去请求依赖的服务。</em></strong></p>
<hr>
<h4 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h4><p>①导入依赖包<code>spring-cloud-starter-netflix-hystrix</code></p>
<p>②启动类添加注解:<code>@EnableHystrix, @EnableCircuitBreaker</code></p>
<p>③给Controller里的RequestMapping方法添加一个<code>@HystrixCommand(fallback = &quot;xxx&quot;)</code>的注解，xxx就是一个fallback方法名。当降级模式触发的时候，停止请求，改为调用fallback方法。</p>
<p>（HystrixCommand上可以进行很多配置）</p>
<p>一两次失败的request并不会导致断路器打开，而多次之后可以看到断路器确实已经开启：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_12.png" alt="sb_12"></p>
<p>Hystrix的隔离策略：<strong><em>线程隔离</em></strong> 和 <strong><em>信号量隔离</em></strong>。</p>
<p>一般推荐HystrixCommand使用线程隔离，而HystrixObservableCommand使用信号量隔离。</p>
<p><strong>HystrixCommand和HystrixObservableCommand的区别：</strong></p>
<p>①HystrixCommand用在依赖服务返回单个操作结果的时候。有两种执行方式</p>
<p>　　  -execute():同步执行。从依赖的服务返回一个单一的结果对象，或是在发生错误的时候抛出异常。</p>
<p>　　  -queue();异步执行。直接返回一个Future对象，其中包含了服务执行结束时要返回的单一结果对象。</p>
<p>　　　　</p>
<p>②HystrixObservableCommand 用在依赖服务返回多个操作结果的时候。它也实现了两种执行方式</p>
<p>　　  -observe():返回Obervable对象，他代表了操作的多个结果，他是一个HotObservable</p>
<p>　　  -toObservable():同样返回Observable对象，也代表了操作多个结果，但它返回的是一个Cold Observable。</p>
<p>参考链接：<a href="https://www.cnblogs.com/happyflyingpig/p/8079308.html" target="_blank" rel="noopener">https://www.cnblogs.com/happyflyingpig/p/8079308.html</a></p>
<p><strong>线程隔离和信号量隔离的区别：</strong></p>
<p><em>THREAD —— it executes on a separate thread and concurrent requests are limited by the number of threads in the thread-pool</em></p>
<p><em>SEMAPHORE—— it executes on the calling thread and concurrent requests are limited by the semaphore count.</em></p>
<p>简单地说，就是线程隔离就是HystrixCommand会在单独的线程上执行（new一个线程），受到线程池的线程数量限制。</p>
<p>而信号量隔离，仍然在调用的线程上执行，隔离等级由线程缩小为信号量。</p>
<p>显然，线程更安全，开销也更高，而信号量可以更高效，开销较低，但限制也较大（信号量个数限制</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_13.png" alt="sb_13"></p>
<h4 id="Feign使用Hystrix："><a href="#Feign使用Hystrix：" class="headerlink" title="Feign使用Hystrix："></a>Feign使用Hystrix：</h4><p>前面使用Hystrix是手动定义一个fallback方法，如果需要为Feign整合Hystrix，那么也很简单，为自定义的FeignClient接口提供一个实现类，然后接口的定义@FeignClient增加一个fallback属性即可。</p>
<p>看起来是没有任何问题的，但却出错了，而且一直解决不了，差点直接弃坑。</p>
<p><strong>当中可能存在的问题：</strong></p>
<p><strong><em>①没有配置Hystrix？</em></strong></p>
<p>网上一堆互联网垃圾互抄都是说这个问题，但并不是，我第一时间就在yml里设置好了</p>
<p><strong><em>②Feign已经包含了Hystrix，所以把启动类的@EnableHystrix去掉？</em></strong></p>
<p>难得看到一个不是提①的帖子，表示了是这个问题，但我去掉了还是存在500的问题</p>
<p><strong><em>③CustomizeFeignClientImpl的问题？路径?另外两个方法？</em></strong></p>
<p>都无关</p>
<p><strong><em>④@EnableFeignClients注解的问题？@EnableHystrix的影响?</em></strong></p>
<p>没有影响。</p>
<p><strong><em>⑤primary = false ？ @primary等等的原因？</em></strong></p>
<p>都不是关键，如果是注入出错的时候，Spring启动的时候就会抛出注入失败的错误。显式给fallback类使用@primary其实就是直接调用它的方法了，那样虽然可以fallback但已经失去了意义。</p>
<p><strong><em>⑥上一章节Feign的decoder，encoder，contract的问题？</em></strong></p>
<p>有可能，换了一个全新的Controller（简化了各种东西），并且把自定义FeignConfiguration也去掉了，RequestLine也换回了RequestMapping。但这时报错无法Autowire，因为它不知道要注入的是CustomizeFeignClient，还是CustomizeFeignClientImpl（注入类型是CustomizeFeignClient，所以两个都是可行的）。这时候我不懂为什么之前没有这个问题，就因为之前有自定义FeignConfiguration?</p>
<p>但是这时候我给CustomizeFeignClient设置了primary = false（官方文档里的解法），还是不行。只能给Impl添加@Primary，可这时候又有问题了，因为优先是Impl，所以无论如何都是fallback，那么就失去了原本的意义。而如果是给接口设置@Primary，那么就是继续500错误。而且之前把Configuration去掉，那么Feign会直接失效的，也可能是这个问题。关于这部分，只好先用着Hystrix，而不是Feign整合Hystrix，具体还得看文档才能解决。</p>
<hr>
<h4 id="Feign使用Hystrix：（解决篇"><a href="#Feign使用Hystrix：（解决篇" class="headerlink" title="Feign使用Hystrix：（解决篇"></a>Feign使用Hystrix：（解决篇</h4><p>问题原因：</p>
<p><strong><em>①Feign依赖包已经包括了Ribbon包，所以需要把Ribbon包去掉。</em></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">    &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;</span></span><br><span class="line"><span class="comment">&lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<p>（Feign整合了很多内容，包括Eureka，Ribbon，Hystrix，但这里只有Ribbon起到了冲突，具体原因不明。其他的诸如spring-cloud-starter-netflix-hystrix等包，不去掉也没有影响。</p>
<p><strong><em>②上一节在创建FeignClient实例的时候，用到了Feign.builder( )，然后认证内容都直接写在里面了，导致后面fallback是没有认证的。从而会导致401错误，最后变成500错误。</em></strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">userUserFeignClient = HystrixFeign.builder().client(client).decoder(decoder).</span><br><span class="line">    requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"user"</span>, <span class="string">"password1"</span>)).</span><br><span class="line">    	target(UserFeignClient.class, "http://microservice-simple-provider-user");</span><br><span class="line">adminUserFeignClient = HystrixFeign.builder().client(client).decoder(decoder).</span><br><span class="line">    requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"admin"</span>, <span class="string">"password2"</span>)).</span><br><span class="line">    	target(UserFeignClient.class, "http：//microservice-simple-provider-user");</span><br></pre></td></tr></table></figure>

<p>改成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserFeignClient userFeignClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestController</span><span class="params">(Client client, Decoder decoder, UserFeignClient userFeign)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userFeignClient = userFeign;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user1/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userFeignClient.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（无须decoder，encoder等等，也不需要那版本烦人的xxx.FeignClientsConfiguration.class了。</p>
<p>如何确定是这里的关键问题？如何看到401错误？</p>
<p>把上述代码改了之后，访问URL，会返回401错误，因为这时候其实已经可以访问到fallback了，但因为是最后的findById的时候没有认证，所以导致出错。之前写Feign刚好有一个搁置的配置文件，用于对Feign的认证，把它加上，问题彻底解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// when we need to add Interceptor for Feign, we need it to add the Http Basic auth.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasicAuthRequestInterceptor <span class="title">basicAuthRequestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"admin"</span>, <span class="string">"password2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"microservice-simple-provider-user"</span>,</span><br><span class="line">            configuration = &#123;FeignConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">FooConfiguration</span>.<span class="title">class</span>&#125;</span></span><br><span class="line"><span class="class">            <span class="title">fallbackFactory</span> </span>= FeignClientFallbackFactory<span class="class">.<span class="keyword">class</span>, <span class="title">primary</span> </span>= <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestLine</span>(<span class="string">"GET /&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@Param(<span class="string">"id"</span>)</span> String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用fallbackFactory而不是fallback类，使得可以打印错误日志（fallback类实现FallbackFactory&lt;xx&gt;接口，实现create方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">UserFeignClient</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = </span><br><span class="line">        LoggerFactory.getLogger(FeiginClientFallbackFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserFeignClient <span class="title">create</span><span class="params">(Throwable meg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserFeignClient() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">                FeignClientFallback.LOGGER.info(<span class="string">"fallback;reason was "</span> + meg.toString());</span><br><span class="line">                meg.printStackTrace();</span><br><span class="line">                User user = <span class="keyword">new</span> User();</span><br><span class="line">                user.setId(<span class="string">"-1"</span>);</span><br><span class="line">                user.setName(<span class="string">"Default user"</span>);</span><br><span class="line">                user.setAge(-<span class="number">1</span>);</span><br><span class="line">                user.setBalance(-<span class="number">111</span>);</span><br><span class="line">                user.setUsername(<span class="string">"default"</span>);</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样当前消费者service也能通过printStackTrace查看提供者service的错误信息（值得注意的是直接LOGGER.info(throwable)并没什么用，不会打印出任何东西。。至此，问题解决。</p>
<hr>
<h4 id="对某个Feign禁用Hystrix："><a href="#对某个Feign禁用Hystrix：" class="headerlink" title="对某个Feign禁用Hystrix："></a>对某个Feign禁用Hystrix：</h4><p>（先编写一个配置类，然后在@FeignClient中导入即可）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignDisableHystrixConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Feign.builder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要禁用Hystrix的@FeginClient引用该配置类即可，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"user"</span>, configuration = FeignDisableHystrixConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">UserFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以直接全局禁用Hystrix，在yml里，一般不会使用。</p>
<h3 id="三-使用Hystrix的监控"><a href="#三-使用Hystrix的监控" class="headerlink" title="三. 使用Hystrix的监控"></a>三. 使用Hystrix的监控</h3><p>Hystrix除了实现容错，还有强大的实时监控功能。</p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><p><strong>①首先，给Consumer服务添加Hystrix监控节点。</strong></p>
<p>并不需要再导入依赖包了，因为<code>spring-cloud-starter-netflix-hystrix</code>就已经足够。另外，书上的例子是根据<code>@HystrixCommand</code>的继续的，它直接就拥有了hystrix.stream节点，不清楚为何。但我觉得可能是版本的原因，也可能是@HystrixCommand和Feign的区别，总而言之，上网查了一下，发现最可靠的办法还是：自己亲手创建者一个节点。这个过程很简单，而且也能对节点有更具体的认识，而不是像之前的，为什么会有info节点，health节点，到现在的hystrix.stream节点？都是系统自带的么?最好还是自己创建。</p>
<p>参考:<a href="https://blog.csdn.net/dangshushu/article/details/80416042" target="_blank" rel="noopener">https://blog.csdn.net/dangshushu/article/details/80416042</a></p>
<p>当然，这里添加的是``/actuator/hystrix.stream`，自己改一下就好，很简单。</p>
<p>这里当时遇到过问题，无法打开这个节点，忘了是什么原因了。一开始以为是@EnableHystrix或者@EnableCircuitBreaker跟@EnableHystrixDashboard冲突，因为删掉前面两个就可以了。但其实并不是，主要原因是，我没有导入Hystrix依赖包！可能是一开始以为Hystrix依赖包跟Hystrix-dashboard依赖包冲突，然后去掉了Hystrix依赖包。所以当时的原因是：没有加Hystrix依赖包，导致前两个注解出现问题而已，这同属一个包的注解如果不兼容，那一般不可能。</p>
<p>然后无论是打开浏览器查看hystrix.stream节点，还是直接查看hystrix查看dashboard界面，都可行了。这里又有一个问题，hystrix.stream一直ping，但没有内容。因为需要先在服务里执行至少一次操作，这里才会有信息，所以使用服务一次，比如xxx:8010/user/1，然后再看hystrix.stream节点就好。</p>
<p><strong>②关于可视化监控Dashboard</strong></p>
<p>首先需要导入依赖的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>只需要在启动类加上<code>@EnableHystrixDashboard</code>即可。</p>
<p>对了，这里没有把Dashboard注册到Eureka上，一开始想着就在本身上监控，所以不注册也OK。</p>
<p><strong>③Dashboard可以监控多个服务实例，但当存在很多个实例的时候，只能一次一次地在hystrix节点上修改url，比较麻烦，而且不能对比。这时候就需要Turbine来聚合监控数据，其实也就是一次显示所有的/hystrix.stream节点，更方便，而且可以横向对比了。</strong></p>
<p>然后这时候发现前面的错了，我的架构搞错了，因为之前无论是Ribbon还是Feign等都直接在Consumer上添加，所以我也就直接都加到Consumer上了。原来Consumer上只需要添加一个Hystrix.stream节点即可（就是那个只有文字的Hystrix监控信息），然后对于dashboard跟Turbine，最好另外分别起两个modules，所以现在的项目架构应该是这样的：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_14.png" alt="sb_14"></p>
<p>这时就遇到了一个问题，太久没有创建子module，都忘了哪些是必须要添加的了，大概如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>PS：我觉得&lt;dependencies&gt;这部分应该是要放到父项目的，但现在懒得搞，后面重构再说。但h2数据库为什么也要导入我也不是很清楚。而且&lt;dependencyManagement&gt;也是必须的。还有启动类记得不能放在默认的package，不然无法scan。</p>
<p>然后Dashboard项目还好，其实跟上面说的是一样的，只是我们把consumer的那些内容都去掉了而已。然后刚刚又不小心解除了技能，之前在project左方找文件的时候，尤其是External Libraries，一堆文件找得头疼，各种快捷键也没有。刚刚才发现，无须快捷键，指到那个区域，直接输入便是搜索，无语了，一下就能把什么jackson，commonxxx揪出来了。</p>
<p>整个Dashboard项目结构：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_15.png" alt="sb_15"></p>
<p>Dashboard启动类前除了@SpringBootApplication，还要增加一个<code>@EnableHystrixDashboard</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixDashboardApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>yml只需要配置一个端口号即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">8030</span></span><br></pre></td></tr></table></figure>

<hr>
<p>Turbine项目的结构同理，只是除了上面Dashboard要导入的资源，还有：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>yml：（这个Turbine需要注册到Eureka，所以还要配置一下Eureka相关属性。但Eureka的依赖包前面是直接放在父项目了，所以是无须在这个module特别导入的）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">8031</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">microservice-hystrix-turbine</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">service-url:</span></span><br><span class="line">			<span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka</span></span><br><span class="line">	<span class="attr">instance:</span></span><br><span class="line">		<span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">turbine:</span></span><br><span class="line">	<span class="attr">app-config:</span> <span class="string">microservice-simple-consumer-user</span></span><br><span class="line">	<span class="attr">cluster-name-expression:</span> <span class="string">"'default'"</span></span><br><span class="line">	<span class="attr">instanceUrlSuffix:</span> <span class="string">/hystrix.stream</span>	<span class="comment"># 没有的话会出现异常</span></span><br></pre></td></tr></table></figure>

<p>这里的app-config就是指定要监控哪些服务，可以指定多个，逗号分隔开即可，甚至同一个实例的不同端口号启动也可以一起监控。由于我没有编写多个consumer，后面就直接拿双端口号实例来测试了。</p>
<p>而且，因为Turbine需要注册到Eureka，所以启动类应该是这样的：（exclude也是必须的，否则它会去yml里找，找不到就又生成了默认密钥了！ PS：去掉Turbine的security就不需要exclude了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude &#123;org.springframework.boot.autoconfigure.security.</span><br><span class="line">    servlet.SecurityAutoConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">boot</span>.<span class="title">actuate</span>.</span></span><br><span class="line"><span class="class">        <span class="title">autoconfigure</span>.<span class="title">security</span>.<span class="title">servlet</span>.<span class="title">ManagementWebSecurityAutoConfiguration</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">EnableTurbine</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TurbineApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DiscoveryClient.<span class="function">DiscoveryClientOptionalArgs <span class="title">discoveryClientOptionalArgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DiscoveryClient.DiscoveryClientOptionalArgs discoveryClientOptionalArgs = </span><br><span class="line">            <span class="keyword">new</span> DiscoveryClient.DiscoveryClientOptionalArgs();</span><br><span class="line">        List&lt;ClientFilter&gt; additionalFilters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        additionalFilters.add(<span class="keyword">new</span> HTTPBasicAuthFilter(<span class="string">"hong"</span>, <span class="string">"root"</span>));</span><br><span class="line">        discoveryClientOptionalArgs.setADditionalFilters(additionalFilters);</span><br><span class="line">        <span class="keyword">return</span> discoveryClientOptionalArgs;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TurbineApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h4><p>然后启动类加上@EnableTurbine，启动，理论上应该就OK了，但果然还是踩坑了，然后下面开始讲述<strong><em>填坑</em></strong>的过程：</p>
<p>①首先必须清晰这几个项目之间是如何工作的，不能只知道它这样写work，而不清楚为何这样写，不求甚解的结果都懂的，后面稍微出现了点状况你也不知道是哪里出现问题，错误得不到正确的定位，就会花费极多的事件去做无用功（这里又要吐槽一次前面的Feign使用Hystrix，定位错误两天，解决一小时）</p>
<p>首先，给Consumer添加了<code>Hystrix.stream</code>节点。这个节点就是可被后面的Dashboard跟Turbine检测的，而且我们看一下配置节点的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">    ServletRegistrationBean regisBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">    regisBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    regisBean.addUrlMappings(<span class="string">"/hystrix.stream"</span>);</span><br><span class="line">    regisBean.setName(<span class="string">"HystrixMetricsStreamServlet"</span>);</span><br><span class="line">    <span class="keyword">return</span> regisBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使不清楚它的源码，但看了也大概知道是啥了，addUrlMappings就是添加节点的URL路径，然后设置了一个BeanName。而且这个Bean也不是瞎创建的，使用了HystrixMetricsStreamServlet来创建，所以很自然地，我们在8010/hystrix.stream里就可以看到一些关于Hystrix监控的信息了，尽管现在还不清楚到底是啥。</p>
<p>然后，Dashboard是一个单独的结点，不需要配置Eureka信息，它也确实无须注册到Eureka，毕竟它是在主页里手动输入url来获取Hystrix信息的（如localhost:8010/hystrix.stream)。PS：启动的时候可能会报错，说无法注册到服务器，不需要管，因为本来就不打算注册到Eureka，不影响。</p>
<p>最后，Turbine是需要注册到Eureka的，因为它不是单独地输入一个URL，然后就检测这一个，它是检测Eureka里所有具备了某个结点的服务（一开始以为默认就是hystrix.stream结点），然后Turbine本身又是一个结点，/turbine.stream,最后只需要把这个结点放到Dashboard里查询，那么就可以在Dashboard里显示所有的Turbine检测到的Hystrix.stream结点。总体逻辑就是这样。</p>
<p><strong><em>②Dashboard can not connect xxx：</em></strong></p>
<p>输入了某个hystrix.stream的URL之后，发现无法connect。这时候看一下日志就知道：401，未授权。所以这里也直接很简单粗暴了，URL前面加上xxx:yyy@即可 （这个好像叫OAuth协议，后面再说）。前面最开始为什么没有这个问题？因为当时Dashboard直接就在Consumer服务里，而Consumer服务是有配置这个认证的代码的，所以自然它也自动认证了。</p>
<p><strong><em>③在Dashboard里输入turbine.stream的时候，一直loading。</em></strong></p>
<p>一开始直接打开turbine.stream，发现一直在打印:”reportingHostsLast10Seconds”:0 ……</p>
<p>很显然，它没有发现到任何的Host，自然也没有信息。这时候再回看turbine的yml配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">turbine:</span></span><br><span class="line">	<span class="attr">app-config:</span> <span class="string">microservice-simple-consumer-user</span></span><br><span class="line">	<span class="attr">cluster-name-expression:</span> <span class="string">"'default'"</span></span><br><span class="line">	<span class="attr">instanceUrlSuffix:</span> <span class="string">/hystrix.stream</span>		<span class="comment"># 没有的话会出现异常</span></span><br></pre></td></tr></table></figure>

<p>我当时consumer偷懒，一直没有给它加名字，所以consumer服务在Eureka里是叫UNKNOWN的。于是我把这里改成了UNKNOWN，确实就找到了。然后我给consumer加回这个正常的名字：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">microservice-simple-consumer-user</span></span><br></pre></td></tr></table></figure>

<p>发现是发现到了，但仍然是loading，这时候日志就看到错误原因了:401</p>
<p>仍然是未授权。这时候应该怎么解决？我前面是直接在Dashboard里的URL添加了认证信息，但这里显然是不行的，为什么？因为Dashboard里的URL直接就是我要监控的那个URL的地址，它具体地调用了某个Provider，然后这个Provider需要认证信息，所以我直接在URL里添加认证信息就可以了。但这里我在Dashboard里输入的URL是turbine.stream的URL，如果我在这个URL里加入了认证信息，那么只是传递给了Turbine。但后续Turbine还要自己去监控各种的服务，显然因为Turbine是连接多个服务的，如果不同的服务认证信息不一致，那么这种在URL前缀加认证信息其实就没必要，所以Turbine也很聪明地直接就不会把这个参数传递到服务（尽管我这里用的是同一个服务实例，如果它传是可以通过认证的，但显然它直接不这么尝试，我认为这个设计是合理的）</p>
<p>最标准的解法应该是，<strong><em>给Turbine增加一个配置类，然后通过认证</em></strong>，但我前面的认证都是针对注册到Eureka 的，而Consumer里的认证是使用Feign的，不可能给Turbine为了认证也加这么一个不需要的东西吧。不清楚如何解决，最后直接在源头：在Provider上配置例外，这样Turbine就不需要认证了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.configure(web);</span><br><span class="line">        web.ignoring().</span><br><span class="line">            antMatchers(<span class="string">"/hystrix.stream"</span>, <span class="string">"turbine.stream"</span>, <span class="string">"/actuator/hystrix.stream"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果还是不行，一开始说找不到/actuator/hystrix.stream。然后加上了这个ignoring也不行。其实当时就猜到了，默认路径应该是/actuator/hystrix.stream，而不是/hystrix.stream（可能是2.x改的）</p>
<p>所以正确的做法，<strong><em>给yml手动配置Turbine要监控的结点</em></strong>（不知道默认是什么，最好就直接自己配置)：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">turbine:</span></span><br><span class="line">	<span class="attr">app-config:</span> <span class="string">microservice-simple-consumer-user</span></span><br><span class="line">	<span class="attr">cluster-name-expression:</span> <span class="string">"'default'"</span></span><br><span class="line">	<span class="attr">instanceUrlSuffix:</span> <span class="string">/hystrix.stream</span>		<span class="comment"># 没有的话会出现异常(验证了这个不可或缺)</span></span><br></pre></td></tr></table></figure>

<p>这里的turbine:instanceUrlSuffix: 就是配置了要监控的后缀。果然401问题解决了，就全部都解决了。</p>
<h4 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h4><p><strong>①Eureka：一共启动了6个项目。其中一个Provider，两个Consumer（通过不同端口启动的），一个Turbine，剩下的就是Eureka，还有没注册到Eureka的Dashboard。</strong></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_16.png" alt="sb_16"></p>
<p><strong>②Turbine.stream可以监控到数据：</strong></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_17.png" alt="sb_17"></p>
<p><strong>③Dashboard的界面：</strong></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_18.png" alt="sb_18"></p>
<p><strong>④给Dashboard输入我们要访问的URL，随便起一个Title（URL可以是单个的hystrix.stream，也可以是监控多个的turbine.stream，这里直接看turbine.stream）</strong></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_19.png" alt="sb_19"></p>
<p><strong>可以看到监控了两个Host，说明成功了。如果是多个不同的实例，会有多个图：</strong></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_20.png" alt="sb_20"></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud笔记(二)</title>
    <url>/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%BA%8C.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​        上一部分对Spring Boot跟Spring Cloud有了基本的认识，同时也添加了Eureka注册中心，使得最基本的服务注册，服务发现都可以实现。但这肯定不够，所以这里继续补充关于Spring Cloud的知识。</p>
<a id="more"></a>



<h3 id="二-添加Ribbon实现负载均衡"><a href="#二-添加Ribbon实现负载均衡" class="headerlink" title="二. 添加Ribbon实现负载均衡"></a>二. 添加Ribbon实现负载均衡</h3><p>关键点：当Client可以用Eureka Server定位到多个服务列表，应该选择哪一个？比如这里的例子，我们启动两个Provider，注册到Eureka Server上。此时Consumer去调用Provider（不再直接调用某一IP，端口，而是符合的服务列表，在这里只要是Provider服务即可）。此时我们需要实现负载均衡，避免某一个Provider服务过载，导致出错。</p>
<p>步骤：</p>
<p>先引入依赖，Ribbon。据说引入了<code>spring-cloud-starter-netflix-eureka-client</code>就可以，因为client已经包含了Ribbon，但我前面不需要引入client也可以实现，所以这里直接引用Ribbon，应该引用Client也行</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（单独取其一即可）</p>
<p>然后给RestTemplate添加一个@LoadBalanced注解，表明该RestTemplate要使用负载均衡算法（这里当然就是直接默认的负载均衡算法，具体的参数配置后面再说）值得一提的是，<strong>@LoadBalanced只能用于setter方法处，所以是不能在构造方法上使用该注解的。</strong></p>
<p>然后改了一下Controller，主要是增加了一个LoadBalancerClient，还有RestTemplate的获取地址不再是硬耦合IP+端口，而是具体的服务名即可。同时还增加了一个log-user-instance，但这个主要是用于记录日志，方便观察到底是哪个Provider被调用了，所以这个并不是关键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MovieController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieController</span><span class="params">(DiscoveryClient discoveryClient, LoadBalancerClient lbc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.discoveryClient = discoveryClient;</span><br><span class="line">        <span class="keyword">this</span>.loadBalancerClient = lbc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，RestTemplate不能改成构造注入，否则加不了@LoadBalanced。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://microservice-provider-user/"</span>) + id, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user-instance"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ServiceInstance&gt; <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> discoveryClient.getInstances(<span class="string">"microservice-simple-provider-user"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/log-user-instance"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logUserInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="string">"microservice-simple-provider-user"</span>);</span><br><span class="line">    MovieController.LOGGER.info(<span class="string">"&#123;&#125;:&#123;&#125;:&#123;&#125;"</span>, serviceInstance.getServiceId(),</span><br><span class="line">                               serviceInstance.getHost(), serviceInstance.getPort());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getForObject里原本是直接写上了IP+端口的，成为了具体的服务名即可。而user-instance是上一章的遗留问题，当时没能查看到这个网页，原来是忘记写GetMapping了。最后一个log-user-instance就是拿来记录日志的，不用管。</p>
<p>然后测试，先启动Eureka，再启动两个Provider（先启动一个，修改yml里的端口号再启动一个。这样就相当于通过两个端口启动了两个Provider。当然这种做法有点蠢，<strong>如何在不修改配置的情况下启动多个？</strong><a href="https://blog.csdn.net/forezp/article/details/76408139" target="_blank" rel="noopener">https://blog.csdn.net/forezp/article/details/76408139</a></p>
<p>最后启动Consumer，这时候调用localhost:8010/user-instance等等的都是可行的，但在调用localhost:8010/user/1 的时候出现了问题，表示找不到该hostname：</p>
<p><strong><em>I/O error on GET request for “<a href="http://user-service/hi&quot;" target="_blank" rel="noopener">http://user-service/hi&quot;</a>: user-service; nested exception is</em></strong></p>
<p><strong><em>java.net.UnknownHostException: microservice-provider-user</em></strong></p>
<p>显然，就是调用/user/{id}的时候，下面的getForObject找不到那个host。找了很多解决方法，比如是不是hostname写错了，但其实这个逻辑并不通。因为user-instance都可行了，说明确实就是这个hostname。然后网上说要导入client包，导了也不行。接着又想是不是不能同时使用构造注入跟设值注入？发现也不是，看我上面的代码，就是同时使用两种注入方式。</p>
<p>最后的解决方法是一个我很早就看到了的错误，需要加入@LoadBalanced注解。这个参数我当然知道有何作用，而且我第一时间就加了，错在哪？因为我最后才发现，我在Application启动类就已经注入了RestTemplate，然后我改Ribbon的时候是在Controller里再注入一次RestTemplate，然后@LoadBalanced等等都是在Controller里进行的。所以，<strong>由于先启动的肯定是Application启动类，这时候就已经进行了@RestTemplate的注入操作了，后面在Controller里的其实已经是废设，自然那个@LoadBalanced也是没有任何效果的。</strong>于是我把Controller里的RestTemplate去掉了注入，在Application启动类里的注入增加了@LoadBalanced，就成功了。然后再测试了一下把Application启动类的注入彻底去掉，在Controller里重新加回注入跟@LoadBalanced，也成功。</p>
<p>负载的效果可能不是很明显，因为我测试的方式比较stupid，就是一次一次调用，看是不是轮流调用两个Provider，确实如此。当然肯定不是严格按照1：1的，在数据很大的时候应该会有小许偏差，但总体上比例就会是在1：1左右。</p>
<p>chapter5剩下的内容：Ribbon负载均衡的配置，包括Java类配置和属性配置（yml）两种方式。其中Java类需要注意不能放在@ComponentScan所能scan的包，不然就公用配置了。一般来说yml更简洁更方便。还有脱离Eureka使用Ribbon的方法（其实就是client包改成了ribbon，然后yml里增加一下ribbon的属性参数）。最后还有一个Lazy加载跟Hungry加载（即只要项目启动就加载，避免第一次调用时响应过慢）这些内容看起来都不难，而且现在不关键，就先不敲代码尝试了.</p>
<h3 id="三-使用Feign实现声明式的REST调用"><a href="#三-使用Feign实现声明式的REST调用" class="headerlink" title="三.  使用Feign实现声明式的REST调用"></a>三.  使用Feign实现声明式的REST调用</h3><p>使用Feign实现声明式的REST调用，并且配置REST的部分参数。</p>
<p>使用RestTemplate虽然已经可以满足所有功能，但比较繁琐（url高度耦合到每一个Mapping处，比如要写一遍Service名，多个参数的时候url会更加的臃肿）</p>
<p><strong>使用Feign的好处：让编写Web Service客户端更加简单，因为它支持Spring MVC注解，JAX-RS注解，整合了Eureka，Ribbon。也就是说，只要使用Feign注解来替代，那么就能在实现Spring MVC的同时，也自动实现负载均衡。</strong></p>
<p>使用步骤：</p>
<p>①添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②创建一个Feign接口，添加@FeignClient（这个FeignClient，用于注入到Controller中，替代RestTemplate进行Restful API的映射设计，以及自动实现负载均衡）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"microservice-simple-provider-user"</span>,</span><br><span class="line">            configuration = &#123;FeignConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">FooConfiguration</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">UserFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestLine</span>(<span class="string">"GET /&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③注入到Controller中：（值得注意的是，由于是接口对象，那么就没办法实现一个setter去注入了，会报错但其实是可行的，因为是通过注解自动生成的FeignClient对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserFeignClient userFeignClient;</span><br></pre></td></tr></table></figure>

<p>④最后就是调用：url都已经被封装到接口里了，使得URL更加的简洁，同时后面多参数的时候会更加明显。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">    turn userFeignClient.findById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于配置，只需要定义一些Feign的配置类，然后在接口的@FeignClient的configuration属性指明即可。</p>
<p>（PS：配置类最好不写@Configuration注解，如果写了，那么不要放在@ComponentScan所扫描的包中，否则会成为全局配置，被所有@FeignClient共享，除非你确实想要成为全局配置。但是由于@FeignClient的configuration属性就可以直接指明，一般没有必要写这个注解）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contract <span class="title">feignContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> feign.Contract.Default();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasicAuthRequestInterceptor <span class="title">basicAuthRequestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"user"</span>, <span class="string">"password"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的两个配置类都已经被添加到UserFeignClient中，第一个把contract改成了feign的原生默认契约，使得可以使用feign自带的注解（如@RequestLine），第二个相当于为Feign添加拦截器，这样当一些接口需要进行给予Http Basic认证才能调用，就需要上面的认证信息。</p>
<p>同时上面还有Spring cloud官网文档上写的Feign的配置属性，可以学习。</p>
<p>除了使用Java类配置，用yml配置也是可以的，跟Ribbon一样，用yml配置更加的简洁。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">config:</span></span><br><span class="line">			<span class="attr">feignName:</span>		<span class="comment"># 改成default就是全局配置</span></span><br><span class="line">				<span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">				<span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">				<span class="attr">loggerLevel:</span> <span class="string">full</span></span><br><span class="line">				<span class="attr">decode404:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>果不其然。。目前还没看出Feign的好处，因为我们这里只是相当于用feign替代了RestTemplate的Restful设计，然后还能增加一些超时，日志的配置而已，关键还是要自定义feign，可以彻底增强Restful API的操作，比如相同的API，不同角色的用户会发生不同的行为。</p>
<p>话说中间在Console看到了一个错误：<strong><em>Batch update failure with HTTP status code 401; discarding 1 replication tasks</em></strong>，显然就是注册服务到Eukera Server失败，网上的解决方法是在Server处的yml配置还是要在defaultZone增加那个user，password，增加了之后就可以了。</p>
<h3 id="四-手动创建Feign"><a href="#四-手动创建Feign" class="headerlink" title="四. 手动创建Feign"></a>四. 手动创建Feign</h3><p>前面对Consumer使用了Feign，感觉也只是替代了RestTemplate的Restful设计，稍微加了一些日志配置，意义不大。但如果是手动创建，将能完成更强的逻辑。</p>
<p>接下来对Provider服务手动创建Feign。</p>
<p>首先，导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之前对于Security包，我只在Eureka Server处添加了该依赖包，但在其他地方添加感觉没有必要，不仅需要同样的用户密码，而且如果密码不同，还可能导致无法注册到Eureka的情况。所以这次需要对Provider额外再增加一个security，感觉会在认证这里出现问题，事实也是如此的。但主要问题在于对Security的配置不熟悉，知道了哪些属性起到什么作用就好。</p>
<p>首先我们需要给Provider的Security添加配置（其实之前Eureka的Security也有配置，不过只是禁用了一下CSRF：</p>
<p>之前的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable();</span><br><span class="line">        <span class="keyword">super</span>.configure(http);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（可以看出来主要是注解@EnableWebSecurity。然后配置的导入，要么@Configuration，要么在启动类里Import(xxx.class)，都是一样的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// all request need HTTP Basic auth</span></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated().and().</span><br><span class="line">            formLogin().and().httpBasic();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A password encoder that does nothing Useful for testing with plain text</span></span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomUserDetailsService userDetailsService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CustomUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"user"</span>.equals(username))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SecurityUser(<span class="string">"user"</span>, <span class="string">"password1"</span>, <span class="string">"user-role"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"admin"</span>.equals(username))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SecurityUser(<span class="string">"admin"</span>, <span class="string">"password2"</span>, <span class="string">"admin-role"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这里的配置类，具体说一下。<code>configure</code>方法，这个其实就是登录功能。不要看起来很复杂，其实and就是起连接作用。然后authorizeRequests就是要验证request的意思，anyRequest就是每一个请求都要验证，没有例外。authenticated：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ExpressionUrlAuthorizationConfigurer&lt;H&gt;.ExpressionInterceptUrlRegistry</span><br><span class="line">    authenticated() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.access(<span class="string">"authenticated"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概也就是通过验证的意思，其他的还有denyAll，rememberMe等等的功能。formLogin就是以一个登录界面显示，而不是弹窗。最后就是表明要基于HTTP Basic来验证。</p>
<p>至于<code>passwordEncoder</code>方法，这是一个明文编码器，因为涉及密码的时候都是要加密的，但这里只是测试，所以就用一个不作任何操作的密码编辑器就好。</p>
<p>验证的过程需要我们根据用户账号和密码，如果通过了就返回一个<code>UserDetails</code>的对象，这是一个接口，所以我们需要手动创建一个实现类，重写相关方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurityUser</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityUser</span><span class="params">(String username, String password, String role)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.role = role;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        Collection&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        SimpleGratedAuthority authority = <span class="keyword">new</span> SimpleGrantedAuthority(role);</span><br><span class="line">        authorities.add(authority);</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（下面还有一些setter，getter就省略了。。虽然我中途有一个错误就是写错了getter，当时自动生成的getPassword方法竟然返回的是null，而不是password，使得我一直密码登录不通过。最后还是一步一步调试才发现是getter出现了问题）</p>
<p>其实关键的方法也没什么，<code>getAuthorities</code>主要是对role的配置而已，因为这是需要返回Collections对象，所以看起来不太一样，其实就是一个getter。但下面这4个方法其实挺关键的，看方法名就大概知道是什么作用，是否锁定账号，是否允许登录。IDEA默认生成的这4个方法是返回false的，这会导致：即使账号密码一致，也会一直卡在登录的界面。</p>
<p>接着的内部类<code>CustomUserDetailsService</code>就是注入一个自定义的Bean。这里就是登录验证的地方，首先获取登录界面的user参数（loadUserByUsername)，然后根据账号密码去进行匹配，生成一个UserDetails的对象并返回。如果这里出错（即没有预设的Username），那么就会返回一个null，登录直接失败。当我们通过了验证，返回一个UserDetails之后，这时候我们会再调用第二个configure方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.userDetailsService(<span class="keyword">this</span>.userDtailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，就是将登录界面的密码与UserDetails进行匹配。如果密码一致，则登录成功。否则会显示：Not granted any authorities(我就是因为getter写错了导致一直显示Not granted any authorities)</p>
<p>最后一切成功，Provider成功注册到Eureka，没有因为多增加一个Security而导致无法注册。同时Provider服务本身也增加了认证机制，使得可以根据不同的账号密码（一般应该是根据用户名，获取role，然后做出不同的工作，但这里只是为了演示Feign的根据情况做出不同处理的作用，所以只是print了一下role。）</p>
<p>两个Security的配置信息关键在于：</p>
<p>Eureka Server的配置无须做出改变：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">microservice-discovery-eureka-ha</span></span><br><span class="line">	<span class="attr">security:</span></span><br><span class="line">		<span class="attr">user:</span></span><br><span class="line">			<span class="attr">name:</span> <span class="string">hong</span></span><br><span class="line">			<span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line">	<span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">	<span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">8761</span></span><br></pre></td></tr></table></figure>

<p>而对于Provider服务，为了注册到Eureka的认证，还是注入Bean的方法比较好（其实yml好像也是一样的，但不要在defaultZone里乱写）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DiscoveryClientOptionalArgs <span class="title">discoveryClientOptionalArgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DiscoveryClientOptionalArgs discoveryClientOptionalArgs = </span><br><span class="line">        <span class="keyword">new</span> DiscoveryClientOptionalArgs();</span><br><span class="line">    List&lt;ClientFilter&gt; additionalFilters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    additionalFilters.add(<span class="keyword">new</span> HTTPBasicAuthFilter(<span class="string">"hong"</span>, <span class="string">"root"</span>));</span><br><span class="line">    discoveryClientOptionalArgs.setAdditionalFilters(additionalFilters);</span><br><span class="line">    <span class="keyword">return</span> discoveryClientOptionalArgs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后Provider服务的自身认证机制，就直接写在自己的Security配置类里就好：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CustomUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"user"</span>.equals(username))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SecurityUser(<span class="string">"user"</span>, <span class="string">"password1"</span>, <span class="string">"user-role"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"admin"</span>.equals(username))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SecurityUser(<span class="string">"admin"</span>, <span class="string">"password2"</span>, <span class="string">"admin-role"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>给consumer service也使用自定义Feign Client。</p>
<p>改成了使用FeignClient的默认配置，然后创建了两个Feign Client（一个UserClient，一个AdminClient），绑定到同一个service（Provider），但使用不同的账号去访问（User/Admin)，于是也会得到不同的效果，在Provider控制台也会显示出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MoviewController</span><span class="params">(DiscoveryClient discoveryClient, Decoder decoder,</span></span></span><br><span class="line"><span class="function"><span class="params">                        LoadBalancerClient loadBalancerClient, Client client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.discoveryClient = discoveryClient;</span><br><span class="line">    <span class="keyword">this</span>.loadBalancerClient = loadBalancerClient;</span><br><span class="line">    userUserFeignClient = Feign.builder().client(client).encoder(getEncoder()).</span><br><span class="line">        decoder(decoder).requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"user"</span>,</span><br><span class="line">        	<span class="string">"password1"</span>)).target(UserFeignClient<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">                                 "http://microservice-simple-provider-user");</span><br><span class="line">    adminUserFeignClient = Feign.builder().client(client).encoder(getEncoder()).</span><br><span class="line">        decoder(decoder).requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"admin"</span>,</span><br><span class="line">        	<span class="string">"password2"</span>)).target(UserFeignClient<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">                                 "http://microservice-simple-provider-user");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user-user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findByIdUser</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userUserFeignClient.findById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"admin-user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findByIdAdmin</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> adminUserFeignClient.findById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于decoder，encoder这部分纠结了好久，最后甚至用到了阿里巴巴的JSONObject包自实现了一个（当然，是上网cv下来的，但搞依赖包也烦了一小会）。可是最后才发现，这部分就没意义，反正都能映射到provider服务就好了，然后在provider的控制台也是会把结果打印出来的。所以关键在于：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">requestInterceptor(new BasicAuthRequestInterceptor("xxx", "xxxx")).target(xx.class, "x");</span><br></pre></td></tr></table></figure>

<p><code>requestInterceptor</code>传入 一个<code>BasicAuthRequestInterceptor</code>，表示账号密码，target就是目标服务。</p>
<p>PS:中途还把id改成了String，其实没什么影响，不过懒得改回去了，万物皆可String</p>
<p>之后的日志配置跟多参数，我感觉一开始是头脑清醒的，结果中间就不知道做什么了。</p>
<p>首先，前面是要先把自定义的FeignClient给注释掉的，然后再在controller里定义了两个，直接在controller里调用相应的FeignClient。结果我改成多参数的时候，首先要先把那个原本的FeignClient弄回来，其实那时候是注释掉了三个地方，结果我只改回了两个，然后启动类的注释忘记去掉了，于是一直在莫名其喵。最后还是还原成之前的代码，然后对比了一下才发现忘记一个注释了，所以前面做的很多就是无用功。</p>
<p>本章节剩下的部分，主要是多参数Feign跟上传文件。其实我觉得还蛮重要的，但我认为作者这里偷懒了，它的代码根本就不能实现，只是画个饼。更关键的是，由于版本的原因，它的代码存在1.x的代码（与2.x不兼容），而我导入2.x的包却没有相关的jar包，搞得我还得上网找一个自实现的Decoder。然后也尝试就这个包换成1.x，发现更恐怖了，整个项目不兼容。总而言之，这部分真的只能搁置。但好歹，最后总算解决了那个不能识别注解的问题。网上都说是Feign默认注解有问题，那个@RequestLine不行。我怀疑他们用的都是1.x。而2.x恰恰相反，就是要使用这个默认注解，然后使用@RequestLine而不是@RequestMapping。总而言之，烦了一整天这个问题。但我觉得主要还是，一开始没有耐心地考虑问题，主要一开始我用@RequestLine确实不可行，于是我也想着改。但其实我当时出错的原因不是这个，而是其他。。所以，一开始对错误的范围认知有误，导致后面也一直错，确定问题的范围真的很关键！不过还好，最后虽然无法生成User，但还是成功将多参数传到了Provider服务。说明Feign多参数的传递还是可行的，而且多次的尝试也让我对整个微服务的架构有了更多的认识（Provider跟Consumer真的是很关键的两个角色）。</p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud笔记(一)</title>
    <url>/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%B8%80.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​        Spring已经渐渐地成为了Java程序员的必备技能，尤其是Java Web方向。同时，Spring也一直在发展，由于Spring存在配置臃肿的问题，所以就出现了Spring Boot框架，用于简化新Spring应用的初始搭建以及开发过程。近年来微服务架构也越来越火，所以在Spring Boot的基础上又出现了Spring Cloud。如果你是常年使用Spring的Java Web程序员，那么Spring Boot跟Spring Cloud很值得一学。</p>
<p>​        本系列文章并非是完整的教程，我阅读的是<strong><em>”<a href="http://www.ityouknow.com/spring-cloud.html" target="_blank" rel="noopener">纯洁的微笑</a>“的博客</em></strong>：。以及书籍<strong><em>《Spring Cloud与Docker微服务架构实战》by周立</em></strong>。相信每一位学习编程的朋友都遇到过一个问题，跟着书上/教程上一步一步走，结果却不一样。有的时候是版本的问题，有的时候是自己的操作出现纰漏，也可能是教程本身也存在纰漏。无论如何，学习是一个挖坑再填坑的过程，在这个过程中我们的技术也会快速提高。所以这篇文章就是记录我在学习Spring Cloud过程中所遇到的问题，以及如何解决（虽然也有构建步骤，但目前写得比较简单，建议结合上面推荐的博客，书籍使用）。如果有朋友也遇到了类似的问题，可以参考一下。</p>
<a id="more"></a>

<p>​        此处使用的<strong><em>Spring Boot版本：2.2.1.RELEASE，Spring Cloud版本：2.2.0.RELEASE</em></strong>。虽然我阅读的主要教程是上面的书籍，但我自己敲的demo项目跟书上有一点不同。书上把每一个章节的项目都分开，比如一个章节是学Feign，一个章节是Hystrix，并没有把它们都结合在一起，我认为这样缺少了一个很重要的工作：整合。然而整合却是必不可少的，既然都使用到了微服务架构，那么自然是要使用多个模板组件。所以我一共只写了一个项目，代码依次在上一个章节代码的基础上继续增加，既要保证功能完好，又要保证功能之间可以兼容。除此之外，书上目前的版本还是Spring Cloud 1.x，毫无疑问已经过时，所以我也改成了2.x。虽然我认为做出的这两个改变是值得的，但确实在学习过程中也遇到了不少的坑，所以也特地记录了下来。</p>
<h3 id="二-前置知识"><a href="#二-前置知识" class="headerlink" title="二. 前置知识"></a>二. 前置知识</h3><p>​        Spring Boot是Spring的一套快速配置框架，而Spring Cloud是一个基于Spring Boot实现的云应用开发工具。所以，Spring Boot可以离开Spring Cloud独立使用开发项目，而Spring Cloud不能离开Spring Boot，属于依赖的关系。所以如果你还是使用Spring，而非Spring Boot，那么至少要了解Spring Boot与Spring的区别。可以参考这篇文章入门：<a href="http://www.ityouknow.com/springboot/2016/01/06/spring-boot-quick-start.html" target="_blank" rel="noopener">http://www.ityouknow.com/springboot/2016/01/06/spring-boot-quick-start.html</a></p>
<p>​        可以看到，Spring Boot项目的构建非常简单，无须再考虑各种诸如xml，数据库，配置文件的配置，更多的只需要注解，达到了非常简便的效果。项目的结构也跟Spring相差无几：</p>
<p><code>src / main / java ：</code> 主程序入口</p>
<p><code>src / main / resources ：</code> 配置文件</p>
<p><code>src / test / java ：</code> 测试</p>
<p>​        在java / com / xx / xxx里的主目录（即与model，service，controller等packages同级的目录），要有一个Application.java，这个其实就是Spring Boot框架的入口，相当于Spring里的XML配置。不过这里抛弃了XML，使用了注解的方式：<strong>@SpringBootApplication</strong>。目前要引入jar包所需要的Maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其实大部分在Maven默认项目里都已经添加好了，剩下的只需要添加支持web的模块：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来对于Controller层的开发也很简单：@RestController，@RequestMapping即可（方法返回String类型，不需要什么ModelAndView）</p>
<p>@RequestMapping是指Controller里的方法都以JSON格式输出，无须再写Jackson等配置了。</p>
<p>对于测试：@Test，@BeforeEach （对于JUnit5，@Before and @After no longer exists； use @BeforeEach and @AfterEach instead）</p>
<p> PS：主要是原本的Before跟After注解就是在每一个Test方法执行时都会执行，改得更加符合其作用</p>
<hr>
<p>​         微服务架构需要有多个modules，如果你愿意的话，你可以把一个modules当作一个项目来操作，但到了微服务这一块，这种做法就比较愚蠢，<strong>于是最好是尝试把多个modules放到同一个project中（使用的是IDEA）</strong>。参考网址:<a href="https://blog.csdn.net/sinat_30160727/article/details/78109769" target="_blank" rel="noopener">https://blog.csdn.net/sinat_30160727/article/details/78109769</a></p>
<p>遇到的问题：</p>
<p><strong><em>①子module跟父module的pom.xml有什么异同？</em></strong></p>
<p>父module的pom如下，可以看到包含了Spring Boot的基本信息，还有子modules的构成</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span>		<span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hongscar<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">module</span>&gt;</span>microservicesimpleprovideruser<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">module</span>&gt;</span>microservicesimpleconsumermovie<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>至于子module，之前该怎么样就怎么样，但parent元素无须做出改动，即：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hongscar<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>microservice-simple-provider-user<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>②写好src/main/java之后，程序无法运行，显示错误：<strong><em>Your ApplicationContext is unlikely to start due to a @ComponentScan of the default package.</em></strong></p>
<p>解决:因为之前错误的父子module关系，导致我的子modules其实还是有默认package的，比如之前的package都是<em>com.hong.microservice-xxxx-provider</em>之类的。但实际上正确的操作，这时候子module的src/main/java，是没有任何package的，即在java目录下创建一个A.java，会没有package语句。而SpringBoot的Application.java确切地说，并不是要放在根目录，而是要放在所有其他类/包的同级/父级目录，是不能够直接放在src/main/java目录下的，必须手动创建一个包把它放进去。<strong>SpringBoot在写启动类的时候如果不使用@ComponentScan指明对象扫描范围，默认指扫描当前启动类所在的包里的对象，如果当前启动类没有包，则在启动时会报错</strong>。（因为默认并没有包，所以就报错了）</p>
<p>解决方案也很显然，自己手动创建了一个basic的package，然后其他的package跟Application.java都放进去，如下图：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_1.png" alt="img"></p>
<p><strong><em>③Test无法通过，但直接运行可以通过</em></strong></p>
<p>解决：看清楚是@Before还是@BeforeEach。至于其他的，目前其实可以直接运行，但如果测试代码出错，后面会踩坑，可以尝试到时候解决，也可以提前把测试代码删掉了避免踩坑（但你知道是测试代码哪里出错了吗）</p>
<p>④创建第二个MicroService的时候，Test又无法通过，而且不是@BeforeEach的问题。报错：</p>
<p><strong><em>java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration, you need to use @Context</em></strong></p>
<p>解决：可能是因为存在了多个service，无法默认指定等等的（毕竟多个module的配置其实我还不是很熟悉），这时候最好就是直接在测试类上面显示指明要测试的是哪个类，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpirngBootTest</span>(classes = MicroserviceSimpleConsumerMovieApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MicroserviceSimpleConsumerApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextsLoad</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加之后，测试也可以运行了，但还是不通过。然后才知道，test目录下的包默认是要跟java下的是一样的。所以，既然java目录下的Application.java的路径是 basic/Application.java (basic是我们自己添加的package），所以test下也需要添加一个名为basic的package（必须名字也为basic）</p>
<p>⑤<strong><em>Caused by: java.lang.IllegalArgumentException: Not a managed type</em></strong></p>
<p>无论是哪个服务，对于domain层的配置都要重复编写。@Entity等等的。</p>
<p>over，运行通过（尽管第一个service的测试还是存在问题，但毕竟我对MockMvc的语法一无所知(问题③))</p>
<h3 id="三-添加Eureka"><a href="#三-添加Eureka" class="headerlink" title="三. 添加Eureka"></a>三. 添加Eureka</h3><p>​        微服务架构的核心思想就是分离各个服务，每一个服务单独作为一个module/project。那么服务如何被其他项目/服务调用？这时候就要用到Eureka，服务注册中心。服务把自己注册到Eureka上，然后其他服务可以在Eureka上发现并调用，这就是微服务的基本机制。</p>
<p>步骤：</p>
<p>pom.xml添加Eureka依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种maven依赖直接去<em>maven repository</em>查找就能找到，还能找到每一个版本。这里值得注意的是，添加的是server，不要错误地添加了client包。同时Spring Cloud的版本号比较特别，使用英语记录版本 ，以下是<strong><em>Spring Cloud英语版本对应的Spring Boot版本</em></strong>：</p>
<table>
<thead>
<tr>
<th>Spring Cloud版本</th>
<th>Spring Boot版本</th>
</tr>
</thead>
<tbody><tr>
<td>Hoxton</td>
<td>2.2.x</td>
</tr>
<tr>
<td>Greenwich</td>
<td>2.1.x</td>
</tr>
<tr>
<td>Finchley</td>
<td>2.0.x</td>
</tr>
<tr>
<td>Edgware</td>
<td>1.5.x</td>
</tr>
<tr>
<td>Dalston</td>
<td>1.5.x</td>
</tr>
</tbody></table>
<p>添加完依赖包，其实就可以运行了。然后要把服务注册到Eureka。这时候才是版本冲突的地方。<strong><em>ERROR org.springframework.boot.SpringApplication - Application run failed</em></strong></p>
<p>一般这种<strong><em>Application run failed</em></strong>，基本就是<strong><em>版本号冲突</em></strong> 的问题了。看了一下，我写的还是书上的Edgware.RELEASE，参考官网的改成了<strong>HOXTON.RELEASE</strong>，就解决了这个问题。</p>
<p>然后又有其他的错误， <strong><em>Failed to start component [NonLoginAuthenticator [StandardEngine[Tomcat] .StandardHost[localhost] .TomcatEmbedded。。。</em></strong></p>
<p>网上查到的也是更加奇怪，说是<strong>SDK里的servlet-api.jar与log4j.jar起冲突了</strong>。其实关于前面的版本号为什么非要添加到Eureka才出问题已经挺奇怪了，这里就更奇怪了，怎么突然就两个jar起冲突了？唯一的解释只能是Eureka毕竟是带有记录功能的，所以就包含了log4j.jar，然后就与servlet-api.jar冲突了。可是我的SDK里却没有这个东西，去External libraries找到了这个东西，然后去掉，竟然真的就可以了。所以说，编程还是需要多积累经验。</p>
<p>效果图：可以看到MicroService已经注册到了Eureka上</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_2.png" alt="img"></p>
<h3 id="四-把多个服务注册到Eureka上"><a href="#四-把多个服务注册到Eureka上" class="headerlink" title="四. 把多个服务注册到Eureka上"></a>四. 把多个服务注册到Eureka上</h3><p>看起来很简单，但却遇到了非常多的问题。首先打开consumer服务的时候，发现pom.xml报错了。想当然的以为又只是IDEA抽风了而已，因为直接运行是可行的，但后来发现确实不是如此。</p>
<p>maven之前欠下的债算是要还了，每当我有一个知识点掌握得含糊不清，得过且过，也许我可以安逸地度过很久，甚至是几年，但总会有再栽跟头的一天。之前我对maven，真的就是把它当作了一个简单的eclipse的import path的功能了，目的实现了就行了，什么&lt;dependencyManagement&gt;，完全不想去弄清楚。之前创建子module之间的依赖，我其实就搞不懂为什么能直接用cn.hongscar.xx来引用依赖？难道因为是项目内部就可以直接引用？没有去想。</p>
<p>首先项目一直会出现今天早上的那个错误，显然就是servlet-api.jar的问题，才发现这东西会一直存在，即使删掉了，maven也会把它自动下载回来。很显然，删掉是很愚蠢的操作，但当时毕竟只想立竿见影，我一直以来都是这么做的，显然正确的操作是添加一个maven的例外。所以正确的操作是添一个&lt;exclusions&gt;在&lt;dependency&gt;里。这确实就可行了，但真的是如此吗？首先，确实是添加了&lt;exclusions&gt;就可以工作了，但为什么maven会 自动把servlet-api.jar下回来，难道这还需要时机？得看你手速快不快，在它把servlet-api.jar下回来之前运行？实际上，就是因为项目本身就存在问题，所以每次rebuild，reimport的时候就把jar包搞回来了。无论如何，&lt;exclusions&gt;显然是更好的选择。</p>
<p>关于我要的目标，其实<strong><em>Maven的基本命令</em></strong>就已经包括了：</p>
<p>-v :查询Maven版本</p>
<p>compile： 编译，把Java源文件编译成.class文件</p>
<p>test：测试项目，测试test目录下的测试用例</p>
<p>package：将项目打包成jar包</p>
<p>clean：删除target文件夹（删除缓存，重新生成）</p>
<p><strong><em>install：将当前项目放到Maven的本地仓库中，供其他项目使用</em></strong></p>
<hr>
<p>我想要的就是把项目安装到本地仓库里，总不能把项目delete了重新创建一次吧。然后在install的过程中查看到底出现了什么问题，这才是解决问题的核心。而不是，clean，complie统统乱点一遍。</p>
<p>然后在install的过程中就能看到问题了：</p>
<p><strong><em>Failure to … in … was cached in the local repository, resolution will not be reattempted until the update interval of nexus has elapsed or updates are forced.</em></strong></p>
<p>首先是Hoxton.RELEASE文件已经缓存了，并且还在使用，就不能update了。这时候真的就是简单粗暴就好，删了，让它重新下载，这个问题就解决了。</p>
<p>接下来的问题更离谱，说是<strong><em>测试代码有问题，所以不能成功build</em></strong>。想起来昨天不懂测试语法，想着项目能正常运行就好，测试代码就没管，没想到就这里埋下了大坑。于是把测试代码全部注释掉，同时rebuild一次（更新classes文件夹），果然，build就成功了。maven本地仓库也就成功出现了该模块。所以，项目到底如何加到maven本地仓库，为什么之前出错，都是有迹可循的，真的不仅仅就是奇怪的经验那么简单。当然，经验是否有用？至少从中能知道，测试代码并不是那么的人畜无害，在正式的build，install（项目打包过程），测试代码也是关键的一环，它有权终止整个过程，尽管你的主程序没有出错，只是测试代码写错了。</p>
<p>其实很多时候，把很多东西都归结于经验，确实有种给自己诡辩的嫌疑。就像是看到pom.xml报错了，第一时间想的是不是IDEA抽风了，完全不去想到底什么原因。诚然，”奇怪“的情况是存在的，但并不能一概而论，很多时候，经验不能成为一个完美的借口。</p>
<p>结果图：    可见两个service都成功添加到Eureka中。</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_3.png" alt="img"></p>
<h3 id="五-构建高可用的Eureka-Server"><a href="#五-构建高可用的Eureka-Server" class="headerlink" title="五. 构建高可用的Eureka Server"></a>五. 构建高可用的Eureka Server</h3><p>​        先从搭建两个Eureka Server互相注册复制开始。根据书上的例子，首先需要修改<strong>hosts文件</strong>。然后先去了解了一下hosts文件是什么（位置：C:\Windows\System32\drivers\etc，如果是Linux，是在/etc/hosts)，主要就是平时我们上网都要输入域名，然后传递到DNS服务器再进行映射，而DNS服务映射到具体的IP地址是需要时间的。这时候我们可以在hosts文件里自定义一些domain name（可以是自定义，可以是公开的），以及对应的IP地址，那么当我们下次输入这个domain name的时候，就直接映射到IP地址，跳过了DNS，因此速度也就更快。比如GitHub.com的IP地址是192.30.255.113。那么添加一行：</p>
<p><code>192.30.255.113          github.com</code></p>
<p>即可使得下次输入GitHub.com就能自动映射到对应的IP addr。</p>
<p>平时我们用的localhost跟127.0.0.1也是如此。127.0.0.1默认就是本地的IP地址，而localhost就是写在hosts里的域名。但在hosts里可以看到这一行是被注释掉的，为什么？因为下面还有一行注释：</p>
<p># localhost name resolution is handled within DNS itself. </p>
<p>也就是说，DNS服务器内部已经把这个写好了，成为了约定，这样就避免了你把localhost乱搞成了其他东西。所以并不是说注释是无效的，而是这一行直接成为了DNS的默认约定配置吧。</p>
<p>OK，然后修改hosts是要给127.0.0.1新增几个新域名（peer1跟peer2）</p>
<p>然后在application.yml里的配置，使用— 可以将yml文件分成多段，由一个spring:profiles来决定（在后续启动的时候传入这个参数，表示要使用哪段yml文件），如果没有指定spring:profiles，则无论是传入哪个参数，都会生效。</p>
<p>启动的时候需要：<code>java  -jar  xxx.jar  --spring.profiles.active=peer1  /  peer2</code></p>
<p>显然，首先我们需要将项目打包成jar文件，然后再分别启动（spring.profiles参数分别为peer1和peer2)</p>
<p>这时就出现了第一个问题，如何打包成jar文件？</p>
<p>联想到昨天吃的亏，印象中maven里就包含了这个操作，确实如此。但成功打包之后，却无法运行，显示：<strong><em>xxx没有主清单属性</em></strong></p>
<p>那么到底是什么是主清单属性？其实也很好猜，就是找不到主类。网上看的大致说法是，maven的打包jar操作是有点特殊的，跟普通的java方式打包生成的目录是不太一致的。于是又尝试了一下mvn install，mvn clean等等命令，都不行。</p>
<p>但在中途也学到了一手：<strong>给mvn的命令增加一个-e参数，可以显示详细的错误信息</strong>：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_4.png" alt="img"></p>
<p>比如这里的错误信息是can’t not delete，那是因为我打开了几个cmd，然后文件正在使用，无法进行mvn clean，把cmd窗口关闭了之后重新clean就可以了。</p>
<p>之后添加了一个叫maven-shade-plugin的插件，还是不行（为什么要添加这些额外的插件，还是有思考的，基本就是要把MainClass的路径也写进入，一并打包）</p>
<p>这时候感觉maven的plugins操作还是不太好用，直接用mvn install -e查看为什么出错，发现是：</p>
<p><strong><em>Caused by: org.codehaus.plexus.component.configurator.ComponentConfigurationException: Cannot find ‘resource’ in class org.apache.maven.plugins.shade.resource.ManifestResourceTransformer</em></strong></p>
<p>完全没有头绪，但在网上有一个很好的帖子：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_5.png" alt="img"></p>
<p>简单概括就是：<strong>SpringBoot本身是存在一个打包插件，而这个另外加的shade反而形成了冲突。</strong>那么就好办了，把SpringBoot的打包插件去掉？一看，pom.xml并没有该插件，但该service是依赖了provider service的，看了一下provider service的pom.xml，确实存在这个插件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>于是想着那就删掉这个！但结果还是不行？可能是别的地方还存在这个插件的导入？毕竟我在最初对maven的版本管理是很混乱的。但我确实暂时不想深究这个问题，直接换了另一种做法：那就不用这个shade插件了，直接使用springboot自带的打包插件。然后给当前pom.xml加上了上述插件（看来依赖是不会继承plugins的），这时候<code>mvn clean &amp;&amp; mvn install</code>，成功，如图：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_6.png" alt="img"></p>
<p>PS：此时我并没有立刻启动Eureka Server节点，而是查看了一下MANIFEST.MF文件，发现确实增加了大概的“主清单属性”，如图：（之前是没有Spring-Boot-Classes等等属性的）</p>
<p>PPPS：对了，vs code打开了MF文件之后就死机了。。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Manifest-Version:</span> <span class="number">1.0</span></span><br><span class="line"><span class="attr">Created-By:</span> <span class="string">Maven</span> <span class="string">Archiver</span> <span class="number">3.4</span><span class="number">.0</span></span><br><span class="line"><span class="attr">Build-Jdk-Spec:</span> <span class="number">12</span></span><br><span class="line"><span class="attr">Implementation-Title:</span> <span class="string">microservice-eureka</span></span><br><span class="line"><span class="attr">Implementation-Version:</span> <span class="number">1.0</span><span class="string">-SNAPSHOT</span></span><br><span class="line"><span class="attr">Main-Class:</span> <span class="string">org.springframework.boot.loader.JarLauncher</span></span><br><span class="line"><span class="attr">Start-Class:</span> <span class="string">basic.EurekaApplication</span></span><br><span class="line"><span class="attr">Spring-Boot-Version:</span> <span class="number">2.2</span><span class="number">.1</span><span class="string">.RELEASE</span></span><br><span class="line"><span class="attr">Spring-Boot-Classes:</span> <span class="string">BOOT-INF/classes/</span></span><br><span class="line"><span class="attr">Spring-Boot-Lib:</span> <span class="string">BOOT-INF/lib/</span></span><br></pre></td></tr></table></figure>

<p>这时候已经猜到成功了，然后按照很前面的命令启动了两个Eureka Server节点，确实如此：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_7.png" alt="img"></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_8.png" alt="img"></p>
<p>peer1看起来一开始报错，但其实很正常，因为peer2还没开始运行，后面peer2运行起来之后，二者就成功互相复制了。效果如图：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_9.png" alt="img"></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_10.png" alt="img"></p>
<p>虽然启动成功了，似乎也成功复制了，但与预期有一点不同（peer1复制了peer2，但peer2没有复制peer1，仍然复制的peer2，配置文件似乎没有写错）</p>
<p><strong><em>DS Replicas</em></strong>有点奇怪，但<strong>*Instances currently8</strong>确实都是二者成功复制了。</p>
<p>有说法是。DS Replicas是指从哪里同步数据，测试先启动peer2，再启动peer1会不会发生改变。（这也是我的个人想法，所以按理说，peer2处的DS Replicas应该是peer1才对）</p>
<p>可是较换peer1跟peer2的启动顺序，Instances currently依然是复制了，但DS Replicas依然二者都是peer2，所以与启动顺序无关。(可能是根据yml的顺序来决定，后面的就是最后的DS，毕竟这两个peer其实都指向同一个IP）。<strong>可能是peer1和peer2的复制顺序真的不是简单的顺序复制吧</strong>，网上说如果真的是那样，那就变回了中心化组件，跟微服务架构背道而驰。</p>
<h3 id="六-给Eureka-Serer增加一个认证"><a href="#六-给Eureka-Serer增加一个认证" class="headerlink" title="六. 给Eureka Serer增加一个认证"></a>六. 给Eureka Serer增加一个认证</h3><p>首先添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其实只要添加了这个依赖，那么此项目在运行时就需要登录。（如果是Server，那么登录Server控制台需要登录，其他服务想注册到此Server也要登录。如果是Service，那么使用Service的时候也要登录）如果不在yml里配置用户名跟密码，默认用户名就是user，密码会在运行时随机生成，打印在控制台。</p>
<p>然后一开始在yml的配置里出现了问题，其实不用查也可以猜到，是版本的原因，2.x换成下面的：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">security:</span></span><br><span class="line">		<span class="attr">user:</span></span><br><span class="line">			<span class="attr">name:</span> <span class="string">user</span>		<span class="comment"># Default user name.</span></span><br><span class="line">			<span class="attr">password:</span> <span class="string">aaa</span>	<span class="comment"># Password for the default user name.</span></span><br><span class="line">			<span class="attr">roles:</span> <span class="string">xxx</span>		<span class="comment"># Granted roles for the default user name.</span></span><br></pre></td></tr></table></figure>

<p>所以最后的yml配置文件如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">microservice-discovery-eureka-ha</span></span><br><span class="line">	<span class="attr">security:</span></span><br><span class="line">		<span class="attr">user:</span></span><br><span class="line">			<span class="attr">name:</span> <span class="string">hong</span></span><br><span class="line">			<span class="attr">password:</span> <span class="string">kk111</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">serviceUrl:</span></span><br><span class="line">			<span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line">		<span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">		<span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">8761</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，前面是否需要加 xx:yy@localhost:8761/eureka/ ，好像加不加都无所谓。。</p>
<p>然后一开始遇到了奇怪的错误，最后把密码删掉了也不行。最后翻GitHub以前的记录，才发现，我连两个false还有port都没有配置，所以最基本的配置一定要记忆清楚。。</p>
<p>接下来是要将服务注册到需要认证的Eureka Server。一开始遭遇到了问题：<strong><em>com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server</em></strong></p>
<p>很显然，就是说不能注册到任何已知的服务器。网上搜到的答案都是针对Eureka Server本身不需要注册（最开始那两个false参数），但显然这里我的错误就是service无法通过Eureka Server的认证。</p>
<p>尝试了几次都不行，最后通过“内华达穷举法”，才发现问题是<strong>CSRF</strong>。只要把CSRF禁用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable();</span><br><span class="line">        <span class="keyword">super</span>.configure(http);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于到底是在yml里设置security参数，然后在defaultZone里增加${…}:${…}@local…，还是直接注入一个<strong><em>DiscoveryClientOptionalArgs的Bean</em></strong>，都可以达到认证的效果，如下：</p>
<p><strong><em>方法①：</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.netflix.discovery.DiscoveryClient.DiscoveryClientOptionalArgs;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DiscoveryClientOptionalArgs <span class="title">discoveryClientOptionalArgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DiscoveryClientOptionalArgs discoveryClientOptionalArgs = </span><br><span class="line">        <span class="keyword">new</span> DiscoveryClientOptionalArgs();</span><br><span class="line">    List&lt;ClientFilter&gt; additionalFilters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    additionalFilters.add(<span class="keyword">new</span> HTTPBasicAuthFilter(<span class="string">"hong"</span>, <span class="string">"kk111"</span>));</span><br><span class="line">    discoveryClientOptionalArgs.setAdditionalFilters(additionalFilters);</span><br><span class="line">    <span class="keyword">return</span> discoveryClientOptionalArgs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>方法②：</em></strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">microservice-simple-provider-user</span></span><br><span class="line">	<span class="attr">jpa:</span></span><br><span class="line">		<span class="attr">generate-ddl:</span> <span class="literal">false</span></span><br><span class="line">		<span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">		<span class="attr">hibernate:</span></span><br><span class="line">			<span class="attr">ddl-auto:</span> <span class="string">none</span></span><br><span class="line">	<span class="attr">datasource:</span></span><br><span class="line">		<span class="attr">platform:</span> <span class="string">h2</span></span><br><span class="line">		<span class="attr">schema:</span> <span class="string">classpath:schema.sql</span></span><br><span class="line">		<span class="attr">data:</span> <span class="string">classpath:data.sql</span></span><br><span class="line">	<span class="attr">security:</span></span><br><span class="line">		<span class="attr">user:</span></span><br><span class="line">			<span class="attr">name:</span> <span class="string">hong</span></span><br><span class="line">			<span class="attr">password:</span> <span class="string">kk111</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">	<span class="attr">client:</span></span><br><span class="line">		<span class="attr">serviceUrl:</span></span><br><span class="line">			<span class="attr">defaultZone:</span> <span class="string">$&#123;xxx.name&#125;:$&#123;xxx.password&#125;@localhost:8761/eureka/</span> </span><br><span class="line">			<span class="comment"># xxx是 spring.security.user</span></span><br><span class="line">	<span class="attr">instance:</span></span><br><span class="line">		<span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>二者无论是单独使用，还是一起使用，都可以达到认证的效果。</p>
<h3 id="七-关于Eureka的元数据metadata"><a href="#七-关于Eureka的元数据metadata" class="headerlink" title="七. 关于Eureka的元数据metadata"></a>七. 关于Eureka的元数据metadata</h3><p>metadata包括标准元数据（自带的，可在服务之间传递信息），还有自定义元数据（一般不会改变客户端的行为，相当于参数传递，给一个参考值）</p>
<p>其实这部分的工作并不多，但主要是让我意识到了，版本控制真的不容易，即便是引入了Maven。之前我在主项目里没有引入spring-boot，然后在provider跟Eureka中都分别引入了。其实没有必要，在主项目引入，然后provider就不必引入了，即使引入了也会被视为duplicate。</p>
<p>同时我需要解决@RestController返回的是XML而不是JSON的问题，发现问题是因为Eureka-Server引入了<strong><em>Jackson-dataformat-xml</em></strong>这个包，所以自然地去<strong><em>exclude</em></strong>掉就好（需要在maven里慢慢找这个包到底从属于哪个包，当然如果记忆好的话，确实是引入Eureka之后才出现这个问题，自然也就是在Eureka-Server的包里了）</p>
<p>然后发现Provider跟Consumer的返回类型都正常了，但Eureka下的apps（测试自定义metadata的入口）依然是XML类型。一看发现项目仍然存在Jackson-dataformat-xml，应该是Eureka Server也自己引入了spring-cloud-eureka-server的原因，所以我把它去掉了（想着这样直接获取主项目的就好），但这时项目却无法运行了。原因是找不到Jackson-dataformat-xml，猜测是因为Eureka  Server没有导入这个包了，于是主项目的exclude就出现了问题（现在回想这个逻辑是不对的，为什么?)。但并不是，把exclude删掉了也不行。才发现哪个找不到Jackson-dataformat-xml，是指项目需要这个，但却不存在。所以说，其实项目还是需要这个包的，尤其是在使用metadata的时候？于是我把这个给彻底去掉了，这样就不可运行了。所以只好主项目依旧exclude，Eureka Server依然导入spring-cloud-eureka-server，但不exclude（此时子项目跟父项目存在不同，当然就以子项目的来覆盖）</p>
<p>所以最后provider等服务是返回JSON了，但apps却仍然是XML。不过想想，毕竟我对apps还不太了解，也不是我自己手动写的@RestController，所以返回XML其实也无可厚非。</p>
<p>PS：最后有一个点，Consumer注入了Provider的依赖，这两个之间是不能同时注入同一个Bean的（会冲突），而且其实只要Provider存在这个依赖，那么Consumer也就存在。所以Consumer没有注入注册Bean，也没有在yml里编写认证用户密码，同样是可以注册到Eureka的。相反，在Provider已经写了认证机制，在Consumer再写一遍，会使得Consumer无法认证，无法注册到Eureka。</p>
<p>Eureka部分到此结束。</p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>大学流水账</title>
    <url>/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E6%80%BB%E7%BB%93.html</url>
    <content><![CDATA[<p>​     时光荏苒，大学毕业的瞬间，给我的感觉便只有四个字，恍如隔世。毕业已经有一段时间，其实答辩结束的时候就已经可以开始写这篇总结，但还是各种因素，迟迟未能动手，最终还是拖到了今天。无论如何，习惯总结的我，对于大学毕业这么一个里程碑，肯定是不能错过的。而且自己的大学，真的有太多的话想说，这篇总结会好好地回顾了我四年的大学生活，自我评价，当然还有未来的展望。</p>
<a id="more"></a>

<p>​     我很想把大学，再一次地拿去和高中比较一番，因为高中给我留下了很多深刻的经历，而大学也一样，这两段经历又给了我截然不同的感受。高中时代的很多记忆碎片我大抵都还记得，只是没有必要在这里仔细述说。印象中高中三年的我，基本就是一直坐在课室，坚持走着课室饭堂宿舍的三点一线，偶尔参加一些小活动而已。当时的我大概是自然而然的，而高中毕业之后才发现那个能一直专注的愣头青般的我已经渐渐远去。当时的自己也没有太多的迷茫，大概只有对大学的憧憬，因此即使高中有很多遗憾，我还是很快就投入到大学生活中去。到了大学，再也没有人管，感觉自己一下子变得很自由。即便是上课，也不是固定的课室固定的座位，衣服也不必再穿校服。突然想到了大一最开始的时候，觉得一切都是那么的不可思议，甚至在有一次去课室的途中，心中感慨了一句，大学真的自由，自由真好啊！可惜这个自由的生活，我还是没有适应好。我大部分的时候还是宅在了宿舍，并且在宿舍也没有进行有效的学习。制定过不少的计划，基本都是开头坚持了几天就结束。这真的导致了我整个大学过得是很失败的。如果可以重来，那该多好呢？可惜，一切都没有重来。</p>
<p>​     大一的我还处于懵懂状态，上学期还保留有挺大的学习热情，只是制定了不少的学习计划却没有好好执行。大一没有什么专业课，只有一门C++。老师确实讲得很烂，但自己也努力得不够。还记得大一的寒假，我在家还在努力地学习C++，如果当时都再坚持一下就好了。大一下学期基本就是萎靡的一个学期，基本整个学期都在玩LOL。上学期积累下来的C++基础，优势也不复存在。下学期各种重要的知识，诸如继承，多态等等的东西，都没有学会，这也为后续放弃C++埋下了伏笔。还记得刚入学的时候还想过要转专业，最后也是在怠惰中放弃。倒不是说转专业是好是坏，但这肯定是一次奋斗的经历，就这么失去了其实也是有点可惜的。总的来说，大一就是迷糊，课程就是按部就班地完成，课余也尝试听了一些讲座，编程比赛的总结会等等。还记得那时候也有过豪言壮志，大学一定要参加一次比赛，不然大学不就浪费了么！回首，只剩下唏嘘。都说大一应该好好放松，不要太着急，其实这才是最大的骗局吧，有多少人就这么一直放松到毕业呢？还记得大一上学期，我就一直觉得自己太懒了，也不好好学习，心理上也一直强制自己去学习。所以也有过让自己早起去湖边读英语的经历，这也让我的四级考了很高的分数。只是这种那种的热情，在后面也慢慢地消散罢了。</p>
<p>​     大二，课程比较繁多。大二确实是很累的一年，因为要接触到很多的专业课，而且大都很重要。然而我基本也就是按部就班地完成了专业课的学习，并没有深入理解。考试成绩还挺好的，不仅没有挂科，而且大部分都是85分以上，我也是从那时候开始觉得自己比较适合考试的。其实大二的时候，相比大一的懵懂，自己也开始想得更多的事情。比如，我开始接触手机软件编程，又或者是web编程。大一的时候基本就是在玩，并且顺便学了一下c++，但大二的时候就开始觉得自己要接触一些实用性的东西，比如切实地投入到有意义的开发当中（手机/网页端的开发）。然后同样也是半途而废吧，没有坚持到最后。当时自我的批判是，看完了书，却没有自己切实地实践一下。比如我看完了一整本web开发的书籍，我应该跟着书上的例子来写一遍的，但我并没有，这使得我在后续再接触web的时候，跟没有学过web是没有太大区别的。如果是用高中的东西来类比，大概就是，看完了一章数学，却一道题也没有做，没有及时巩固？其实大二这一年，自己学习的时间是多了的，玩游戏的时间也少了。也可能是内容太多了，然后自己没有选择一个方面认真钻研，这也是导致失败的原因之一。比如数据结构大作业，一开始我想做一个爬虫软件，然后学习了一下爬虫，同样地也只是但当涉猎，没有深入。后来做一个管理系统，又想学qt，中途觉得困难又去研究了一下mfc，结果也是都没有好好掌握。操作系统和编译原理那种课程我倒是连想法都没有，可能是太难，因而都是做完作业便了事。下学期的专业课就更多了，而且甚至每一门都有实验课，导致印象中，3月开学，从4月开始便是每周至少3天要在实验室。大二下学期我也挺认真学的，数据库，离散数学，算法，UML我都有认真去学，不过同样地也只是完成课业的程度。比如数据库，当时仅仅是完成了老师给的实验，用sql server来进行数据的插删改查，然后就没有继续下去，也就是没有巩固。当时大概应该至少的，将自己大一的C++的大作业进行改进，比如数据从本地存储，改为数据库存储。这样在后续的数据库操作中印象都会更加深刻。同时还有很多种数据库也值得去深入学习，比如mysql，redis，MongoDB等等。大三的时候，有一次中学同学来学校找我聊天，说到他最近的一个项目用了三种数据库，因为他觉得这样可以分别利用不用数据库的优点，但面试官认为这样会使得程序太过臃肿。当时我比较感慨的一点就是，数据库对于计算机软件的必不可缺的，然而当时的我只掌握了mysql（sql server已经被我搁置了）。就觉得自己很多东西都学了，却没学精，然后该学的也没有学，大概是我自己也没有静下来想自己应该学哪些东西？或者是哪些东西重要性很高，最好就应该去学？同样的，算法也只是看懂了考试题，也没有说去OJ刷题，也没有想过在自己写的程序里用算法优化。还有OS，一直说要学习一下linux，同样也只是完成了实验课便结束了。总而言之，大二下学期就这么按部就班地过去了，不能说没有认真学习，每门专业课都能达到学校的要求（不仅仅是及格），但就是没有进一步的自我思考自我反馈。而且看到成绩挺好的时候还会有膨胀感，自己对大学考试的套路模式也渐渐了如指掌，考试真的就是填表放假般的轻松了，但这种膨胀感显然没有让我感觉到危机感。不过，大二下的自己还遇到了其他的问题，所以当时能坚持下来已经算是不错的结果。大二的自己感觉学了挺多东西，打算暑假巩固一波，也就是切实地去写点手机软件，网页等。然后被家里赶去学车了，整个暑假基本也就在驾校渡过，因此大二就这么结束了。</p>
<p>​     大三，其实是最难过的一年。刚开学就说要分方向，然而自己前面埋下的隐患，自己对所有专业课都只是能够考好试的水平，然后自己课外学习的东西也没有学得比较好。反复再三，就报了数字媒体和手机开发。数字媒体是自己直觉上应该是最感兴趣的方向，而手机开发和数字媒体是互相选择的，因此就选了两个方向。然而第一节课就让我产生了挫败感，老师第一节课讲的内容我就完全听不懂，讲了一堆什么小波分析，傅立叶变换。而且其实事先就知道数媒是最难的方向之一，当时跟室友都在犹豫要不要放弃换方向，但最后还是没有换。然后就开始了一个学期的数媒煎熬时期。我现在还清楚地记得，数媒一共两门课，一门就叫数字媒体，一门叫计算机图形学。计算机图形学要求一个大作业，而数媒要求4个大作业。而且事后我觉得，每一个数媒大作业的难度都比图形学的要难。也不知道是不是老师的问题，还是这个方向的确要学的东西太多太难。第一个大作业，我和两个同学钻研了两个星期，竟然连其中的一个功能都实现不出来。我还记得要求是做一个图形处理软件，可以选择一个图片，然后点按钮就可以进行相应的图片操作，比如旋转，放大缩小，降噪等等。反正有很多功能，底层都是对图片的像素点，通过算法进行处理。总而言之，我们三个人从头到尾就一直卡在了旋转这一部分。后来，后面的一些功能倒是可以实现出来，只是实现的方式有点stupid，但旋转最终实现的效果还是不尽人意。更恐怖的是，第一个大作业还没完成，第二个大作业就来了。第二个大作业好像是研究GPU对图形处理的效率等等，然后学习什么CUDA。然后当时我们三个稍微了解了一下，就回去继续做第一个大作业。当时其实已经都第二个大作业了，但看到同学，见面还是调侃，“你今天旋转了吗？”。之后，第二个大作业没过两个星期，老师就布置下来第三个大作业，自己制作一个视频，情节场景等都是自己设计。这个制作视频并不是所谓的用手机拍下来然后对视频处理，而是完完全全地用代码来生成。首先就是用软件建模，构建出各种的物体，人物，设置场景，每个动作设定等等，然后再连接起来等等。这个的难度当时在我看来就比前两个大作业都要难得多了，横向对比一下图形学的大作业，图形学的大作业是要求建模，构建物体，然后构建场景，将物体布置在场景中，然后调整比例等等。构建物体当中还有很多细节我也忘记了，反正就是什么色彩，光照，渲染，设置光源等。最终的成果就是一个多彩的场景。这个其实工作量已经不多不少，而制作一个视频相当于就是制作一个场景的数十倍吧，而这仅仅是数媒的四个大作业之一。然后也就稍微学了一下unity3D和3ds，但想想那个工作量，还是望而却步。这个时候时间大概来到了11月，我觉得一整个学期都只学数媒，大概也是很累人的吧。然而大三还是有别的课程需要去搞的，软件架构，项目管理，安卓，ios开发，每一个都需要大作业。现在回想当时是真的煎熬，到底是如何熬过来的。图形学大作业也是teamwork，不过全部都是我一个人做的便是。临近寒假，数媒的第四个大作业也分发下来，看来是要我们寒假的时候好好把四个大作业都做了。第四个是将传感器连接到软件中，当时好像是用leapmotion。大致就是要我们开发一个游戏，可以用外接传感器来操控的。寒假的时候真的很短，反正转眼就开学，四个倒是都做完了，不过质量感人，我甚至答辩都不敢去了。我跟室友说，我不去了，挂科就挂科，这学期也不学数媒这个方向了，再也不想接触数媒老师。不过最后还是没有挂科，甚至不是最后一名。至此数媒噩梦到此结束，然后新的噩梦又到来，那便是找实习。找实习其实有一个很麻烦的点就是，我刚刚放弃了数媒，却又要找实习，那么数媒的影响到底有多大呢？大二上学期的时候学了java，当时就开始放弃了c++，决定将java当作主语言。而数媒是要用c/c++/c#这种语言的，然后大三上的时候基本都是在写c++，但现在找实习，又不是找数媒相关的，c++又难。于是我便又要重新把java捡了回来，并且是搁置了半年的情况下。大三上的课程对于找实习的重要性实在太高，选了web方向的同学，对于java web的知识又了解，大作业中又有锻炼，而我这种重新来的，甚至需要复习一遍java，然后再重学web，然后学各种诸如ssh的框架等。错过了最佳的找实习时间段，然后就要兼顾学校的课程压力。最终搞完一个麻烦的手机开发实训便结束了大三。</p>
<p>​     大四，大学的最后一年。找实习找得太久，当中也想过很多事情。我也是事后才发现，自己整个大学一直就在错过。大一其实是最该好好放松的一年，同时也应该大一就大致想一下整个大学的路。结果我大一只有无所事事的上学期还有沉迷游戏的下学期。大二其实应该要具体地掌握些什么，事实上我也开始学了，然而并没有深入，使得大二真的只能用按部就班来形容。大三分方向，真的应该提前就了解好，如果我提前了解多一点数媒，读一下数媒的课本，知道他真的这么难，也许我就换了一个更值得的方向，大三下找实习的时候也就不至于因为掌握得不够好而没有找到好实习。因为学的方面挺多，却没有学精，唯一一个花了很久时间钻研的方向，最终还是不敢继续下去而放弃。大三刚开始的时候，我还有很多突然心血来潮般的想法。比如如果当初没有学软件就好了，还不如直接选个数学靠谱（因为自己大二对离散数学也很喜欢）。比如大学还是应该多学点东西啊，比如考点什么证，结果自己还是只稍微涉猎。又比如突然觉得出国真的很好啊，如果早一点想到这些，大一的时候就更努力一点去提一下绩点了。感觉自己整个大学，没有很好的规划。最终还是找到了一个不错的实习，虽然并没有学到太多东西，但也是第一次社会经历。也是因为没学到太多东西，感觉自己的大学太遗憾了，于是希望毕设能改变自己，学到东西，然后选择了区块链为题目。我也不可以说没学到东西，只是这东西真的挺烦人的，使得我毕设虽然没太多体力活，但还是耗到了最后一刻。中间也想过很多事情，最终决定了考研，于是也就安心地放下了找工作的念头，然后准备毕设的事情。毕设结束前夕，一直在为毕设而烦恼。然而毕设结束的那一刻，每个人都会有一个念头，“啊，这样就毕业了吗？”是的，毕设这门大学最后一课，就这么结束了。答辩完的那天是6月8号，正好是高考的最后一天。我还记得那天早上早早地就出发，一路上狂风暴雨，去到课室的时候，裤子都快要湿到膝盖那里了，更不用说鞋子。那几天刮台风，似乎从小到大，我从来没有见过这么大的台风。答辩完的时候已经是下午2点，我原本想回宿舍睡觉，但发现并不能睡着，结果只是在床上小憩了10来分钟便下床。我走到阳台看着外面的狂风暴雨，心境在渐渐地变化。我很想回家，但又不想回家。答辩完到离校的这段日子，是我在学校里最无所事事的一段时光。我每天习惯地打开电脑，但发现什么都不想做，只是看一下论坛，看一下直播，等待吃饭的时间，和交心的朋友一起去饭堂吃饭。大学毕业的伤感远远超出我的想象，那是高中的时候完全无法体会到的情绪。我很喜欢在微博上发一些感慨，并不是想给谁看，我只想给我自己看。离别的日子匆匆而来，然而校园里依旧那么宁静。在华工的最后一个晚上，我们宿舍三个人都不约而同地失眠。第二天似乎还是和往常一样，看直播，吃饭，只是下午多了个拿毕业证的事情。然后我们就各奔东西，有人没有感觉，有人悲痛欲绝，有人还在等待释怀，但我们都不能回头。我走的时候宿舍只剩下一个人了，室友说要送我到楼下，我说不用了。他静静地站在门口看着我离开，而我不敢回头，就这么离开。最后跟我大学最重要的朋友在地铁里分别，带着信物，我终究还是回到了家，于是，大四也就这么结束了。</p>
<p>​     四年的大学生活转瞬即逝，回顾了一整遍，感觉也没有想象中的混，但最终的结果自己肯定是不太满意。比如从大一的时候没有制定好整个大学的基本规划，对于考研出国考公务员等事情，我都是后知后觉，没有事先考虑好，以至于错过了最好的时机。对于学习，也没有很好的规划，没有确定好自己的方向，导致大学似乎学了很多，但又没有深入，然后又好像什么都没有学过。对于做人，我曾经试过无数次想要改变自己的性格，比如内向型人格的我，总是被教导要开朗外向一点，而我也想过很多次要变得开朗，但最后我才发现，做我自己就好，没必要为了谁而改变什么。其实我在大学里，真的变了很多，至少我自己是这么觉得的。我觉得我的大学，似乎也没有那么的不堪，继续向前就好。</p>
<p>​     当然，大学里也养成了很多坏习惯，比如拖延症，作息不规律，做事拖拉，不能坚持等，希望早点成为更好的自己吧。这就是我的大学。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>验证docker的例子</title>
    <url>/%E9%AA%8C%E8%AF%81docker%E7%9A%84%E4%BE%8B%E5%AD%90.html</url>
    <content><![CDATA[<p>根据前面的docker知识点，可以使用这些知识点，结合例子来实际操作一遍。</p>
<p>其实最开始看阮一峰大佬博客的时候，就已经遇到了一个问题：需要用浏览器访问。而我之前一直都直接在命令行里操作，一时间不知道该怎么办。当然了，没有浏览器就真的不行吗，也许不是，根据网上的说法，直接使用curl命令也可以，只是没那么方便，于是还是先下定决心要搞一个可视化界面。这里用到的是VNC。</p>
<a id="more"></a>

<p>关于VNC的环境配置，其实也遇到了很多问题，但当时忘记总结了，现在回过头来发现当时的浏览器记录没了（不要问我为什么浏览器记录会没了= =），只能凭印象地稍微说几句。一开始想着直接给服务器安装GNOME桌面，设置了优先使用桌面启动而非控制台，然而一点用处也没有。于是我又回归到VNC上，VNC其实也有很多种，但似乎不同版本之间都是可通的。这里值得一提的是，VNC也是简单的C-S架构，所以我们不能仅仅在本地安装了VNC-Client，就觉得可以连上了，更关键的还要在服务端也安装一个VNC-Server。当时随便找了一个TigerVNC，在CentOS上直接用yum install就可以安装的，建议先用<code>yum list | grep tigervnc</code>，然后把tigervnc跟tigervnc-server都安装了就好。</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_1.png" alt="img"></p>
<p>第一次启动vncserver的时候，会让我们设置client登录到server需要的密码，需要输入两次，密码不会显示出来，都是常见的情况。然后是最关键的一步，需要指定端口。tigervnc-server默认开启的是5901端口，可以用netsta -tlnp查看是否存在该端口。这时候我在vncviewer（client）仍然无法ping通，一直显示time-out，其实就是没有连接到。找了很多方法都不行，后来突然想到了之前配置redis的时候也是如此，防火墙，配置文件全都到位了，就是不行，结果直接去腾讯云服务器上的端口管理设置了一下就可以了。于是我也就过去尝试地添加了一个5901端口，竟然就连通了，吃惊，如下：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_2.png" alt="img"></p>
<p>连接上了之后就好办了许多，看阮一峰大佬的例子也一直水到渠成，包括他使用docker安装WordPress的例子，看评论里还有部分朋友是前两个方法无法ping通，而我成功三个方法都完美无差错，感觉还是可以的。于是VNC的部分到此结束。</p>
<p>可是仅仅靠一个博客的例子也太简单了，于是继续按照书上的例子来加深印象。书上用的是nginx的例子，各种参数我大概都理解是什么意思，–volume其实就是-v，-p是端口映射等等的。然后就遇到了一个老生常谈的问题，在映射目录下加了一个html文件，确实可以访问，可是出现了中文乱码。中文乱码真的是经典问题，那么接下来就来具体诉说如何解决这个中文乱码的问题。（题外话，如果前面偷懒直接用curl而不用vnc，就会忽略掉中文乱码这个错误）</p>
<p>以往解决中文乱码，很简单，修改配置文件，mysql等数据库就是这样处理的。那么，我们现在的本机（其实就是localhost，有一些翻译成宿主机），完全就没有安装nginx，全靠一个仓库提供的nginx image，然后在docker里运行，那么哪里找到配置文件呢？</p>
<p>我主要参考的是这篇文章：<a href="https://blog.csdn.net/wangfei0904306/article/details/77623400" target="_blank" rel="noopener">https://blog.csdn.net/wangfei0904306/article/details/77623400</a></p>
<p>很显然， 主要用到的就是-v参数，第一个是映射到nginx的默认目录，使得当前的html页面就可以直接被nginx访问到。第二个是把主配置文件nginx.conf映射过去，第三个是子配置文件目录conf.d。我还是先把话说在前面了，这段代码是有问题的，不然也没必要特意开一篇文章：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_3.png" alt="img"></p>
<p>然后另一个问题又来了，那位博主是在宿主机也安装了nginx，所以他能直接拿现成的nginx.conf，conf.d来用，可我并没有。我可选的操作有：①直接上网，比如把博主的这两个配置文件下过来。②那就安装一次nginx。③把nginx image里的配置文件拿出来，然后改造。显然，前两种虽然也能解决问题，但有点蠢，显然不是最优解，第三种方法才是最合适的。用到的命令也很简单，首先启动container，然后进入container：（参数似乎不能乱）</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_4.png" alt="img"></p>
<p>然后就是复制文件的命令docker cp：（当时学的时候没看得是什么用处，现在彻底懂了）</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_5.png" alt="img"></p>
<p>于是成功把配置文件都拿出来了，然后呢？按照代码运行，出错，预期之内。下面是排错过程：</p>
<p>①把后面两个-v都去掉，看能否运行。结果是可以的，说明，错误确实就在后面两个-v的映射过程。</p>
<p>②加上后面的参数，又报错。这里值得一提的是，启动一般不会有报错信息，除非你把image名写错了，那么如何查看容器是否启动出错了？docker container ls -all。这可以列出所有的container，包括隐藏的container。而且有一项关键的属性是，status，可以根据该属性的值判断是否启动成功。当status为UP，说明容器启动成功。如果status是exited，说明启动了一下就退出，那自然就是出错了。还有一种情况，status是created，这也被我遇到了，直觉地想就是一直卡在了创建阶段，自然也是出错的时候。</p>
<p>③把所有的容器都关闭了，并且也删除了，再访问该IP地址（在这之前都是通过浏览器访问的），竟然还可行？这一点有点匪夷所思，因为container确实已经关闭了，甚至都已经删掉了，可在VNC的browser上却可以访问。一开始以为是缓存的问题，后来换成无痕浏览也有这个问题（换成无痕浏览倒是减少了这个情况）。这其实让我很无语，所以浏览器也不是万能的，它不仅卡，还可能本身就有问题！那么此时应该怎么办？curl。</p>
<p>④接下来就是具体地看代码哪里出错的地方了。首先有一个有趣的地方，目录映射是通过一个冒号完成的。然后冒号前后似乎不能加空格，加了会报错。（虽然直觉上不会，但我测试的时候，只有第一个-v，是应该可以正常运行的，可有空格就会报错，没有就不会报错，也许还有其他干扰我没注意到，但我懒得继续测试了）第二个错误的点，幸好我当时选择的是第三种解决方法，所以我刚刚进入了容器内部，查看了文件目录结构，我发现它的目录是 /etc/nginx/nginx.conf，而非/etc/nginx/nginx.conf:ro，这可能是版本的原因，也许以后还会变，但只要知道如何操作就行。同时由于我懒，我用的是参数”$PWD/…”，所以记得一定要在正确的目录调用该命令。不然后面就遇到了这种错误，我进入了conf.d目录，修改了配置文件，然后直接就在那里启动命令，PWD是错的，那么命令自然也会错了，最终的命令如下：（还是顺便提一下吧，”&quot;真的就是最简单的换行符而已，所以如果你喜欢，你可以全部写在一起，都是可行的，只是可读性不高）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker run \</span><br><span class="line"></span><br><span class="line"> --name myNginx \</span><br><span class="line"></span><br><span class="line"> -d -p 96:80 \</span><br><span class="line"></span><br><span class="line"> -v <span class="string">"<span class="variable">$PWD</span>/"</span>:/usr/share/nginx/html \</span><br><span class="line"></span><br><span class="line"> -v <span class="string">"<span class="variable">$PWD</span>/nginx.conf"</span>:/etc/nginx/nginx.conf \</span><br><span class="line"></span><br><span class="line"> -v <span class="string">"<span class="variable">$PWD</span>/conf.d/"</span>:/etc/nginx/conf.d  \</span><br><span class="line"></span><br><span class="line">nginx:my</span><br></pre></td></tr></table></figure>

<p>⑤这时候可以成功启动，通过docker container ls -all就可以看到status是UP。可是，还是乱码。关于配置文件的修改，我是在default.bak里增加了一行 charset: utf-8。结果，原来最后的原因就是错误三。我把整个容器重新关了删了再启动，然后无痕浏览，总算没有乱码了。至此，解决Docker中的nginx中文乱码问题到此解决。</p>
<p>⑥PS：中间还遇到一些非常weird的错误，比如WARNING: IPv4 forwarding is disabled. Networking will not work.原因可能是前面操作docker不当，导致“ default the ipv4 forwarding is not turned on in the image from docker to prevent any security vulnerabilities. ”即Docker处于安全考虑默认关闭该设置。解决方法是：<a href="https://blog.csdn.net/Kohang/article/details/85125054" target="_blank" rel="noopener">https://blog.csdn.net/Kohang/article/details/85125054</a> 好吧，实际上只要你上网搜一下上面的WARNING，你就会看到无数篇一模一样的解决方法。还好，这次是可行的答案，不然。</p>
<p>其实这个例子也不是简单的中文乱码问题，因为跟乱码相关的东西，其实就一行charset: utf-8。从这个例子中，学到的不仅仅是如何解决中文乱码，更多的是：如何获取container中的文件到宿主机，-v映射具体是什么，如何查看container是否正常运行等等。关于-v映射，我在修改default.conf的时候，先进行了备份：cp default.conf default.conf.bak，然后再对default.conf进行修改，如果出错了可以直接删掉，把default.conf.bak改回原名即可。最后我进入container内部查看的时候，发现对应的映射目录，存在的就是两个文件，default.conf和default.conf.bak。所谓的映射，其实就是把宿主机的文件放入容器的指定路径。</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_6.png" alt="img"></p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_7.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Debug</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON笔记</title>
    <url>/JSON%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>本篇文章是阅读《JSON必知必会》所做的笔记。虽然JSON的内容比较少，但做成记录也是极好的。</p>
<p>JSON是一种数据交换格式。JavaScript Object Notation</p>
<p>JSON独立于编程语言。</p>
<p>JSON需要用双引号包裹key-value。当值是字符串时，必须使用双引号。如果是<strong>数字，布尔值，数组，对象，null</strong>等其他数据类型，则不应该被双引号包裹。多个key-value之间用逗号来分割。</p>
 <a id="more"></a>

<p>可以在双引号内部使用单引号，空格等特殊字符(即英文数字以外的其他字符).但这不是一种好的选择，因为使用空格和特殊字符忽略了可移植性。</p>
<p>PS：JSON的key<strong>必须用双引号包裹</strong>。如果没有双引号，那这并不是一个JSON对象，而是一个JavaScript对象。而且在JavaScript中，可以使用单引号来代替双引号，但JSON必须使用双引号。</p>
<p>在传递数据时，需要提前告知接收方数据是什么类型，这就涉及到媒体类型。（又称，互联网媒体类型，内容类型Content-type，MIME类型）它使用”类型/子类型”这种格式来表示，比如text/html。</p>
<p>JSON的MIME类型是：application/json</p>
<p>JSON的对象数据类型可以嵌套。比如一个JSON可以作为另一个JSON的key-value</p>
<p>\用作转义。</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/json_1.png" alt="">          </p>
<p>（上面的例子： \n表示换行，而\n就是普通的字符串\n）</p>
<p>JSON的布尔类型只允许小写形式<strong>true或false</strong>。用1和0，TRUE,FALSE都会报错。</p>
<p>(PS：用1和0不是报错，但这时候变成了数字类型，而不是布尔类型。而用大写的TRUE跟FALSE，True等，则会直接报错) </p>
<p><strong>对于JSON的null属性，也必须是小写。（而且JSON没有undefined，那是JS的）</strong></p>
<p>JSON的数组类型，用[ ]包裹。数组的每一项用逗号隔开，而且，数组里可以是任意合法的JSON数据类型。比如同时具备字符串和数字。[“qqq”, 234, null, “rrr”]</p>
<p>但最好不要这样做，<strong>应该使得数组的每一项都是相同的数据类型</strong></p>
<p>（因为在大多数编程语言里，都是如此的。提高可移植性）</p>
<p>JSON Schema：定义JSON数据的数据要求。比如哪些字段是必填的，哪个字段有哪些要求，最大长度为多少，哪个字段必须是什么数据类型等等。</p>
<p>PS：JSON Schema同样需要用双引号包裹。</p>
<p>例子：</p>
<p> <img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/json_2.png" alt=""></p>
<p>这就是一个Schema文件。</p>
<p>在验证JSON的时候，JSON Schema Lint。</p>
<p>一方面输入JSON Schema，一方面输入JSON。</p>
<p>预防网络攻击：</p>
<p>1.JSON中存储的数组，应该放在对象中，使其成为非法的js，否则一个JSON只存储了一个数组，这时候它既是合法的JSON，也是合法的js，进行CSRF攻击则可以运行js，获取JSON里的敏感信息。CSRF，cross-site request forgery，（sea-surf）跨站请求伪造。</p>
<p>例子：不好的做法：(虽然最外面没加花括号，但它是合理的，这称为顶层JSON数组)</p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"user"</span>: <span class="string">"bobbarker"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"phone"</span>: <span class="string">"555-555-5555"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>正确的做法：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"info"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"user"</span>: <span class="string">"bobbarker"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"phone"</span>: <span class="string">"555-555-5555"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><em>XSS，cross-site scripting</em></strong>，跨站脚本攻击（注入攻击，通过向网站注入恶意代码来实现）</p>
<p>JSON是一个脚本，要代表对象再进行操作，需要将其转换成对象，并装入内存中。</p>
<p>在JavaScript中，使用eval( )函数可以将文本转换成对象。</p>
<p>当JSON被拦截并修改成恶意代码，用eval函数会直接变成调用JSON的脚本。比如JSON被修改成alert方法，eval方法本该是把JSON文本变成对象，但这里会直接调用了alert方法，即JSON如果被修改成一个脚本，eval方法就会变成执行该脚本。</p>
<p>正确的方法是，使用JSON.parse( )函数来替代eval。该函数仅会解析JSON，而不会执行脚本。所以如果JSON被修改成脚本，该parse就不会通过，报错并且不会执行脚本。</p>
<p>当用户之间的信息传递是用JSON传递的时候，必须要用eval，这个时候就可能出现，JSON里存在脚本，进行注入攻击。</p>
<p>可以使得信息中不能包含HTML，或者把HTML字符转码，比如把&lt;div&gt;转成&amp;lt;div&amp;gt;等</p>
<p>抵御注入攻击的关键：找出可能的注入点，并加入一些额外的步骤来加以防范。</p>
<p> JSON本身不构成什么威胁，它只是文本。</p>
<p><strong><em>在定位JSON安全问题的时候，应该记住以下三件事。</em></strong></p>
<p>①不要使用顶级数组。顶级数组是合法的Javascript脚本，它们可以用&lt;script&gt;标签链接并使用。</p>
<p>②对于不想公开的资源，仅允许使用HTTP POST方法请求，而不是GET方法。GET可以通过URL来请求，甚至可以放在&lt;script&gt;标签链接中。</p>
<p>③使用JSON.parse()来代替eval()。eval()函数会将传入的字符串编码并执行，这会使你的代码易被攻击。</p>
<p> 尽管Javascript的XMLHttpRequest对象看上去和XML有关，但实际上我们使用它来发起HTTP请求。在它包含XML的名字命名时，XML是在发起这类请求时最常用的数据交换格式。然而XMLHttpRequest并不仅限于使用XML，用于请求JSON是完全可以的。</p>
<p>从Web Api上获取JSON数据：（一个例子）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myXMLHttpRequest = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"http://api.openweathermap.org/data/2.5/weather?lat=35&amp;lon=139"</span>;</span><br><span class="line"></span><br><span class="line">myXMLHttpRequest.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myXMLHttpRequest.readyState === <span class="number">4</span> &amp;&amp; myXMLHttpRequest.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> myObject = <span class="built_in">JSON</span>.parse(myXMLHttpRequest.responseText);</span><br><span class="line">        <span class="keyword">var</span> myJSON = <span class="built_in">JSON</span>.stringify(myObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myXMLHttpRequest.open(<span class="string">"GET"</span>, url, <span class="literal">true</span>);</span><br><span class="line">myXMLHttpRequest.send();</span><br></pre></td></tr></table></figure>



<p>序列化：将对象转换成文本的过程。    反序列化：将文本转换成对象的过程</p>
<p>序列化：JSON.stringify( )                 反序列化：JSON.parse( )</p>
<p>浏览器一般对资源共享有限制，只允许来自同一域名的资源。</p>
<p>CORS，cross-origin resource sharing，跨域资源共享。</p>
<p>可以在响应头加上Access-Control-Allow前缀的属性，来控制，哪些HTTP方法可用，哪些域名可用等等。（在对抗CSRF时，设置只允许POST，则避免了CSRF的恶意GET方法。而且设置只允许同一域名可以获取资源，这样可以避免外部获取资源）</p>
<p>CORS,JSON-P</p>
<p> JSONP（JSON with Padding）是资料格式JSON的一种使用模式，可以让网页从别的网域索要资料。由于同源策略，一般来说位于server1.example.com的网页无法与不是server1.example.com的服务器沟通，而HTML的&lt;script&gt;元素是一个例外。利用&lt;script&gt;元素 的这个开放策略，网页可以得到从其他来源动态产生的JSON资料，而这种使用模式就是所谓的JSONP。用JSONP抓到的资料并不是JSON，而是任意的JavaScript，用JavaScript直译器执行而不是用JSON解析器解析。</p>
<p>JSON-P的padding（内联），就是将JavaScript加入JSON文档。如：</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">getTheAnimal(</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="attr">"animal"</span>: <span class="string">"cat"</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>内联于JSON文档的JavaScript调用了一个函数，函数参数是JSON。函数参数提供了一个将数据传递给函数的方式。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>docker笔记</title>
    <url>/docker%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>记录docker学习的笔记。本文主要是参考了阮一峰的Docker教程，：<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html。在阅读完这篇Docker教程的过程中所做的笔记，用我自己的语言整理了一遍。" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html。在阅读完这篇Docker教程的过程中所做的笔记，用我自己的语言整理了一遍。</a></p>
<a id="more"></a>

<h3 id="Docker出现的原因，解决了哪些问题，如何解决的，有哪些应用？"><a href="#Docker出现的原因，解决了哪些问题，如何解决的，有哪些应用？" class="headerlink" title="Docker出现的原因，解决了哪些问题，如何解决的，有哪些应用？"></a>Docker出现的原因，解决了哪些问题，如何解决的，有哪些应用？</h3><p>软件开发的一个大难题，就是环境配置，经常出现各种因为环境配置而出现的错误。（我相信你在编写maven项目的时候就已经被各种依赖包的版本给困扰到了，环境变量同样如此）比如安装一个python应用，计算机必须要有python引擎，还要有各种依赖，可能还要配置环境变量。除此之外，随着软件的迭代还有运行环境的升级，一些老旧的模块可能与当前环境不兼容。开发者常常会说：“它在我的电脑上是没有问题的”（It works on my machine)，换言之，在其他电脑能不能运行，我不确定，我也不想管。环境变量如此麻烦，换一台机器就要重来一次，十分浪费时间。于是有人在想，能不能从根本上解决问题，比如软件可是带着环境变量一起安装？也就是说，在安装的时候，把原始环境一模一样地复制过来。</p>
<p>一种可行的解决方法，虚拟机。直接去现场对机器进行配置，或者去客户家配置电脑环境，并不现实，但使用虚拟机就可以达到模拟运行系统的效果，直接把开发时的最终环境一起打包，就可以彻底还原软件的原始环境。</p>
<p><strong>但这个方案存在一些缺点：</strong></p>
<p>①资源占用多。一个虚拟机是需要一定的内存和磁盘空间的，所以即使你的项目只有1MB，续集你依然要几百MB才能运行。</p>
<p>②冗余步骤多。一个虚拟机是一个完整的操作系统，所以一些系统级别的操作步骤，往往都不能跳过，比如用户登录。</p>
<p>③启动慢。启动的时候就跟启动一台电脑的时间一样。</p>
<p><strong>显然，为了保存运行环境，直接copy一个虚拟机，并不可取，因为我们需要的只是一些必要的环境变量，一些组件，而非一个彻底完整的操作系统。</strong>所以，我们需要的是一个虚拟的“小型虚拟机”，里面只包含我们的程序所需要的组件即可。这种东西就叫做：Linux容器(Linux Containers,LXC)</p>
<p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。因为的进程级别的，相比虚拟机就有很多的优势，比如：启动快，资源占用少，体积小。因为它只需要占用需要的资源，包含要用到的组件。总而言之，有点像轻量级的虚拟机。</p>
<p>Docker，就是一种LXC的封装，提供了简单易用的容器使用接口。Dockers将应用程序与该程序的依赖，一起打包在一个文件里面(image)。运行这个文件，就会生成一个虚拟容器(container)。程序在这个虚拟容器里运行，就好像在真实的物理机器上运行。有了Docker就无须担心环境问题。用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理，复制，分享，修改，就像管理普通的代码一样。</p>
<p><strong><em>Docker的主要用途：</em></strong></p>
<p>①提供一次性的环境。无论是开发环境，单元测试环境，还是其他，都可以轻松提供。</p>
<p>②提供弹性的云服务。因为Docker容器可以随开随关，很适合动态扩容和缩容。</p>
<p>③组建微服务架构。容器可以存放多个服务，还有它们的各种依赖。所以一台机器就可以跑多个服务，在本机就可以模拟出微服务架构。</p>
<h3 id="Docker重要概念："><a href="#Docker重要概念：" class="headerlink" title="Docker重要概念："></a>Docker重要概念：</h3><p>image文件：Docker把应用程序及其依赖，都打包在image文件里面。一个image文件可以通过继承另一个image文件，进行拓展。这是一个二进制文件</p>
<p>container：容器文件，通过image文件生成的实例，本身也是一个文件，称为容器文件。</p>
<p>（二者的关系，image就像class，container就像是具体的对象）</p>
<p>Dockerfile：它是一个文本文件，用于配置image。Docker根据该文件生成二进制的image文件（也就是说，我们要生成image文件，实际上是通过生成Dockerfile文件来指定依赖）</p>
<p>(而且，Dockerfile的文件名必须就叫Dockerfile，这样也使得后续用Dockerfile构建image的时候，直接指定Dockerfile的路径即可，那个参数是【path】，所以无法指定具体的文件名）</p>
<p>编写Dockerfile文件的过程：</p>
<p>1.在项目的根目录，新建一个文件 .dockerignore    (就是忽略的路径），（可选）</p>
<p>.git node_modules npm-debug.log</p>
<p>2.创建一个文本文件Dockerfile，写入：    （举例）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">FROM node:8.4 COPY . /app WORKDIR /app RUN npm install --registry=https://registry.npm.taobao.org EXPOSE 3000</span><br><span class="line"></span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure>
<p>每一行的含义：</p>
<p>FROM：表明要继承哪个image，这里继承的官方的node image，版本号是8.4（默认library/…)</p>
<p>COPY：将当前目录下的所有文件，（除了.dockerignore里提到的），都copy到image文件里的/app目录</p>
<p>WORKDIR：指定工作路径</p>
<p>RUN……：启动成功之后会运行的命令，这里是运行npm install安装依赖</p>
<p>EXPOSE：将容器暴露特定的端口号，允许外部连接这个端口</p>
<p>CMD：在容器成功启动后，会自动执行该命令</p>
<p>（ps：RUN和CMD有什么区别？RUN命令是在image文件的构建阶段执行，执行的结果都会打包进入image文件。而CMD命令则是在容器启动成功后执行。另外，一个dockerfile可以包含多个RUN命令，但只能有一个CMD命令。同时，指定了CMD命令之后，docker container run命令就不能附加命令，否则它会覆盖掉CMD命令，也就是docker run的CMD命令把dockerfile里的覆盖了。）</p>
<h3 id="Docker常用命令："><a href="#Docker常用命令：" class="headerlink" title="Docker常用命令："></a>Docker常用命令：</h3><p>①列出本机的所有image</p>
<p><code>docker image ls    /     docker images</code></p>
<p>删除image文件</p>
<p><code>docker image rm 【imageName】</code></p>
<p>从Docker仓库抓取具体image到本地（默认是官方仓库，可配置国内的镜像文件）</p>
<p><code>docker image pull 【path/.../imageName】</code>    （前面默认的path是 library/，是官方仓库的默认组）</p>
<p>②通过image生成container实例，并运行该实例</p>
<p><code>docker container run 【imageName】</code>        （如果本地无法找到，会自动去仓库抓取，即pull）</p>
<p>列出本地的container：</p>
<p><code>docker container ls    [ -all ]        /    docker ps</code></p>
<p>删除container：    </p>
<p><code>docker container rm 【containerID】</code></p>
<p>docker container run的一些参数：</p>
<p>例子：<code>docker container run -p 8000:3000 -it koa-demo /bin/bash</code></p>
<p>-p：容器的3000端口，映射到本机的8000端口</p>
<p>-it：容器的Shell映射到当前的Shell，然后你在本机窗口输入的命令，就会传入容器中</p>
<p>/xxx：容器启动之后，内部第一个执行的命令。这里是启动Bash，保证用户可以使用Shell</p>
<p>退出容器：先ctrl+c停止进程，在ctrl+d退出容器。</p>
<p><code>docker contain kill</code>：终止容器运行</p>
<p>退出之后，容器文件并不会删除，所以需要手动rm，但应该删除，下次再由image创建。可以在运行时增加一个参数–rm，表明容器终止运行后自动删除容器文件。</p>
<p>③使用Dockerfile文件，创建image文件：</p>
<p><code>docker image build -t xxx .</code>(docker image build，-t表明image文件的名字，  “.”表示当前路径）</p>
<p>（xxx可以指定版本号，格式为 xxx:yyy，放在冒号之后。如果不指定版本号，默认为latest）</p>
<p>（ps：   docker image build == docker build）</p>
<p>④一些有用的命令</p>
<p><code>docker container start</code></p>
<p>（docker container run命令是新建容器，每运行一次，就会新建一个容器，如果同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器（当然，没有–rm参数了），那么就要使用docker container start命令，用于启动已经生成，已经停止运行的容器文件。</p>
<p><code>docker container stop</code></p>
<p>（docker contain kill是向容器里面的主进程发出SIGKILL信号，而docker container stop是发出SIGTERM信号，然后过一段时间再发出SIGKILL信号。这两个信号的的差别是，如果进程收到SIGTERM信号，可以自行进行收尾清理工作，但也可以不理会这个信号。而如果收到SIGKILL信号，就会强行立即终止，那么正在进行中的操作会全部丢失。也就是说，kill是强制性立即关闭，而stop会给一定的时间让container把收尾工作完成，如果超出一定时间后还没完成收尾，那么才强制结束）</p>
<p><code>docker container logs</code></p>
<p>用于查看容器的输出，即容器里Shell的标准输出。如果容器docker run的时候没有使用-it参数，就要用这个命令查看输出。（或者是显式指定要运行在后端的时候）</p>
<p><code>docker container exec</code></p>
<p>docker container exec命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令.</p>
<p><code>docker container cp</code></p>
<p>用于从正在运行的Docker容器里面，将文件拷贝到本机。</p>
<p>写法：<code>docker container cp 【containerID】:【/path/to/file】</code></p>
<p>-—-</p>
<h3 id="实例：使用Docker架设WordPress网站（需要WordPress容器和MySQL容器）"><a href="#实例：使用Docker架设WordPress网站（需要WordPress容器和MySQL容器）" class="headerlink" title="实例：使用Docker架设WordPress网站（需要WordPress容器和MySQL容器）"></a>实例：使用Docker架设WordPress网站（需要WordPress容器和MySQL容器）</h3><p>方法一：自己自建WordPress容器</p>
<p>步骤：</p>
<p>①通过官方的PHP image，构建一个PHP container    例子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">--rm \							// 停止运行后，自动删除容器文件</span><br><span class="line">--name wordpress \				// 容器的名字  </span><br><span class="line">--volume <span class="string">"<span class="variable">$PWD</span>/"</span>:/var/www/html \	</span><br><span class="line">// 将当前目录（<span class="variable">$PWD</span>)映射到/var/www/html（即Apache对外访问的默认目录）  </span><br><span class="line">php:5.6-apache			// image名，说明装的是PHP 5.6版本，并且自带apache服务器</span><br></pre></td></tr></table></figure>

<p>②之后在当前目录下创建的文件，都会直接被Apache服务器提供给外界访问，所以直接把WordPress安装包拷贝到此处，就可以通过容器访问到WordPress的安装界面</p>
<p>所以这一步很简单，wget下载，然后tar -xvf解压即可。</p>
<p>（遇到的小问题，由于太多国人使用WordPress了，大概是导致别人服务器都炸了，于是WordPress已经默认屏蔽了大陆的IP，所以直接wget是不可行的。解决就是在windows自己找资源，再传）</p>
<p>③使用MySQL image来构建MySQL container，例子：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">-d \  </span><br><span class="line">--rm \  </span><br><span class="line">--name wordpressdb \  </span><br><span class="line">--env MYSQL_ROOT_PASSWORD=123456 \ </span><br><span class="line">--env MYSQL_DATABASE=wordpress \  </span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure>

<p>每行参数的含义：</p>
<p>-d：容器启动后，在后台运行（这时候要查看输出就需要用logs</p>
<p>–rm， –name：自动删除，容器名</p>
<p>–env：向容器进程传入一个环境变量MYSQL_ROOT_PASSWORD，该变量会作为MySQL的根密码，同时还传入一个MYSQL_DATABASE，容器里面的MySQL会根据该变量创建一个同名的数据库</p>
<p>④定制Container，也就是Dockerfile</p>
<p>此时WordPress容器和MySQL容器都已经有了，但二者并没有链接到PHP Container中。我们需要先在PHP image的基础上，安装mysqli的拓展，然后启动Apache。Dockerfile文件如下：</p>
<p><code>FROM php:5.6-apache RUN docker-php-ext-install mysqli CMD apache2-foreground</code></p>
<p>然后再基于Dockerfile创建一个image文件（包含了mysqli拓展的PHP image）</p>
<p><code>docker build -t phpwithmysql .</code>    （该image文件名为phpwithmysql）</p>
<p>⑤WordPress容器链接mysql</p>
<p>PHP container已经增加了mysqli的拓展，而对于WordPress，在启动的时候连接即可。启动命令如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">--rm \  </span><br><span class="line">--name wordpress \  </span><br><span class="line">--volume <span class="string">"<span class="variable">$PWD</span>/"</span>:/var/www/html \		// --volume  == -v  </span><br><span class="line">--link wordpressdb:mysql \					  </span><br><span class="line">phpwithmysql</span><br></pre></td></tr></table></figure>

<p>新加的那行，表示WordPress容器要连接到wordpressdb容器，冒号表示该容器的别名为mysql。最后还要修改一下wordpress目录的权限，让容器可以将配置信息写入这个目录（/var/www/html)</p>
<p><code>chmod -R 777 wordpress</code></p>
<p>接着，在启动PHP container的时候，命令行会返回一个对外开放的IP地址，比如172.17.0.2,直接访问即可出现WordPress的安装界面。</p>
<p>总结：PHP image（web server） + wordpress.tar.gz(到/var/www/html) + mysql链接</p>
<p>方法二：</p>
<p>方法一需要自己创建WordPress容器，还是有点麻烦，实际上Docker已经提供了官方的WordPress image，直接用那个即可。</p>
<p>步骤：</p>
<p>①新建并启动MySQL Container（跟方法1一样）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">-d \  </span><br><span class="line">--rm \  </span><br><span class="line">--name wordpressdb \  </span><br><span class="line">--env MYSQL_ROOT_PASSWORD=123456 \  </span><br><span class="line">--env MYSQL_DATABASE=wordpress \  </span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure>

<p>②然后基于官方的WordPress image，创建WordPress Container</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">-d \  --rm \  </span><br><span class="line">--name wordpress \  </span><br><span class="line">--env WORDPRESS_DB_PASSWORD=123456 \  </span><br><span class="line">--link wordpressdb:mysql \ </span><br><span class="line">wordpress</span><br></pre></td></tr></table></figure>

<p>（方法一，我们需要给php image增加mysqli拓展，然后启动php container，作为我们自己创建的WordPress image，然后再link数据库，实际上，直接一个wordpress即可（调用官方Docker）</p>
<p>但是，上面指定了-d，也就是在后台运行，所以前台看不到输出，此时需要inspect命令查看输出。</p>
<p><code>docker container inspect wordpress</code></p>
<p>找到IPAddress字段，那就是对外开放的IP地址，直接访问即可。</p>
<p>此时虽然用了官方的WordPress image，简化了很多不必要的步骤，但还是存在一些问题。比如，每次新建容器，返回的IP地址不能保证相同，导致需要更换IP地址来访问WordPress。WordPress安装在容器里面，本地无法修改文件。解决方法如下:</p>
<p>创建WordPress Container的命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">-d \  </span><br><span class="line">-p 127.0.0.2:8080:80 \  </span><br><span class="line">--rm \  </span><br><span class="line">--name wordpress \  </span><br><span class="line">--env WORDPRESS_DB_PASSWORD=123456 \  </span><br><span class="line">--link wordpressdb:mysql \  </span><br><span class="line">--volume <span class="string">"<span class="variable">$PWD</span>/wordpress"</span>:/var/www/html \  </span><br><span class="line">wordpress</span><br></pre></td></tr></table></figure>
<p>只新加了两行参数：</p>
<ul>
<li>-p 127.0.0.2:8080:80：将容器的 80 端口映射到127.0.0.2的8080端口。</li>
<li>–volume “$PWD/wordpress”:/var/www/html：将容器的/var/www/html目录映射到当前目录的wordpress子目录。</li>
</ul>
<p>这样我们就固定了IP地址，同时还指定了一下端口的映射，还有容器的文件目录映射。（容器会把文件默认放到Apache的默认路径，然后再映射到wordpress子目录，使得本地也可以修改文件）</p>
<p>方法三：</p>
<p>方法二主要是，分别启动两个容器，然后在启动时，在命令行里提供容器之间的连接信息。还有一种更简单的方法，就是使用Docker Compose。关键点：定义一个YAML格式的配置文件，在里面写好多个容器之间的调用关系，只需要一个命令就可以同时启动/关闭这些容器。</p>
<p>步骤：</p>
<p>①安装，pass</p>
<p>②创建yml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mysql:</span>    </span><br><span class="line">	<span class="attr">image:</span> <span class="string">mysql:5.7</span>    </span><br><span class="line">	<span class="attr">environment:</span>     </span><br><span class="line">		<span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span>     </span><br><span class="line">		<span class="bullet">-</span> <span class="string">MYSQL_DATABASE=wordpress</span> </span><br><span class="line"><span class="attr">web:</span>    </span><br><span class="line">	<span class="attr">image:</span> <span class="string">wordpress</span>    </span><br><span class="line">	<span class="attr">links:</span>     </span><br><span class="line">		<span class="bullet">-</span> <span class="string">mysql</span>    </span><br><span class="line">	<span class="attr">environment:</span>     </span><br><span class="line">		<span class="bullet">-</span> <span class="string">WORDPRESS_DB_PASSWORD=123456</span>    </span><br><span class="line">	<span class="attr">ports:</span>    </span><br><span class="line">    	<span class="bullet">-</span> <span class="string">"127.0.0.3:8080:80"</span>    </span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/var/www/html</span>    </span><br><span class="line">    <span class="attr">volumes:</span>     </span><br><span class="line">    	<span class="bullet">-</span> <span class="string">wordpress:/var/www/html</span></span><br></pre></td></tr></table></figure>

<p>（显然，一个是mysql容器，一个是web容器）</p>
<p>启动：<code>docker-compose up</code>        （同时启动两个容器，此时就可以访问127.0.0.3到安装界面）</p>
<p>关闭：<code>docker-compose stop</code></p>
<p>关闭之后，容器文件还是存在的，写在里面的数据也不会丢失。下次再启动的时候，还可以复用。如果要删除，需要先暂停两个容器，然后调用删除命令：</p>
<p><code>docker-compose rm</code></p>
<p>首先是自定义image，然后启动，连接。后续的改进是，可以直接用官方或者别人写好的image来进行启动，连接。最后的方法是，直接使用docker-compose，不需要在启动命令的时候写一堆参数，直接写到yml文件里即可，同时还能保存容器信息，进行复用。自此，Docker的基本示例到此结束。</p>
<p>参考：<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p>
<p>PS：    （很多情况下可以省略image ， container等关键字）</p>
<p>docker image build  == docker build</p>
<p>docker container run == docker run（即使是run image，也是构建出container）</p>
<p>docker container rm = docker rm</p>
<p>docker container stop = docker stop</p>
<p>进入容器，除了exec，还可以用attach：</p>
<p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_8.png" alt="img"></p>
<p>删除所有容器（包括已经结束了的）：</p>
<p><code>docker rm -f $(docker ps -a -q)</code></p>
<p>删除所有image：</p>
<p><code>docker rmi -f $(docker images)</code></p>
<p>导出容器为压缩包：</p>
<p><code>docker export 【options】 container_id &gt; xxx.tar</code>    (&gt; xxx其实不是必须的）</p>
<p>导入容器：</p>
<p><code>docker import xxx.tar container_name</code></p>
<p>Dockerfile一些常用指令：</p>
<p>FROM：表示基本的image（一般是Docker Hub或者其他仓库别人制作好的image），在此基础上进行修改调整。FROM必须在其他指令之前。</p>
<p>RUN：启动成功之后会执行的命令</p>
<p>CMD：容器启动成功之后执行的（区别上面看RUN与CMD的区别，记住多条CMD只会执行一条，所以如果启动时docker run存在CMD命令，那么会直接把Dockerfile的CMD命令全部忽略掉）</p>
<p>ADD：添加源文件到目的路径。如果路径不以斜杠结尾，被视为文件。如果源文件是可识别的压缩包格式，docker还会自动解压</p>
<p>ARG：设置构造参数    ENV：设置环境变量</p>
<p>（ARG与ENV的区别：ARG设置的是构建时的环境变量，在容器运行时是不会存在这些变量的。ENV主要就是运行时的环境变量）</p>
<p>COPY：与ADD类似，但不支持URL和压缩包（ADD除了文件，还可以是URL或压缩包）</p>
<p>EXPOSE:声明暴露的端口</p>
<p>LABEL：为镜像添加元数据metadata</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码阅读</title>
    <url>/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html</url>
    <content><![CDATA[<h3 id="一-前言："><a href="#一-前言：" class="headerlink" title="一. 前言："></a>一. 前言：</h3><p>​        在准备面试的过程中，发现HashMap源码是很常见的考点，于是进行了仔细的学习。以前都说读源码是快速提高Java水平的好途径，在阅读了HashMap的部分重要源码之后真的是深有体会，于是写下此篇文章做记录。具体内容包括，HashMap的构造方法，put，get方法，以及put&amp;get所需要的hash方法，还有扩容时所需要的resize方法。我们将对这几个方法的源码进行阅读，理解它的逻辑，以及一些巧妙的设计。</p>
<a id="more"></a>

<h3 id="二-HashMap原理："><a href="#二-HashMap原理：" class="headerlink" title="二. HashMap原理："></a>二. HashMap原理：</h3><p>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。<br><strong>常用的方法有</strong>：<br>构造方法，可以定义initialCapacity初始容量，factor负载因子。<code>threshold = initialCapacity * factor</code><br>put，get，二者需要用到hash方法，也就是散列函数。<br>resize：放数组容量不足时，元素个数大于threshold时，就要扩容。<br>HashMap使用数组链表来存储数据（数组的每一项都是一个链表），JDK1.8开始，当链表的长度到达一定程度，就会把该链表转换成红黑树。</p>
<hr>
<h3 id="三-①-构造方法："><a href="#三-①-构造方法：" class="headerlink" title="三. ① 构造方法："></a>三. ① 构造方法：</h3><p>构造方法一共有4个：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_1.png" target="_blank" rel="noopener" title="HashMap构造方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_1.png" alt="HashMap构造方法" title="HashMap构造方法"></a><br>显然，第一个就是没有参数，此时会设置默认的负载因子factor。<br>对于第二个，实际上就是将float参数设置为默认的负载因子default_factor。<br>对于第四个，是传入一个Map对象进行初始化。我们重点看第三个构造方法：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_2.png" target="_blank" rel="noopener" title="第三个构造方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_2.png" alt="第三个构造方法" title="第三个构造方法"></a><br>前面的都是判断一下边界值，就省略了。<br>HashMap有几个关键的成员属性：<br><strong>initialCapacity</strong>：初始容量大小（数组大小，但后面会改变）<br><strong>factor</strong>：负载因子<br><strong>threshold</strong>：initialCapacity * factor（到达这个值的时候，哈希数组会扩容）<br>（初始化之后，后续用size表示哈希数组里的元素个数，当size超过threshold之后，扩容）<br>然后我们发现一行关键的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br></pre></td></tr></table></figure>

<p>点进入看<em>tableSizeFor</em>的函数逻辑：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_3.png" target="_blank" rel="noopener" title="tableSizeFor"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_3.png" alt="tableSizeFor" title="tableSizeFor"></a><br>可以看到这个方法的目的：<strong>returns a power of two size for the given target capacity</strong></p>
<p>也就是说，<strong>哈希数组的长度，永远是2的幂次方</strong>，至于为什么，请看后面的<strong>question1</strong>.<br>关于这个算法的逻辑，用下图可以说明：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_4.png" target="_blank" rel="noopener" title="tableSizeFor算法的逻辑"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_4.png" alt="tableSizeFor算法的逻辑" title="tableSizeFor算法的逻辑"></a><br>连续的n |= n &gt;&gt;&gt; 1, 2, 4, 8, 16，通过这样，最多可以让连续32位为1.不管capacity是多少，比如它是1011，减去1之后是1010，第一个不为0的位是第4位，那么这个算法会返回10000.<br>（这里的关键是<strong>或运算</strong>，因为第一位是1，1和任何数字进行或运算都为1，因此，n&gt;&gt;&gt;1，会使得n的前2位变为2，然后再执行n&gt;&gt;&gt;2，就是前4位，再执行n&gt;&gt;&gt;4，就是前8位。）如果数字没有那么高位，那么高位全是0，并且n&gt;&gt;&gt;x全部都为0，因而或运算为0，高位没有任何影响，看下图例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_5.png" target="_blank" rel="noopener" title="高位运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_5.png" alt="高位运算" title="高位运算"></a><br>这个算法，巧妙地通过了位运算，返回了一个不小于capacity 的最小2的幂次方。至于为什么要-1，是防止capacity已经是2的幂次方的情况，比如是10000，如果不减1，那么返回的将会是100000.减去1，使得初始的capacity改为1111（1111和1001，1101等都是一样的）。<br>以上的情况都是在capacity不为0的情况考虑的，而当capacity为0的时候，无论经过几次运算，都为0，那么最后的capacity将为1（最后有一个n+1的操作），所以也是符合预期结果的。<br>这样，我们就得到了一个2的幂次方的capacity，即哈希数组的长度（所以比如，当我们传入的capacity为12，最终生成的数组长度会是16.）<br>结果：<br> // 如果没有指定initialCapacity, 则不会给threshold赋值, 该值被初始化为0<br> // 如果指定了initialCapacity, 该值被初始化成不小于initialCapacity的最小的2的次幂</p>
<hr>
<h3 id="四-②put方法："><a href="#四-②put方法：" class="headerlink" title="四. ②put方法："></a>四. ②put方法：</h3><p>可以看到，put方法其实还有两个参数，但put方法并没有重载方法，所以如果我们需要改变后两个参数，应该使用putVal方法自己修改，但一般不需要，在下文看putVal的方法里我们就知道着两个参数是什么作用了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接下来关键是看putVal的方法实现：（逐行分析，中文注释）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;			</span><br><span class="line"><span class="comment">//创建一些后面需要的变量，略</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;	</span><br><span class="line"><span class="comment">//如果哈希数组为空，即还没初始化，先resize一次，resize后面再看，这里只需要知道</span></span><br><span class="line"><span class="comment">//会创建一个默认长度的哈希数组即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)	</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//如果哈希数组该index没有元素，即没有发生碰撞，直接插入一个newNode即可。</span></span><br><span class="line"><span class="comment">//这里的(n - 1) &amp; hash的原理，查看后面的question2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;	<span class="comment">//说明已经有元素，发生了碰撞，然后我们就沿着链表/红黑树去插入Node</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">//我们首先会查看第一个元素（在第一个元素时就能确定它是链表还是数组）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;	</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"><span class="comment">//这里的p是上文的p = tab[i = (n - 1) &amp; hash]，即第一个元素，如果第一个元素跟待插入</span></span><br><span class="line"><span class="comment">//的元素是相同的，即key相同（hash肯定是已经相同的了），然后我们只需要更改p的值</span></span><br><span class="line"><span class="comment">//即可。这里的逻辑是，把p赋值给新创建的Node e，然后跳出整个循环之后，再判断e</span></span><br><span class="line"><span class="comment">//是否位null，如果e为null，那么直接进行value的替换即可，否则，往后看。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="comment">//判断该index项是链表还是红黑树，如果是红黑树再进入putTreeVal，此处略</span></span><br><span class="line">        <span class="keyword">else</span> &#123;	</span><br><span class="line"><span class="comment">//说明是链表，并且第一个元素也不相等，所以我们就遍历链表，然后插入到链表的最</span></span><br><span class="line"><span class="comment">//后，并且，如果链表长度过长，还会引起链表树化的操作。如果是整个数组的长度过</span></span><br><span class="line"><span class="comment">//大，那么还要对数组进行resize。（PS：这里的元素相等是指key，链表里的key都是互</span></span><br><span class="line"><span class="comment">//不相等的，只是它们发生hash冲突导致都放在数组的同一个index上。所以如果在中间</span></span><br><span class="line"><span class="comment">//发现了相同的key，那么就跟前面一样，其实也是e = p的逻辑，然后在后续直接覆盖</span></span><br><span class="line"><span class="comment">//value即可。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;		</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//p.next为null，那么直接将p.next新建一个newNode即可。即已经到达链表的最后。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line"><span class="comment">//这是指链表长度大于等于TREEIFY_THRESHOLD的时候，进行树化。默认是8.注意这</span></span><br><span class="line"><span class="comment">//里为什么是&gt;= THREIFY_THRESHOLD，看起来是7个就可以树化，但实际上还是8个</span></span><br><span class="line"><span class="comment">//的。具体的看后面的question4.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="comment">//如果遇到了相等的key，那么就是覆盖value。注意此时并未到链表的最后，所以这里的</span></span><br><span class="line"><span class="comment">//e不等于null。而上面的(e = p.next) == null，上面逻辑的e会是null。这个e后面马上用到</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line"><span class="comment">//这里的p = e实际上就是 p = p.next，因为并没有执行for循环里的两个if，如果执行了其</span></span><br><span class="line"><span class="comment">//中一个，都会直接break跳出循环。（个人觉得这个p = e放在for判定语句里可读性更好</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="comment">//这就是前面一直说的e，如果存在相同的key，那么e就不是null，此时直接覆盖value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">//这就是第三个参数，表示已有相同的key时是否更新。onlyIfAbsent默认是false，所以这</span></span><br><span class="line"><span class="comment">//里的if是一定会触发，即一定会覆盖value。如果手动将onlyIfAbsent改为true，那么就是</span></span><br><span class="line"><span class="comment">//只有当oldValue为null的时候，才能改变key的value，否则都不会改变。</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);	</span><br><span class="line"><span class="comment">//这个在HashMap是空方法，在LinkedHashMap的时候才会被重写并使用。</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="comment">//覆盖了value（或者不覆盖），就把oldValue返回，方法结束。因此插入一个相同key的</span></span><br><span class="line"><span class="comment">//元素，实际上是更新该key的value，方法的逻辑在这里已经完成，不会改变HashMap的</span></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	<span class="comment">//最外层的if-else循环结束</span></span><br><span class="line">    ++modCount;</span><br><span class="line"><span class="comment">//到达了这里，说明不存在相同的key，所以插入了一个新的key，改变modCount以及</span></span><br><span class="line"><span class="comment">//哈希数组的元素个数size</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line"><span class="comment">//如果改变了之后，哈希数组的元素个数大于threshold，此时发生碰撞的概率较大，因此</span></span><br><span class="line"><span class="comment">//进行resize，即对哈希数组进行扩容，后面会讲到。</span></span><br><span class="line">    afterNodeInsertion(evict);	<span class="comment">//同样是LinkedHashMap的东西，此处为空方法。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主要是这么几个步骤：</strong><br><strong><em>①如果当前table为空，先进行初始化</em></strong><br><strong><em>②查找插入的键值对是否存在，存在的话，先进行赋值，后续将更新旧的键值对</em></strong><br><strong><em>③不存在，插入链表尾部，如果链表长度大于一个阈值，进行链表转化树的操作</em></strong><br><strong><em>④如果size大于一个阈值，进行扩容</em></strong><br>PS：threshold在初始化的时候，值为2的幂次方（在tableForSize那里可以看到），但threshold应该是capacity * factor，当size大于threshold的时候才执行resize。那么会不会因此而导致初始化的时候threshold并不受factor的影响？<br>（比如我们初始化的时候，capacity传参是10，factor是0.75，在tableForSize里，我们知道threshold会被赋值为不小于10的2的幂次方，即16.然后根据put的逻辑，应当是++size &gt; threshold的时候才扩容，那么初始化的threshold是16，而不是预期的值16 * 0.75 = 12？）<br>实际上并不是的，上面的threshold实际上就不应该是哈希数组的长度（所以JDK源码在构造方法里，把2的幂次方赋值给threshold确实有迷惑的意思）。在put方法的第一个步骤，即“如果当前table为空，先进行初始化”。那么我们再看一下这一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">   		 n = (tab = resize()).length;</span><br></pre></td></tr></table></figure>

<p>当table为空，那么要先resize，即数组是在这里才进行建立的。在resize里面，是把threshold赋值给了另一个叫newCap的变量（看变量名可知，显然就是新的哈希数组的长度），然后threshold又会被改变为newCap * factor。所以threshold虽然确实是2的幂次方，但确实并不是代表哈希数组的长度，仍然是作为扩容的判断点（<strong>虽然是个无聊的问题，但感觉是JDK源码的变量具有迷惑性！</strong>）至于resize的源码，继续看。</p>
<hr>
<h3 id="五-③get"><a href="#五-③get" class="headerlink" title="五. ③get"></a>五. ③get</h3><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_6.png" target="_blank" rel="noopener" title="get方法的源码"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_6.png" alt="get方法的源码" title="get方法的源码"></a><br>get方法显然简单很多。<strong>首先判断是否存在该key，如果不存在，返回null。</strong><br>getNode的逻辑体也是比较简单，先查找第一个元素，看key值是否相等。至于为什么需要“always check first node”，显然，因为<strong>JDK1.8可能是链表，可能是红黑树，需要进行判断</strong>。<br>如果当第一个first就是相等的，那么就直接返回。如果不在，判断是否是红黑树，如果是，使用另一套逻辑，如果不是，就是简单的链表遍历，对比，e = e.next，应该很好理解，此处略。</p>
<hr>
<h3 id="六-④hash"><a href="#六-④hash" class="headerlink" title="六. ④hash"></a>六. ④hash</h3><p>首先给出<strong>HashMap计算哈希码的整体步骤</strong>：<br><strong><em>1.获取key的hashCode</em></strong><br><strong><em>2.对hashCode进行处理（hash方法），主要是高16位不变，而低16位与高16位进行异或操作</em></strong><br><strong><em>3.对capacity进行取模（使用了 hash &amp; (n - 1)进行优化）</em></strong><br>在put和get方法中，可以看到都需要对key进行hash运算：</p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_7.png" target="_blank" rel="noopener" title="put方法的hash运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_7.png" alt="put方法的hash运算" title="put方法的hash运算"></a></p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_8.png" target="_blank" rel="noopener" title="get方法的hash运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_8.png" alt="get方法的hash运算" title="get方法的hash运算"></a></p>
<p>因为<strong>hashcode就是为了HashMap而生的</strong>，在学习重写equals时为何要重写hashCode的时候我们就已经知道了。那么HashMap里到底如何重写hashCode方法呢，如下：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_9.png" target="_blank" rel="noopener" title="HashMap中的hashCode方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_9.png" alt="HashMap中的hashCode方法" title="HashMap中的hashCode方法"></a><br>嗯。。。很简单的异或运算，结合了key和value的hashCode，没什么特别的。结合value同样是减少碰撞。这个就是步骤1.</p>
<p>那么接下来看一下步骤2，HashMap自定义的hash方法：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_10.png" target="_blank" rel="noopener" title="HashMap中自定义的hash方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_10.png" alt="HashMap中自定义的hash方法" title="HashMap中自定义的hash方法"></a><br>从逻辑上看，就是hash本身与hash右移16位的结果进行异或。<br>h &gt;&gt;&gt; 16的结果：高16位全部变成0，原本高16位的处于低16位。<br>h ^ ( h &gt;&gt;&gt; 16)的结果：<br>1.高16位不变。<strong>因为0与任何数进行异或，返回的都是那个数本身</strong>。0 ^ 1 = 1, 0 ^ 0 = 0<br>2.低16位于原本的高16位进行异或。<br>步骤3对capacity取模，很好理解，不能超出哈希数组的范围。第二步的意义何在？看<strong>question3</strong>.</p>
<hr>
<h3 id="七-⑤resize"><a href="#七-⑤resize" class="headerlink" title="七. ⑤resize"></a>七. ⑤resize</h3><p>在put的过程中，当size超出了threshold，那么就需要进行resize扩容。逻辑比较复杂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;		</span><br><span class="line"><span class="comment">//oldCap表明，table里原本已经存在key-value</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">//如果oldCap都已经扩容到最大了，那么就直接将threshold设为最大值，只好任你碰撞</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line"><span class="comment">//没有超出最大值，那么就安心扩容为原来的 2倍。值得注意的是newCap跟newThr都扩</span></span><br><span class="line"><span class="comment">//容为 2倍，仔细看 if 语句的判定。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line"><span class="comment">//这个就是我们前面所说的，当初始化的时候，会将threshold仅仅作为一个变量赋值给</span></span><br><span class="line"><span class="comment">//newCap，然后后面又把newCap*factor赋值给threshold</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line"><span class="comment">//这里就是调用new HashMap( )的情况，一个构造参数也没有的时候，直接赋默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//当上面第一个if里面没有执行里面的两个子if语句时，newThr仍然没有变化，即为0.需要在这里再对threshold进行修改。</span></span><br><span class="line"><span class="comment">//（比如上面的： else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span></span><br><span class="line"><span class="comment">//                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)，此时newCap可能超出了MAX，那么</span></span><br><span class="line"><span class="comment">//newThr就仍然为0.又或者是 else if (oldThr &gt; 0)  newCap = oldThr;中，即初始化带int参数的时</span></span><br><span class="line"><span class="comment">//候，这里仍然没有对threshold进行赋值。）</span></span><br><span class="line"> 	<span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"><span class="comment">//这段代码就是普通地判断threshold是否会超出MAX而已</span></span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"><span class="comment">//我们已经将新数组的各种参数（capacity，threshold等）都设置好了，接下来需要将原</span></span><br><span class="line"><span class="comment">//本的数组元素放入到新的哈希数组中。显然，因为这个操作，使得resize方法是一个极</span></span><br><span class="line"><span class="comment">//其耗费时间的方法，所以在大概知道元素个数的时候，不应该使用默认值16，而是显式</span></span><br><span class="line"><span class="comment">//定义HashMap的初始容量，减少resize次数，可以显著地提高效率</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//这里table中存放的只是Node的引用, 将oldTab[j]=null只是清除旧表的引用, 但是真正的</span></span><br><span class="line"><span class="comment">//node节点还在, 只是现在由e指向它。所以这里主要是提醒JVM，这里可以被GC清理了</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 如果该存储桶里面没有元素, 就直接将它放到新表的目标位置</span></span><br><span class="line">    </span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)	<span class="comment">//如果是树，则根据红黑树的逻辑拆分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line"><span class="comment">// 不是红黑树，那么就是链表。因此我们需要把该链表放入新的哈希数组的位置。</span></span><br><span class="line"><span class="comment">//主要是获取整条链表（即使只有 1个元素，结构仍然是链表）。</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//设置了两个链表，原因是根据不同情况，插入到不同的链表，最后再根据结果赋值</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;		<span class="comment">//第n位为0</span></span><br><span class="line"><span class="comment">// 我们知道hash &amp; (n - 1)就是原本的位置，那么hash &amp; n是什么？原本的哈希值为n - 1</span></span><br><span class="line"><span class="comment">//位，当它扩容之后，它的哈希值位n - 1或者n位，即第n位要么是0，要么是1，而</span></span><br><span class="line"><span class="comment">//hash &amp; n就是能获取第n位的值，在后面我们会解释为什么</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;						<span class="comment">//第n位为1</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);		<span class="comment">//此处do-while刚好使得循环至少执行1次</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;		<span class="comment">//根据0还是1决定赋值哪个</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于resize的最后那一部分：<br>在JDK1.7之前，都是直接再计算一次hash，然后放入新的哈希数组位置（index,bucket）。<br>但在JDK1.8中，代码得到了改进，看一下官方注释：<br><strong><em>Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</em></strong><br>大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。（n - 1位哈希码，变成n - 1位或 n位）<br>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_11.png" target="_blank" rel="noopener" title="resize时hash位置的变化"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_11.png" alt="resize时hash位置的变化" title="resize时hash位置的变化"></a><br>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_12.png" target="_blank" rel="noopener" title="resize后index的变化"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_12.png" alt="resize后index的变化" title="resize后index的变化"></a><br>因此，<strong>我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</strong>可以看看下图为16扩充为32的resize示意图：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_13.png" target="_blank" rel="noopener" title="resize整个示意图"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_13.png" alt="resize整个示意图" title="resize整个示意图"></a><br>那么，<strong>为什么 hash &amp; n就是可以获得第n位的值呢？</strong><br>首先我们必须知道，n是一个2的幂次方数，它的二进制i形式是00……1000……<br>易知，0 &amp; x = 0，1 &amp; x = x，而我们就是想要hash值的第n位的x值。<br>因此，hash &amp; n，刚好就是取到了新的hash值的第n位的x值。<br>故得出结论:    （最后的if，else判断）<br>如果<code>(e.hash &amp; oldCap) == 0</code> 则该节点在新表的下标位置与旧表一致都为 j<br>如果 <code>(e.hash &amp; oldCap) == 1</code>则该节点在新表的下标位置 j + oldCap</p>
<hr>
<hr>
<h3 id="八-中间遗留出来的questions："><a href="#八-中间遗留出来的questions：" class="headerlink" title="八. 中间遗留出来的questions："></a>八. 中间遗留出来的questions：</h3><p><strong>question1：哈希数组的长度为什么需要是2的幂次方？</strong><br>ans：因为在映射的时候，需要执行(n - 1) &amp; hash，当n不为2的幂次方的时候，n的个位为1，(n - 1)的个位则为0，又因为0 &amp; x = 0，因此使得最后一位必定是0，即浪费了1个位的空间，碰撞的几率也会增大。而如果n是2的幂次方，那么(n - 1)的个位必定是1，1 &amp; x = x，即根据hash的个位来决定，而不是一定返回0，因此能降低碰撞几率，充分利用每一个位。</p>
<hr>
<p><strong>question2： （n - 1 ) &amp; hash的原理？</strong><br>ans：因为n是2的幂次方，因而(n - 1)的值位000……1111（若干个1.(n - 1) &amp; hash，即返回hash的低<br>⌈log2(n - 1)⌉ （2为底）位的值，即hash &amp; n。如下图：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_14.png" target="_blank" rel="noopener" title="hash &amp; (n - 1)"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_14.png" alt="hash &amp; (n - 1)" title="hash &amp; (n - 1)"></a><br>使用(n - 1) &amp; hash而不使用hash % n的好处：<br>位运算是计算机最快的运算，因此效率更高。同样因为n是2的幂次方，因而该算法也不会出现超出取模范围的错误。</p>
<hr>
<p><strong>question3：为什么要将低16位与高16位进行异或操作？</strong><br>ans：先看一下源码的代码注释：<br><strong><em>Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don’t benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</em></strong><br>设计者认为<strong>(n - 1) &amp; hash很容易发生碰撞</strong>，因为如果不对hash进行其他处理，那么hash起作用的仅仅是⌈log2(n - 1)⌉，比如当n为16的时候，hashCode起作用的仅仅是低4bit的有效位，那么当然容易碰撞了。因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是<strong>把高16bit和低16bit异或了一下</strong>。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。（即通过h ^ (h &gt;&gt;&gt; 16)，<strong>间接让高16位也参与计算，从而让键值对分布均匀，降低hash碰撞</strong>）</p>
<p>如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞<strong><em>(we use trees to handle large sets of collisions in bins)</em></strong>，在JEP-180中，描述了这个问题：<br><strong><em>Improve the performance of java.util.HashMap under high hash-collision conditions by using balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class.</em></strong><br>之前已经提过，在获取HashMap的元素时，基本分两步：<br>首先根据hashCode()做hash，然后确定bucket的index；<br>如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。<br>在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是<strong>O(1)+O(n)</strong>。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。<br>因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了<strong>O(1)+O(logn)</strong>了，这样在n很大的时候，能够比较理想的解决这个问题。</p>
<hr>
<p><strong>question4：为什么判定条件是”binCount &gt;= TREEIFY_THRESHOLD - 1”，但树化的条件仍然是bitCount &gt;= TREEIFY_THRESHOLD - 1?</strong><br>ans：这里：<code>binCount &gt;= TREEIFY_THRESHOLD - 1</code>，看起来是大于等于7就会树化，但其实并不是的。因为在刚执行完<code>p.next = newNode(...);</code>此时binCount仍然还没有执行完++。所以仍然是链表中元素的个数大于等于<code>TREEIFY_THRESHOLD</code>（默认是8），才会树化。<br>举例：当元素个数为1的时候，即只有p，此时binCount为0，然后执行<code>p.next = newNode(...)</code>。if判断失效，然后才执行binCount++（即添加完p.next之后，里面已经有k个元素了，但if判断的时候的binCount值为k - 1，只有到下一轮循环才改成k。<br>当链表一共有6个元素的时候，此时binCount为6（已经是下一轮循环），执行p.next = newNode,一共有7个元素。if判断（6 &lt; = 7)，所以不会树化，循环结束，binCount为7.然后下一轮循环，添加元素，为8，此时 7 &lt;= 7，为真，树化。<br>PS：Hash冲突是指不同对象的hashCode通过hash算法后得出了相同定位的下标，这时候采用链地址法，会将此元素插入至此位置链表的最后一位，形成单链表。当存在位置的链表长度 大于等于 8 并且当前数组容量超过64时，HashMap会将链表 转变为 红黑树，这里要说明一点，往往后者的条件会被大多数人忽略，当桶数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长。这个时候应该优先扩容，而不是立马树化。毕竟高碰撞率是因为桶数组容量较小引起的，这个是主因。容量小时，优先扩容可以避免一些列的不必要的树化过程。</p>
<hr>
<h3 id="九-其他一些常见问题："><a href="#九-其他一些常见问题：" class="headerlink" title="九. 其他一些常见问题："></a>九. 其他一些常见问题：</h3><p><strong>1. 什么时候会使用HashMap？他有什么特点？</strong><br>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p>
<p><strong>2. 你知道HashMap的工作原理吗？</strong><br>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。HashMap是非线程安全的，在多线程的操作下会存在异常情况，可以使用HashTable或者ConcurrentHashMap进行代替</p>
<p><strong>3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</strong><br>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p>
<p><strong>4. 你知道hash的实现吗？为什么要这样实现？</strong><br>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p>
<p><strong>5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong><br>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p>
<p><strong>6. JDK1.8之前，HashMap在并发的情况下会出现问题，比如同时put的时候甚至会引起死循环，导致CPU使用率100%，为什么？</strong><br>因为JDK1.8之前的resize方法是需要rehash的，导致在旧链表迁移到新链表的时候，如果在新链表的数组索引相同，会导致链表元素倒置，在JDK1.8中不需要rehash，直接根据新增的1bit是0还是1，决定是在原本位置还是增加capacity的位置，不会倒置。<br>而JDK1.8之前的transfer，以JDK1.7为例，当两个线程同时resize的时候，由于链表倒置，有可能出现循环链表的情况，导致无限循环，耗尽CPU算力。具体看这里：<a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a><br>HashMap是非线程安全的，在多线程的操作下会存在异常情况，比如类似于数据库的更新丢失（两个线程同时put，可能会导致其中一个put失效）。可以使用Hashtable或者ConcurrentHashMap进行代替。（Hashtable的效率太低，不推荐使用）<br>PS：回到本题的主干：<strong><em>存放数据时发现正在扩容会怎么样。</em></strong><br>对于JDK1.7，应该就是同时resize，导致死循环。对于JDK1.8，则不会出现死循环。（1.7是头插法，导致会倒置，形成循环链表。而<strong>1.8增加了tail指针，使用尾插法</strong>，时间复杂度仍然是O(1)，但不会倒置，因而不会出现死循环。）。1.8中hashmap的确不会因为多线程put导致死循环，但是依然有其他的弊端，比如数据丢失等等。因此多线程情况下还是建议使用concurrenthashmap。</p>
<p>参考网站：<br><a href="https://segmentfault.com/a/1190000015812438" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015812438</a><br><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a><br><a href="https://juejin.im/post/5a7719456fb9a0633e51ae14" target="_blank" rel="noopener">https://juejin.im/post/5a7719456fb9a0633e51ae14</a><br><a href="https://juejin.im/post/5c7f69dff265da2dea054fdc" target="_blank" rel="noopener">https://juejin.im/post/5c7f69dff265da2dea054fdc</a><br><a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="noopener">https://blog.csdn.net/fan2012huan/article/details/51097331</a><br><a href="https://blog.csdn.net/zhuqiuhui/article/details/51849692" target="_blank" rel="noopener">https://blog.csdn.net/zhuqiuhui/article/details/51849692</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL锁的判断</title>
    <url>/MySQL%E9%94%81%E7%9A%84%E5%88%A4%E6%96%AD.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>本文的最终解决的问题：<strong>如何判断一条SQL语句用到了哪些锁？</strong><br>（特别地，这里考虑的是<em>MySQL</em>数据库的锁机制）</p>
<p>首先，我们需要先对<em>MySQL</em>的事务机制，锁机制，索引机制都总结一遍。</p>
<a id="more"></a>

<hr>
<h3 id="二-事务隔离级别："><a href="#二-事务隔离级别：" class="headerlink" title="二. 事务隔离级别："></a>二. 事务隔离级别：</h3><p><strong>RU：Read UnCommitted<br>RC：Read Committed<br>RR：Repeatable Read （default）<br>Serializable</strong></p>
<p>总结：<br>RU可以读取未提交的数据，因此存在脏读的问题。<br>RC只能读取已经提交的数据，因而解决了脏读的问题，但存在不可重复读的问题<br>RR保证了可以重复读的问题。<br>RR与Serializable都解决了大部分的问题，因此默认就是RR。（当然，在需求高性能的情况下，会使用RC）</p>
<p>查看MySQL的隔离级别：<br><code>select @@tx_isolation</code> 查看当前会话的事务隔离级别<br><code>select @@global.tx_isolation</code> 查看系统全局的隔离级别<br>设置隔离级别：<br><code>set session/global transaction isolation level xx;</code><br>(xx can be <strong>read uncommitted, read committed, repeatable read, serializable</strong>)</p>
<hr>
<h3 id="三-锁机制："><a href="#三-锁机制：" class="headerlink" title="三. 锁机制："></a>三. 锁机制：</h3><p>MySQL锁的类型：（有多种分法）<br><strong><em>①根据锁的兼容情况，可以分为4种：</em></strong><br><strong><em>Shared locks，Exclusive locks</em></strong>（共享锁，排他锁，即S锁，X锁，在其他数据库也有这两种）<br><strong><em>Intention Locks</em></strong>：意向锁，分为共享意向锁IS，共享排他锁IX锁。（作用后续说，<strong>针对MySQL的行锁而出现</strong>）</p>
<p><strong><em>②根据锁的锁定范围，可以分为三种：</em></strong><br><strong><em>表锁 Table Locks，行锁 Record Locks，页锁 Page Locks</em></strong><br>（在MyISAM中为Table Locks，而在<strong>InnoDB中只有Record Locks</strong>。Page Locks存在于BerkeleyDB）<br>表锁和行锁的区别：<br><strong>表锁的开销较小，不会产生死锁，锁定范围大，但并发度最低<br>行锁的开销较大，可能产生死锁，锁定范围较小，并发度更高</strong><br>页锁此处不解释（我也不会）</p>
<p><strong><em>③InnoDB下的Lock Type：</em></strong><br>由于目前重点使用的MySQL引擎一般是InnoDB，因此对InnoDB进行更细致的了解。<br><strong>InnoDB的行级锁（InnoDB不存在表级锁，只是在特定情况下看起来像是表级锁的形式而已）：</strong><br><em>1.Record Locks：A record lock is a lock on an index record.</em> 即锁定一个index的record。<br><em>2.Gap Locks：A gap lock is a lock on a gap between index records, or a lock on the gap before the first or after the last index record.</em> 即锁定record之间的的间隙。<br>（Gap Locks存在于RR与Serializable，不存在于RC。RU一般不会用，不考虑，而且也没有）<br><em>3.Next-Key Locks:A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.(3 = 1 + 2)</em><br><del>PS：此处有一个小test，事务隔离级别是与系统全局的设置有关的（即使两个Session transaction isolation level都设置为RC，但如果Global transaction isolation level设置为RR，那么就按照RR的情况来执行，即此时存在Gap Locks。所以不清楚Session level有何作用）</del></p>
<hr>
<p>不同情况的加锁情况：<br>要考虑这个问题，先整理一些基础知识：</p>
<p><strong><em>①首先要了解锁之间的兼容性（S锁，X锁，IS锁，IX锁）：</em></strong></p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_1.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_1.png" alt="MySQL中InnoDB引擎中锁的兼容性"></a><br>PS：这是<strong>仅限于Table-level的compatibility</strong>，网上传的很多都忽略了这个。</p>
<p><strong>关于意向锁：主要是用于解决行锁和表锁的冲突。</strong>试想一下，当事务A锁住了表中的一行（假设为S锁)，而事务B需要申请整个表的X锁。那么事务B需要做的事情：<br>1.判断表是否被其他表锁锁住（无论X,S），这个很简单.<br>2.判断表中的每一行是否被行锁锁住（无论X,S，因为X与二者均不兼容）。<br><strong>如果只有X,S锁，那么我们需要逐行检查，如果有1个亿的data，那么就需要查询1亿行。</strong><br>如果添加了意向锁呢？意向锁的作用方式：<br>当一个事务需要获取一个<strong>行锁</strong>的X锁，先获取一个IX锁。<br>当一个事务需要获取一个<strong>行锁</strong>的S锁，先获取一个IS锁。<br>（记住，<strong>上面的表格是仅限表锁的情况</strong>，如果需要获取表锁的X/S锁，那么不需要获取IX,IS锁。另外，<strong>IX,IS锁是数据库后台自动获取的，无须我们显式调用</strong>）<br>这个时候，当另一个事务，要申请X锁，第一步依然是判断是否被其他表锁锁住。<br>第二步就改成了，判断该表是否存在IX,IS锁。（如果存在IX，IS锁，说明该表存在X，S锁，不管是哪一行）<strong>仅仅通过判断是否存在意向锁，就省去了遍历所有行的操作。</strong><br>（PS：如果另一个事务要申请的是S锁，同样如此，只是不需要判断IS锁，而是判断IX锁）<br>记住：<strong>意向锁与表级的X锁不兼容，但与行级的X锁是兼容的</strong><br>（不然你先获取了IX锁，如何继续获取X锁呢？）</p>
<hr>
<p><strong><em>②数据库的并发控制协议</em></strong></p>
<p><em>MVVC：Multi-Version- Concurrency Control。</em>即基于多版本的并发控制协议。<br>它最大的好处：读操作不加锁，读写不冲突，可以极大地增强并发性。<br><em>Lock-Based Concurrency Control。</em>即基于锁的并发控制。<br>（如果我们每一种操作都需要获取lock，由lock来完全实现并发控制，那么并发性会相当地差。其实也就是相当于Serializable，完全串行化执行。所以<strong>现阶段，大部分的数据库都不会是完全的基于lock去实现并发控制，而是实现了MVVC模式</strong>）</p>
<p>在MVVC并发控制中，读操作可以分为两种；<strong>snapshot read</strong>(快照读）,<strong>current read</strong>(当前读）<br>所谓snapshot，就是系统在某一个时刻的印象，所以此时读取到的不一定是最新的数据，可能是某个历史版本的数据，那么这时候就不需要加锁。（因为本来就不一定是最新的数据，那么两次snapshot read不一致也是很正常的，所以怎么能算是脏读幻读呢（滑稽）！）<br>current read就不一样了，它就是要读取系统最新的数据，所以此时需要对读操作进行加锁，然后再基于Lock-Based去进行并发控制。</p>
<p><strong>在MySQL InnoDB中，snapshot read又称简单的select</strong>，一般形式为：<br><code>select *from table where ？;</code> # 存在例外，后面分析<br>current read：<br><code>select* from table where ? lock in share mode || for update || for share</code>(8.0之后的版本)<br>(如果直接显式要lock了，那么都lock了，当然就是要current read，而不是读取snapshot了）<br>insert，update，delete（这些操作当然不能读snapshot，不然你update一个已经被delete掉的数据吗)<br>(从底层源码来说，update，delete都包含一个current read，而insert，需要检查unique key冲突）</p>
<hr>
<p><strong><em>③聚簇索引（cluster index）：</em></strong></p>
<p>这是由MySQL<strong>自动生成</strong>的一个index（无法人为控制），它一般是直接把主键设置为<strong><em>cluster index</em></strong>，所以又称主键index。<br>（如果表没有创建主键？那么按照以下规则来创建cluster index：（一般还是要显式给表一个PK）<br>1.会用一个唯一的非空的index列，作为cluster index<br>2.如果没有这样的index，那么InnoDB会隐式生成一个主键来作为cluster index<br>其他人为定义的索引，称为辅助索引（<strong><em>secondary index</em></strong>），也可以称为非聚簇索引。<br>关于这两个index的具体区别，查找时的路径有何不同，可以参考这篇文章：<br><a href="https://www.cnblogs.com/rjzheng/p/9915754.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9915754.html</a><br>关键点：每创建一个index，那么就会生成一个B+树，因此index不能乱加，会导致index的时候需要同时维护多个index，导致效率低下）</p>
<p>PS：这里有一个关键点，就是<strong>cluster index是无论如何都会存在的。</strong>（不管你有没有创建其他index，每个表都会存在一个cluster index）<br>根据网上很多的文章，都提及到一个内容：InnoDB只有在使用index的时候才是使用行锁，否则会变成表锁。<strong>这句话是错误的</strong>。因为即使我们没有创建index，在select的时候也没有使用index列，那么一样会使用一个隐式创建的cluster index去寻找数据，所以<strong>InnoDB只存在行锁，不存在表锁。</strong><br>官方文档：<br><strong><em>Record Locks<br>A record lock is a lock on an index record. For example, SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE; prevents any other transaction from inserting, updating, or deleting rows where the value of t.c1 is 10.<br>Record locks always lock index records, even if a table is defined with no indexes. For such cases, InnoDB creates a hidden clustered index and uses this index for record locking. See Section 15.6.2.1, “Clustered and Secondary Indexes”.</em></strong><br>可是很多人表示自己亲自测试过，发现确实是整个表都锁住了呀，难道不是表锁吗？这主要是因为对底层了解不足，只开了两个session发现无法同时select就感觉是整个表都锁起来，是不正确的。这时候最正确的做法是：查看MySQL的状态表，查看当前存在的锁，然后<strong>直接查看锁的类型</strong>。毕竟网上说的都不权威，但MySQL它自己创建的表是最权威的！<br>我们这里创建两个session，发现存在lock，waiting的情况，这时候在另一个无须waiting的session执行： <strong>use information_schema;</strong> 进入到MySQL自带的information_schema数据库中<br>然后执行： <strong>select* from innodb_locks;</strong> 即可找到当前存在的locks。<br>（也可以使用 <strong>show engine innodb status;</strong>查看，不过可读性较差，需要仔细观察）<br>下面给出两个命令的结果：（第一个是select* from innodb_locks;)</p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_2.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_2.png" alt="select* from innodb_locks的显示结果"></a></p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_3.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_3.png" alt="show engine innodb status的显示结果"></a></p>
<hr>
<p>PS：<strong>MySQL8.0与之前的版本不一致（5.7及以前）</strong>。如下：（如果不是使用8.0可以跳过）<br>MySQL5.7及之前，可以通过<code>information_schema.innodb_locks</code>查看事务的锁情况，但，只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。<br>MySQL8.0删除了information_schema.innodb_locks，添加了<code>performance_schema.data_locks</code>，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁，也就是说即使事务并未被阻塞，依然可以看到事务所持有的锁（不过，正如文中最后一段所说，performance_schema.data_locks并不总是能看到全部的锁）。表名的变化其实还反映了8.0的performance_schema.data_locks更为通用了，即使你使用InnoDB之外的存储引擎，你依然可以从performance_schema.data_locks看到事务的锁情况。<br>那么为何RECORD LOCKS会表现出类似于表锁的形式？这是因为InnoDB在没有使用index的时候，会使用cluster index（所以依然是行锁）此时会生成record locks和gap locks，并且是把每一个record，每一个gap都锁住，表现形式就像是整个表都被锁住的情况（但仍然是行锁）。<br>有的人可能觉得，这不是在挑文字游戏？并不，因为只有在特定情况下，才会出现这种情况，当我们修改一些其他参数，或者使用不同的index，都会出现不同的情况，到那时候就不再是整个表都锁住了。这个在最后的时候会详细说明，现在只需要知道，<strong>InnoDB，绝对不存在Table locks。</strong></p>
<hr>
<hr>
<h3 id="四-不同情况的加锁处理分析"><a href="#四-不同情况的加锁处理分析" class="headerlink" title="四. 不同情况的加锁处理分析"></a>四. 不同情况的加锁处理分析</h3><p>有了这些准备，我们开始讨论不同情况的加锁处理分析（加不加锁，加哪种锁）</p>
<p>此处参考了大佬的文章：<strong><em><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">http://hedengcheng.com/?p=771</a></em></strong><br><strong>情况①：简单的snapshot read: select* from table where id = 1;</strong><br>这时候<strong>一般不加锁</strong>。但上文也说了，存在例外，那就是当事务隔离级别为Serializable的情况下，由于每一个操作都完全串行化，因而也不存在snapshot了，该操作会升级为current read，因而需要加锁。（同时，Serializable的情况下，MySQL的并发控制协议会从MVVC降级为Lock-Based。一般除非系统冲突非常严重，否则不采用Serializable）</p>
<p>有了第一个情况，可以发现<strong>加锁的情况是要考虑其他因素的，不能仅仅是给一个SQL语句就问获得了什么锁，还要考虑很多种情况</strong>。一般而言，需要考虑以下几种情况：（假设搜寻的字段为id）<br><strong>1.id是否为主键？<br>2.当前系统的隔离级别是什么？<br>3.id如果不为主键，那么它是否存在index？<br>4.如果id存在secondary index，那么这个index是否是unique index？<br>5.两个SQL的执行计划是什么，索引扫描？全表扫描？</strong>（这里我是参照大佬的文章来写的，但个人认为第五点其实跟前面的重叠了。如果id为主键，那么就是采用了cluster index，即全表扫描。如果id不存在index，同样是采用cluster index。如果id存在index，无论是否是unique，都为索引扫描。）</p>
<p>现在给定一个表：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_4.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_4.png" alt="测试所用的表结构"></a><br>对于上面的几种情况，不一定每一种都排列组合一遍，把关键的点get到即可。<br>下面通过<strong>8种情况</strong>来考虑：</p>
<hr>
<p><strong>①~④：RC级别<br>⑤~⑧：RR级别</strong></p>
<hr>
<h4 id="①搜寻字段是主键-PK）"><a href="#①搜寻字段是主键-PK）" class="headerlink" title="①搜寻字段是主键(PK）"></a>①搜寻字段是主键(PK）</h4><p><code>delete from testN where id = 10;</code><br>此时其他事务无法访问id = 10这一行记录<br>情况最简单，直接在主键上id = 10的记录上加上X锁即可（在id字段上锁）。</p>
<hr>
<h4 id="②字段不是主键，但存在一个unique-index。"><a href="#②字段不是主键，但存在一个unique-index。" class="headerlink" title="②字段不是主键，但存在一个unique index。"></a>②字段不是主键，但存在一个unique index。</h4><p><code>delete from testN where name = &#39;abc&#39;;</code><br>同样无法访问name = ‘abc’这一行记录，但同时在id和name1字段上锁。<br>这种情况下，由于存在index，所以会在index上查询，这时候会给unique index加上X锁。同时当select的时候，如果没有指定secondary index的字段（*号也不行），那么还会到cluster index里去顺序查找。具体看图：（在上面最开始讲到cluster index里的文章就有具体说明）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_5.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_5.png" alt="聚簇索引"></a><br>所以这个时候，除了给secondary unique index进行加锁，还会对cluster index进行加锁。<br>所以此处是给id，name1字段都加上了锁。（当然，被加锁的record依然是那一条，因为unique）</p>
<p>为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：<code>update t1 set id = 100 where name = ‘d’;</code>此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。</p>
<hr>
<h4 id="③字段不是主键，而且字段存在一个index，但并不是unique-index"><a href="#③字段不是主键，而且字段存在一个index，但并不是unique-index" class="headerlink" title="③字段不是主键，而且字段存在一个index，但并不是unique index"></a>③字段不是主键，而且字段存在一个index，但并不是unique index</h4><p><code>delete from testN where number = 12;</code><br>这种情况其实跟第②种情况是类似的，只是可能锁住多个record（因为不是unique index）<br>同样也是对number（index列）进行了加锁，然后还会对cluster index列加锁。<br>PS：看起来②和③可以归并在一起，但在RR的时候可以看到很大的不同。</p>
<hr>
<h4 id="④字段不是主键，而且不存在index。"><a href="#④字段不是主键，而且不存在index。" class="headerlink" title="④字段不是主键，而且不存在index。"></a>④字段不是主键，而且不存在index。</h4><p>此时会使用cluster index进行扫描，即全表扫描。而且会把所有的record都锁住。因为该条件无法通过索引快速过滤（暂且把cluster index视为很特殊的index吧，不然你都不需要自己创建index了），这时候在存储引擎层面就会将所有的记录加锁后返回，然后由MySQL Server层进行过滤。这是由于MySQL的实现所决定的。（在实际的实现中，进行了一些优化，在过滤条件中，如果发现不满足条件，那么在中途就会把不满足条件的记录释放锁。这样避免了把所有record都锁住导致的低并发，但也违背了二阶段锁的约束。这样最终持有锁的，会是满足条件的记录。但那大概是在事务提交执行的过程中，所以本地编写事务但不commit，依然会表现为全部记录加锁）</p>
<hr>
<h4 id="⑤搜寻字段是主键-PK）"><a href="#⑤搜寻字段是主键-PK）" class="headerlink" title="⑤搜寻字段是主键(PK）"></a>⑤搜寻字段是主键(PK）</h4><p>跟①没有区别</p>
<hr>
<h4 id="⑥字段不是主键，但存在一个unique-index。"><a href="#⑥字段不是主键，但存在一个unique-index。" class="headerlink" title="⑥字段不是主键，但存在一个unique index。"></a>⑥字段不是主键，但存在一个unique index。</h4><p>跟②没有区别</p>
<hr>
<h4 id="⑦字段不是主键，而且字段存在一个index，但并不是unique-index"><a href="#⑦字段不是主键，而且字段存在一个index，但并不是unique-index" class="headerlink" title="⑦字段不是主键，而且字段存在一个index，但并不是unique index"></a>⑦字段不是主键，而且字段存在一个index，但并不是unique index</h4><p>有区别了，为什么？RR相对于RC，解决的问题是幻读，不可重复读。为何⑤跟⑥的加锁却没有任何改变？幻读，不可重复读是指当前事务，连续执行两次current read，返回了不同的数据。而⑤和⑥都是unique index，能够保持唯一性，不用担心值会发生改变（改变值需要X锁，与S锁不兼容）。<br>那么在⑦的时候，字段存在了index，但该index并不是unique index，这时候问题就出现了，如果还是按照③的做法，那么就可能出现幻读跟不可重复读的情况。<br>举一个例子，按照我们上面给的table的来示例：（假设采用③的只对record进行加锁的模式）<br>字段名为： id， name1，number1， age (PK为id）<br>执行的current read的语句为：<br><code>select *from testN where number1 = 18 for update;</code>(number1是非unique index列)<br>那么假如当我们在另一个session执行：<code>insert into testN values(xx,xx,18,xx); commit;</code><br>这时候该session中的 transaction是可以成功提交的，因为并没有gap lock，而只是把原本符合条件的 record给锁住了，而不是把所有number1=18的都锁住。<br>这时候再次执行 <code>select* from testN where number1 = 18 for update;</code>就会出现<strong><em>幻读</em></strong>。</p>
<p>因此，<strong><em>此时会锁住符合记录与相邻记录的间隔。这个就称为间隔锁：gap locks</em></strong><br>假如：字段的取值是：12，32，18，18，20，24，30.选择的条件是 id = 18<br>那么除了锁住两个18的记录，还会锁住12与18，18与20之间的间隔（有序性）<br>所以此时锁住的范围：record locks： 18， 18<br>gap locks： [12, 18) ∪ [18, 20)所以整体锁住的范围就是： <strong>[12, 20)</strong></p>
<hr>
<h4 id="⑧字段不是主键，而且不存在index。"><a href="#⑧字段不是主键，而且不存在index。" class="headerlink" title="⑧字段不是主键，而且不存在index。"></a>⑧字段不是主键，而且不存在index。</h4><p>⑧跟⑦不一样的地方是，⑦会把符合条件的record的与前后record的间隔都给锁住，而⑧由于是全表搜索（无index，只有cluster index），因此⑧首先是把所有的records都锁住，然后再把所有records的间隔都锁住（包括±∞）。假如age列（非index列）一共有20，22，30等三个值，那么由行锁record locks和间隔锁gap locks锁住的范围为：<br><strong>(-∞, 20) ∪ [20, 22) ∪ [22, 30) ∪ [30, +∞）（因为表现为整个表都锁住了，所以容易误以为是表锁）</strong><br>（虽说误以为是表锁是错误的理解，但确实要<strong>尽量避免</strong>这种情况，因为这种情况需要加很多锁。当该非index列有n个records的时候，需要加<strong><em>n个record locks，(n+1)个gap locks，一共需要（2n+1)个锁，开销是极其大的。</em></strong>所以尽量通过index来查询，避免加入过多的锁，影响性能。</p>
<hr>
<h3 id="附：测试"><a href="#附：测试" class="headerlink" title="附：测试"></a>附：测试</h3><p>数据以上面的testN的数据为例，事务自动提交设置为否：<code>set autocommit = 0</code>（除了在阐述③如何引起幻读的情况下，需要commit，其余都无须commit，只需要显示到被锁住即可。并且这一步会放到最后执行，前面的每一项测试，在测试完毕之后，都执行rollback，避免事务对数据的更改）<br>初始数据：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_6.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_6.png" alt="初始数据"></a><br>确保环境：（1~4在RC，5~8在RR。虽说应该是global才生效，但直接把session跟global都设置一遍) （两个终端都设置）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_7.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_7.png" alt="初始环境(1~4RC,5~8RR)"></a></p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_8.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_8.png" alt="初始环境(1~4RC,5~8RR)"></a></p>
<hr>
<h4 id="情况①："><a href="#情况①：" class="headerlink" title="情况①："></a>情况①：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_9.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_9.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_10.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_10.png" alt="B终端"></a><br><strong><em>结论：①确实只锁住了id为10的那条记录，其他所有都没有锁。</em></strong></p>
<hr>
<h4 id="情况②："><a href="#情况②：" class="headerlink" title="情况②："></a>情况②：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_11.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_11.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_12.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_12.png" alt="B终端"></a><br><strong><em>结论：②确实也是只把name1=’abc’该列锁住了。没有其他任何的锁。</em></strong></p>
<hr>
<h4 id="情况③："><a href="#情况③：" class="headerlink" title="情况③："></a>情况③：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_13.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_13.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_14.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_14.png" alt="B终端"></a><br><strong>结论：③，number1为20有两个记录，这两个确实都被锁住了。而且其他都没有锁住，没有gap locks</strong></p>
<hr>
<h4 id="情况④："><a href="#情况④：" class="headerlink" title="情况④："></a>情况④：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_15.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_15.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_16.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_16.png" alt="B终端"></a><br><strong>结论：④理论上是锁住所有record，但在判定不符合之后就把锁释放了（即那个违背了二阶段锁的优化操作），所以最后只把age为22的锁住了。</strong></p>
<hr>
<p>RC环境转RR环境：<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_17.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_17.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_18.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_18.png" alt="B终端"></a></p>
<hr>
<h4 id="情况⑤："><a href="#情况⑤：" class="headerlink" title="情况⑤："></a>情况⑤：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_19.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_19.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_20.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_20.png" alt="B终端"></a><br><strong>结论：⑤与①相同，没有任何变化。</strong></p>
<hr>
<h4 id="情况⑥："><a href="#情况⑥：" class="headerlink" title="情况⑥："></a>情况⑥：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_21.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_21.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_22.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_22.png" alt="B终端"></a><br><strong>结论：Ⅵ与②相同，没有任何变化。</strong></p>
<hr>
<h4 id="情况⑦："><a href="#情况⑦：" class="headerlink" title="情况⑦："></a>情况⑦：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_23.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_23.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_24.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_24.png" alt="B终端"></a><br><strong>锁住18，与预期相同。</strong>18相邻的元素为12，20，因而把 [12, 18)∪ [18, 20)给锁住了。（锁的范围是左闭右开，因而12无法insert，但20是可以insert的）</p>
<p><strong>下面再测试锁住20的情况。</strong><br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_25.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_25.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_26.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_26.png" alt="B终端"></a></p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_27.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_27.png" alt="B终端"></a><br><strong>锁住20，同样跟预期相同，会把[18, 20) ∪ 20 ∪ [20, 40)都锁住</strong></p>
<p><strong>假设选择的值是最小/最大，是否也像no index的情况下，锁住±∞？</strong><br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_31.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_31.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_32.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_32.png" alt="B终端"></a></p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_33.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_33.png" alt="B终端"></a><br>答案是会的。所以也跟预期一样。</p>
<p><strong>结论：⑦与③不同，在RR的情况下会使用gap locks，锁住间隔。</strong></p>
<hr>
<h4 id="情况⑧："><a href="#情况⑧：" class="headerlink" title="情况⑧："></a>情况⑧：</h4><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_28.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_28.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_29.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_29.png" alt="B终端"></a></p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_30.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_30.png" alt="B终端"></a><br>表就像完全锁住一样，因为record locks &amp; gap locks 把整个表都锁住了。<br><strong>结论：⑧在RR的情况下，会把所有的record都锁住，也会把所有的gap锁住。</strong></p>
<hr>
<p>最后，测试RC环境下，③可能会导致<strong>幻读</strong>的情况：（RR已经确定不会出现幻读）<br>环境参数：（RR改回RC）<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_34.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_34.png" alt="A终端"></a></p>
<p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_35.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_35.png" alt="B终端"></a></p>
<p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_36.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_36.png" alt="A终端"></a></p>
<p>中间，在另一个终端B执行：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_37.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_37.png" alt="B终端"></a><br>可见session1的lock并没有锁住session2创建number1为18的值。只要unique行没有duplicate，那么就可以insert，insert更多例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_38.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_38.png" alt="B终端"></a></p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_39.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_39.png" alt="A终端"></a></p>
<p>PS：<strong>以上讨论的是什么时候加锁</strong>。至于加什么锁，应该很好判断。如果是select lock in share mode，那就是加S锁，select for update，就是加X锁。</p>
<hr>
<hr>
<p><strong><em><code>当范围比较的时候，又有所不同！当范围比较的时候，又有所不同！</code></em></strong></p>
<p>(上面考虑的都是等值筛选的情况） 以下就不考虑等值的情况<br>使用数据：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_40.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_40.png" alt="使用数据"></a></p>
<hr>
<h4 id="①使用PK的情况（cluster-index）"><a href="#①使用PK的情况（cluster-index）" class="headerlink" title="①使用PK的情况（cluster index）"></a>①使用PK的情况（cluster index）</h4><p>SQL句子： （用4个句子来解释）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select* from testf where pid &gt; 30 for update;</span><br><span class="line">select* from testf where pid &gt; 33 for update;</span><br><span class="line">select* from testf where pid &gt; 50 for update;</span><br><span class="line">select* from testf where pid &lt; 30 for update;</span><br></pre></td></tr></table></figure>

<p><strong>对于RC：</strong><br>句子1：首先符合条件的记录为pid = 33， pid = 47.对这两个records加上X锁。<br>句子2：首先符合条件的记录为pid = 47，对着一个record加上X锁。<br>句子3：没有符合条件的记录。<br>句子4：两个符合，加锁。<br>此时执行select：句子1可以获取pid = 11，12，的记录，句子2可以获得11，12，33，句子3全部可以<br>此时执行insert：除了相同的pid（duplicate），没有任何限制。(但insert相同的pid时，还是会起冲突哦。先是waiting获得lock，然后获得了之后才发现，duplicate，insert失败。即添加被record lock锁住的记录，仍然要waiting，而其他就无须获取锁的就直接duplicate。下同）<br><strong>对于RR：（增加gap locks）</strong><br>句子仍然对符合的records加上X锁，之后，开始增加gap locks：<br>句子1：<br>gap locks：对于 pid &gt; 30，因而需要找一个左边界，找一个左边最接近30的record，在这里即为22.因此，gap locks的范围：<strong><em>[22, 33) ∪ [33, 47) ∪ [47, ＋∞)</em></strong><br>对于insert，不能insert record locks &amp; gap locks范围里的pid。合理。<br>对于select，也还是跟RC情况一样。因为被record locks锁住的在RC就不能访问，而被gap locks锁住的范围无法insert，因而select也肯定是empty set。那么，就不会出现幻读。<br>句子2：<br>与句子1的唯一区别是，33刚好就在表里，那么左边界到底是22还是33？<br>好的，答案是33，因为判定条件≠33啊。剩下的也就一样了，<strong><em>gap locks：[33, 47)∪[47, +∞)</em></strong><br>句子3：<br>这个有点特别的是，没有record。但其实是一样的，找边界，因而这里这里的边界显然就是47，<strong><em>gap locks： [47, +∞)</em></strong><br>句子4：<br>值得注意的是，左边界是无穷，右边界显然是33.但这里的右边界竟然是闭合的！<br>所以此处<strong><em>gap locks：(-∞, 33]</em></strong>,因而只能insert 34之后的pid。所以select的时候就只能select 47了，33是不可以的。insert也不能包括33.</p>
<hr>
<h4 id="②不使用PK，使用unique-index"><a href="#②不使用PK，使用unique-index" class="headerlink" title="②不使用PK，使用unique index"></a>②不使用PK，使用unique index</h4><p>修改了一下表的结构跟数据：num具备一个unique index<br>测试了一下，<strong>发现跟PK一模一样。懒得说。（内部实现实际上有区别的，如果说要什么区别的话，那就是上面刚开始说的①和②的区别啊！②会先给unique index加锁再给cluster index加锁。</strong><br>(其实就是cluster index那一篇拓展文章)</p>
<hr>
<h4 id="③不使用PK，使用non-unique-index-从这里开始很特别。"><a href="#③不使用PK，使用non-unique-index-从这里开始很特别。" class="headerlink" title="③不使用PK，使用non-unique index 从这里开始很特别。"></a>③不使用PK，使用non-unique index 从这里开始很特别。</h4><p>直接讨论RR：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select* from testf where num &gt; 200 for update;</span><br><span class="line">select* from testf where num &gt; 150 for update;</span><br><span class="line">select* from testf where num &gt; 400 for update;</span><br><span class="line">select* from testf where num &lt; 250 for update;</span><br></pre></td></tr></table></figure>

<p>对于句子1：<br>终端A：<br><a href="hhttps://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_41.png"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_41.png" alt="A终端"></a></p>
<p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_42.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_42.png" alt="B终端"></a><br>显然，select还是只把符合的记录给锁住了，即只锁住了300，100跟200均可select。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_43.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_43.png" alt="B终端"></a><br>对于insert，依然是找到相应的边界值（这里显然是200），于是锁住了[200, +∞)，因而可以insert 199</p>
<p>对于句子2：（<strong>看起来应该会跟句子1一样，但结果……</strong>）<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_44.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_44.png" alt="A终端"></a></p>
<p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_45.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_45.png" alt="B终端"></a><br><strong>select竟然全部记录都获取不到了，除了不存在的空记录</strong>。那么insert呢？<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_46.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_46.png" alt="insert情况"></a></p>
<p>既然已经是所有record都上锁了（record locks），那么理应把record之间的间隔也上锁（RR），结果insert确实如此，全部都无法insert。<br>（而句子1跟句子2的区别，仅仅只有150跟200，200存在于里面，而150不在。<strong>推测：索引为B+树类型，所以当存在相同的元素时，就可以直接根据B+树的有序性进行合理上锁，即对符合条件的记录上锁</strong>。那么如果不存在相同的元素，即不存在150，而且又不是unique index，仅仅是使用了一个non-unique index并且被动地去cluster index中查找，这时候就会把所有记录上锁，因为cluster index是一个特殊的index，具体的细节我也不懂，得去看源码。但现在只需要知道，<strong>cluster index无法标记到相同的元素，就无法进行定位了，然后就直接把所有record都锁了，当然在RR下还有gap locks</strong>）</p>
<p>对于句子3：<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_47.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_47.png" alt="A终端"></a></p>
<p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_48.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_48.png" alt="B终端"></a><br>可见，由于里面没有符合条件的记录，所以select没有被阻塞。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_49.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_49.png" alt="B终端"></a></p>
<p>可是，insert却是会被阻塞的。而且阻塞范围就是寻找边界。这里上锁的区域是[300, ＋∞)<br>（虽然400不存在于表中，但由于没有符合的记录，就没有把record给上锁了，所以也仅仅是添加了gap locks。但gap locks包含300，却只能search不能insert。看来只能看源码才能切实看懂了！先记住罢！）</p>
<p>对于句子4：<br>跟句子2是一样的，select全部锁住了，毫无意外的话，insert应该也会被全范围的gap locks给锁住。（// TODO = =！）<br>确实如此，就不贴图了。</p>
<p>本来不想测试RC的，但RR的结果有点出人意料，所以现在再把RC也测试一遍：<br>句子1：<strong>select还是一样，符合条件的锁住。insert没有任何阻塞</strong>（因为不存在gap locks）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_50.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_50.png" alt="B终端"></a><br>句子2：跟RR的不一样，并不会全部锁住，而且也不会把记录都锁住。<br>select依然是符合条件的才锁住。而insert依然是没有任何阻塞（没有gap locks）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_51.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_51.png" alt="B终端"></a><br>句子3：还是一样。select该锁的锁，insert无阻塞。<br>句子4：一样。pass<br>（RC的insert无阻塞是毫不意外的，首先RC不存在gap locks，至于已经存在的record则会因为PK/cluster index而产生冲突，并不是因为gap Locks）</p>
<hr>
<h4 id="情况④：不使用PK，也不使用index"><a href="#情况④：不使用PK，也不使用index" class="headerlink" title="情况④：不使用PK，也不使用index"></a>情况④：不使用PK，也不使用index</h4><p>RC：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select* from testf where num &gt; 200 for update;</span><br><span class="line">select* from testf where num &gt; 150 for update;</span><br><span class="line">select* from testf where num &gt; 400 for update;</span><br><span class="line">select* from testf where num &lt; 250 for update;</span><br></pre></td></tr></table></figure>

<p>句子1：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_52.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_52.png" alt="B终端"></a><br>select全部锁住了，而且不仅仅是记录，包括gap。而RC是不存在gap locks的。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_53.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_53.png" alt="B终端"></a><br>而insert却是依旧跟预期一样，毫无阻塞（因为RC没有gap locks）</p>
<p>句子2：select也是一样全部阻塞。而insert也是毫无阻塞</p>
<p>句子3：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_54.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_54.png" alt="B终端"></a><br>select毫无阻塞，因为没有找到记录。insert也是毫无阻塞。</p>
<p>句子4：还是那样，select完全阻塞，insert没有阻塞。</p>
<p>RR：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select* from testf where num &gt; 200 for update;</span><br><span class="line">select* from testf where num &gt; 150 for update;</span><br><span class="line">select* from testf where num &gt; 400 for update;</span><br><span class="line">select* from testf where num &lt; 250 for update;</span><br></pre></td></tr></table></figure>

<p>句子1：<br>select依然全部被阻塞（RC都阻塞， RR岂有不阻之理？）<br>insert也是全部阻塞，因为RR多了gap locks，自然也就全部范围都锁住了。<br>句子2跟句子4显然结果也会是一样的。<br>那么再看句子3，竟然也是全部阻塞。</p>
<p>上面都是详细的推导环节，虽然还有所疑惑，但至少结果是没有错的，先总结了吧（关于insert并发这个，以后再说吧。这个应该满足了select/delete/update与insert之间的所有关系了，只差并发insert这一环节） PS : insert还有一个insert意向锁</p>
<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>分两大类情况：等值筛选（id = x），范围筛选（id &gt; x)<br>以下操作只考虑select跟insert（delete跟update约等于select。）</p>
<p>先看<strong>等值筛选</strong>：</p>
<p><strong><em>① RC / RR + PK</em></strong></p>
<p>锁住该条记录的。select，insert均不能使用相同的字段值（insert是因为同名，select是因为锁）</p>
<p><strong><em>② RC / RR + Unique Index</em></strong></p>
<p>跟①一样，只是底层实现有所不同（先对Unique Index的记录加锁，再对cluster index的记录加锁）</p>
<p><strong><em>③ RC + Non-unique Index</em></strong></p>
<p>锁住所有符合条件的记录（因为不是unique，可能选出多条记录）</p>
<p><strong><em>④ RC + No index(无索引）</em></strong></p>
<p>锁住所有的记录（MySQL优化后，对判断不满足条件的记录，进行释放锁操作。违背了2PL协议）</p>
<p><strong><em>⑤ RR + Non-unique Index</em></strong></p>
<p>锁住符合条件的记录，并且新增gap locks。会锁住记录与其相邻记录的中间间隔（按照有序排列）<br>gap locks一般按照 左闭右开的原则。</p>
<p><strong><em>⑥ RR + No index</em></strong></p>
<p>锁住所有的记录，具备gap locks。因为所有记录都锁住，所以从-∞到＋∞其实都被锁住了。<br>n条记录时，n个Record Locks， n + 1 个gap locks，一共 2n+1 个锁。</p>
<p><strong>范围筛选</strong>：（PS：如果两个select都是S锁，那当然是可以同时存在的，S锁之间兼容）</p>
<p><strong><em>① RC + PK / Unique Index / Non-Unique Index</em></strong></p>
<p>(RC条件下，只要使用Index，无论是Unique Index还是Non-Unique）<br>锁住符合的记录，可以select没有锁的记录，insert无限制。</p>
<p><strong><em>② RR + PK / Unique Index</em></strong></p>
<p>锁住符合的所有记录，还有gap locks。同样是可以select没有锁的记录，insert无限制。</p>
<p><strong><em>③ RR + Non-unique Index</em></strong></p>
<p><strong>Ⅰ. 当表中存在比较的值（即id &gt; x, table存在 id = x的记录）</strong></p>
<p>同①</p>
<p><strong>Ⅱ. 当表中不存在比较的值（id &gt; x, table不存在id = x的记录）</strong></p>
<p>select全部阻塞（除了不存在的记录），insert全部阻塞（record已经阻塞，加上gap必然的结果)</p>
<p><strong>Ⅲ. 当select返回的是empty set （例子：where id &gt; 100，而table中不存在id大于100的记录）</strong></p>
<p>同① （其实跟 Ⅰ 也是等价的，只是符合的记录为empty set）</p>
<p><strong><em>④ RC + No Index</em></strong></p>
<p><strong>Ⅰ. select返回的值非空</strong></p>
<p>select完全阻塞（包括不存在的记录也无法select），insert无阻塞（RC不存在gap）</p>
<p><strong>Ⅱ. select返回的是empty set</strong></p>
<p>select跟insert都没有阻塞</p>
<p><strong><em>⑤ RR + No index</em></strong></p>
<p>select跟insert必定全部阻塞。</p>
<p>PS：在RR的情况下，对于并非全锁的情况，Gap Locks的边界值考量方法都是一样的（都是找左右相邻最近的，即使你是empty set，那么就找table中最大/最小的那个当边界，都是一样的，此处略）<br>并且，此处主要考虑的是RC跟RR级别下的情况。<strong>对RU跟Serializable并无太多讨论</strong>。而且只考虑了select与insert，select与select之间的冲突（据说select跟delete，update都是一个形式，那么就略了），还剩下的是Insert与Insert之间的冲突，即并发插入，TODO吧。</p>
<p>PPPS：写完之后再整理，想到了大佬文章里的第五点，<strong>SQL语句的执行计划是什么？是索引扫描还是全表扫描？</strong>我当时认为这点可以忽略，因为我认为cluster index必定存在，所以即使是全表扫描也是等同于索引扫描，只是扫描cluster index的时候存在一点特殊（就是上文提到的那点）现在看来，cluster index虽然是index，但确实是特殊的index，当我们需要使用全表扫描，<strong>即使是使用了cluster index，也是不能完全等同于索引扫描的</strong>。想想最后在范围搜索那里，出现的意外情况无法理解的，应该就是这一点了吧。（因为当时的注意力主要在考虑InnoDB是否存在表锁，然后最后的主要论据就是必定存在cluster index，所以必定有索引，表现出表锁的特征其实是行锁加间隔锁的作用等等……实际上，这一点倒是没有错，但cluster index是特殊的index也不可忽视！）</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM知识整理</title>
    <url>/JVM%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html</url>
    <content><![CDATA[<h3 id="一-类的生命周期：加载→连接→初始化→使用→销毁"><a href="#一-类的生命周期：加载→连接→初始化→使用→销毁" class="headerlink" title="一. 类的生命周期：加载→连接→初始化→使用→销毁"></a>一. 类的生命周期：加载→连接→初始化→使用→销毁</h3><h5 id="连接-包括："><a href="#连接-包括：" class="headerlink" title="连接 包括："></a>连接 包括：</h5><p>①验证（确保被加载的类的正确性）<br>②准备（为静态变量分配内存，并将其初始化为默认值（指0，false，null等），同时将static final值转换为具体的常量<br>③初始化：为静态变量执行赋值语句（static，非final），执行静态块<br>PS：初始化只有在对类主动使用时才会执行，包括以下：<br>①new<br>②访问静态域的时候<br>③反射（如Class.forName)<br>④初始化某个类时，其父类也会初始化<br>⑤运行main方法时，该类加载</p>
<a id="more"></a>

<hr>
<h5 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器:"></a>类加载器:</h5><p><em>①Bootstarp ClassLoader</em>（启动类加载器，由C++实现的类，无法获取实例）<br>负责加载JDK下/lib的类库（如java.*等关键类，是最底层的Class Loader)</p>
<p><em>②Extension ClassLoader</em>（拓展类加载器<br>负责加载JDK下 /lib/ext目录，即额外的类库</p>
<p><em>③Application ClassLoader</em>（应用程序类加载器负责加载用户类路径的类，即ClassPath</p>
<p><em>④其他自定义的类加载器    User Class Loader</em><br>PS：这里的加载器并不是通过继承组成的关系，而是组合。    ②③④都继承自java.lang.ClassLoader</p>
<hr>
<h4 id="question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）"><a href="#question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）" class="headerlink" title="question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）"></a>question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）</h4><p>ans：双亲委派模型：当一个Class loader收到了加载类的请求，它不会立刻加载，而是先交给父类加载器加载，但父类加载器找不到那个类，才传递回给子类加载器。即优先在Bootstarp中加载，然后是Extension，然后就才是Application。<br>这样做的好处：<br>①只有1个classloader加载了类，防止内存中会出现同样的字节码<br>②增强了安全性，避免用户自己定义了java预定义的类并成功覆盖。比如用户自定义了一个java.lang.Object的类，这时候它会优先从Bootstrap中加载，而Bootstrap中加载的是java预定义的Object类，而不是用户自定义的Object类，这样就避免了用户的Object类覆盖。如果是先从Application Class loader中加载，那么就是先加载用户自定义的Object类，而Java预定义的Object类被覆盖掉。</p>
<hr>
<hr>
<h3 id="二-JVM的内存结构："><a href="#二-JVM的内存结构：" class="headerlink" title="二. JVM的内存结构："></a>二. JVM的内存结构：</h3><p><strong>JDK1.6： Heap + PermGen（Method Area）永久区，方法区 + Stack + Program Counter Register</strong><br>同时：<strong>①Stack = JVM Stack + Native Method Stack</strong><br>Stack用于描述Java方法执行的内存模型，每个方法执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表，操作栈，动态链接，方法出口，基本类型和对象的引用等等。每一个方法从被调用直至执行完成的过程，就对应一个栈帧在JVM Stack中从入栈到出栈的过程。<br>（Native同理，只是作用与本地方法）<br>PS：如果线程请求的栈深度大于JVM所允许的深度，抛出StackOverflowError。<br>如果JVM Stack可以动态拓展，拓展时无法申请到足够的内存，抛出OutOfMemoryError</p>
<hr>
<p><strong>②Heap = Young Generation年轻代 + Old Generation 老年代</strong><br><strong>Young = Eden + From Survivor  + To Survivor</strong><br>通过各种参数可以控制各区域的内存大小，进而达到JVM调优效果<br>-Xms， -Xmx：设置Heap的最小，最大空间的大小<br>-XX:NewSize， -XX:MaxNewSize： 设置年轻代最小，最大空间的大小<br>-XX:PermSize, -XX:MaxPermSize： 设置永久区最小， 最大空间的大小<br>-Xss：设置每个JVM Stack的大小<br>（PS：Perm是永久区，要设置老年代只能通过 Heap - Young来间接控制）<br>PS：在Heap区中，有可能抛出OutOfMemoryError</p>
<hr>
<p><strong>③Program Counter Register</strong><br>较小的内存空间，是当前字节码的行号指示器（用于分支，跳转等待）<br>如果执行的是Java方法，记录正在执行的JVM字节码的指令地址。<br>如果是Native方法，那么为空（Undefined）<br>（此区域是JVM唯一无OutOfMemoryError的区域，因为一般不会在这里抛异常）</p>
<p><strong>④PermGen（Method Area）方法区，永久区</strong><br>用于存储已经被JVM加载的类信息，常量，静态变量，JNI编译后的代码·<br>（会抛出OutOfMemoryError）<br>PS：Heap 和Method Area在线程间是会共享资源的，而Stack和Counter是线程私有的。</p>
<hr>
<p><strong><em>JDK各版本的区别： (1.6 ~ 1.8)</em></strong><br>JDK1.6中，各种常量池是放在方法区中的<br>JDK1.7中，常量池放在Heap中，此时：Heap = Young + Old + 各种常量池<br>（PS：关于常量池，这里还有一个TODO，即intern那中问题，看《JVM入门到放弃》）<br>JDK1.8:常量池依然在Heap中，但永久区/方法区被移除，改为使用metaSpace（元空间）</p>
<hr>
<hr>
<h4 id="question2：移除永久区PermGen的原因"><a href="#question2：移除永久区PermGen的原因" class="headerlink" title="question2：移除永久区PermGen的原因"></a>question2：移除永久区PermGen的原因</h4><p>①永久区一直只存在于HotSpot JVM，而JRockit VM没有永久区，为了融合两个JVM而做出的调整，无须继续配置永久区<br>②永久区内存经常不够用，或者发生内存泄漏，抛出OutOfMemoryError：PermGen<br>③永久区会为GC带来不必要的复杂度，并且回收效率偏低</p>
<hr>
<h4 id="question3：元空间metaSpace和永久区的区别？"><a href="#question3：元空间metaSpace和永久区的区别？" class="headerlink" title="question3：元空间metaSpace和永久区的区别？"></a>question3：元空间metaSpace和永久区的区别？</h4><p>元空间并不在VM中，而是使用本地内存，默认情况下，仅受本地内存的限制。（可以通过配置参数来控制meta Space，默认情况下，最大空间没有限制，即内存的上限）。配置参数：<br>-XX：MetaspaceSize， -XX：MaxMetaspaceSize    初始空间大小，最大空间大小<br>-XX：MinMetaspaceFreeRadio， -XX：MaxMetaspaceFreeRadio：<br>在GC之后，最小/最大的Metaspace剩余空间容量的百分比</p>
<hr>
<h4 id="question4：常量池为什么要移动到Heap"><a href="#question4：常量池为什么要移动到Heap" class="headerlink" title="question4：常量池为什么要移动到Heap"></a>question4：常量池为什么要移动到Heap</h4><p>因为方法区的回收比较困难，会导致过多严重的bug，所以从1.7开始就把常量池移动到Heap，为后续移除PermGen做出准备（在JDK1.8已把PermGen移除）</p>
<hr>
<h3 id="三-GC算法："><a href="#三-GC算法：" class="headerlink" title="三. GC算法："></a>三. GC算法：</h3><p><strong>①标记-清除 Mark-Sweep</strong><br>缺点：效率不高，且会产生大量的内存碎片<br><strong>②复制算法 Copying</strong><br>缺点：会使内存缩小一半，不能直接用在Old，因为持续复制长生存期的对象会导致效率降低<br><strong>③标记-压缩 Mark-Compact</strong> （在①的基础上，清除完之后还对碎片进行压缩）<br><strong>④分代收集Generational Collection</strong> 即年轻代用 复制算法，老年代用标记清除/压缩</p>
<hr>
<p><strong>垃圾回收器</strong>：<br>①Serial，串行收集器。最古老，最稳定，效率高。但会产生较长的停顿<br>②ParNew，即Serial的多线程版本<br>③Parallel，于ParNew类似，但更关注系统的吞吐量<br>④CMS（Concurrent Mark Sweep）<br>重视服务的响应速度，希望系统停顿时间最短，但会产生大量的空间碎片，降低吞吐量。<br>⑤G1（Garbage-First）<br>满足了GC停顿时间要求，同时又具备高吞吐量的特征<br>（收集器之间可以组合使用，如Young使用A，Old使用B）</p>
<p>MinorGC：对年轻代进行GC。特点：频繁，回收速度快<br>MajorGC：对老年代进行GC。<br>FullGC：全堆范围的GC</p>
<hr>
<h4 id="question5：什么情况下会出现内存溢出-泄漏？"><a href="#question5：什么情况下会出现内存溢出-泄漏？" class="headerlink" title="question5：什么情况下会出现内存溢出/泄漏？"></a>question5：什么情况下会出现内存溢出/泄漏？</h4><p>虽说Java有GC，无须我们手动释放资源，但在运行时还是可能出现对象可达，但不会被使用的情况，这时候就会导致内存泄漏。例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/jvm_1.png" target="_blank" rel="noopener" title="Java内存泄漏例子"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/jvm_1.png" alt="Java内存泄漏例子" title="Java内存泄漏例子"></a><br>内存溢出的可能原因：<br>①内存泄漏导致Stack内存不断增大，引发OutOfMemory（Stack处）<br>②大量jar，class文件加载，装载类的空间不足，溢出 （Class Loader处）<br>③操作大量对象，导致Heap空间不足，溢出（Heap处）<br>④nio直接操作内存，内存过大导致溢出（内存处）<br>（同理应该MetaSpace溢出也是一样的）<br>解决方法：查看是否有内存泄漏，设置参数增大空间，代码是否存在死循环生成过多对象</p>
<hr>
<h4 id="question6：JVM从Young到Old的晋升条件是什么"><a href="#question6：JVM从Young到Old的晋升条件是什么" class="headerlink" title="question6：JVM从Young到Old的晋升条件是什么"></a>question6：JVM从Young到Old的晋升条件是什么</h4><p>①对象在Eden出生，经过一个MinorGC还存活，就被Survivor容纳，在From和to中复制交换。如果经过[MaxTenuringThreshold]（默认是15）次交换还存活，进入Old<br>②如果对象大小等于Eden的二分之一，直接分到Old。如果Old也分配不下，做一次MajorGC<br>（如果小于Eden的二分之一，但没有足够的空间，进行MinorGC）<br>③MajorGC之后，如果Survivor仍然放不下，则放到Old<br>④动态年龄判断。如果大于等于某年龄的对象超过survivor空间的一半，则这些对象全部都直接进入Old（无须达到MaxTenuringThreshold)</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库三级封锁协议</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>数据库并发会导致各种问题（即多线程下导致的同步问题），需要用lock来解决。</p>
<p>一般会导致的问题：<strong><em>脏读，不可重复读，第一类更新丢失，第二类更新丢失</em></strong></p>
<p>为了解决这些问题，需要使用锁机制，数据库一般有三级封锁协议。本文阐述了这些问题具体是什么，锁机制如何解决这些问题。</p>
<a id="more"></a>

<h3 id="二-数据库并发导致的问题"><a href="#二-数据库并发导致的问题" class="headerlink" title="二. 数据库并发导致的问题"></a>二. 数据库并发导致的问题</h3><hr>
<p>①<strong><em>脏读</em></strong>（<em>dirty read</em>）：事务A update了data，事务B读取了update后的data，此时事务A rollback，导致B读取的是错误的数据，即dirty data</p>
<hr>
<p>②<strong><em>不可重复读</em></strong>（<em>unrepeatable read</em>）：B读取了data，A读取了data并且进行了update，此时B再次读取data，两次获取到的data并不一致。</p>
<hr>
<p>③<strong><em>第一类更新丢失</em></strong>：A读取了data①，B读取了data并且进行update，commit。A同时又对data进行update，而这个update是在①的基础上操作的，最终B的更新就会被丢失。</p>
<hr>
<p>④<strong><em>第二类更新丢失</em></strong>：B读取了data，A读取了data。B对data进行update，然后commit。接着A又对data进行update，commit。同样的，B的更新会被丢失。</p>
<hr>
<h3 id="三-数据库的锁机制"><a href="#三-数据库的锁机制" class="headerlink" title="三. 数据库的锁机制"></a>三. 数据库的锁机制</h3><p>数据库有两种锁，S锁和X锁：<br><strong>S锁（shared）：事务可读不可写。（其他事务可以同时添加S锁）</strong><br><strong>X锁（exclusive）：事务可读可写。（其他事务不可以同时添加任何锁）</strong><br>锁之间的兼容性，设定有两个锁a1，a2，用f(a1, a2)来表示两个锁的兼容性，如果f = 1，则表示兼容。如果f = 0，则不兼容。<br>f(s, s) = 1;其他诸如：f(x, x)= f(x, s)= f(s, x) = 0;<br><strong><em>即X锁不能与其他锁同时存在。而s锁与s锁之间可以同时存在。</em></strong></p>
<hr>
<p><strong>1.一级锁协议：</strong>事务T修改数据R之前，先加X锁，直到事务结束时释放（无论是正常结束commit还是非正常结束rollback）<br>作用：可防止 更新丢失问题。<br>不能防止： 脏读，不可重复读，幻读等。<br>PS：任何数据库都至少满足一级锁的协议，因为更新丢失是不能接受的错误，所以更新丢失一般只存在于理论讨论中，实际应用中基本不会出现这个问题。</p>
<hr>
<p><strong>2.二级锁协议：</strong>在一级锁的条件下，T在读取R之前先加S锁，读完后释放。<br>作用：可防止更新丢失，脏读。<br>不能防止： 不可重复读，幻读。</p>
<hr>
<p><strong>3.三级锁协议：</strong>在一级锁的条件下，T在读取R之前先加S锁，事务结束后释放。<br>作用：可防止 更新丢失，脏读，不可重复读，幻读。</p>
<hr>
<hr>
<h3 id="四-具体例子来说明锁的作用机制："><a href="#四-具体例子来说明锁的作用机制：" class="headerlink" title="四. 具体例子来说明锁的作用机制："></a>四. 具体例子来说明锁的作用机制：</h3><h5 id="①不使用锁导致的更新丢失问题："><a href="#①不使用锁导致的更新丢失问题：" class="headerlink" title="①不使用锁导致的更新丢失问题："></a>①不使用锁导致的更新丢失问题：</h5><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_1.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_1.jpg" alt=""></a></p>
<h5 id="②使用一级锁解决更新丢失问题："><a href="#②使用一级锁解决更新丢失问题：" class="headerlink" title="②使用一级锁解决更新丢失问题："></a>②使用一级锁解决更新丢失问题：</h5><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_2.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_2.jpg" alt=""></a><br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_3.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_3.jpg" alt=""></a></p>
<h5 id="③为什么一级锁不能解决脏读问题："><a href="#③为什么一级锁不能解决脏读问题：" class="headerlink" title="③为什么一级锁不能解决脏读问题："></a>③为什么一级锁不能解决脏读问题：</h5><p>脏读例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_4.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_4.jpg" alt=""></a><br>用一级锁的情况：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_5.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_5.jpg" alt=""></a></p>
<h5 id="④使用二级锁解决脏读问题："><a href="#④使用二级锁解决脏读问题：" class="headerlink" title="④使用二级锁解决脏读问题："></a>④使用二级锁解决脏读问题：</h5><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_6.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_6.jpg" alt=""></a></p>
<h5 id="⑤为什么二级锁不能解决不可重复读问题："><a href="#⑤为什么二级锁不能解决不可重复读问题：" class="headerlink" title="⑤为什么二级锁不能解决不可重复读问题："></a>⑤为什么二级锁不能解决不可重复读问题：</h5><p>不可重复读例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_7.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_7.jpg" alt=""></a><br>使用二级锁的情况：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_8.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_8.jpg" alt=""></a></p>
<h5 id="⑥三级锁解决不可重复读："><a href="#⑥三级锁解决不可重复读：" class="headerlink" title="⑥三级锁解决不可重复读："></a>⑥三级锁解决不可重复读：</h5><p>三级锁相当于，完全串行化。即一个事务开始了，其他事务都完全不能开始进行，无论是读还是写。因此就上述的例子，一定是A完全执行完毕，才轮到B执行。那么就必定不会出现不可重复读的问题。（三级锁的完全串行化，也就是，为了解决并行化带来的问题，直接不使用并行，改为串行执行。）</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Github的简要操作</title>
    <url>/Github%E7%9A%84%E7%AE%80%E8%A6%81%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<p>记录一下IDEA项目提交到GitHub的整体操作:（主要是清晰每一步的作用，而不是死记硬背）<br><strong>step1:</strong><br>IDEA的GitHub<strong>连通配置</strong>。（这个就在setting-git那里，但一般配置一次就不再需要了，pass）<br><strong>step2：</strong><br>将本地的项目连接到GitHub。 <em>VCS — Import into Version</em> Control （会让你创建一个仓库）<br>然后再将项目切实地与该仓库连接。<em>VCS — Import into Version Control — Create Git Repository</em><br>（有一次没有Create，右键项目甚至没有git操作）</p>
<a id="more"></a>

<p><strong>step3：</strong><br>连接了之后，就是提交操作了，提交其实一共有3个步骤，不要胡乱pull跟push就什么都不会了。<br><strong>PS：只要IDEA的项目已经成功执行了步骤1和2，那么之后其实就不需要前面两个步骤了。</strong><br>①<strong>VCS — Git — add</strong><br>作用，把本地发生改变了的代码添加到branch中，其实就是先把你的代码都commit到本地的一个分支了，但这里还没有提交。<br>②<strong>VCS — Git — Commit File</strong><br>第一步的操作只是add到工作环境，还没添加到本地仓库，这里把所有add的文件commit到本地操作<br>③最后就是提交到远程仓库。这个最后一步才是pull跟push的地方。<br><strong><em>先pull，再push即可</em></strong>。<br>pull的作用其实就是先跟远程仓库的代码对比，因为可能别人已经commit过，与你的代码产生冲突，这时候你需要解决这些冲突再commit，不然你把别人的代码覆盖了怎么办？<br>push就是最后的提交代码了，一般pull成功的话push也就没有问题。</p>
<p>但是，在第一次创建的时候，可能会存在问题，好像是因为不在同一个项目里，无论是change分支，还是git pull —allow-unrelated-histories啊等等的，都不行。<br>其实第一次创建，又不可能conflict（唯一可能conflict的地方只有一个readme文件而已。。）<br>所以干脆直接强制push即可: <strong>git push -u origin master -f</strong> (-f 很显然，就是force）</p>
<p>其他常用操作：<br>查看远程仓库： git remote -v (remote就是远程的意思）<br>添加远程仓库： git remote add (nick_name) (repository-url)<br>删除仓库（注意是删除与仓库的连接而已)：git remote remove nick_name<br>（一般nick_name都叫origin了，不知为何，先这样记着）</p>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读Servlet的源码</title>
    <url>/%E9%98%85%E8%AF%BBServlet%E7%9A%84%E6%BA%90%E7%A0%81.html</url>
    <content><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>在写SSM项目的过程中，遇到了一些小问题，不知道如何解决。其实对于框架的很多问题，很多时候都是因为框架的封装性，然后自身没有理解框架的内部逻辑而导致的。于是这次想花点时间好好读一下Servlet的源码，这样可以更好地理解JavaWeb底层，遇到问题也能更加地游刃有余。当然此次阅读源码只是比较浅显的，先看官方文档，然后在有目的性地读一部分源码来感受文档的内容。如果要认真看那肯定要看很久，目前还没这个时间。<br>    <strong>首先是Servlet API包含了两个软件包，javax.servlet和javax.servlet.http</strong>，为什么会有两个呢，因为早先设计该规范的人认为Servlet是一种服务模型，不一定要依赖于某种网络协议之上，于是就抽象出了一个javax.servlet，同时再提供一个基于HTTP协议上的接口拓展。但目前看来，似乎还没有发现有其他协议上实现的Servlet技术。</p>
<a id="more"></a>

<hr>
<h3 id="二-HTTPServlet抽象类"><a href="#二-HTTPServlet抽象类" class="headerlink" title="二. HTTPServlet抽象类"></a>二. HTTPServlet抽象类</h3><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/1.jpg" alt="img">)](<a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/1.jpg" target="_blank" rel="noopener">https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/1.jpg</a>)<br>官方解析：<br>    <em>Provides an abstract class to be subclassed to create an HTTP servlet suitable for a Web site.A subclass of HttpServlet must override at leat one method usually one of these: doGet,doPost,doPut,doDelete.</em><br>    提供一个抽象类，使得它的子类可以更方便地创建一个标准HTTP Servlet。子类必须至少实现以下方法的其中一个：<strong>doGet，doPost，doPut，doDelete</strong><br>    <strong>标准Servlet接口有一个service方法</strong>，即service的标准服务方法。但是service方法没必要override，因为HTTPServlet已经把service方法写好了，把标准的HTTP请求通过它们的HTTP request类型(即请求的doXXX)，分别转发到具体的处理方法中。比如类型是doGet，就转发到doGet方法中。<br>HttpServlet里的service方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    String method = req.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// servlet doesn't support if-modified-since, no reason</span></span><br><span class="line">        <span class="comment">// to go through further expensive logic</span></span><br><span class="line">        doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">        <span class="keyword">if</span> (ifModifiedSince &lt; (lastModified / <span class="number">1000</span> * <span class="number">1000</span>)) &#123;</span><br><span class="line">            <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                    <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                    <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">            maybeSetLastModified(resp, lastModified);</span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">        <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        可以看到是通过Java反射的机制，获取了HttpServletRequest的方法，返回了一个method的字符串，根据method来判定到底是属于哪一个doXXX，再分别调用doXXX方法。这里我钻了一下牛角尖，HttpServletRequest里有多个方法，getMethod方法的内部逻辑是如何返回的呢。HttpServletRequest只是一个接口，寻找了很久只找到了一个实现类HttpServletRequestWrapper，然而还是没有具体的getMethod实现。最后知道了这个HttpServletRequest是由J2EE的容器来实现的，比如Tomcat，webLogic。看来我们是不能得知getMethod的具体逻辑了，只需要知道它可以返回HTTP报文头的method是什么就行。<br>​        然后如果是METHOD_XXX方法，就调用doXXX方法。好几个方法都没有特别，直接调用。但HEAD方法和GET方法多了一个逻辑，用于验证文件是否已经被修改。HEAD和GET都是获取服务器上的资源，但HEAD不需要返回消息体，只请求返回报文头，空的消息体，也就是说，它可以用于检测资源是否有效，是否存在，网站是否有篡改等。当需要这类操作的时候，就不需要用GET了，用HEAD即可。如果本地有缓存文件，和要GET的文件是相同的，没有修改过的，那么此时就会返回状态码304，表示文件没有被修改。虽然返回304的时候已经做了一次数据库查询，但可以避免接下来更多的数据库查询。对于HEAD方法，只返回HTTP报文头，更是降低了带宽的消耗。<br>​    最终到达了doXXX的方法，以GET方法为例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String protocol = req.getProtocol();</span><br><span class="line">    String msg = lStrings.getString(<span class="string">"http.method_get_not_supported"</span>);</span><br><span class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">"1.1"</span>)) &#123;</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这里有个特别的地方是，虽然doXXX方法有具体的实现，但它是无论如何都会返回错误的，即sendError。这是避免了具体子类直接调用HttpServlet的doXXX方法。因此子类必须重写至少1个doXXX方法，然后再通过HTTP的method判断要调用哪个doXXX方法，进而调用子类重写的doXXX方法。</p>
<hr>
<h3 id="三-Servlet-ServiceConfig接口"><a href="#三-Servlet-ServiceConfig接口" class="headerlink" title="三. Servlet, ServiceConfig接口"></a>三. Servlet, ServiceConfig接口</h3><p>​    一个Java Servlet具有生命周期，这个生命周期定义了一个Servlet如何被载入并被初始化，如何接受请求并对请求的响应，如何从服务中被清除等等。Servlet的生命周期被javax.servlet.Servlet这个接口所定义。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/5.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/5.jpg" alt="img"></a><br>​    所有的Java Servlet都会直接或间接地实现javax.servlet.Servlet接口，这样它才能在一个servlet引擎中运行。servlet引擎是web服务器按照Java Servlet API定制的拓展。Servlet引擎提供网络服务，能够理解MIME请求，并提供一个运行Servlet的容器。<br>​    只有实现了Servlet接口的才是Servlet，然后才包含Servlet的生命周期。当然，继承了HttpServlet，就是继承了GenericServlet，就是实现了Servlet接口。<br>​    ServletConfig就是用于获取Servlet的配置，比如初始化参数，参数名等等，还可以获取该Servlet的ServletContext对象。</p>
<hr>
<h3 id="四-ServletContext接口"><a href="#四-ServletContext接口" class="headerlink" title="四. ServletContext接口"></a>四. ServletContext接口</h3><p>​    Servlet上下文，服务器会为工程建立一个全局唯一的ServletContext对象，工程内部所有的Servlet都共享这个对象，可以用于读取全局配置参数，搜索资源文件等等。</p>
<hr>
<h3 id="五-ServletRequest接口等"><a href="#五-ServletRequest接口等" class="headerlink" title="五. ServletRequest接口等"></a>五. ServletRequest接口等</h3><p>ServletRequest接口，请求时产生的对象，ServletResponse接口，响应时产生的对象。<br>SingleThreadModel接口，使得Servlet成为单线程。（只接受1个请求）<br>GenericServlet类，实现了Servlet接口，使得编写Servlet更方便。<br>ServletInputStream，ServletOutputStream抽象类，继承InputStream，OutputStream<br>ServletException，UnavailableException类，没什么好说的。</p>
<hr>
<h3 id="六-Filter接口"><a href="#六-Filter接口" class="headerlink" title="六. Filter接口"></a>六. Filter接口</h3><p>​    用于对request，response等任务进行过滤，一般是用doFilter方法来过滤，可以通过FilterConfig的对象来获取Filter的初始化参数。包含了destroy，init，doFilter方法。<br>生命周期：当有Servlet的service方法要被执行时，被init，直到所有的service方法已经执行完毕doFilter，或者过了一定的时间之后，就会执行destroy方法。<br>​    对具体实现类的基本要求：<br>①要对request进行验证检查。<br>②对request和response可以选择自定义实现类去包装<br>③当有多个过滤方法的时候，需要用到过滤链FilterChain，并且在当前的Filter没执行完之前，当前的数据都不会被通过。执行完之后会继续执行chain里的下一个filter<br>④在过滤链调用下一个filter的时候，就要直接设置当前的response header（避免窜数据）<br>FilterChain的多个filter执行顺序在web.xml的filter-mapping里控制<br>FilterConfig，对Filter的初始化配置参数等等。</p>
<hr>
<h3 id="七-RequestDispatcher接口"><a href="#七-RequestDispatcher接口" class="headerlink" title="七. RequestDispatcher接口"></a>七. RequestDispatcher接口</h3><p>​    直译就是请求分发器。具备两个方法，forward和include。<br>定义了一个对象，从客户端接受请求之后，需要将请求发给服务器。有的时候需要传递给另一个资源去响应。比如用户请求资源A，A可以在接受请求后，在A上面做一些准备工作，再从A转发转发大都B，由B去响应例子。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/2.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/2.jpg" alt="img"></a><br>第一个request就是A的准备工作，第二个就是转发到B，由B去响应。</p>
<p>include不是转发，是包含某个资源，比如Servlet，JSP，HTML页面<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/3.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/3.jpg" alt="img"></a></p>
<hr>
<h3 id="八-HttpServletRequest，HttpServletResponse接口"><a href="#八-HttpServletRequest，HttpServletResponse接口" class="headerlink" title="八. HttpServletRequest，HttpServletResponse接口"></a>八. HttpServletRequest，HttpServletResponse接口</h3><p>继承ServletRequest，ServletResponse接口，用于处理一个HTTP格式的请求/响应<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/4.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/4.jpg" alt="img"></a><br>主要方法，setAttribute，getAttribute(继承得来的),getSession等等。Response同理。</p>
<hr>
<h3 id="九-HTTPSession接口"><a href="#九-HTTPSession接口" class="headerlink" title="九. HTTPSession接口"></a>九. HTTPSession接口</h3><p>创建一个HTTP会话。<br>方法主要是获取Session的参数(ID，creationTime，最长存在时间等等),以及setAttribute。。</p>
<p>HttpSessionBindingListener接口。HTTPSession监听器，添加到Session中，监听Session，此处是监听binding，绑定事件。<br>还有其他的Session的Listener，比如Attribute，Activation监听器。（也就是HttpSessionAttributeListener,HttpSessionActivationListener）</p>
<p>HttpSessionBindingEvent类，实现了HttpSessionBindingListener接口。只多了两个成员属性。<br>HttpUtils类，收集HTTP Servlet使用的静态的有效方法。</p>
]]></content>
      <categories>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>在vscode配置Java环境遇到的问题</title>
    <url>/%E5%9C%A8vscode%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>​        之前一直把vscode当作一个sublime的强化版，仅仅把它当作一个编辑器而已。虽然一直也清楚这是一个很好的IDE，但却没有好好利用，可能是因为之前一直觉得IntelliJ IDEA已经满足了我的需求罢。直到最近，IDEA真的是变本加厉，只要一输入（拿着键盘随便乱敲），那么CPU就会暴增。cpu暴增一般情况下倒没什么所谓，反正没有超100就行吧（刚打开的时候还真的会升到100），可是我这破电脑只要CPU稍微高一点，风扇就开始呜呜呜地，像一台发电机。明天等待工具到了真的要把它拆开来除一下灰尘，但无论如何，IDEA过于臃肿已经是显而易见的问题了，还是需要认真考虑一下如何使用vscode吧。说实话，真的没想到我这么快就会想跟IDEA说再见，还记得当时刚开始学C++，非要听信那个菜比老师，用vs2010，体验极差，而我竟然用了两年多。大二的时候开始学Java，一开始是使用Eclipse，感觉也是比vs2010提升了一个档次。后来接触到了IDEA，真的是感觉神仙一样的软件，各种智能补全。当然了，中途还因为学数媒的原因，下载了一个vs2013，那个的体验其实也很好的，反正真的应该大一的时候就直接用vs2013，而不是那脑残的vs2010。总而言之，技术永远是在进步的，需求也是在增加的，对于用户，程序员，都是一样的。</p>
<a id="more"></a>        其实还考虑过优化IDEA，但参照了一下网上的做法，无论是修改JVM参数，还是关闭所有代码检查，都无济于事。说实话，一开始也不抱什么希望，因为我是只要键入就会飙升，那真的不太行。
<pre><code>然后开始搞vscode，突然想到了以前也尝试过，未遂。当时遇到的问题就是，它说我的JDK指向路径是空的，是version 0，可我指向的确切就是我一直使用的JDK8，我的IDEA都是在使用这个的。其实比较麻烦的是，我对vscode的各种参数，各种setting，包括快捷键，真的是几乎一无所知。当时仅仅也只是下载了几个plugins，当个普通的编辑器就完事了。最无奈的是，一直显示我没有配置JDK，或者准确地说应该是配置失败，但我直接使用一个Code Runner的插件时，直接使用alt+B就能成功运行了，可即便如此，还是不能直接点最上方的运行/ 调试，点了就报错。如果这个插件可以调试我可能就这样先暂时用着了，可是它似乎真的只能run，那只好继续处理。既然说是这个JDK有问题，那我便直接去下一个JDK吧，我下载了一个JDK12，修改了JAVA_HOME，重启电脑。结果发现java -version仍然是1.8。经过了许久的处理才发现，我以前在配置JDK的时候太过不求甚解了，导致遗留下来了很多错误。就是说，虽然这样做可以运行，但并不是正确的做法。比如JAVA_HOME其实就是用于存放JDK的一个路径，之后如果要放到ClassPath，或者Path等等的，都可以引用这个参数，%JAVA_HOME%，后面紧接着/bin，/lib等等的，差不多也就是可重用可维护了，以后如果要换JDK，直接改JAVA_HOME就行了。可我当时在ClassPath里使用了这个参数，在Path里却没有，说明当时根本就没有理解这个参数的作用。然后我把Path的绝对路径改成了JAVA_HOME，发现仍然不行。再仔细一看，原来这个根本就没有用上，因为上面还有3个不知道是什么的JavaPath，有什么AdoptOpenJDK，有Oracle commons files等等。在一台电脑上如果存在多个JavaPath，那么是最上方（win7应该就是最左方）的生效。所以我一直以为整台电脑都使用了的E盘的library下的JDK，原来根本就没有，我的环境变量竟然一直是OpenJDK，也就是说classpath跟path使用了两个不同的JDK罢了。把以前的蜜汁path都去掉之后，再把自己新增的%JAVA_HOME%/bin移动到了最上方，这下总算就成功了，java -version也成功改成了12。那么IDEA里一直用的1.8，会不会因此不能运行？答案是不会，因为IDEA根本就不需要环境变量的那个Path参数，那个是在cmd里，全局里生效的，相当于IDEA是在本地自己使用了另一个JDK。我一开始觉得JDK有点奇怪，使用java -verbose查看JDK路径，我还好奇为什么会是在C盘的一个OpenJDK里，原来是当时留下的各种错误啊。
JDK总算配置好了，但vscode依然不能运行，显示不能找到主类。这会我又没有动脑子，直接去改参数瞎搞。其实这个问题我在看编程思想的第一章就应该碰到过了，因为vscode毕竟不是传统的IDEA，它本体就是一个编辑器，非常轻量级，只有40M，但它可以通过各种plugins来增强功能罢了。因此，可能就是vscode确实就是直接使用环境变量里的ClassPath跟Path，直接命令行运行程序的，而IDEA这种还有更多的改进。那么直接在cmd里编译运行java程序会有一个什么经典的问题呢，就是package。最开始学java 的时候都尝试过cmd里编译运行，结果有一天会发现，自己明明第一个程序在cmd里是可行的，但在eclipse或者IDEA把代码复制过去便是找不到主类的。唯一的区别便是package，package其实就是一个文件夹，对于javac，java命令，这个还没智能到直接跳入到相应的位置去执行正确的文件，所以当时我们的解决方案是这样的，直接删掉package语句，然后就可以运行了，但显然并不是长远之计，难道以后写的程序都不加package了吗？于是正经的方案是这样的，给命令增加一个-d参数，还有一个什么什么的，忘记了，然后就可以根据package语句进入相应的路径去执行正确的文件了。所以，在vscode里也是要对基本的命令进行修改，比如默认是java test，那么就改成 java -d …… test。所以最后是在settings里增加这段代码：</code></pre><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/vscode_1.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/vscode_1.png" alt="settings代码"></a><br>        进入相应的$dir，然后再进行javac跟java，那么就大功告成（看起来还是跟-d有所区别的）至于其他的注释，便是针对其他的语言，这里无须理会。最后把vscode进行reload，程序就成功运行了。</p>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次服务器CPU100%的问题</title>
    <url>/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8CPU100%25%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<p>PS：写在前面，这篇文章最后<strong>并没有解决</strong>服务器CPU100%的问题，仅仅是记录在尝试过程中学到的知识点。</p>
<p>​    今天原本打算使用redis连接项目，正好网站备案通过了，正打算先测试一下域名是否可用，结果反而整个项目都不可用了。想着应该又是tomcat那边的问题，先上服务器看了一下，感觉服务器的卡顿越来越厉害了，时不时就会卡住然后断开连接。想想腾讯云也不至于这么烂，于是查了一下原因。虽说最后没有解决，但当中的过程还是学习到了很多。目前先把出错的服务器保存了一个snapshot，然后对服务器进行重载。先把这个问题放下，以后再回去解决。（主要是我数据库没有进行备份，数据还在上面，而数据库也出问题了，完全无法connect，自然也无法备份了。但保存了snapshot，那么数据库文件还在里面，等到需要那部分数据的时候，就对snapshot进行载入，然后再修复错误去获取数据吧，现在先放下这个问题）</p>
<a id="more"></a>    首先就是先运行了一下top命令，意外地发现%id为0，即CPU idle space为0，也就是CPU使用率竟然是100？那肯定是出现问题了，而且这样的话断开连接也不足为奇了，那么CPU 100%到底是从什么时候开始的，先查看了一下腾讯云的监控记录：

<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_1.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_1.png" alt="腾讯云的监控记录"></a></p>
<p>​    （吃惊）竟然一直是100的？我服务器上也没运行几个程序，也就一个tomcat（而且因为网站备案的原因，甚至直接stop了），还有mysql跟redis，但又没有事务读写，怎么会出现问题呢？于是我调了一下时间，调到5月初直到现在，看看是否一直都是100，还是在什么时候变成了100：</p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_2.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_2.png" alt="更久之前的监控数据"></a></p>
<p>把鼠标指到确切的转折点，可以看到，是8月30号这天开始飙升的，而且之后就一直高居不下，那么8月30那天我在服务器上做了什么呢。翻了一下日记，我在8.30这天学习了Redis，也就是在服务器上装了Redis。虽说没什么道理，但确实如此，没有任何其他理由。等一下我还要在我刚刚重装的服务器上安装mysql跟redis，看一下还会不会出现100的问题。如果会，再重装，只安装redis。虽说后面会换另一台服务器去单独做MySQL跟redis服务器，但这个问题肯定还是要解决的。</p>
<hr>
<p>那么在解决的过程我使用了哪些命令，又遇到了哪些子问题，继续去处理的，现在列一个清单。</p>
<p>①首先去查询top的用法<br>top命令虽然是我实习的时候用得最熟练的命令，但时间过去太久了，我也记不清它的很多数值是什么意思。然后知道了%Cpu就是CPU的使用情况，其中：%us表示用户空间程序的CPU使用率，%sy表示系统（Kernel）的CPU使用率，%ni表示用户空间且通过nice调度过的程序的CPU使用率。<br><em>CPU time = user space time + system space time</em><br>至于nice调度，其实就是进程的优先级，大致先知晓即可。<br>%id：空间的CPU（我就是这里一直是0，也就是idle space为0，CPU使用率100）</p>
<p>②除了CPU，还有可能是内存的问题<br>    对着top使用回车（刷新），发现CPU idle space很奇怪，会变化，而且要么是0，要么是100，显然是出现了一个错误的进程，然后突然导致100，而且还是一直生成，短暂过后又结束。最坑的是，使用top并找不到一个高CPU使用率的进程，所以完全不理解为何是100？可能是top显示的只是用户进程，不显示系统进程？<br>    于是继续对磁盘进行查看，使用了df -h命令。图片没有存，但大概是，磁盘空间大小是50G，已经使用了41G。虽然安装软件的时候没有想太多，但毕竟只安装了几个软件，不至于这么大的空间，因而对这块还是存有疑惑。然后再查看了腾讯云的磁盘监控（对了，腾讯云的监控出错了，然后还得执行一段命令才能查看，但就是很简单地copy执行一次即可，就在腾讯云官方上的代码）。最后的磁盘监控结果是这样的：</p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_3.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_3.png" alt="磁盘监控结果"></a></p>
<p>当时的磁盘读写一直很大，我就猜测是MySQL出现了错误，然后一直在编写错误日志？</p>
<p>③处理MySQL中的问题<br>    首先，我当时安装MySQL并没有直接安装服务service，这确实不是一个好的选择，tomcat也是如此。平时偶尔想对服务进行处理，使用systemctl，结果显示没有此service。然后还得去安装路径里自己调用shell脚本，然后还得找到这个安装路径，又是locate又是find，又是whereis的。<br>    然后想先看一下错误日志在哪，以往每次打开文件都是vim，实际上用head跟tail是一个很好的选择。不然突然一下子出现一大串文字的体验也是很差劲的。<br>    不过尝试了很多次，都无法彻底关闭mysql。这也就是安装法的最差劲的地方吧。找到了mysqld进程，都直接kill -9了，依然没有用处。如果是安装服务，直接systemctl stop即可。</p>
<p>④其他命令<br>因为top没有看到高CPU利用率的进程，于是还尝试了一些其他命令。<br>vmstat：查看系统负载<br>pidstat：查看进程使用磁盘的情况<br>pidstat -d 1：<br>netstat -na | grep 80 查找<em>80</em> 的端口（看是否开放，正在使用）</p>
<p>⑤finally<br>    其实没有解决问题，所以只能用最笨的方法，重装系统。虽然重装系统很快，一分钟就结束了，但还是很不好。首先必须得对服务器进行snapshot备份，毕竟数据库的数据也取不出来（感觉出错的原因主要就是MySQL跟redis的错）。然后数据至少存在了snapshot当中，等到需要那部分数据或者有空的时候，再new一个服务器去尝试解决。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>关于链表的一些疑惑</title>
    <url>/%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E6%83%91.html</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>​        链表想通的时候，感觉很简单，比数组还简单，只需要维护一个next指针，然后对指针进行操作即可。但有的时候也会遇到想不通的情况，这时候即便是非常简单的问题，都很难解决。所以这篇文章总结一下链表可能遇到的疑惑，下次遇到的时候查阅即可，无须每次都进行艰难的debug。</p>
<a id="more"></a>

<h5 id="当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？"><a href="#当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？" class="headerlink" title="当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？"></a>当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？</h5><p>出现这个疑惑是在一个非常简单的题目：<strong><em>反转一个链表</em></strong>。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" target="_blank" rel="noopener" title="反转链表"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" alt="反转链表" title="反转链表"></a><br>当时就觉得很奇怪，理应是非常简单的，却感觉不会做，画了很久的图，最后还用了4个指针才完成了，代码也是略显复杂。然后一看标准答案，果然跟预期的一样，十分简洁，但当时没有深究，于是后面总是要还的。因为一个地方不明白，后面肯定还会出现，这时候只会更加麻烦。<br>接下来看一下当时看不懂的标准答案：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" target="_blank" rel="noopener" title="答案"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_2.png" alt="答案" title="答案"></a></p>
<p>当时的疑惑很简单，curr.next指向了prev，但紧接着，prev就又发生了改变，那么curr.next不会改变吗？这看起来有点违反直觉，一开始觉得应该是二者指向了相同的地址，然后地址发生了改变，二者也就同时改变，但其实并不是这样的。这里最关键的就是引用的概念了。这里实际上是两个引用，curr.next跟prev，而curr.next = prev表示的是，curr.next指向了prev引用指向的对象。之后prev指向了其他的对象，并不会对curr.next造成影响。</p>
<hr>
<p>但是有的地方看起来是会发生改变，为什么？<br>首先要确定，到底改变的是对象，还是一个引用指向了其他的对象。<br>立刻想到的就是遍历，移除某个元素的例子：（移除所有val等于某个值的结点）</p>
<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" target="_blank" rel="noopener" title="链表移除某个元素的例子"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_3.png" alt="链表移除某个元素的例子" title="链表移除某个元素的例子"></a></p>
<p>这里对current操作，最后为什么head也会改变？<br>首先解答一个很简单的问题，为什么要有current，而不是直接在head上操作。因为我们在中间会将current后移（current = current.next)，这就导致了我们最后如果返回的是current，那么current已经移到了最后，即使前面的结果是正确的，也没有意义。<br>为什么要提这个问题？因为我一开始对于这个就想错了。我最开始对current引用的理解是，在current上操作，避免对head发生改变。但我们确实就是希望head发生改变啊，毕竟我们最后返回的就是改变后的head。所以我们确实就是通过current指向了head，然后改变current的中间结构，同时也成功地改变了head的中间结构，但我们要获取最终的链表，那么就需要获取头结点，所以才不对head进行操作。所以我们仅仅是保留了最初的头指针而已，如果上面的答案，是对head操作，最后返回的是current，作用也是一样的。<br>接下来就是问题的关键了，那么为什么会跟着改变？看起来current只是一个对象的引用罢了。这就是引用跟对象的区别了，这里的current确实是一个引用，但current.next却是一个实打实的存在于内存中的对象。所以，current.next = current.next.next，是直接在对象上发生改变，那么自然head.next(也就是现在的current.next）也会跟着改变了。而current = current.next，就是引用指向了其他的对象，也就是current引用指向了current.next。由于是引用指向了其他对象，那么显然也不会对head发生改变了。（所以关键就是确定到底是改变引用指向，还是改变对象）</p>
]]></content>
      <categories>
        <category>Datastructure</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Mysql的optimize语句</title>
    <url>/%E5%85%B3%E4%BA%8EMysql%E7%9A%84optimize%E8%AF%AD%E5%8F%A5.html</url>
    <content><![CDATA[<p>看到了一个optimize的语句，想尝试一下，但发现这个语句默认只在MyISAM引擎的表上执行，在InnoDB可能会出现错误，于是的确出现了错误：<br><em>Table does not support optimize, doing recreate + analyze instead</em></p>
<p>查找网上的解法，看到了这篇文章:<a href="https://blog.csdn.net/e421083458/article/details/39522513" target="_blank" rel="noopener">https://blog.csdn.net/e421083458/article/details/39522513</a><br>看样子是只需要在启动mysqld进程的时候，增加—skip-new参数即可。但下面还要一个shell脚本一键完成，因此想先尝试shell脚本。</p>
<a id="more"></a>

<p>可是发现在shell脚本里仍然不可执行，网上有说即使是用户root，可能也会因为一些错误而导致并非100%具备root的权限，因此尝试改了一下权限（权限在mysql.user表中），仍然不行。</p>
<p>无奈，只好使用第一种方法了。由于不是用systemctl启动的mysql，因此需要找到mysqld的启动进程我感觉以后装service还是直接装服务类型的程序，而不是用.sh文件启动的服务，那个太麻烦了（主要是我没有去刻意记住程序的位置，每一次都要locate，whereis去定位文件位置）。</p>
<p>然后发现关闭失败，即使找到process ID，kill -9，也无法关闭。然后我发现了一个很好的mysql管理命令：<code>mysqladmin -u root -p command</code><br>即使用root用户去运行mysql的某个“command”，启动命令之后先输入password，即可执行。<br>然后这里是关闭，所以是：mysqladmin -u root -p shutdown。没有显示异常。<br>再查找一下mysqld是否还存在：ps aux | grep mysqld，确实不存在了。<br>再在本地的navicat尝试连接数据库，连接失败。好了，数据库确实关闭了。</p>
<p>接下来我们启动mysqld，直接进行/xxx/xxx/mysqld 仍然显示错误，需要用root权限去启动，就跟直接调用shutdown时候出现的错误一样，那就简单了，直接继续用mysqladmin即可：<br><code>mysqladmin -u root -p /xxx/xxx/mysqld —daemin=xxx —skip-new</code><br>结果发现竟然不可以，推测是mysqladmin只能直接调用相关命令？其实增加参数肯定是可以的，但我不会啊！emm，那么换种思路，直接在调用mysqld脚本的时候增加user参数就好辣，于是：<br><code>/usr/sbin/mysqld —deamonize —pid-file=/xxx/xx/xx/xxx/mysqld.pid —skip-new —user=root</code><br>然后就启动成功了（其实刚刚shutdown的时候也直接加这么个参数就行了吧）</p>
<p>既然已经重新使用—skip-new参数去启动mysqld了，那么应该就能使用optimize命令了？</p>
<p>回到本地，用navicat继续调用optimize table <code>article</code>; 结果，竟然还是不行。错误信息：<br><em>[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column ‘information_schema.PROFILING.SEQ’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by”</em></p>
<p>然后发现原因是这个：<br><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/optinnodb_1.png" alt="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/optinnodb_1.png)"><br>即navicat的版本问题？！那么就直接在服务器上执行一遍吧。</p>
<p>然后再服务器上optimize table，果然没有任何错误。成功执行。（虽然只是个简单的命令，还是折腾了许久）<br>关于optimize的作用：当 您的库中删除了大量的数据后，您可能会发现数据文件尺寸并没有减小。这是因为删 除操作后在数据文件中留下碎片所致。Discuz! 在系统数设置界面提供了数据表优化的功能，可以去除删除操作后留下的数据文件碎片，减小文件尺寸，加快未来的读写操作。您只要在做完批量删除，或定期（如 每一两个月）进行一次数据表优化操作即可。</p>
<p>参考链接：<br><a href="https://www.cnblogs.com/Alight/p/3585646.html" target="_blank" rel="noopener">https://www.cnblogs.com/Alight/p/3585646.html</a><br><a href="https://blog.csdn.net/chuixue24/article/details/86624792" target="_blank" rel="noopener">https://blog.csdn.net/chuixue24/article/details/86624792</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Redis笔记</title>
    <url>/Redis%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>chapter1.</p>
<p>Redis没有表和Schema（Schema就是数据库对象的集合，这个集合包含了各种对象如：表、视图、存储过程、索引等</p>
<p>Redis用 key-value存储数据，所有的key必须是string类型</p>
<p>Redis的命令不区分大小写，但存储的数据区分（包括key-value）</p>
<a id="more"></a>

<p>chapter2.</p>
<p><strong>数据类型：（一个key只对应一种类型的value）</strong></p>
<p>1.string        </p>
<p>（关于双引号，应该默认是字符串，加引号保证空格的存在。单引号也可以）</p>
<p>SET    执行成功返回OK</p>
<p>（如果键值已经存在，那么覆盖先前的值。可以用EXIST命令来测试key的存在性。也可以用SETNX，即当key不存在时set。 set if not exist。如果设置成功，SETNX返回1.否则返回0）</p>
<p>命令选项：NX，XX（存在时候才set）</p>
<p>从Redis 2.6.12版本开始，SET命令的行为可以通过一系列参数来修改：</p>
<p>EX second：设置键的过期时间为second秒。SET key value EX second效果等同于 SETEX second value</p>
<p>PX millisecond： 设置键的过期时间为millisecond毫秒。SET key value PX m == PSETEX m value</p>
<p>NX：只有在键不存在时，才对键进行设置操作。SET key value NX == SETNX key value</p>
<p>XX：只有在键存在时，才对键进行设置操作。</p>
<p>选项例子：</p>
<p>redis 127.0.0.1:6379&gt; SET not-exists-key “value” <strong>NX</strong> OK      # 键不存在，设置成功</p>
<p>redis 127.0.0.1:6379&gt; SET exists-key “value” <strong>XX</strong></p>
<p># EX 和 PX 可以同时出现，但后面给出的选项会覆盖前面给出的选项 redis 127.0.0.1:6379&gt; SET key “value” <strong>EX 1000 PX 5000000</strong> OK</p>
<p>redis 127.0.0.1:6379&gt; SET key-with-expire-and-NX <strong>“hello” EX 10086 NX</strong> OK            //我猜是EX时hello。NX时10086</p>
<p>GET    不存在时返回    (nil)</p>
<p>STRLEN    计算字符串长度</p>
<p>APPEND    向一个字符串末尾追加字符串。如果该字符串不存在，先新建一个空字符串，再append</p>
<p>SETRANGE     参数： stringA， int， stringB</p>
<p>对stringA从偏移量int开始，直到结尾，用stringB替换（偏移量从0开始）</p>
<p>同理，如果stringA不存在，也是先new一个空字符串。如果int为0，那么就是new。</p>
<p>如果int不为0，前面的字符为 \x00     (好像是C++里的空字符）</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\7edf3f2832d645dca2c218773e8e0077$5pwjcaa(}cs.png)</p>
<p>\xhh表示十六进制，\x00 == 0x00， \x77 == 0x77。代码的作用应该就是看一下res地址对应的起始两个字节的值是否为0x00和0x77，对应于ascii字符的NULL和w。</p>
<p>OBJECT命令：可以查看value的内部编码形式    使用形式：OBJECT ENCODING stringA</p>
<p>（OBJECT还有其他功能，略）</p>
<p>string的三种编码形式：</p>
<p>①<strong>int</strong>。存储64位有符号整数表示的字符串</p>
<p>②<strong>embstr</strong>。长度小于等于44子节点字符串（使得在内存使用和性能方面更有效率）</p>
<p>③<strong>raw</strong>。长度大于44字节的字符串</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\801aa6d8307c4dea977870465435f2f2\clipboard.png)</p>
<p>2.列表 list    （就是stack，queue，array等等的）</p>
<p>LPUSH     key1     value1    value2</p>
<p>往 key1中添加 value1，value2值。返回添加元素之后key1的值。</p>
<p>如果key1已经存在，就是在后面继续添加，反之新建再insert</p>
<p>RPUSH    (将value添加到list的右端）</p>
<p>LINSERT         key1     BRFORE / AFTER        value1</p>
<p>添加到value1的前面/后面</p>
<p>只有当list存在才添加。 LPUSHX, RPUSHX</p>
<p>LRANGE        获取一定范围里的value</p>
<p>LRANCE     key1    int1        int2</p>
<p>即获取int1 ~ int2中的元素。index从0开始（跟数组一样）</p>
<p>（如果int2为 -1，表明读到结尾。所以 [0, -1] 就是输出所有value。</p>
<p>[2, -1]就是从第3个元素开始，输出到结尾）</p>
<p>获取某个index下的value：</p>
<p>LRANCE     key1    index1        index1     即可。</p>
<p>也可以： LINDEX       key1    index    </p>
<p>LPOP        RPOP        删除一个元素</p>
<p>list的index定义：从左到右： 0 ~ N - 1    从右到左：    -1 ~ -N</p>
<p>（所以0 ~ -1 表示整个列表）</p>
<p>​    </p>
<p>LTRIM    key1    int1        int2</p>
<p>删除key1中int1 ~ int2 之外的value</p>
<p>例子：LTRIM    key1    1    -1</p>
<p>即删除index为1到结尾以外的所有元素，即，只删除index为0的元素</p>
<p>LSET     key1    int        value</p>
<p>设置index为int的值，更改为value</p>
<p>LPOP和RPOP有对应的阻塞版本，即当list为空时，阻塞版本会将客户端阻塞。</p>
<p>BLPOP        BRPOP</p>
<p>同时还要设置超时时间，如果为0，表示永久等待。（在任务调度场景十分有用）</p>
<p>例子：</p>
<p>worker1&gt;        BRPOP     que1    0</p>
<p>worker2&gt;        BRPOP     que1    0</p>
<p>两个终端，阻塞执行。</p>
<p>此时对que1添加一个value1，worker1先执行，解除阻塞，把value1删除。</p>
<p>然后再对que1添加value2，value3，此时worker2解除阻塞，把value2删除。</p>
<p>最后que1里剩下了value3(先添加value2，立即删除，所以是剩下value3）</p>
<p>3.哈希 HASH 类型</p>
<p>相当于Map类型，即key里面还存储了其他的key-value，但存储实现方式是hashing。</p>
<p>（Redis本身其实就相当于一个hash。Redis的数据对象也可以再次使用hash，只要字段和值都是string类型。为了与Redis的key区分，hash里的“key-value”应该说成    “field-value”）</p>
<p>HMSET    key1    field1    value1    field2    value2    ……</p>
<p>设置多个hash字段，以及属性。（其实field-value集就是key1的value）</p>
<p>HMGET    key1    field1    field2    ……</p>
<p>获取多个hash的value</p>
<p>HGET    HSET    （获取/设置单个）</p>
<p>HEXISTS        是否存在某个字段</p>
<p>HGETALL    获取所有field和value    （阻塞，hash特别大时会导致Redis阻塞）</p>
<p>HDEL    删除field</p>
<p>可以用HSCAN替代HGETALL，此处略。</p>
<p>4.集合    SET类型</p>
<p>集合，SET，与Java一样，唯一，无序。（可用于去重）</p>
<p>SADD    添加</p>
<p>SISMEMBER    测试一个value是否在SET中</p>
<p>SREM    删除</p>
<p>SCARD    获取集合中成员的数量</p>
<p>SMEMBERS    列出所有value</p>
<p>同理，SMEMBERS会导致阻塞，可以改用SSCAN。略</p>
<p>集合间的操作：     SINTER        KEY        [KEY …]    交集</p>
<p>​    SUNION    KEY        [KEY …]        并集</p>
<p>​     SDIFF        差集</p>
<p>将集合运算的结果保存到K中：SINTERSTORE  K   KEY  [KEY…]</p>
<p>SUNIONSTORE    SDIFFSTORE</p>
<p>SET的编码，有两种方式：</p>
<p>intset    ：    对于value全是整数，且元素个数小于set-max-intset-entries时(默认为512）</p>
<p>（可以节省占用空间）</p>
<p>hashtable：    intset不适用时的默认编码</p>
<p>5.有序集合    SORTED SET类型</p>
<p>有序。    实现方式为：每个value还要拥有一个用于排序的权重。</p>
<p>ZADD    key1    weight1    value1    weight2    value2 ……    添加。</p>
<p>（与SET命令类似，可以使用NX,XX等选项）</p>
<p>ZREVRANGE        key1    int1        int2        [WITHSCORES]</p>
<p>获取排序。int1 ~ int2的value，0 ~ -1 即整个，和list一样。</p>
<p>WITHSCORES可选，表示 是否要列出 weight权重。</p>
<p>ZINCRBY    key1    int    value1</p>
<p>给value1的权重增加int</p>
<p>ZREVRANK    key1    value1</p>
<p>获取value1的排名（第一为 0）</p>
<p>ZSCORE        key1    value1</p>
<p>获取value1的权重</p>
<p>ZUNIONSTORE    合并两个SORTED SET。略</p>
<p>ZRANGEBYSCORE   key   MIN   MAX(从小到大），    ZREVRANGEBYSCORE</p>
<p>ZCOUNT KEY MIN MAX（指定范围内的成员个数）</p>
<p>集合之间的操作：ZINTERSTORE, ZUNIONSTORE    (没有ZDIFFSTORE, ZUNION）</p>
<p>6.HyperLogLog （HLL）类型</p>
<p>唯一计数类型。虽然可以用SET来计数，但需要考虑内存消耗和性能下降问题。</p>
<p>如果我们不需要获取SET的内容，只想获得不同value的个数，就可以考虑用HLL</p>
<p>PFADD    添加</p>
<p>PFCOUNT     统计数量</p>
<p>PFMERGE    添加多个</p>
<p>HLL对象的两种存储方式：</p>
<p>Sparse（稀疏）：对于长度小于hll-sparse-max-bytes（默认为3000）的HLL，采用此。</p>
<p>（存储效率更高，但可能会消耗更多的CPU资源）</p>
<p>Dense（稠密）：当Sparse不适用时。</p>
<p>7.Geo类型</p>
<p>存储地理位置相关的数据类型</p>
<p>GEOADD,    GEOPOS（获取），    GEODIST(比较距离）</p>
<p>等等。略</p>
<p>key的管理。</p>
<p>DBSIZE:    显示数据库的size，即数据库一共有多少个key</p>
<p>获取所有的key：</p>
<p>KEYS *</p>
<p>scan 0</p>
<p>KEYS的后面的参数是 正则表达式，scan后面的参数是cursor，游标，不懂。</p>
<p>删除key：</p>
<p>DEL        UNLINK        </p>
<p>(二者都可以同时删除多个，并且返回删除的key数量）</p>
<p>UNLINK主要用于执行大KEY的异步删除（即非阻塞？）当删除string以外的数据类型，当数量很大时，很可能导致服务器延迟，此时应该用UNLINK（UNLINK会在另一个线程，而不是主事件循环线程中执行删除操作，因此不会阻塞事件的处理。）</p>
<p>EXISTS    判断是否存在某个key</p>
<p>TYPE    获取key的（值）数据类型</p>
<p>RENAME        former_name        new_name    重命名</p>
<p>迁移键      （其实这些比较复杂少用的，到时要用到肯定还是上网查的，目前还没用到死记硬背真的没必要！倒是几种基本类型的常用操作确实值得记忆一下！）</p>
<p>①MOVE  KEY  DB    （redis内部可以有多个DB，用于内部迁移。但一般一个数据库即可！</p>
<p>②dump + restore</p>
<p>③migrate</p>
<p>（只需知道②是非原子性的，而③是原子性的即可！）</p>
<p>遍历键：keys ，或者scan（渐进式，游标。。）</p>
<p>关于多数据库，实际上是一个废弃的功能。并不能实现0号数据库是正式数据库，而1号数据库是测试数据库等等的想法。Redis已经在逐渐弱化这个功能，例如Redis的分布式实现Redis Cluster只允许使用0号数据库，留着只为了向下兼容。而且因为Redis是单线程的，所以使用的还是一个CPU，如果其中一个存在慢查询，那么依然会影响其他数据库（甚至会导致业务问题的定位非常困难）</p>
<p>PS:如果真的要使用多个数据库的功能，完全可以在一台机器上部署多个Redis实例，彼此之间使用端口号来进行区分（计算机一般有多个CPU，这样既保证了业务之间不会受到影响，又合理地使用了CPU资源）</p>
<p>清除所有数据：flushdb，flushall（后者是清除所有数据库） 慎用，会把所有数据都删掉，而且会阻塞。别乱用。！！！</p>
<p>chapter3.</p>
<p>数据特性：</p>
<p>1.位图 bitmap</p>
<p>(也称位数组或位向量），是由比特位bit组成的数组（其值只有0或者1）可用于记录每个用户是否属于某个表（使用过某个功能）等等。</p>
<p>（bitmap并不是一种新的数据类型，它实际的底层数据是字符串。）</p>
<p>-————————–</p>
<p>bitmap vs SET</p>
<p>显然，bitmap用于计数，而SET也可以，那么二者有什么区别呢？</p>
<p>对于bitmap：无论用户是否使用过某个功能，每个用户都需要占用bitmap中的1个比特（0/1）</p>
<p>对于SET：假设另起一个8字节的整型来存储用户ID（表示使用过某个功能），那么只有当用户使用过该功能，才需要存储该用户ID（一个ID 8字节）</p>
<p>假设有20亿个用户，某功能有80%的用户使用过。那么：</p>
<p>对于bitmap：需要在内存中分配20亿个bit，即大约250MB</p>
<p>对于SET：需要 20e x  80%  x  8   大约是12.8G</p>
<p>结论：当一个功能比较流行，更密集，即如果使用bitmap，1的概率更大的时候，用bitmap更好。反之，如果一个功能比较稀疏，使用人数较少，那么直接使用SET会更好（比如上述例子改为1%）</p>
<p>-—————————</p>
<p>SETBIT     key1    value1    1 / 0</p>
<p>对key1的value1设置相应的bit值，0或者1</p>
<p>GETBIT    key1    value1</p>
<p>查询value1对应的bit值，返回0或者1</p>
<p>BITCOUNT    key1</p>
<p>查询key1中所有的value，bit为1的个数。</p>
<p>BITOP    [OPERATOR]        result    key1    key2</p>
<p>BITOP用于进行位操作，包括：AND,OR,XOR,NOT（NOT只需要指定1个key，其他2个）</p>
<p>即对key1和key2进行位操作，然后将结果存储在result键中。</p>
<p>2.设置key的过期时间</p>
<p>除了使用DEL或者UNLINK删除key，还可以通过设置key的超时时间让Redis自动地删除key</p>
<p>EXPIRE        key1    int</p>
<p>将键key1的超时时间设置为int</p>
<p>TTL        key1</p>
<p>查看key1在过期前的剩余时间。</p>
<p>如果该key并没有过期时间，那么将返回-1.</p>
<p>如果该key已经过期，那么将返回-2</p>
<p>当key过期之后是否立刻删除？</p>
<p>并不，但当客户端试图访问过期key时，Redis会立即将其从内存中删除。（被动过期）</p>
<p>而对于那些已经过期但还没被访问的key，有一个基于概率的算法来进行主动删除。（略）</p>
<p>当发现有太多已经过期的key没有被删除时，可以通过执行SCAN命令来触发被动过期</p>
<p>如何清除一个key的过期时间？</p>
<p>1.PERSIST        使一个key成为持久的key</p>
<p>2.当key的value被替换或者删除。包括SET,GETSET, *STORE等等的命令会清除过期时间</p>
<p>（但修改list，set，hash的元素并不会清除过期时间，因为修改元素的操作并不会替换key所关联的值对象）</p>
<p>3.被另一个没有过期时间的key重命名</p>
<p>3.SORT命令</p>
<p>当我们需要获取一个Redis列表或者集合的已排序副本，或者以某种非权重的顺序对SORTED SET中的元素进行排序时候，就需要用到SORT命令</p>
<p>SORT key1        对    list    /    set/    sorted set 进行排序</p>
<p>（默认只能对数字排序，int/ double）</p>
<p>对于字符串，需要加ALPHA修饰符。</p>
<p>SORT key1    ALPHA</p>
<p>SORT    key1    ALPHA    LIMIT    int1        int2</p>
<p>排序之后，获取int1 ~ int2的元素。（index从0开始）</p>
<p>除了默认数字排序以及ALPHA，还可以通过其他key的权重来进行排序。</p>
<p>SORT     key1    BY    key2~x（用通配符表示多个）</p>
<p>（此处key2的value，hong123_104 &gt; hong123_455 &gt; hong123_333 &gt; 200 &gt; 365）</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\ab95885bd2bc4ec9bbadda92013433f6\clipboard.png)</p>
<p>用处：</p>
<p>比如A_userid是一个用户的记录。 count_userid是一个用户的使用次数。（每一个userid都有对应）</p>
<p>那么当我们需要对A_userid的value进行排序（里面的value并不是使用次数，比如，是消费总额），而我们是希望通过“使用次数”这个属性来排序，那么就用到了 BY 修饰符。</p>
<p>SORT     key1     BY        key2*    DESC/ASC(默认ASC）GET    xxx        STORE    key3</p>
<p>GET选项：表示要获取哪一个类型的值，比如是key2，key1里的*，而不一定是value</p>
<p>（GET可使用多次）</p>
<p>STORE选项：把GET得到的结果存储到key3</p>
<p>4.管道    pipeline</p>
<p>Redis客户端与服务端使用RESP协议进行通信，大致的通信过程如下：</p>
<p>1，客户端向服务端发送一个命令</p>
<p>2，服务器接受该命令并放入执行队列（Redis是单线程的执行模型）</p>
<p>3，命令执行</p>
<p>4，服务器将命令执行的结果返回到客户端</p>
<p>第2，3步耗费的时间取决于Redis服务器（一般较短），主要的时延还是1，4步的网络传输。</p>
<p>使用pipeline好处：客户端将多个命令打包在一起，并将它们一次性发送，而不再等待每个单独命令的执行结果。同时，pipeline是在服务器执行完所有的命令后再返回结果。</p>
<p>因此即使是执行多个命令，第1，4步也只发生一次，所以总的执行时间会大大减少。</p>
<p>使用方法：在Redis-cli中加入    –pipe选项</p>
<p>5.Redis事务        transaction</p>
<p>关键命令：</p>
<p>MULTI：用于组装一个命令，表示命令的开始部分。</p>
<p>EXEC：用于执行一个事务</p>
<p>DISCARD：取消事务</p>
<p>WATCH：用于监视key。当这些key在事务执行之前发生改变，那么事务将被取消。</p>
<p>Redis事务与关系数据库事务的区别：Redis事务没有回滚。</p>
<p>所以当所有正确的命令入队列之后，如果在执行过程发生错误，位于发生错误命令之后的其他命令将继续执行，而不会回滚。</p>
<p>6.发布订阅    PubSub</p>
<p>即终端分为了发布者和订阅者。订阅者可以订阅指定的频道（发布者），当发布者发送信息时，会一次性发送给所有的订阅者，同时发布者也可以单独给某位订阅者发送信息（类似公众号的模式）</p>
<p>命令：</p>
<p>SUBSCRIBE    订阅        (如果该频道从未被订阅过，那么会自动创建该频道）</p>
<p>UNSUBSCRIBE    取消订阅</p>
<p>PUBLISH        发布信息（一个发布者可以是多个频道的所有者，因此需要选择发布到哪个频道）</p>
<p>7，Lua脚本</p>
<p>略</p>
<p>chapter4.</p>
<p>Redis常用场景：</p>
<p>1.存储Session。</p>
<p>Session一般存储在外部存储系统，如果一个web服务器宕机，其他服务器仍然可以从外部存储中获取Session并继续服务。而与关系数据库相比，Redis的访问延迟非常低（存储在内存），所以用于存储Session非常合适。同时Redis的对key过期机制非常契合Session的有效期。</p>
<p>2.分析，排行，队列，最新的N个记录等等</p>
<p>这些功能使用SQL也可以做到，但SQL查询要比Redis查询慢得多。</p>
<p>3.缓存</p>
<p>因为Redis是基于内存的数据存储系统，所以在关系数据库前面增加Redis作为缓存，通常能够加速数据库的查询过程。</p>
<p>例如，在查询关系数据库之前，先在Redis中查找记录。如果找到就直接使用，如果找不到就从关系数据库中查找，并将记录放置到Redis中。在向关系数据库写入时，我们也将记录写入Redis。同时为了限制缓存的大小，可以设置过期时间，或者LRU等等的收回策略。</p>
<p>Redis的缺点：</p>
<p>因为Redis默认将全部数据都放在内存中，所以Redis的容量有限，不能作为单一的数据库来存储大量的数据（虽然有一些基于云的Redis提供了使用SSD作为数据存储后端的选项）。</p>
<p>其次，因为Redis事务并不完全符合关系数据库的ACID规范。如果要使用完全符合ACID规范的事务，就不能使用Redis。</p>
<p>其他命令：</p>
<p>FLUSHALL：删除所有的数据库的所有keys。</p>
<p>CONFIG SET XXX XX    设置conf配置文件，将XXX的属性值改成XX</p>
<p>同理还有 CONFIG GET XXX</p>
<p>INFO MEMORY    查看Redis的内存使用情况</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\2d1e6c0c369b432aa5976bc06ebecf77\clipboard.png)</p>
<p>普通Java程序使用Redis：使用Jedis即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring程序使用Redis：<a href="https://blog.csdn.net/Evankaka/article/details/50396325" target="_blank" rel="noopener">https://blog.csdn.net/Evankaka/article/details/50396325</a></p>
<p>依赖包，除了redis.clients，还需要：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>chapter5：</p>
<p>Redis复制，从一个Redis服务器，将data全部复制到另一个。略    INFO REPLICATION</p>
<p>chapter6：</p>
<p>由于Redis是在内存中存储数据的，所以当服务器重新启动时，所有的数据都将丢失。所以我们需要：像上一章一样复制复制备份到另一个服务器，或者持久化到disk。</p>
<p>持久化到磁盘的机制：RDB, AOF</p>
<p>RDB：可以看做是Redis在某一个时间点上的快点（snapshot），适合于备份和错误恢复</p>
<p>AOF：一个写入操作的日志，将在服务器启动时被重新放。</p>
<p>使用RDB的操作：</p>
<p>CONFIG SET SAVE “900 1”    （还是使用CONFIG SET修改配置文件）</p>
<p>永久启用RDB：cat conf/redis.conf | grep “^save”</p>
<p>RDB的结果会生成yige.rdb文件。二进制形式。略</p>
<p>由于RDB并不能提供非常强的一致性，虽然可以定期将数据保存到RDB，但在崩溃时，保存的时刻到崩溃时刻中间的数据将会丢失。</p>
<p>AOF是一种只记录Redis写入命令的追加式文件，因为每个写入命令都会被追加到文件中，所以AOF的数据一致性更高。</p>
<p>启用AOF持久化：CONFIG SET APPENDONLY YES</p>
<p>永久启动： cat conf/dis.conf | grep “^appendonly”</p>
<p>二者可以同时使用。</p>
<p>chapter7：高可用和集群Redis</p>
<p>当Redis的数据越来越大的时候，安全性会受到损害（宕机的时候恢复的时间越来越长）同时key越来越多，内存的使用率越来越大，内存的大小成为了性能的瓶颈。因此配置多个node（多个Redis服务器的集群），可以增加安全性和可用性。</p>
<p>略</p>
<p>chapter8：生产环境部署</p>
<p>即在Linux上部署Redis，成为真正的服务器，可不仅仅是一个测试demo。这个时候还需要配置各种参数，如客户端连接参数，数据库本身参数，key的管理，LRU，LFU等等的算法策略，还有日志。</p>
<p>略</p>
<p>chapter9：管理Redis</p>
<p>即Redis服务上线之后，对日常的Redis进行运维操作。</p>
<p>查看参数，备份，监控内存使用情况，监控客户端等等。</p>
<p>chapter10：Redis的故障诊断</p>
<p>chapter11：使用Redis模块拓展Redis    略略略</p>
<p>————————–Redis Dev &amp; Ops</p>
<p>chap2：</p>
<p>keys *， dbsize：</p>
<p>dbsize直接获取Redis内置的一个变量，时间复杂度为1</p>
<p>而keys会遍历所有键，所以时间复杂度是n（当Redis保存了大量键的时候，就不应该使用）</p>
<p>exists key，    del key，        </p>
<p>expire key seconds（设置过期时间</p>
<p>ttl key ：返回剩余过期时间。  大于等于0就是剩余值，-1是没设置过期时间，-2是键不存在</p>
<p>type key，  object encoding key   ： type是返回键的类型，object encoding是返回内部编码实现类型</p>
<p>（根据具体情况计算性能，底层选择不同的类型：</p>
<p>string字符串： raw，    int，        embstr</p>
<p>hash哈希：    hashtable，        ziplist</p>
<p>list列表：        linkedlist，        ziplist</p>
<p>set集合：    hashtable，        intset</p>
<p>zset有序集合（Sorted Set）：    skiplist，    ziplist</p>
<p>incr key：使key自增1.（如果不是整数，会报错。如果不存在这个key，创建一个，默认值为0，incr后就是变成1。 必须是整数，浮点数也会报错）</p>
<p>Redis使用了单线程 + IO Multiplexing（多路复用）模型来实现高性能的内存数据库服务</p>
<p>（所谓的IO Multiplexing，指由N个client要访问，然后IO根据哪个client ready了，就选择那个（就像是一个电路图：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\1e1c5c3688d74413b43baa95057179b0\clipboard.png)</p>
<p>IO Multiplexing主要是可以提高连接数。但始终还是单线程，因此如果其中一个命令的执行时间特别长，那么就会造成其他命令的阻塞。所以Redis是面向快速执行场景的数据库。</p>
<p>（内存的处理速度是磁盘IO的10万倍，所以Redis的效率是很快的，能达到每秒万级别）</p>
<p>（内存是100ns， Disk seek是10 000 000ns）</p>
<p>①字符串类型  string：</p>
<p>key都是字符串类型，字符串可以是字符串，数字，二进制（图片，音频，视频</p>
<p>（所以 set  1  123也是可行的。key为1，value为123）</p>
<p>set 选项： ex秒级过期时间， px 毫秒级， nx：键必须不存在，才可以设置成功。 xx：与nx相反</p>
<p>例子：setnx hello redis    (nx可以用作分布式锁的一种实现方案，因为只有一个可以set成功）</p>
<p>mset ： 批量设置值            例子： mset key1 value1 [key2 value2 ……]</p>
<p>get,  mget同理。</p>
<p>批量命令可以提升开发效率。如n次get，需要n次网络时间+n次命令时间。</p>
<p>而mget只需要1次网络时间+n次命令时间</p>
<p>（批量操作发送的命令数是有节制的，否则可能造成Redis阻塞或者网络阻塞）</p>
<p>del key [key ……]    del可以删除多个。 </p>
<p>incr,decr</p>
<p>incrby  key  increment(指定自增数值，可为负数）        decrby  key  decrement    （不能为浮点数</p>
<p>incrbyfloat  key  increment（每次增加的值为浮点数，同时key也能为浮点数，不然执行一次就没了）</p>
<p>append key  value    在尾部追加值</p>
<p>strlen  key        字符串长度</p>
<p>getset        设置，并且返回原来的值</p>
<p>setrange    key    offset    value    设定offset偏移值的那一位，字符由value替代（从0开始</p>
<p>例子： set redis  pest        setrange  redis  0  b    get  redis   ==》  best</p>
<p>getrange  key  start  end    (偏移量从0开始。 [start,  end]        （没有-1）</p>
<p>总结：del，mset，mget这三个的时间复杂度为O(n)，getrange为O(n),n是字符串的长度，如果字符串不是很长，可以视为O(1)。其他都是O(1)</p>
<p>字符串内部编码:  int,  embstr(小于等于39个字节的字符串） ， raw（大于39个字节）</p>
<p>②哈希 hashing</p>
<p>即value本身又是一个键值对。</p>
<p>设置值： hset  key   field  value    （同样还有hsetnx。相当于set和setnx的区别</p>
<p>获取值： hget  key   field      （一个key存储多个  field - value）</p>
<p>删除field： hdel  key  field1  [field2 ……]    返回成功删除field的个数</p>
<p>计算field的个数：   hlen  key</p>
<p>批量set/get  :  hmget  key  field [ field …]    hmget  key field  value [ field  value……]</p>
<p>hexists  key  field    判断是否存在</p>
<p>hkeys  key    获取所有的field（感觉叫hfields更恰当，但确实是hkeys</p>
<p>hvals    key</p>
<p>hgetall     key        获取所有的field-value</p>
<p>（当哈希元素比较多，hgetall可能会阻塞。如果只需要获取部分，可以使用hmget。如果一定要获取全部field-value，可以使用hscan，该命令会渐进式地遍历哈希类型。）</p>
<p>hincrby   key   field   increment    给key.field增加increment（可以为负数）    hincrbyfloat</p>
<p>hstrlen    key   field</p>
<p>总结：hdel，hmget，hmset是O(k)，k是field的个数。hgetall，hkeys， hvals是O(n)，n是field的总数</p>
<p>其他都为O(1)</p>
<p>哈希内部编码：ziplist（压缩列表）：当元素个数小于hash-mmmax-ziplist-entries(默认是512），同时所有值都小于hash-max-ziplist-value(默认是64字节），就使用ziplist（结构更紧凑，节省内存）</p>
<p>hashtable（哈希表）：当无法满足ziplist时，ziplist的读写效率会下降，而hashtable的读写为O(1)</p>
<p>ps：对于一个用户的各种信息属性，可以单独用不同的key，但这样用户信息性差，一般不会使用这种方案。比较好的方案是使用哈希类型，提高内聚性，控制在ziplist之内，有效减少内存空间的使用。（必须的时候使用hashtable也不是不行）</p>
<p>哈希类型是稀疏的，而关系数据库是完全结构化的，当在关系数据库增加新的列，所有行都要设置值（如果没有指定就设置为NULL）。但可以做复杂的关系查询，而Redis比较困难。</p>
<p>③列表 list</p>
<p>rpush，lpush（二者都可以插入多个）    linsert key before | after  pivot  value</p>
<p>lrange key  start  end 查找</p>
<p>……</p>
<p>懒了，其实各种类型的操作就略过吧，上面已经看过一次了，把上面的复习一遍就好。主要看它举的实例并理解。</p>
<p>chap3：各种功能topic</p>
<p>①慢查询</p>
<p>Redis有一个表专门记录命令执行较长的命令（只包含执行时间，不包含客户端等待时间）</p>
<p>参数：slowlog-log-slower-than    (超出该值则记录，单位是微秒。）</p>
<p>1 秒 = 1000 毫秒 = 1000 000微秒    （即默认是10毫秒）</p>
<p>slowlog-max-len ：慢查询日志的最大记录，如果超出上限，则最早insert的那条删除。</p>
<p>（slowlog-max-len设置大一点，不会耗费很多内存空间的）</p>
<p>设置命令：config xx int        持久化到配置文件：    config  rewrite</p>
<p>获取日志： slowlog  get  [n]    // n表示指定条数</p>
<p>slowlog len  ： 获取慢查询日志列表的当前长度</p>
<p>slowlog reset：重置（即clear</p>
<p>②redis shell</p>
<p>redis-cli的各种参数：</p>
<p>-h  ： host    -p： port        -a： auth        </p>
<p>-r 重复执行n次：  redis-cli -r 3 ping    </p>
<p>(即重复执行3次ping命令，ping命令会测试服务器的连通性，如果连通，返回PONG）</p>
<p>-i 表示每隔几秒执行一次命令（与-r连用，单位是秒）</p>
<p>例子：redis-cli -a xxx -r 10 -i 1 info | grep used_memory_human    每隔1秒输出内存的使用量</p>
<p>-x：将stdin读取，作为redis-cli的最后一个参数，例如；</p>
<p>echo “gogogo” | redis-cli -a xxx -x set hello    # 之后hello的值就被设置为”gogogo\n”</p>
<p>值得注意的是，echo输入，会存在一个换行符，进入redis-cli里再set才不会有换行符。</p>
<p>–scan和–pattern ：扫描指定模式的keys，相当于使用scan命令</p>
<p>–slave：将当前客户端模拟成一个子节点，然后获取当前Redis结点的更新操作。</p>
<p>（可以用于记录当前连接Redis结点的一些更新操作）</p>
<p>（在一个客户端中使用redis-cli –slave -a xxx，然后其他客户端的更新，当前都会有命令记录）</p>
<p>–rdb：请求Redis实例生成并发送RDB持久化文件，保存在本地。</p>
<p>–pipe：把批量的命令一次发送到一个管道中，一次执行</p>
<p>–bigkeys：使用scan命令获取占用内存比较大的键值。（这些键可能是系统的瓶颈）</p>
<p>–eval ： 执行指定的Lua脚本</p>
<p>–latency :测试到目标Redis的网络延迟   redis-cli  -h  {另一台机器的host IP}  –latency</p>
<p>–latency-history :上面的只有一条记录，而这个是每执行15秒就生成另一条记录（可以用作对比），同时也可以使用-i参数来控制间隔时间。</p>
<p>-latency-dist   使用统计图表的形式从控制台输出信息</p>
<p>info  ： redis-cli  info    输出redis的所有信息（很长，配合| grep使用）</p>
<p>redis-cli –stat：实时获取Redis的重要统计信息（比info少很多，但可以实时查看一些增量的数据）</p>
<p>–raw ， –no-raw    使得返回的结果是原始格式 / 不是原始格式</p>
<p>当存储中文时，保存在redis里的中文会被转义成16进制。此时无论是命令行时get还是进入redis-cli之后get，返回的结果都是二进制格式，如： \xe4\xbd\xa0\xe5\xa5\xbd</p>
<p>如果使用–raw，则返回原始格式，即中文： redis-cli –raw get hello (–raw必须在get前面）</p>
<p>PS:但是在进入redis-cli之后的get好像无法指定参数，所以不能返回raw，只能在命令行时指定–raw</p>
<p>③redis-server</p>
<p>redis-server是Redis的启动脚本。可选参数只有：–test-memory，用于检测当前的OS能否稳定地分配指定容量的内存给Redis（防止因为内存问题造成Redis崩溃）</p>
<p>（检测时间较长，但输出passed this test表示检测完毕。 单位是MB，所以1024就是1G）</p>
<p>一般只是用于调试跟测试，快速沾满机器内存做一些边界测试</p>
<p>④redis-benchmark</p>
<p>用于为Redis做基准性能测试</p>
<p>-c：表示客户端的并发数量（默认50）</p>
<p>-n：表示客户端的请求总量（默认是100000）</p>
<p>例子：redis-benchmark  -c  100  -n  20000，代表100个客户端同时请求Redis，一共执行20000次。</p>
<p>-q：只显示 requests per second信息。</p>
<p>-r：插入更多的键。如-r 10000，插入10000个随机的键（仅作测试使用）</p>
<p>-P：表示每个请求的pipeline的数据量（默认是1）</p>
<p>（我发现恰当指定pipeline的值，比默认是1要快。）</p>
<p>-k：表示客户端使用使用keepalive，1为使用，0为不使用，默认是1</p>
<p>-t 指定命令测试</p>
<p>–csv：按照csv格式输出，可以到处到excel等（注意是两条杠）</p>
<p>⑤Pipeline</p>
<p>Redis客户端的一条命令的4个过程：发送命令，命令排队，命令执行，返回结果。</p>
<p>（第一步跟第四步称为Round Trip Time，RTT，往返时间）</p>
<p>虽然有部分批量操作的命令，但大部分命令都没有批量命令，此时需要使用pipeline，一次过发送多个命令，减少RTT的次数（由于Redis的处理速度很快，只要Pipeline包含的命令数不是太多，就能有效提升效率）</p>
<p>（高级语言的客户端中基本都支持Pipeline。比如Jedis。）</p>
<p>提升的结论：</p>
<p>1.一般Pipleline的执行速度会比逐条执行要快（Redis的性能瓶颈是网络，即RTT）</p>
<p>2.客户端和服务端的网络时延越大（即RTT越大），那么Pipeline的提升效果越明显。</p>
<p>原生批量命令与Pipeline的区别：</p>
<p>1.原生批量命令是原子的，而Pipeline是非原子的。</p>
<p>2.原生批量是一个命令对应多个key，而Pipeline是支持多个命令的</p>
<p>3.原生批量是Redis服务端支持实现的，而Pipeline需要服务端和客户端的共同实现。</p>
<p>Ps：Pipeline一次组装的命令个数不能太多，否则会增加客户端的等待时间，以及网络阻塞，可以将一次包含大量命令的Pipeline拆分成多次较小的Pipeline来完成。</p>
<p>Pipeline虽然只能操作1个Redis实例，但即使在分布式Redis的场景中，也可以作为批量操作的重要优化手段。</p>
<p>⑥事务</p>
<p>Redis提供了简单的事务功能，但又跟关系数据库的事务不太一样。它无法保证很多方面的数据一致性，因为需要复杂事务的业务不应该放在Redis中实现。</p>
<p>multi：开启一个事务（事务里不可以嵌套事务</p>
<p>……中间执行的各种命令都会输出QUEUED，即存储在事务里，但还没开始执行。</p>
<p>exec：执行事务。        discard：取消事务</p>
<p>Redis的事务不提供回滚功能，如果执行出错，那么会出现问题：</p>
<p>1.当命令出现语法错误</p>
<p>此时Redis在执行每一条命令之前就已经发现了，因而这时候执行exec会显示错误。然后每一条语句都会失效。（因为根本就没有去执行，并不是回滚）</p>
<p>2.当命令出现运行时错误</p>
<p>有一些语句，不存在语法错误，但在运行时才会出现错误，这时Redis在检查语句的时候是不能发现的，只能在执行的时候才发现。比如对于SET跟SORTED SET，对一个SET使用SSET的ZADD操作，并不属于语法错误，但在运行时会出错。这时候事务不会回滚，因而在出错之前的语句，仍然已经执行成功，而且出错之后的语句也会执行！无论如何，这种问题只能靠程序员自己避免。</p>
<p>watch： 使得客户端监控1个或者多个键，有效期直到执行了unwatch或者exec。</p>
<p>当客户端A监控的这些keys，只要有其中一个被修改了(除非是在A的事务中进行修改的），那么该客户端A下的第一个事务不会执行。（返回nil）</p>
<p>小细节点：</p>
<p>1.如果是在当前客户端A的事务中修改了被监控的值，那么是可以成功执行的，因为要保证的是，在执行事务的时候，该值不会在事务在之外发生了变化。</p>
<p>2.如果是在当前客户端A的事务之外修改了被监控的值，那么也是不可以执行的。如果是在其他客户端B中修改，那么一定不能执行（即使是在B的事务环境中执行，也不行）</p>
<p>3.准确地说，并不是执行exec会取消，而是当事务（即multi）结束的时候，watch的键会取消。所以，如果执行了multi……discard，这时候其实watch已经失效了。后面如果继续使用multi，是可以执行事务的。所以单独地使用exec / discard(即在没有multi的前提下运行这两条命令），watch是仍然存在的。</p>
<p>⑦Lua</p>
<p>语法省略。</p>
<p>Redis使用Lua的方法：eval，evalsha</p>
<p>eval当作命令的时候：  eval  脚本内容  key个数  key列表  参数列表</p>
<p>例子：eval ‘return “hello “ .. KEYS[1] .. ARGV[1] ‘  1  redis  world</p>
<p>输出：”hello redisworld”</p>
<p>如果Lua脚本较长，可以使用–eval直接执行文件</p>
<p>evalsha：将Lua加载到Redis，得到该脚本的SHA1检验和，之后evalsha使用SHA1作为参数就可以直接执行对应的Lua脚本，避免每次都发送Lua脚本的开销，而且脚本也能常驻在服务端了。</p>
<p>script load：将脚本内容加载到Redis内存中：redis-cli script load “xxx”        返回SHA1值。</p>
<p>执行脚本： evalsha  脚本SHA1值  key个数  key列表  参数列表</p>
<p>Lua的redis.call可以实现对Redis的访问：</p>
<p>redis.call(“set”, “hello”, “world”)        redis.call(“get”, ”hello”)</p>
<p>pcall也可以调用Redis，但如果call执行失败，脚本会直接结束，而pcall会忽略错误继续执行（根据具体的情况进行函数的选择）</p>
<p>Lua对于Redis的好处：</p>
<p>1.Lua在Redis中的原子执行的，执行中途不会插入其他命令</p>
<p>2.Lua可以自定制命令，并且可以将这些命令常驻在Redis内存中，达到复用的效果</p>
<p>3.Lua可以将多条命令一次性打包，有效地减少网络开销。</p>
<p>举一个Lua的例子：</p>
<p>假设有user1,user2,user3,user4这几个键，分别对应一个数字。</p>
<p>如get user1 =》 123    ，user2 = 444 , user3 = 743 , user4 = 814</p>
<p>有一个列表，存储了这几个键：</p>
<p>lpush  hot  user1, user2, user3, user4</p>
<p>现在我们需要对列表内所有的键对应的值进行+1操作，并且保证是原子执行，返回操作的个数。</p>
<p>Lua脚本：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\a8de5b73eb2142e490223c07e13bee29\clipboard.png)</p>
<p>执行Lua脚本： redis-cli  -a  xxx  –eval  my.lua  hot（即执行my.lua脚本，第一个key参数是hot列表）</p>
<p>Redis管理Lua脚本：</p>
<p>script load：将Lua脚本加载到Redis</p>
<p>script exists sha1 [sha1 …]：判断sha1是否已经加载到内存</p>
<p>script flush：清除Redis内存以及加载的所有Lua脚本（此时需要重新load</p>
<p>script  kill：杀掉正在执行的Lua脚本（如果Lua比较耗时，或者存在死循环等问题，就可以考虑kill</p>
<p>ps：Redis提供了一个参数，是Lua脚本的超时时间，但仅仅是当Lua脚本超过该时间之后，向其他命令发出BUSY的信号，但并不会停止掉服务端和客户端的脚本执行。其他命令会收到“Busy Redis is busy running a script”的错误。</p>
<p>但是，如果Lua脚本正在执行写操作，那么script kill将不能生效，此时只能使用shutdown save停掉Redis服务。（如果是死循环的重复写操作，那么只能shutdown save了）</p>
<p>⑧bitmap，HyprtLogLog，订阅，GEO等等（上面的笔记有</p>
<p>chap4：客户端</p>
<p>Redis的CS模型：</p>
<p>Redis制定了RESP（Redis Serialization Protocol，Redis序列化协议），实现客户端与服务端的正常交互。这种协议简单高效，能被机器解析，同时也容易理解。</p>
<p>发送命令的格式：先指定参数个数（前面加一个*，然后每一个参数前面用$加数字，表示该参数的长度。）</p>
<p>例子：SET hello world</p>
<p>底层发送的命令格式：(下面的各种参数与\r\n之间是没有空格的，只是这里增加以下可读性</p>
<p>*3 \r\n $3 \r\n SET \r\n $5 \r\n hello \r\n $5 \r\n world \r\n</p>
<p>上面的每一部分解释：</p>
<p>首先，每一part都是单独的一行(\r\n就是换行了），然后*3表示有3个参数， $3表示第一个参数的长度3，第一个参数是SET。$5表示第二个参数长度5，第二个参数是hello.第三个的长度也是$5,值为world</p>
<p>返回结果的格式：</p>
<p>有5种：</p>
<p>1.状态回复： 在RESP中，第一个字节是 +</p>
<p>2.错误回复：在RESP中，第一个字节是 -</p>
<p>3.整数回复：在RESP中，第一个字节是  :</p>
<p>4.字符串回复：在RESP中，第一个字节是 $</p>
<p>5.多条字符串回复：在RESP中，第一个字节是  *</p>
<p>从redis-cli.c的源码的 cliFormatReplyTTY方法，可以看到一共有这几种执行结果：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\8cc4710fe2404a6582bb758a14fd3161\clipboard.png)</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\a3fbdf67f35f4db3a293a700bf15f534\clipboard.png)</p>
<p>一共有REDIS_REPLY_ERROR,  STATUS,  INTEGER,  STRING, NIL, ARRAY</p>
<p>Jedis的重要类，重要方法，重要功能等等：</p>
<p>1.基本连接： Jedis</p>
<p>但默认是直连，于是每一次都要新建/关闭TCP的开销，资源无法控制（无法限制Jedis对象的个数)，Jedis线程不安全。而使用连接池，可以事先初始化好Jedis连接，降低TCP的开销。而且借用和归还到连接池的操作都是在本地进行的，只有少量的并发同步开销。</p>
<p>2.Jedis连接池：JedisPool</p>
<p>一般还有它的配置类GenericObjectPoolConfig类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"poolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"1000"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（此处的JedisPoolConfig是GenericObjectPoolConfig的子类，只有一个默认构造方法，初始化一下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolConfig</span> <span class="keyword">extends</span> <span class="title">GenericObjectPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JedisPoolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setTestWhileIdle(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setMinEvictableIdleTimeMillis(<span class="number">60000L</span>);</span><br><span class="line">        <span class="keyword">this</span>.setTimeBetweenEvictionRunsMillis(<span class="number">30000L</span>);</span><br><span class="line">        <span class="keyword">this</span>.setNumTestsPerEvictionRun(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS:书上列了一堆GenericObjectPoolConfig的属性，因为BaseObjectPoolConfig还有很多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericObjectPoolConfig</span> <span class="keyword">extends</span> <span class="title">BaseObjectPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericObjectPoolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseObjectPoolConfig</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_LIFO = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_FAIRNESS = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_MAX_WAIT_MILLIS = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFALUT_MIN_EVICTABLE_IDLE_TIME_MILLIS = <span class="number">1800000L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NUM_TESTS_PER_EVICTION_RUN = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_TEST_ON_CREATE = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_TEST_ON_BORROW = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_TEST_ON_RETURN = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFALUT_TEST_WHILE_IDLE = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_BLOCK_WHEN_EXHAUSTED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_JMX_ENABLE = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_JMX_NAME_PREFIX = <span class="string">"pool"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_JMX_NAME_BASE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_EVICTION_POLICY_CLASS_NAME = <span class="string">"org.apache.commons.pool2.impl.DefaultEvictionPolicy"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lifo = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> fairness = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxWaitMillis = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> minEvictableIdleTimeMillis = <span class="number">1800000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> softMinEvictableIdleTimeMillis = <span class="number">1800000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numTestsPerEvictionRun = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> String evictionPolicyClassName = <span class="string">"org.apache.commons.pool2.impl.DefaultEvictionPolicy"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnCreate = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnBorrow = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnReturn = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testWhileIdle = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeBetweenEvictionRunsMillis = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> blockWhenExhausted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> jmxEnabled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> String jmxNamePrefix = <span class="string">"pool"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.看一下当时在Spring下自己的项目的Redis完整配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"poolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"300"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"1000"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"poolConfig"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6379"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"xxx.xx.xx.xxx"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"xxxx"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"100000"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"database"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- org.springframework.data.redis.core.RedisTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisTemplate"</span> <span class="attr">class</span>=<span class="string">"com.hong.utils.redis.MyRedisTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashKeySerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"keySerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"valueSerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashValueSerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"methodCacheInterceptor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.support.SimpleCacheManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"caches"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.hong.utils.redis.RedisUtil"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"redisTemplate"</span> <span class="attr">ref</span>=<span class="string">"redisTemplate"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"common"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisUtil"</span> <span class="attr">class</span>=<span class="string">"com.hong.utils.redis.RedisUtil"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"redisTemplate"</span> <span class="attr">ref</span>=<span class="string">"redisTemplate"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- name属性的值,是用于等会的注解当中 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"common"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还是很好理解的，首先JedisPoolConfig是连接池的配置。</p>
<p>然后JedisConnectionFactory就是连接的配置（连接池要预先创建连接，那么自然需要一个Factory去创建连接，而至于hostName，password，timeout，port等等的，确实就应该写在factory里了，同时还传入了poolConfig配置，database就是默认是第一个数据库吧，也没什么好说的）</p>
<p>然后是RedisTemplate，这个也很显然，就跟JdbcTemplate，就是封装了原生的Redis API，然后提供了更易操作的方法接口罢了。我们看一下方法：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\3e927f8193dc487b9d462e096537527a\clipboard.png)</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\a5493d3d73cb441ca0a50ab95ad2323f\clipboard.png)</p>
<p>方法确实很多哈，这里也没必要截完了，反正都是封装好了的Redis原生API，不妨随意选择一个方法去查看？就选keys方法吧，返回所有的键，很简单的方法逻辑，这里重在理解方法的主要构成，没必要选择太复杂的方法逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keys</span><span class="params">(K pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(pattern);</span><br><span class="line">    Set&lt;<span class="keyword">byte</span>[]&gt; rawKeys = (Set)<span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;Set&lt;<span class="keyword">byte</span>[]&gt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Set&lt;<span class="keyword">byte</span>[]&gt; doInRedis(RedisConnection connection) &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.keys(rawKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.keySerializer != <span class="keyword">null</span> ? SerializationUtils.deserialize(rawKeys, <span class="keyword">this</span>.keySerializer) : rawKeys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看不出什么，但感觉关键就是把具体的参数传到execute方法，然后再执行，再看几个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Object&gt; <span class="title">execRaw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (List)<span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;List&lt;Object&gt;&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">List</span><span class="params">(Object)</span> <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> connection.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">    <span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> </span>&#123;</span><br><span class="line">            connection.del(<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;rawKey&#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，都是把不同的参数传到了execute方法。所以说就是对execute方法进行重载咯！我们查一下，确实，一堆的execute重载方法：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\bf4ed38156ac4f6f811fff3169568859\clipboard.png)</p>
<p>那我们还是继续拿keys指向的那个execute来看一下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; action, <span class="keyword">boolean</span> exposeConnection, <span class="keyword">boolean</span> pipeline)</span> </span>&#123;</span><br><span class="line">		Assert.isTrue(initialized, <span class="string">"template not initialized; call afterPropertiesSet() before using it"</span>);</span><br><span class="line">		Assert.notNull(action, <span class="string">"Callback object must not be null"</span>);</span><br><span class="line"></span><br><span class="line">		RedisConnectionFactory factory = getConnectionFactory();</span><br><span class="line">		RedisConnection conn = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (enableTransactionSupport) &#123;</span><br><span class="line">				<span class="comment">// only bind resources in case of potential transaction synchronization</span></span><br><span class="line">				conn = RedisConnectionUtils.bindConnection(factory, enableTransactionSupport);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				conn = RedisConnectionUtils.getConnection(factory);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">boolean</span> existingConnection = TransactionSynchronizationManager.hasResource(factory);</span><br><span class="line"></span><br><span class="line">			RedisConnection connToUse = preProcessConnection(conn, existingConnection);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">boolean</span> pipelineStatus = connToUse.isPipelined();</span><br><span class="line">			<span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">				connToUse.openPipeline();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			RedisConnection connToExpose = (exposeConnection ? connToUse : createRedisConnectionProxy(connToUse));</span><br><span class="line">			T result = action.doInRedis(connToExpose);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// close pipeline</span></span><br><span class="line">			<span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">				connToUse.closePipeline();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> any other connection processing?</span></span><br><span class="line">			<span class="keyword">return</span> postProcessResult(result, connToUse, existingConnection);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!enableTransactionSupport) &#123;</span><br><span class="line">				RedisConnectionUtils.releaseConnection(conn, factory);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>前面两行Assert，普通的断言语句。然后后面的几行就很显然了，先获取ConnectionFactory，然后再在try-catch块里获取connection。具体的怎么getConnectionFactory这种是涉及到比较复杂的很多类的跳转的，但本质上都只是设计模式的运用，此处可以不管。接下来的就是Redis的操作了，先判断一下事务同步管理器，连接预处理等等的，最后再放入pipeline执行（因为keys是一个批处理操作，原子性的）。最后再返回postProcessResult。话说再刷新了一下，这段代码更新了，这个var11确实没有存在的必要，直接return postPro…即可。但总体来说，确实也是获取到ConnectionFactory，然后生成连接，再操作。那么，RedisTemplate的作用确实也跟我们预期的一样。</p>
<p>除此之外，网上也有提到，Redis可以直接存储Java对象，那么就需要序列化跟反序列化。    在Spring中，是通过StringRedisSerializer跟JdkSerializationRedisSerializer实现的。那么，RedisTemplate下面传入的两个蜜汁property也是可以理解了。至于传入connectionFactory，那是当然的了，我们上面看源码也已经看到了，RedisTemplate是需要调用connectionFactory生成连接的）</p>
<p>接下来最后这两个，MethodCacheInterceptor跟RedisUtil。我第一次使用的时候，直接拿RedisUtil当作RedisTemplate使用了，只是简单的set，get，那确实是足够的（RedisUtil是我的自定义类，只有最简单的set，get，remove）。其实认真一点看类名，就知道它的作用了，MethodCacheInterceptor，Redis的作用是什么？就是Cache。那么Method，Interceptor？显然，就是对方法进行拦截，确定哪些属性要考虑缓存的问题。如果需要，那么就要用到RedisUtil（基本就是最简单的set，get，remove，所以使用一个迷你版的RedisUtil就可以满足RedisTemplate的功能了）</p>
<p>至于MethodCacheInterceptor，是自己写的方法，我们看一下这份网上cv的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodCacheInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = Logger.getLogger(MethodCacheInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; targetNamesList; <span class="comment">// 不加入缓存的service名称</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; methodNamesList; <span class="comment">// 不加入缓存的方法名称</span></span><br><span class="line">    <span class="keyword">private</span> Long defaultCacheExpireTime; <span class="comment">// 缓存默认的过期时间</span></span><br><span class="line">    <span class="keyword">private</span> Long xxxRecordManagerTime; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> Long xxxSetRecordManagerTime; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodCacheInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File f = <span class="keyword">new</span> File(<span class="string">"D:\\cacheConf.properties"</span>);</span><br><span class="line">            <span class="comment">//配置文件位置直接被写死，有需要自己修改下</span></span><br><span class="line">            InputStream in = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="comment">//			InputStream in = getClass().getClassLoader().getResourceAsStream(</span></span><br><span class="line"><span class="comment">//					"D:\\lunaJee-workspace\\msm\\msm_core\\src\\main\\java\\com\\mucfc\\msm\\common\\cacheConf.properties");</span></span><br><span class="line">            Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">            p.load(in);</span><br><span class="line">            <span class="comment">// 分割字符串</span></span><br><span class="line">            String[] targetNames = p.getProperty(<span class="string">"targetNames"</span>).split(<span class="string">","</span>);</span><br><span class="line">            String[] methodNames = p.getProperty(<span class="string">"methodNames"</span>).split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加载过期时间设置</span></span><br><span class="line">            defaultCacheExpireTime = Long.valueOf(p.getProperty(<span class="string">"defaultCacheExpireTime"</span>));</span><br><span class="line">            xxxRecordManagerTime = Long.valueOf(p.getProperty(<span class="string">"com.service.impl.xxxRecordManager"</span>));</span><br><span class="line">            xxxSetRecordManagerTime = Long.valueOf(p.getProperty(<span class="string">"com.service.impl.xxxSetRecordManager"</span>));</span><br><span class="line">            <span class="comment">// 创建list</span></span><br><span class="line">            targetNamesList = <span class="keyword">new</span> ArrayList&lt;String&gt;(targetNames.length);</span><br><span class="line">            methodNamesList = <span class="keyword">new</span> ArrayList&lt;String&gt;(methodNames.length);</span><br><span class="line">            Integer maxLen = targetNames.length &gt; methodNames.length ? targetNames.length</span><br><span class="line">                    : methodNames.length;</span><br><span class="line">            <span class="comment">// 将不需要缓存的类名和方法名添加到list中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; targetNames.length) &#123;</span><br><span class="line">                    targetNamesList.add(targetNames[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; methodNames.length) &#123;</span><br><span class="line">                    methodNamesList.add(methodNames[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object value = <span class="keyword">null</span>;</span><br><span class="line">        String targetName = invocation.getThis().getClass().getName();</span><br><span class="line">        String methodName = invocation.getMethod().getName();</span><br><span class="line">        <span class="keyword">if</span> (!isAddCache(targetName, methodName))       <span class="comment">// 不需要缓存的内容</span></span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();               <span class="comment">// 执行方法返回结果</span></span><br><span class="line">        Object[] arguments = invocation.getArguments();</span><br><span class="line">        String key = getCacheKey(targetName, methodName, arguments);</span><br><span class="line">        System.out.println(key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (redisUtil.exists(key))             <span class="comment">// 判断是否有缓存</span></span><br><span class="line">                <span class="keyword">return</span> redisUtil.get(key);</span><br><span class="line"></span><br><span class="line">            value = invocation.proceed();                       <span class="comment">// 写入缓存</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> String tkey = key;</span><br><span class="line">                <span class="keyword">final</span> Object tvalue = value;</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (tkey.startsWith(<span class="string">"com.service.impl.xxxRecordManager"</span>)) &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, xxxRecordManagerTime);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tkey.startsWith(<span class="string">"com.service.impl.xxxSetRecordManager"</span>)) &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, xxxSetRecordManagerTime);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, defaultCacheExpireTime);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否加入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAddCache</span><span class="params">(String targetName, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetNamesList.contains(targetName)</span><br><span class="line">                || methodNamesList.contains(methodName)) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建缓存key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCacheKey</span><span class="params">(String targetName, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Object[] arguments)</span> </span>&#123;</span><br><span class="line">        StringBuffer sbu = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sbu.append(targetName).append(<span class="string">"_"</span>).append(methodName);</span><br><span class="line">        <span class="keyword">if</span> ((arguments != <span class="keyword">null</span>) &amp;&amp; (arguments.length != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                sbu.append(<span class="string">"_"</span>).append(arguments[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sbu.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRedisUtil</span><span class="params">(RedisUtil redisUtil)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先第一个是构造方法，里面就是对Interceptor的配置，比如过期时间啊，要拦截哪部分的方法啊等等的。这段代码显然有点糙（毕竟上面的都是优雅的源码，这个虽然也是网上大佬写的，但还是有差距哈）。然后invoke方法，这个是最关键的方法。我们的这个类实现了MethodInterceptor接口，这个接口就是只有这么1个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implement this method to perform extra treatments before and</span></span><br><span class="line"><span class="comment">     * after the invocation. Polite implementations would certainly</span></span><br><span class="line"><span class="comment">     * like to invoke &#123;<span class="doctag">@link</span> Joinpoint#proceed()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation the method invocation joinpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result of the call to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Joinpoint#proceed()&#125;, might be intercepted by the</span></span><br><span class="line"><span class="comment">     * interceptor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable if the interceptors or the</span></span><br><span class="line"><span class="comment">     * target-object throws an exception.  */</span></span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从注释也可以看得出来，用于对方法在before或者after进行加强（此处有点像AOP）。而对于invoke方法，前面首先是要读取配置辣，然后try-catch也是比较显然的，判断是否有缓存，如果有，直接return，如果没有，写入缓存（其实这里的interceptor的invoke方法写得不够好，应该要分情况去缓存的，这个大概只是一个demo，还要修改很多，但这里暂时不讨论）。后面的这个Thread我没看懂是为何，既然用到了RedisUtil，应该跟它demo的逻辑有关系，但跟整体的Cache关系不大，略。至于其他的方法，都是辅助这个invoke方法的，比如判断是否要写入缓存，是否存在键等等，关键还是invoke。</p>
<p>至此，对当时Spring整合Redis的全部配置文件，每一个导入的类作用是什么，为什么要有这些property，应该是能有比较清晰的认知了。</p>
<p>4.Jedis的一些重要方法</p>
<p>其实最关键的框架也就是上面的第3点了。这一部分还有的就是Pipeline，调用Lua脚本等等，也是直接调用就行（看着方法名，方法参数来就行，只要对Redis的原生操作足够熟悉）。</p>
<p>Pipeline就直接使用Pipeline类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pipeline</span> <span class="keyword">extends</span> <span class="title">MultiKeyPipelineBase</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pipeline.MultiResponseBuilder currentMulti;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Response&lt;T&gt; <span class="title">getResponse</span><span class="params">(Builder&lt;T&gt; builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.currentMulti != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">super</span>.getResponse(BuilderFactory.STRING);</span><br><span class="line">            Response&lt;T&gt; lr = <span class="keyword">new</span> Response(builder);</span><br><span class="line">            <span class="keyword">this</span>.currentMulti.addResponse(lr);</span><br><span class="line">            <span class="keyword">return</span> lr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getResponse(builder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClient</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Client <span class="title">getClient</span><span class="params">(<span class="keyword">byte</span>[] key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Client <span class="title">getClient</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isInMulti()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.discard();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.sync();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用Lua是在Jedis下的方法：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\60fbd8249e904bc3a36241008b228f76\clipboard.png)</p>
<p>看了一下，RedisTemplate搜eval竟然没有相关方法。然后再搜了一下script，就出来了：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\c46dfa03d3e647adb313655d32a4e859\clipboard.png)</p>
<p>显然，这个就是调用脚本的总方法了。原来没有eval是因为，RedisTemplate还有更大的野心，它要一个方法来执行所有的跟Redis兼容的脚本。。那么看来Jedis也有其他的调用脚本的方法，此处就不再赘述。</p>
<p>客户端管理的API</p>
<p>client list：列出与Redis服务端相连的所有客户端连接信息。下面的客户端的属性：</p>
<p>标识：id，addr，name，fd（socket的文件描述符，如果fd=-1，表示客户端不是外部客户端，而是Redis内部的伪装客户端）</p>
<p>输入缓冲区： qbuf， qbuf-free。缓冲区会动态调整，只是要求每个客户端缓冲区的大小不能超过1G。如果超过了，客户端将会被关闭。而且缓冲区不受maxmomory控制，假设一个Redis实例设置了maxmemory为4G，已经存储了2G，但是如果此时输入缓冲区使用了3G，加起来就超过了maxmemory的限制，可能会产生数据丢失，键值淘汰，OOM等情况。</p>
<p>导致输入缓冲区过大的主要原因：Redis的处理速度跟不上输入缓冲区的输入速度，并且每次进入输入缓冲区的命令包含了大量的bigkey，从而造成了输入缓冲区过大的情况。或者是Redis发生了阻塞，短期内不能处理命令，造成客户端输入的命令积压在了输入缓冲区。</p>
<p>监控输入缓冲区的方法：</p>
<p>1.client  list（收集qbuf和qbuf-free，找到可能出现问题的客户端）</p>
<p>2.info clients，找到最大的输入缓冲区，设置client_biggest_input_buf参数，超过一定值告警</p>
<p>输出缓冲区：obl，oll，omem。与输入缓冲区不一样，输出区可以通过参数设置。输出区根据客户端的不同分为3种：普通客户端，发布订阅客户端，slave客户端（子客户端）。包含：固定缓冲区（16KB，用于返回比较小的执行结果0，动态缓冲区（返回比较大的结果）</p>
<p>客户端的存活状态：age：连接时间    idle：最近一次空闲时间</p>
<p>通过设置参数来控制客户端： config set maxclients（最大客户端连接数，默认10000）</p>
<p>config set timeout（客户端空闲时间超过这个值，就会被关闭，默认是0，即不关闭）</p>
<p>（一般开发的时候用默认的就行，实际发布和运维的时候，idle是必须大于0的）</p>
<p>flag：参数：表示客户端的类型。</p>
<p>N：普通客户端。M：master。S：slave。O：正在执行monitor命令。x：正在执行事务</p>
<p>b：正在等待阻塞事件     u：客户端未被阻塞        d：一个被watch的键已被修改，无法exec事务</p>
<p>c：回复完整的输出后，关闭连接        A：尽可能快地关闭连接</p>
<p>其他诸如：client setName/getName , kill port, pause timeout(毫秒），不再赘述</p>
<p>monitor：可以监控其他客户端的命令调用（在哪个时间，调用了哪个命令）。但在并发量过大的时候，monitor客户端的输出缓冲会暴涨，可能会瞬间占用大量内存。</p>
<p>tcp-keepalive:检测TCP连接活性的周期，默认是0.防止大量的死连接占用系统资源。</p>
<p>tcp-backlog：是一个队列，用于接受的TCP连接。此参数就是队列的大小，默认511，一般不修改。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Swing笔记</title>
    <url>/Swing%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>JFrame：基础窗口<br>JLabel：纯文本<br>JButton：按钮<br>JTextField：输入文本框</p>
<p>Swing有内置的专用线程来接受UI事件并更新屏幕（如果从其他线程着手对屏幕的操作，可能产生冲突和死锁）</p>
<a id="more"></a>例子：

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SwingUtilities.invokeLater(<span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO the operation about the screen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>(不再直接操作JLabel，而是提交一个Runnable，当事件队列获取这通任务时，执行这个Runnable，不会做其他事情。前提是所有代码都如此提交，包括main。将包含初始化组件的任务在内部都设置为在SwingUtilities.invokeLater内调用)</p>
<p>JFrame默认使用BorderLayout</p>
<p>JTextArea： 多行文本输入 （常用方法append，可以rollback）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JTextArea t = <span class="keyword">new</span> JTextArea(<span class="number">20</span>, <span class="number">40</span>);</span><br><span class="line">t.setLineWrap(<span class="keyword">true</span>);    <span class="comment">//设置自动换行，默认为不换行</span></span><br><span class="line">t.setWrapStyleWord(<span class="keyword">true</span>);    <span class="comment">//断行不断字（不会把一个词分在两行中显示）</span></span><br><span class="line">JFrame jFrame = <span class="keyword">new</span> JFrame();</span><br><span class="line">jFrame.add(<span class="keyword">new</span> JScrollPane(t));    <span class="comment">//JScrollPane,给组件增加滚动条</span></span><br></pre></td></tr></table></figure>

<p>Container：面板，用于添加组件，布局等。JFrame实际不能直接设布局和添加组件，但JDK简化了写法，使得给JFrame的操作默认传给Container。<br>setLayout：设置布局<br>JFrame extends Frame<br>Frame extends Window<br>Window extends Container<br>( super.setLayout(…);)<br>布局管理器自适应窗口大小，如果窗口大小尺寸改变，组件的大小，形状和位置都会做出相应的改变</p>
<p>布局：<br>①BorderLayout：四个边框区域和一个中间区域<br>使用面板重载的add方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jFrame.add(BorderLayout.NORTH, <span class="keyword">new</span> JButton());</span><br></pre></td></tr></table></figure>

<p>除CENTER，加入的组件都是沿一个方向压缩到最小尺寸，同时在另一个方向上拉伸到最大尺寸。而CENTER是两个方向同时拉伸，以覆盖中间区域。</p>
<p>②FlowLayout：流布局。组件自左到右流动到窗体，占满空间后换行。组件为合适大小（刚好充满标签的大小）</p>
<p>③GridLayout：表格布局。创建一个放置组件的表格，依次放入。组件大小：自适应窗体。<br>例子：new GridLayout(7, 3); //默认为(n, 1);</p>
<p>④绝对定位：setLayout(null); 把容器的布局管理器设置为空，然后使用setBounds( )方法来定位组件<br>（比较简单粗暴，但是在不同大小的屏幕中显示效果会不一样）</p>
<p>各种按钮：<br>new BasicArrowButton(BasicArrowButton.NORTH);<br>JToggleButton, JCheckBox复选框， JRadioButton单选<br>ButtonGroup 按钮组：将多个AbstractButton对象添加进去，然后只有一个可以选中（排他）<br>例子：将两个JRadioButton加到ButtonGroup实现单选<br>（PS：对于JButton无效，因为只有一个状态，加以监听）</p>
<p>ImageIcon对象：获取文件地址以及文件名，即可用作程序中的图标<br>组件：setRolloverEnabled(true); //是否可以翻转，组件图标是否能改变<br>setRolloverIcon(icon); //设置松开时的图标<br>setPressedIcon(icon);<br>setToolTipText(“…”); //悬浮时，组件的提示语<br>setBorder(Border border); //设置一个边框</p>
<p>JTextField获取数据： jtf.getText(); setEditable(); //默认为true</p>
<p>组合框JComboBox 多选一，如果可自写，setEditable(true); getSelectedIndex(0 ~ n-1), 如果自定义，返回-1 getSelectedItem()</p>
<p>列表框JList<br>与JComboBox的区别：总是占据一定屏幕，可以多选（ctrl）<br>getSelectedValues();返回被选中的items，返回一个字符串数组。<br>JList本身没有对滚动条提供直接支持，需用通过JScrollPane</p>
<p>页签面板：JTabbedPane<br>类似文件夹的页签，里面可容纳多个组件（页面） 使用例子：浏览器上方选择不同页面的面板</p>
<p>消息框：<br>JOptionPane.showMessageDialog(); //消息对话框<br>JOptionPane.showConfirmDialog(); //确认对话框<br>返回值为int： JOptionPane.YES_OPTION &lt;=&gt; 0 , JOptionPane.NO_OPTION &lt;=&gt; 1 ,<br>JOptionPane.CANCEL_OPTION &lt;=&gt; 2 , JOptionPane.CLOSED_OPTION &lt;=&gt; -1</p>
<p>caidan :JMenuBar 能拥有菜单的组件，包括JApplet，JFrame，JDialog及它们的子类。 setMenuBar()方法</p>
<p>JPopupMenu 弹出式菜单 编写自定义对话框： extends JDialog</p>
<p>JDialog 默认布局： BorderLayout<br>setVisiable(true); 必须显式调用才可以使得Dialog显示出来 dispose(); 关闭JDialog，释放资源</p>
<p>文本对话框：JFileChooser 可用于选择，打开文件，保存文件等功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JFileChooser jfc = <span class="keyword">new</span> JFileChooser();</span><br><span class="line">jfc.setFileSelectionMode(JFileChooser.FILES_ONLY);  <span class="comment">//只选文件</span></span><br><span class="line"><span class="comment">//其他参数 DIRECTORIES_ONLY ， FILES_AND_DIRECTORIES</span></span><br><span class="line"><span class="keyword">int</span> value = jfc.showOpenDialog(<span class="keyword">null</span>);    <span class="comment">//打开一个文件选择对话框</span></span><br><span class="line"><span class="keyword">int</span> value1 = jfc.showSaveDialog(<span class="keyword">null</span>);    <span class="comment">//弹出保存文件选择框</span></span><br><span class="line"><span class="comment">//返回值： APPROVE_OPTION 为正常，其他都是有错误的情况</span></span><br></pre></td></tr></table></figure>

<p>getSelectedFile(), getCurrentDirectory() 用于查询操作的返回结果</p>
<p>Container的validate(); 使容器再次布置其子组件（刷新容器的作用）</p>
<p>任何能接受文本的组件都可以接受HTML文本（Swing组件上的HTML)<br>(必须使文本以<html>标记开始，然后就可以开始使用HTML标记)</p>
<p>Jslider 滑块 ProgressMonitor 进度条</p>
<p>选择外观：①可插拔外观（跨平台，默认） ②只适应当前系统的外观<br>选择②：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;    <span class="comment">//写在main()开头</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>deprecated</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记1</title>
    <url>/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.html</url>
    <content><![CDATA[<p>Python是完全面向对象的语言，函数，模块，数字，字符串都是对象。</p>
<p>Python的值不用定义类型，直接赋值即可使用。（因为任何数据都是对象，包括数字。所以变量赋值就是把对象关联起来。每一次变量重新赋值，并没有改变对象的值，只是新创建了一个新对象，并用变量指向它。）</p>
<p> 布尔值为True，False。为False的情况：</p>
<p>数字0（包括0.0），空字符串，None（None是Python里的一个特殊值，表示空值），</p>
<p>空集合,包括( ) , [ ] , { }    其他值都认为是True</p>
<p>变量名不能以 双下划线开头（这类标识符具有特殊意义，如： _<em>init_</em>( ) 代表类的构造函数）</p>
<p>同时只能由数字，字母，下划线组成。其他符号都不行。</p>
<a id="more"></a>

<p>算术运算符：</p>
<p>‘la ‘  *  3 =  ‘la la la ‘</p>
<p>10 / 3 = 3.3333(普通的除）        10 // 3 = 3(取整，跟java的一样）</p>
<p>3**2 = 3^2 = 9</p>
<p>关系运算符，对于字符串，从左到右比较字符。</p>
<p>‘z’ &gt; ‘a’ &gt; ‘Z’ &gt; ‘A’</p>
<p>逻辑运算符：not ， and， or</p>
<p>在字符串前面加u，表示Unicode编码。    u’asdczx’</p>
<p>id( )：输出变量的地址。</p>
<p>当x = y,二者就指向了同一个地址，此时  x is y  返回True。 x is not y 返回False</p>
<p>print可以有占位符。</p>
<p>例子：</p>
<p>“X’s address is : %d”    此时%d就是普通的字符串，但如同在后面增加value</p>
<p>“X’s address is : %d” %(id(x))        那么%d就会被  id(x) 所替换。</p>
<p>类型转换：</p>
<p>字符串转数字： int(x), long(x), float(x)    都有第二个可选参数，表进制。</p>
<p>eval(“..”)    计算字符串里的表达式。例子：eval(‘4+2’) 输出6</p>
<p>数字转字符串：str(x)</p>
<p>repr(obj)    将对象转换为可打印的字符串</p>
<p>chr(整数）将一个整数转换为ASCII字符。    ord（字符） 将一个ASCII字符进行转换为整数</p>
<p>hex（）整数转16进制        oct（） 转8进制</p>
<p>访问字符串某下标： [ ]</p>
<p>“asdefg”[3] = ‘e’    index从0开始。</p>
<p>截取子字段：[a : b]     获取index从a开始，到b-1的字串。</p>
<p>如果用 a - b，会将a - b计算出结果，然后再获取。如果是负数，则从后面算起。-1是最后一个。</p>
<p>范围是： [-length ~ length - 1]    a[-length]  ==  a[0]        [-1]  ==  a[length - 1]</p>
<p>in ， not in    某字符/字符串是否存在于该字符串中</p>
<p>r”asdzxc\nsdew” 使得\n这种转义符失效，成为普通字符串。R同理。这个例子要在print里生效。</p>
<p>-—</p>
<p>Python对于缩进是有限制的，错误的缩进会报错。</p>
<p>（CMD中写Python，tab第一次是4个空格，后面是8个空格，容易出错。）</p>
<p>例如if语句：</p>
<p>if a &gt; 10:    </p>
<p>print(“xxx”);        //如果不缩进，会报错</p>
<p>如果if中有多个语句，这些语句都要有相同的缩进。在cmd中，也要缩进，以一个空行结束if体。</p>
<p>elif    ：    相当于else if</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">15</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">20</span>:</span><br><span class="line">    print(<span class="string">"zz"</span>)</span><br><span class="line"><span class="keyword">elif</span> a &gt; <span class="number">15</span>:</span><br><span class="line">    print(<span class="string">"xx"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"cc"</span>)</span><br></pre></td></tr></table></figure>

<p>while语句:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    sum += i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">print(i)</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>

<p>for语句：   for i in range(start, end):    &lt;==&gt; for (int i = start; i &lt; end; i++) s</p>
<p>​        循环体</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">sum1 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">	sum1 += i</span><br><span class="line">print(i)		<span class="comment"># 100</span></span><br><span class="line">print(sum1)		<span class="comment"># 5050</span></span><br></pre></td></tr></table></figure>

<p>(这里前面i定义与否都可以，但不定义的话，print(i)里会有warning，但还是可以运行的。</p>
<p>try-except语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    i = <span class="number">10</span></span><br><span class="line">    print(<span class="number">30</span> / (i - <span class="number">10</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">	print(<span class="string">"Finished execute!"</span>)</span><br></pre></td></tr></table></figure>

<p>raise 可以显式抛出异常（相当于throw）</p>
<p>——–数据结构</p>
<p>1.列表List    （跟数组差不多，index从0开始）</p>
<p>定义一个list：    a = [ ]</p>
<p>len( ) 输出长度    append添加到最后        index(i, element)    插入到index为i处</p>
<p>a1.extends(a2)    将a2的元素全部添加到a1中</p>
<p>效果等同于：  a1 = a1 + a2</p>
<p>PS:使用加号运算符，会导致a1的内存地址改变。（即a1指向了新的内存地址）</p>
<p>a1 = a2;      #二者都是list</p>
<p>当a2改变的时候，a1也会跟着改变。（二者指向同一个list）</p>
<p>（但如果a2的改变是改变了内存地址，如上面的加号运算符，那么a1还是指向a2原本的内存地址，而a2指向了新的内存地址。此时a1 is a2 返回False）例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">d = [<span class="number">2000</span>, <span class="number">3000</span>]</span><br><span class="line">c = b</span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))	<span class="comment"># if c == b True 2266036261960</span></span><br><span class="line">b.append(<span class="number">1000</span>)</span><br><span class="line">print(c)												<span class="comment"># [1, 2, 88, 99, 1000]</span></span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))	<span class="comment"># if c == b True 22660360261960</span></span><br><span class="line"></span><br><span class="line">b.extend(a)</span><br><span class="line">print(c)												<span class="comment"># [1, 2, 88, 99, 1000, 1, 3, 5, 7]</span></span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))	<span class="comment"># if c == b True 22660360261960</span></span><br><span class="line"></span><br><span class="line">b = b + d</span><br><span class="line">print(c)												<span class="comment"># [1, 2, 88, 99, 1000, 1, 3, 5, 7]</span></span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))	<span class="comment"># if c == b True 2266065942728</span></span><br><span class="line">print(b)												<span class="comment"># [1, 2, 88, 99, 1000, 1, 3, 5, 7, 2000, 3000]</span></span><br></pre></td></tr></table></figure>

<p>list也可以用str( )转换成字符串。否则print的时候与字符串连接会报错。需要：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"some strings here: "</span> + str(aList))</span><br></pre></td></tr></table></figure>

<p>删除元素，length也会改变。（感觉也就C,JAVA的数组还是不可变长度了）:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> listName[index]</span><br></pre></td></tr></table></figure>

<p>相当于String的indexOf，找到第一个element 的index。如果不存在，抛出异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.index(element)</span><br></pre></td></tr></table></figure>

<p>遍历数组，for语句即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">" "</span>)		<span class="comment"># 1 3 3 3 5 7 3</span></span><br></pre></td></tr></table></figure>

<p>不换行print，第二个参数为 end=… 其中… 为每一次输出后面加到末尾的字符串，这里是一个空格。</p>
<p>同时for语句的range函数，如果省略掉一个参数，那么就是从0开始。</p>
<p>可以用for语句的同时，使用enumerate( )函数进行对 index跟value同时遍历，例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'csd'</span>, <span class="string">'we'</span>, <span class="string">'zca'</span>, <span class="string">'ert'</span>, <span class="string">'hnx'</span>]</span><br><span class="line"><span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    print(<span class="string">"第%d个元素是: %s"</span> % (i, val), end=<span class="string">"。。"</span>)</span><br><span class="line"><span class="comment"># 第0个元素是: a。。第1个元素是: we。。……</span></span><br></pre></td></tr></table></figure>

<p>（这个占位符的%后面要加空格，不然又有warning）</p>
<p>sort( ) ： 对list进行排序        a.sort( ) 才是正确的。   sort(a) 没有效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'z'</span>, <span class="string">'A'</span>, <span class="string">'Z'</span>, <span class="string">'B'</span>]</span><br><span class="line">a.sort()</span><br><span class="line"><span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    print(val, end=<span class="string">"。。"</span>)	<span class="comment">#A。。B。。Z。。a。。z。。</span></span><br></pre></td></tr></table></figure>

<p>(z &gt; a &gt; Z &gt; A)</p>
<p>reverse( )： list倒转。如果希望倒序，应该先sort，再reverse</p>
<p>range(start, end)    （range函数实际上会生成一个list）</p>
<p>从start到end递增（到end的时候就结束循环），start 默认值为0</p>
<p>2.元组 tuple</p>
<p>与list很相似，</p>
<p>区别在于：一经定义，内容就不能改变（所以没有插入，删除等功能）。而且可以同时存储不同类似的数据，用圆括号，而不是中括号括起来。</p>
<p>各种方法都与list一致：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(a[<span class="number">0</span>])			<span class="comment"># 1</span></span><br><span class="line">print(a[<span class="number">3</span>])			<span class="comment"># 4</span></span><br><span class="line">print(len(a))		<span class="comment"># 4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">", "</span>)		<span class="comment"># 1, 2, 3, 4</span></span><br><span class="line">print()</span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    print(<span class="string">"a[%d] is : %s"</span> % (index, value), end=<span class="string">", "</span>)	<span class="comment"># a[0] is : 1, a[1] is 2, a[2] is 3, a[3] is 4,</span></span><br></pre></td></tr></table></figure>

<p>由于内容不能改变，所以没有sort函数，也没有reverse。可以先将tuple转换为list，然后再对list排序，再将结果赋值给tuple。</p>
<p>转换：</p>
<p>列表对象 = list(元组对象)</p>
<p>元组对象 = tuple(列表对象)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">31</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">14</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">","</span>)	<span class="comment"># 31, 12, 23, 14,</span></span><br><span class="line">print()</span><br><span class="line">b = list(a)</span><br><span class="line">b.sort()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)):</span><br><span class="line">    print(b[i], end=<span class="string">", "</span>)	<span class="comment"># 12, 14, 23, 31,</span></span><br><span class="line">print()</span><br><span class="line">a = tuple(b)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">", "</span>)	<span class="comment"># 12, 14, 23, 31,</span></span><br></pre></td></tr></table></figure>

<p>3.字典    directory</p>
<p>用{ }，就是键值对。    { key1: val1, key2: val2, … , keyn: valn}</p>
<p>len( ) 长度。    </p>
<p>a[keyx] = valx    添加</p>
<p>a1.update(a2)        合并两个字典，结果放入a1.（此处不可以用a1 = a1 + a2,会报错）</p>
<p>删除键： pop</p>
<p>判断是否存在： in</p>
<p>遍历keys，values：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1 = &#123;<span class="string">'name'</span>: <span class="string">'小明'</span>, <span class="string">'sex'</span>: <span class="string">'男'</span>&#125;</span><br><span class="line">d2 = &#123;<span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'score'</span>: <span class="string">'80'</span>&#125;</span><br><span class="line">d1.update(d2)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d1.keys():</span><br><span class="line">    print(key, end=<span class="string">", "</span>)	<span class="comment"># name, sex, age, score</span></span><br><span class="line">print()</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d1.values():</span><br><span class="line">    print(value, end=<span class="string">", "</span>)	<span class="comment"># 小明, 男, 18, 80,</span></span><br></pre></td></tr></table></figure>

<p>或者 ：   for (k, v) in dict.items( ):        # items( )，获取key-value结果集    (代码略)</p>
<p>清空字段：  a.clear( )</p>
<p>字典也可以嵌套，跟多维list一样。</p>
<p>{‘name’ : {‘first’: ‘Kevin’, ‘last’: ‘Seth’}, ‘age’: 40}</p>
<p>访问嵌套字典：字典[键] [键]        print(d[‘name’] [‘first’])</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d1 = &#123;<span class="string">'name'</span>: &#123;<span class="string">'first'</span>: <span class="string">'Kevin'</span>, <span class="string">'last'</span>: <span class="string">'Seth'</span>&#125;, <span class="string">'age'</span>: <span class="number">24</span>&#125;</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d1.values():</span><br><span class="line">    print(value)	<span class="comment"># &#123;'first': 'Kevin', 'last': 'Seth'&#125;	\n	24</span></span><br><span class="line">print(d1[<span class="string">'name'</span>][<span class="string">'first'</span>])		<span class="comment"># Kevin</span></span><br></pre></td></tr></table></figure>

<p>4.集合    set</p>
<p>集合由一组无序排列的元素组成，同时集合里没有重复的元素。</p>
<p>分为可变集合（set） 和不可变集合（frozenset）</p>
<p>（可变集合 创建后，可以添加元素，修改元素，删除元素）</p>
<p>创建集合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = set(<span class="string">'python'</span>)</span><br><span class="line">print(type(s))		<span class="comment"># &lt;class 'set'&gt;</span></span><br><span class="line">print(s)			<span class="comment"># &#123;'o', 't', 'h', 'n', 'p', 'y'&#125; (无序,每一次都不相同)</span></span><br><span class="line"></span><br><span class="line">s1 = set(<span class="string">'apple'</span>)</span><br><span class="line">print(s)			<span class="comment"># &#123;'a', 'l', 'p', 'e'&#125;</span></span><br></pre></td></tr></table></figure>

<p>len( ) ：获取集合的长度</p>
<p>for e in s    遍历。</p>
<p>add 添加。添加后的元素也在随机位置</p>
<p>s1.update(s2) 添加集合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = set([<span class="number">41</span>, <span class="number">22</span>, <span class="number">13</span>, <span class="number">54</span>, <span class="number">19</span>, <span class="number">38</span>, <span class="number">77</span>, <span class="number">5</span>, <span class="number">6</span>])		<span class="comment"># 也可以直接&#123;41, 22, 13, ……&#125;</span></span><br><span class="line">print(len(s))</span><br><span class="line">s.update([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">print(s)		<span class="comment"># &#123;4, 5, 38, 6, 41, 13, 77, 19, 54, 22&#125;</span></span><br></pre></td></tr></table></figure>

<p>remove(value)    删除指定的集合元素</p>
<p>clear( )    清空</p>
<p>in：判断某个value是否存在于集合中    存在返回True。否则False</p>
<p>A &lt; B , 如果A是B的真子集，返回True。</p>
<p>A &lt;= B, A是B的子集。</p>
<p>A &gt; B, A是B的真超集        A &gt;= B    A是B的超集</p>
<p>|   : 并集，    s1  |  s2   ==   s1 ∪ s2</p>
<p>也可以用这个union方法：    s = s1.union(s2)</p>
<p>&amp;  : 交集        s1  &amp;  s2  ==  s1  ∩  s2</p>
<p>也可以用这个intersection方法：    s = s1.intersection(s2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s = s1.intersection(s2)</span><br><span class="line">ss = s1 &amp; s2</span><br><span class="line">print(s)		<span class="comment"># &#123;3&#125;</span></span><br><span class="line">print(ss)		<span class="comment"># &#123;3&#125;</span></span><br></pre></td></tr></table></figure>

<p>^    :差分集        即    （s1 ∪ s2） - (s1 ∩ s2)</p>
<p>也可以用这个symmetric_difference方法：    s = s1.symmetric_dirrerence(s2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s = s1 ^ s2</span><br><span class="line">ss = s1.symmetric_difference(s2)</span><br><span class="line">print(s)		<span class="comment"># &#123;1, 2, 4&#125;</span></span><br><span class="line">print(ss)		<span class="comment"># &#123;1, 2, 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>按位运算：  &amp;与    |或    ^异或</p>
<p>-————————-</p>
<p>函数：</p>
<p>在函数里定义的变量是局部变量，作用域就是在函数体内。如果全局变量和局部变量同名，那么在函数体内只能访问局部变量。如果在定义局部变量之前调用了同名的“全局变量”，会报错。因为函数体内只能访问局部变量，会显示：UnboundLocalError: local variable ‘a’ referenced before assignment</p>
<p>Python的传值是按值传递的（但传的值都是对象，数字也是对象，这点跟java不一样）</p>
<p>（经过测试：传数值，字符串都不会随着函数而改变，但list，directory会发生改变！）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(list)</span>:</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(len(list)):</span><br><span class="line">        <span class="keyword">if</span> x != len(list) - <span class="number">1</span>:</span><br><span class="line">            print(list[x], end= <span class="string">' + '</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(list[x], end=<span class="string">' '</span>)</span><br><span class="line">        total += list[x]</span><br><span class="line">    print(<span class="string">"="</span>, total)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">list = [<span class="number">15</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">65</span>]</span><br><span class="line">sum(list)		<span class="comment"># 15 + 25 + 35 + 65 = 140</span></span><br><span class="line"><span class="comment"># 只是普通的函数演示,并不是演示list/directory会改变</span></span><br></pre></td></tr></table></figure>

<p>函数定义后面的参数可以指定默认值，（有默认值的参数只能出现在没默认值的参数的后面）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(message, times = <span class="number">1</span>)</span>:</span></span><br><span class="line">    print(message * times)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">say(<span class="string">'hello'</span>)			<span class="comment"># hello</span></span><br><span class="line">say(<span class="string">'Python'</span>, <span class="number">3</span>)		<span class="comment"># PythonPythonPython</span></span><br></pre></td></tr></table></figure>

<p>如果没有指定默认值，那么调用say(‘hello’)的时候参数个数就不对，会报错。当参数个数不一致的时候（或多或少），都会报错（不要跟JS混淆）</p>
<p>可变长参数（跟java不一样），这里是指参数可以是元组，或者是字典。</p>
<p>在形参前面加<em>，表示为 可变长参数。    <em>是元组，</em></em>是字典</p>
<p>例子：def f(*t):    此时调用可以是：f(1),f(1,2), f(5,756,234,23), f({‘a’: ‘111’, ‘b’: ‘324534’})</p>
<p>def f(**t):        此时调用可以是： f(a=1), f(a=1, b=2, c=3), f(a=1, b=12, c=543, d=765)</p>
<p>函数可以指定返回值，return。在函数体里用就行，定义上不用写什么。</p>
<p>Python预定义函数：</p>
<p>abs, pow(x, y), ound(x [, n]) 四舍五入，保留n位小数。 divmod(a,b) 返回 a / b , a % b</p>
<p>(这个四舍五入，-2.5的结果是-2，2.5的结果是2）</p>
<p>PS：Python2中，2.5的结果是3.0。但在python3中，2.5会返回2，2.5000000001才会返回3</p>
<p>字符串处理函数： lower, upper , swapcase(大写转小写，小写转大写）</p>
<p>capitalize 首字母大写。    title 首字母大写，其余为小写</p>
<p>title是每一个单词的首字母大写，例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'hello woRLd'</span>.title()</span><br><span class="line">print(s)					<span class="comment"># Hello World</span></span><br><span class="line">s = <span class="string">'hello woRLd'</span>.capitalize()</span><br><span class="line">print(s)					<span class="comment"># Hello world</span></span><br></pre></td></tr></table></figure>

<p>ljust，rjust， center        左对齐，右对齐，居中对齐，第一个参数为width表示字符串总长度，第二个参数可选，当长度不足时填充，默认是空格填充。</p>
<p>zfill， 用0填充到width长，右对齐。</p>
<p>搜索和替换：</p>
<p>str.find(substr)    查看字符串str中出现子串substr的第一个字母的位置，找不到则返回-1</p>
<p>index    与find函数相同，但找不到的时候会报错</p>
<p>rfind    从右侧开始find    （注意index的结果还是顺序来算的）</p>
<p>rindex            </p>
<p>count    计算子串的出现次数</p>
<p>（以上5个方法还有两个可选参数，start，end，表示搜索范围从start到end - 1）</p>
<p>str.replace(oldstr, newstr [,count])    替换。count为替换次数。</p>
<p>strip，lstrip，rstrip，把前后，前，后的[chars]字符去掉。默认为空白符。</p>
<p>expandtabs    把tab字符替换成空格，每个空格替换成[tabsize]个空格，默认是8个</p>
<p>分割和组合：</p>
<p>split（跟java一样），    splitlines 按照行分隔符划分    join把字符串序列用特定字符连接起来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="string">'214, '</span><span class="number">233</span><span class="string">', '</span><span class="number">532</span><span class="string">']</span></span><br><span class="line"><span class="string">str = '</span><span class="comment">##'</span></span><br><span class="line">s = str.join(list)</span><br><span class="line">print(s)			<span class="comment"># 214##233##532 </span></span><br><span class="line"><span class="comment"># 这里会有一个warning：shadows build_in names 'xx', 因为list, str这种变量名起得不好，容易引起歧义，应该取得更能表达意思的名字 （但这里只是简单的演示代码,str跟list其实就能表示清楚了。。)</span></span><br></pre></td></tr></table></figure>

<p>startwith，endswith，isalnum（是否全是字母或数字），isalpha 字母  isdigit</p>
<p>islower   isupper</p>
<p>help(obj)  输出这个对象的帮助信息（可能是命令，可能是list等等的对象）</p>
<p>（传入一个list，就能看到List列表对象的源码）</p>
<p>type(obj)    显示一个对象的数据类型</p>
<p>字符串会返回：    &lt;class ‘str’&gt;</p>
<p>数值会返回：        &lt;class ‘int’&gt;    &lt;class ‘float’&gt;</p>
<p>列表会返回：        &lt;class ‘list’&gt;</p>
<p>-——————————-</p>
<p>类</p>
<p>1.变量，构造函数，析构函数，调用等等：</p>
<p>PS： <strong>xxx</strong> 表示系统定义的名字    __xx:表示是类的私有变量名(类外不能直接访问)</p>
<p>直接在构造器里调用  self.str11 = ‘111’    也算是定义了一个成员变量str11（即使函数外部没有定义str11这个变量。）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span>		<span class="comment"># constructor</span></span><br><span class="line">        self.__str = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(self)</span>:</span>				<span class="comment"># normal function</span></span><br><span class="line">        print(self.__str)</span><br><span class="line">    __str = <span class="string">'MyString'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span>				<span class="comment"># destructor</span></span><br><span class="line">        print(<span class="string">"bye~"</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">p = Person(<span class="string">'Hong'</span>)</span><br><span class="line">p.sayHello()				<span class="comment"># Hong</span></span><br><span class="line"><span class="keyword">del</span> p						<span class="comment"># bye~</span></span><br><span class="line">p1 = Person(<span class="string">'Kai'</span>)</span><br><span class="line">p1.sayHello()				<span class="comment"># Kai</span></span><br><span class="line"><span class="comment"># bye~		(at the end of the program, p1 will release)</span></span><br><span class="line"><span class="comment"># if no 'del p' exists ahead, it will print 'bye~' twice here!</span></span><br></pre></td></tr></table></figure>



<p>2.静态变量，静态方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span>:</span></span><br><span class="line">    str = <span class="string">"this is the static"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.str = <span class="string">'MyString111'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.str)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">staticMethod</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(cls.str + <span class="string">' , '</span> + str(cls))</span><br><span class="line">        print(<span class="string">'this is a static method'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = MyString()</span><br><span class="line">s.output()                  <span class="comment"># MyString111   the value of instance</span></span><br><span class="line">print(MyString.str)         <span class="comment"># MyString      the value of class, static variable</span></span><br><span class="line">s.str = <span class="string">'Hong'</span></span><br><span class="line">MyString.str = <span class="string">'qqq'</span></span><br><span class="line">s.output()                  <span class="comment"># Hong</span></span><br><span class="line">print(MyString.str)         <span class="comment"># qqq           the value of class, static variable</span></span><br><span class="line">MyString.staticMethod()     <span class="comment"># this is a static method</span></span><br><span class="line">s.staticMethod()            <span class="comment"># this is a static method</span></span><br></pre></td></tr></table></figure>

<p>定义静态方法需要在方法前加：@staticmethod    （而且参数列表里不能有self）    </p>
<p>而定义静态变量不需要任何东西，每一个变量都同时是实例变量和静态变量。只要是通过类名访问的就是静态变量（看上面的例子，str通过instance访问时，就是实例变量，通过类名访问时则是静态）</p>
<p>类方法：@classmethod，第一个参数是cls（表示当前的类）</p>
<p>（其实类方法跟静态方法区别不大，静态方法可以直接用类名表示当前类。但一般的区分是这样的：静态方法存放与类无关的逻辑代码，如单纯的表达式计算。而类方法存放与类属性相关的逻辑代码）</p>
<p>isinstance(对象名， 类名或类型名）</p>
<p>例子： isinstance(str, MyString)        isinstance(1, int)</p>
<p>继承：class B (A)   B继承A，同时构造器里需要显式调用一次父类构造器</p>
<p>子类会继承父类的属性跟方法（私有除外）但如果提供了访问私有函数的公共接口，那么子类通过继承了这个public方法，也是可以间接访问父类私有函数的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, propertyA)</span>:</span></span><br><span class="line">        self.propertyA = propertyA</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__functionA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(str(self.propertyA) + <span class="string">' ... in class A'</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__functionA()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, propertyA, propertyB)</span>:</span></span><br><span class="line">        A.__init__(self, propertyA)		<span class="comment"># call the father constructor</span></span><br><span class="line">        self.propertyB = propertyB</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionB</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(str(self.propertyB) + <span class="string">' ... in class B'</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">a1 = A(<span class="number">10</span>)</span><br><span class="line">a1.functionAA()		<span class="comment"># 10 ... in class A     access the private f by a public f</span></span><br><span class="line">b1 = B(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">b1.functionAA()		<span class="comment"># 5 ... in class A		the same as class A</span></span><br><span class="line">b1.functionB()		<span class="comment"># 10 ... in class B</span></span><br><span class="line">print(b1.propertyA)	<span class="comment"># 5</span></span><br><span class="line">print(b1.propertyB)	<span class="comment"># 10</span></span><br><span class="line"><span class="comment"># a1.__functionA()	# both a and b can't access the private atribute directly</span></span><br></pre></td></tr></table></figure>

<p>如果子类不调用父类的构造器，那么在父类构造器执行的语句就不会生效。比如，父类有属性a = 1，构造器里有赋值语句 a = 5.如果调用了父类构造器，那么子类继承的a属性值为5，如果没有调用，子类继承的属性值为1.如果父类的属性a仅仅定义在构造器里，那么调用父类构造器之后，子类成功继承属性a。如果没有调用父类构造器，则没有继承属性a，会报错（但其他构造器之外的成员都可继承）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        self.a = a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'method in class A'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, propertyA, propertyB)</span>:</span></span><br><span class="line">        A.__init__(self, propertyA)             <span class="comment"># call the father constructor</span></span><br><span class="line">        self.propertyB = propertyB</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'the method in class B'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b1 = B(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">b1.functionAA()          <span class="comment"># the method in class B</span></span><br><span class="line">b1.function1()</span><br><span class="line"><span class="comment"># print(b1.a)			error, B object has no attribute 'a'</span></span><br></pre></td></tr></table></figure>

<p>同时，子类和父类有同名函数，此时是多态，会调用子类的函数，而非父类。（类型是子类）</p>
<p>抽象类和抽象方法：</p>
<p>Python通过类库abc实现抽象类，所以需要先import</p>
<p>from  abc  import  ABCMeta,  abstractmethod</p>
<p>在抽象类的第一行写下：   _<em>metaclass_</em>  =  ABCMeta</p>
<p>在抽象方法前增加：    @abstractmethod</p>
<p>抽象方法的定义：    def  abs_method_name (self): pass</p>
<p>PS：亲测，不需要前面三个步骤，想定义抽象方法直接在函数体 改为 pass 即可！</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myabs</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># __metaclass__ = ABCMeta</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abcmethod</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normalmethod</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"method in myabs"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myimp1</span><span class="params">(myabs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abcmethod</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="number">1123</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sub_abs_method</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># print(234)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = myimp1()</span><br><span class="line">a1.func1()              <span class="comment"># 111</span></span><br><span class="line">a1.abcmethod()          <span class="comment"># doesn't call,but no error</span></span><br><span class="line">a1.sub_abs_method()     <span class="comment">#234</span></span><br><span class="line"></span><br><span class="line">a2 = myabs()            <span class="comment"># abstract class still can make an instance</span></span><br><span class="line">a2.normalmethod()       <span class="comment"># call the non-abstract function(method in myabs)</span></span><br><span class="line">a2.abcmethod()          <span class="comment"># doesn't call,but no error</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，抽象类是可以实例化的，也可以调用非抽象方法跟抽象方法。而且子类也会继承这个抽象方法。但调用没有实现的抽象方法（pass），不会产生任何结果。</p>
<p>而且抽象类可以实例化，跟普通的没有区别。想定义抽象方法直接定义为pass即可</p>
<p>（我觉得抽象方法的主要用途是定义一个公共的方法，但未提供实现。子类可以选择实现并且使用，可以不实现，这时候甚至还能调用这个方法，但没有结果。比直接报错要好）</p>
<p>至于抽象类，似乎目前没有用，可能后面配合 模块 可以实现抽象类禁止实例化？    //TODO</p>
<p>多态：在不同的子类，同名方法可以有不同的实现。（如果子类没有实现该方法，就调用父类方法）</p>
<p>对象复制：</p>
<p>直接a2 = a1，之后二者指向同一个对象。除非指向其他对象，否则仅仅改变属性，内存地址并不会发生变化。而且a1的属性值改变之后，a2也跟着改变（二者始终指向同一个对象）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    property = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(id(a))            <span class="comment"># 3035407383560</span></span><br><span class="line">a.property = <span class="number">234</span></span><br><span class="line">print(a.property)       <span class="comment"># 234</span></span><br><span class="line">print(id(a))            <span class="comment"># 3035407383560 address don't change</span></span><br><span class="line">a2 = a</span><br><span class="line">print(a2.property)      <span class="comment"># 234</span></span><br><span class="line">print(id(a2))           <span class="comment"># 3035407383560</span></span><br><span class="line">a.property = <span class="number">567</span></span><br><span class="line">print(a.property)       <span class="comment"># 567</span></span><br><span class="line">print(a2.property)      <span class="comment"># 567   a2 change its value too</span></span><br><span class="line">print(id(a2))           <span class="comment"># 3035407383560</span></span><br><span class="line">print(id(a))            <span class="comment"># 3035407383560</span></span><br></pre></td></tr></table></figure>

<p>当函数的参数是对象是自定义的类对象时，由于传入的参数并没有声明类型，所以这个时候应该先对参数进行类型判断。    if isinstance(str, MyString):   …</p>
<p>-——————————</p>
<p>模块module    相当于java里的jar包，有封装好的函数，变量可以使用。</p>
<p>import xxx    调用：xxx.f        xxx.val</p>
<p>常用模块：</p>
<p>1.sys</p>
<p>可以获取系统的信息，还可以获取运行时的命令行参数，用作输入等等，例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用命令:  python test.py 3, 4, 9, 1 (如果逗号后面没有空格,好像会把整个当作list)</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.platform)			<span class="comment"># win32</span></span><br><span class="line">print(<span class="string">"一共有%d个参数"</span> % len(sys.argv))		<span class="comment"># 5个, 包括 test.py</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(sys.argv)):</span><br><span class="line">    sum += int(sys.argv[i])</span><br><span class="line">print(sum)									<span class="comment"># 17</span></span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure>

<p>2.platform</p>
<p>可以获取操作系统的详细信息和与Python有关的信息</p>
<p>3.math</p>
<p>与数学有关的。</p>
<p>常量：e，pi</p>
<p>常用方法：</p>
<p>fabs：取绝对值</p>
<p>floor：返回小于等于x的最大整数</p>
<p>log（x，a）：返回loga(x)    如果不指定a，默认是e</p>
<p>log10</p>
<p>pow（x，y） ：    x^y</p>
<p>sqrt    :    根号x</p>
<p>trunc：    返回x的整数部分</p>
<p>4.random</p>
<p>生成随机数</p>
<p>random( )    :生成一个0到1的随机浮点数  0 &lt;= n &lt; 1.0</p>
<p>uniform(a, b)    :生成a~b范围内的随机浮点数 [a, b]  或者 [b, a] （看哪个比较大）</p>
<p>randint（a，b）：生成a~b之间的随机整数（a不能比b大）    [a, b]</p>
<p>randrange (a, b, c): </p>
<p>生成 [a, b)范围里的随机数，每次递增的间隔为c。即获取a, a+c, a+2c, a+3c ……（不包括b）</p>
<p>choice（sequence） ： 从sequence里随机获取一个元素。sequence可以是list，tuple，string</p>
<p>shuffle    打乱list</p>
<p>sample（sequence， k） ：    从sequence中随机获取长度为k的片段。原有sequence不会被修改</p>
<p>5.Decimal</p>
<p>导入： from decimal import Decimal  （用于浮点数计算，精度更高）</p>
<p>6.fractions</p>
<p>用于表现和处理分数。</p>
<p>x = fractions.Fractions(1, 3)</p>
<p>print(x)            #   1/3</p>
<p>对x计算之后，还会进行自动约分。如1/6 * 4会变成 2/3</p>
<p>\7. time模块    （常用）</p>
<p>struct_time数组，表示时间    或者时间戳（1970.1.1到现在的总毫秒数）</p>
<p>year，month，day，hours，minutes，seconds，weekday（星期一为0），yday一年一共几天</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">print(time.time())                          <span class="comment"># 1567835487.381137</span></span><br><span class="line">print(time.localtime(time.time()))</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2019, tm_mon=9, tm_mday=7, tm_hour=13, tm_min=51, tm_sec=56,</span></span><br><span class="line"><span class="comment"># tm_wday=5(星期六）, tm_yday=250（今年的第250天）, tm_isdst=0)</span></span><br><span class="line">print(time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>))   <span class="comment"># 2019-09-07 13:57:13</span></span><br><span class="line">print(time.ctime())                         <span class="comment"># Sat Sep  7 13:57:39 2019</span></span><br></pre></td></tr></table></figure>

<p>自定义模块：一个.py文件就是一个模块，外部可以通过import导入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> myPackage.m1.myMath</span><br><span class="line"></span><br><span class="line">a = myPackage.m1.myMath.sum(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">print(a)			<span class="comment"># 7</span></span><br></pre></td></tr></table></figure>



<p>-—————</p>
<p>函数式编程（感觉跟面向过程差不多，只是功能都封装到函数里）</p>
<p>lambda表达式， 可用作匿名函数</p>
<p>返回函数名   =   lambda  参数列表  ：  返回值表达式</p>
<p>还可以将lambda表达式作为数组里的value：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sum1 = <span class="keyword">lambda</span> x, y, z: x + y + z		<span class="comment"># 输入参数是x, y, z,返回值是三个的和</span></span><br><span class="line">print(sum1(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>))					<span class="comment"># 9</span></span><br><span class="line">Arr = [(<span class="keyword">lambda</span> x: x**<span class="number">2</span>), (<span class="keyword">lambda</span> x: x**<span class="number">3</span>), (<span class="keyword">lambda</span> x: x**<span class="number">4</span>)]</span><br><span class="line">print(Arr[<span class="number">0</span>](<span class="number">5</span>), Arr[<span class="number">1</span>](<span class="number">4</span>), Arr[<span class="number">2</span>](<span class="number">5</span>))	<span class="comment"># 25, 64, 625</span></span><br></pre></td></tr></table></figure>

<p>(但PEP8标准觉得def比lambda要好。准确的是，lambda一般用于匿名函数，如果要把lambda赋值给一个变量作函数变量，那还是用def比较好）</p>
<p>map函数</p>
<p>result_sequence = map(function，sequence1 [，sequence2 …])</p>
<p>(function里有n个参数，那么就需要sequenceN）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">    print(e, end=<span class="string">", "</span>)      <span class="comment"># (0, 4), (1, 16), (2, 36), (3, 64), (4, 100),</span></span><br><span class="line">print()</span><br><span class="line">arr = map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>])</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">    print(e, end=<span class="string">", "</span>)      <span class="comment"># (0, 101), (1, 203), (2, 305), (3, 407), (4, 509),</span></span><br></pre></td></tr></table></figure>

<p>filter函数</p>
<p>filter（function，sequence）</p>
<p>对sequence里的每一个元素调用function，结果为true的返回。最终的结果序列成为filter的返回值</p>
<p>reduce函数</p>
<p>reduce（function，sequence）</p>
<p>function必须有2个参数。然后sequence里的前两个参数调用function，返回结果和第三个参数继续调用function，直到最后一个。</p>
<p>zip函数        压缩，解压(下面例子不能同时for，迭代器对象只能单向迭代一次，到了结尾之后，第二次迭代就像是迭代了一个空的list)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">zipped = zip(a, b)</span><br><span class="line"><span class="comment"># for element in zipped:</span></span><br><span class="line"><span class="comment">#     print(element, end=", ")        # (1, 4), (2, 5), (3, 6),</span></span><br><span class="line"></span><br><span class="line">unzipped = zip(*zipped)</span><br><span class="line"><span class="keyword">for</span> element1 <span class="keyword">in</span> unzipped:</span><br><span class="line">    print(element1, end=<span class="string">", "</span>)         <span class="comment"># (1, 2, 3), (4, 5, 6),</span></span><br></pre></td></tr></table></figure>



<p>闭包：即函数的嵌套。</p>
<p>在fun1里定义另一个fun2，然后fun1里的返回语句是return fun2，这时候就去调用fun2.</p>
<p>递归，一样的道理。</p>
<p>迭代器。</p>
<p>1.iter( )   可以获取一个sequence的迭代器。    next（Iterator）获取下一个元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">12</span>, <span class="number">345</span>, <span class="number">234</span>, <span class="number">65</span>, <span class="number">78</span>, <span class="number">54</span>]</span><br><span class="line">it = iter(list)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = next(it)</span><br><span class="line">        print(s, end=<span class="string">", "</span>)          <span class="comment"># 12, 345, 234, 65, 78, 54,</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>（原生迭代器竟然没有hasNext方法！辣鸡，建议自己实现一个Iterator）</p>
<p>2.enumerate（）   将列表或者元组生成一个有序号的序列（index，value）</p>
<p>生成器：</p>
<p>当存在迭代器的时候，比如for in，实际上每一次都会调用一次next（）函数，表示生成下一个对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addList</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> alist:</span><br><span class="line">        <span class="keyword">yield</span> i + <span class="number">1</span></span><br><span class="line">alist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> addList(alist):</span><br><span class="line">    print(x, end=<span class="string">', '</span>)      <span class="comment"># 2, 3, 4, 5,</span></span><br><span class="line">print()</span><br><span class="line">print(alist)                <span class="comment"># [1, 2, 3, 4]  alist的值并没有变化！</span></span><br><span class="line"></span><br><span class="line">x = addList(alist)</span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 2</span></span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 3</span></span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 4</span></span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p>用生成器 yield。<a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856" target="_blank" rel="noopener">https://blog.csdn.net/mieleizhi0522/article/details/82142856</a></p>
<p>yield相当于return，但下一次再进入到这个方法体的时候，会从yield这个语句后面开始执行。显式用next（generator）来调用相应的generator（有yield的方法），在for in的时候，实际上是每一次都隐式调用了next方法的。</p>
<p>同时如果要传值进行next，那么就用generator.send(value),这样就不会出现yield那一句的值丢失（因为return了之后，从下一个语句开始执行，当前语句在下一次是失效的。如a = yield 4，相当于return了4，但下次是从a的赋值才是进行，但右边的值实际上已经丢失，此时传值才可以让a有值，否则是None值。）</p>
<p>那么，生成器和普通的递归有什么区别？</p>
<p>首先，代码可以更加的简洁，看例子：</p>
<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\83e1a372729240e29c855c809401023c\clipboard.png)</p>
<p>或者这个例子：<a href="https://blog.csdn.net/weixin_40581980/article/details/80986026" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40581980/article/details/80986026</a></p>
<p>（用了生成器语法，直接用1行代码替代了一整个class的功能）</p>
<p>同时，迭代器其实是隐式调用next，而每一步（+1）都会生成元素，开辟空间，添加元素到list</p>
<p>比如我们要获取10000000里的所有素数。如果用迭代器，那么就是 for i in range（2，100000000）</p>
<p>，这样会生成一个很大的list。虽然结果不会有那么多，但中间隐式调用next还是会生成一个临时是长度为10000000的list，极度消耗内存空间。（每一步都要调用next）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primes</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span></span><br><span class="line">        self.max = max</span><br><span class="line">        self.number = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.number += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.number &gt;= self.max:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">elif</span> check_prime(self.number):</span><br><span class="line">            <span class="keyword">return</span> self.number</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__next__()</span><br></pre></td></tr></table></figure>

<p>如果使用生成器呢，此时首先无须迭代，那么也就无须用class来实现，用函数即可。然后在循环里，是先进行check，然后check通过之后，才开始yield（生成），并且下一次next的时候，可以从这一步继续执行下去，生成下一个素数。即无须像迭代器一样，首先需要逐步生成所有的数，然后再check。（相当于比如1到1亿里面，有1000万个素数，那么迭代需要生成一个1亿长度的list，然后再查找，找到1000万个素数，再输出。而用生成器，则是找到一个素数，再添加元素到list里，最后的list长度就只有1000万，远小于1亿!）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Primes</span><span class="params">(max)</span>:</span></span><br><span class="line">    number = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> number &lt; max:</span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> check_prime(number):</span><br><span class="line">            <span class="keyword">yield</span> number</span><br><span class="line">            </span><br><span class="line">  </span><br><span class="line">primes = Primes1(<span class="number">100000000000</span>)</span><br></pre></td></tr></table></figure>



<p>Python的可移植性：先编译成字节码，然后将其转发到虚拟机(Python虚拟机)中运行（跟java一样）</p>
<p>生成的字节码文件：.pyc文件</p>
<p>Python的编译器总是在运行时出现，因为程序执行之前不需要预编译和链接等等的操作，使得开发周期大大缩短。（具备了更多的动态语言特性，可以在一个Python程序中执行另一个Python程序，即可以动态地修改代码，无须拥有或者编译整个系统的代码）</p>
<p>Python的实现，即编译器，PVM的实现方式：CPython，Jython，IronPython</p>
<p>执行优化工具：Psyco实时编译器（对PVM的增强工具）</p>
<p>print语句，在Python2不需要括号，在Python3需要（被视为一个函数调用）</p>
<p>模块：一个.py文件实际上就是一个模块</p>
<p>UNIX输入输出重定向（Python支持UNIX输入输出重定向）</p>
<p>例子：python xxx.py  &gt; saveit.txt    输出会输出到saveit.txt中，而非控制台</p>
<p>导入模块。</p>
<p>import a.b    &lt;==&gt;    from a import b</p>
<p>也可以用一个变量来赋值：import a.b.c.d    q = a.b.c.d</p>
<p>导入的时候，被导入的模块文件会从头执行一次（包括def，class的定义，还是简单的print，都会执行）同时由于导入消耗较大，因此运行两次import（即使在中途模块文件被修改了），也不会执行第二次import，这时候要使用reload（在Python2是内置，Python3里并没有）</p>
<p>exec( open(‘xxx.py’).read( ))</p>
<p>对于exec，代码都相当于粘贴到当前模块文件中，因此同名变量会产生冲突。    </p>
<p>而import跟from并不会。例子：</p>
<p>（我们在myMath.py里定义了一个ak变量，值为100）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ak = <span class="number">50</span></span><br><span class="line">exec(open(<span class="string">'myModule/myMath.py'</span>).read())</span><br><span class="line">print(ak)				<span class="comment"># 100</span></span><br></pre></td></tr></table></figure>

<p>（对于import和from，当我们要访问它的变量，我们需要使用myModule.myMath.ak, myMath.ak等）</p>
<p>Python是动态类型的（自动地跟踪类型，而不是要求声明代码），</p>
<p>但Python也是强类型语言（只能对一个对象进行适合该类型的有效的操作）</p>
<p>字符串截取（跟数组一样操作）：</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'python'</span></span><br><span class="line">print(s[<span class="number">2</span>])</span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">3</span>])		<span class="comment"># [start, end - 1] 'yt'</span></span><br><span class="line">print(s[<span class="number">1</span>:])		<span class="comment"># [start, -1]	'ython'</span></span><br><span class="line">print(s[:])			<span class="comment"># equals with s</span></span><br><span class="line">print(s[:<span class="number">-1</span>])		<span class="comment"># 'pytho'	[0, end - 1], that's [0, -2]</span></span><br><span class="line">print(s[:<span class="number">3</span>])		<span class="comment"># 'pyt'		[0, 2]</span></span><br></pre></td></tr></table></figure>

<p>字符串是不可变的，不能对单独一个字符进行改变等，只能重新赋值（指向另一个字符串对象！）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'python'</span></span><br><span class="line"><span class="comment"># s[0] = 'J'		error</span></span><br><span class="line">print(s)</span><br><span class="line">s = <span class="string">'J'</span> + s[<span class="number">1</span>:]</span><br><span class="line">print(s)			<span class="comment"># Jython</span></span><br></pre></td></tr></table></figure>

<p>实际上还有第三个参数，a[ i : j : k ]        k默认是1，表示每隔k个字符索引一次。</p>
<p>所以如果是’abcdefg’[::2]  ==  ‘aceg’</p>
<p>如果K为-1，表示反转字符串。    “hello”[::-1]    ==    “olleh”</p>
<p>如果是 [a : b : -1]    会将[b + 1, a]的字符串反转输出（b最小为0，因此不能获取第一个字符，只能通过index为0获取第一个字符）</p>
<p>slice( ) 切片函数。</p>
<p>dir(obj)    返回一个list，即该obj包含的所有方法（包括继承而来的各种方法，默认方法）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> textwrap</span><br><span class="line">s = <span class="string">'str'</span></span><br><span class="line">res = str(dir(s))</span><br><span class="line">print(textwrap.fill(res, width=<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\516fb192a01f4a4384d78e6724706a55\clipboard.png)</p>
<p>（textwrap是一个Python标准库的模块，可以用于格式化输出，这里使得每行输出长度最大为100）</p>
<p>help(obj)    返回obj的类定义。    help(obj.func)    返回obj该方法的定义，帮助信息</p>
<p>（因为Python一切皆对象，当然函数也是一个对象）    </p>
<p>关于len( )，转义符也属于长度1</p>
<p>len(‘A\nB\tC’)    ==    5</p>
<p>关于字符串匹配。</p>
<p>导入re模块，用match( reg, str)方法匹配，返回匹配的结果串，并且可以根据括号进行分组</p>
<p>PS：使用group可以获取分组内容，而且括号仅限小括号。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">regexp = <span class="string">'Hello[ \t]*(.*)world'</span></span><br><span class="line">string = <span class="string">'Hello        Python world'</span></span><br><span class="line">match = re.match(regexp, string)</span><br><span class="line">print(match.group(<span class="number">1</span>))		<span class="comment"># 'Python ' 表示括号里的内容</span></span><br><span class="line"></span><br><span class="line">string = <span class="string">'/usr/home/lumberjack'</span></span><br><span class="line">regexp = <span class="string">'/(.*)/(.*)/(.*)'</span></span><br><span class="line">match = re.match(regexp, string)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    print(match.group(i))</span><br><span class="line"><span class="comment"># group(0)为整个string,group(n)为第n个括号的内容</span></span><br></pre></td></tr></table></figure>

<p>这些字符串操作都是一个真正的序列操作，所以很多对于list等等都是有效的。</p>
<p>比如list也可以用-1下标表示最后一个元素！</p>
<p>list的赋值不能超出边界。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># L[10] = 100		并不会把length提到10, 而是直接报错, 只能用append等</span></span><br></pre></td></tr></table></figure>

<p>Python的核心数据类型，都支持任意的嵌套。（同时list允许不同类型的元素）例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, [<span class="string">'fsd'</span>, <span class="number">4</span>], <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list))</span><br><span class="line">	print(list[i], end=<span class="string">", "</span>)		<span class="comment"># 1, 2, ['fsd', 4], 5, </span></span><br><span class="line">print()</span><br><span class="line">print(list[<span class="number">2</span>][<span class="number">0</span>] + <span class="string">', '</span> + str(list[<span class="number">2</span>][<span class="number">1</span>]))	<span class="comment"># fsd, 4</span></span><br></pre></td></tr></table></figure>

<p>列表解析表达式 list comprehension expression</p>
<p>语法:    [ result_expression   for   item   in   list   filter_expression]</p>
<p>（第一个的result_expression可以调用后面for item的item数组）</p>
<p>例子：[ [1, 2, 3], [4, 5, 6], [7, 8, 9]]    一个二维矩阵，现在要提取第二列，并且每个值加1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">col2 = [item[<span class="number">1</span>] + <span class="number">1</span> <span class="keyword">for</span> item <span class="keyword">in</span> list]</span><br><span class="line">print(col2)				<span class="comment"># [3, 6, 9]</span></span><br><span class="line">col2Doules = [row[<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> list <span class="keyword">if</span> row[<span class="number">1</span>] %  <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">print(col2Doubles)		<span class="comment"># 获取第二列的偶数元素, [2, 8]</span></span><br></pre></td></tr></table></figure>

<p>如果使用括号的解析语法，就变成了生成器generator：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">generator = (sum(row) <span class="keyword">for</span> row <span class="keyword">in</span> list1)</span><br><span class="line">print(next(generator))			<span class="comment"># 6</span></span><br><span class="line">print(next(generator))			<span class="comment"># 15</span></span><br><span class="line">print(next(generator))			<span class="comment"># 24</span></span><br><span class="line">print(list(map(sum, list1)))	<span class="comment"># [6, 15, 24]</span></span><br></pre></td></tr></table></figure>

<p>（直接用map函数，对列表的每一列进行sum操作，然后用list转换成列表）</p>
<p>ps：sum跟list都是标准模块里的函数，可以直接使用，平时不要覆盖掉</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mydir = &#123;<span class="string">'name'</span>: <span class="string">'hong'</span>, <span class="string">'jobs'</span>: [<span class="string">'student'</span>], <span class="string">'age'</span>: <span class="number">24</span>&#125;</span><br><span class="line">print(mydir)                <span class="comment"># &#123;'name': 'hong', 'jobs': ['student'], 'age': 24&#125;</span></span><br><span class="line">mydir[<span class="string">'sex'</span>] = <span class="string">'male'</span></span><br><span class="line">print(mydir)                <span class="comment"># &#123;'name': 'hong', 'jobs': ['student'], 'age': 24, 'sex': 'male'&#125;</span></span><br><span class="line">mydir[<span class="string">'jobs'</span>].append(<span class="string">'programmer'</span>)</span><br><span class="line">print(mydir)     <span class="comment"># &#123;'name': 'hong', 'jobs': ['student', 'programmer'], 'age': 24, 'sex': 'male'&#125;</span></span><br><span class="line">print(mydir[<span class="string">'jobs'</span>][<span class="number">-1</span>])    <span class="comment"># programmer</span></span><br></pre></td></tr></table></figure>

<p>Python也有GC机制，但我们也可以手动删除不再需要的对象（del），也可以赋值为0，引发GC</p>
<p>字典可以用in判断是否存在某个key，也可以get(key1, default_value)</p>
<p>如果存在key1，则返回，如果不存在，返回default_value</p>
<p>文件。    要调用open函数来生成file对象。</p>
<p>第一个参数是路径，第二个参数是权限。默认是’r’,只能是’r’或者’w’，不能是’rw’</p>
<p>同时还可以是’rb’，表示将读出来的数据改为二进制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'data.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">'Hello\n'</span>)</span><br><span class="line">f.write(<span class="string">'world\n'</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'data.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">text = f.read()</span><br><span class="line">print(text)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>判断类型，isinstance是最好的选择</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> type(list1) == type([]):</span><br><span class="line">    print(<span class="string">'yes'</span>)</span><br><span class="line"><span class="keyword">if</span> type(list1) == list:</span><br><span class="line">    print(<span class="string">'yep'</span>)</span><br><span class="line"><span class="keyword">if</span> isinstance(list1, list):</span><br><span class="line">    print(<span class="string">'yeah'</span>)</span><br></pre></td></tr></table></figure>

<p>Python操作符表达式：</p>
<p>yield  x                            生成器表达式</p>
<p>lambda  args  ：  expression            匿名函数</p>
<p>x  if  y  else  z                        y为真时，x。否则z</p>
<p>x  or  y，    x  and  y，  not  x</p>
<p>x  in  y，  x  not  in  y        （iterables，sets）</p>
<p>x  is  y，  x  is  not  y</p>
<p>&lt; , &gt; ,== , !=  |,  &amp; ,   ^（异或）,    &lt;&lt;左移    &gt;&gt;右移    /除，    //除，取整数结果</p>
<p>s[i: j: k]    数组切片，从[i, j)中，每隔k个数输出一个列表</p>
<p>……</p>
<p>当两个类型不一样的数字进行运算时，结果为更复杂的那个类型。</p>
<p>如：40 + 3.14 = 43.14    3.14 + （2+3j） = 5.14+3j</p>
<p>x &lt; y &gt; z，    x &gt; y &gt; z， x  &gt;  y  &lt; z 这种是可行的</p>
<p>math.floor( )    返回不大于x 的最大整数。所以x为2.5时，结果为2.为-2.5时候，结果为-3</p>
<p>//整除，实际上就是对获得的结果，再进行floor。</p>
<p>所以  5 // 2 == 2    5 // -2  == -3</p>
<p>如果真的只想要整数部分，应该用trunc</p>
<p>python的整数没有范围，支持无穷的大小</p>
<p>进制计数：</p>
<p>0o开头：八进制    （第一个是0，第二个是小写的o）</p>
<p>0x开头：十六进制</p>
<p>0b开头：二进制</p>
<p>oct(x)      十进制转八进制</p>
<p>hex(x)    十进制转十六进制</p>
<p>bin(x)    十进制转二进制</p>
<p>或者是  int( num, x)        第二个参数可选，表示进制，默认是10</p>
<p>eval函数，可以将字符串作为python代码执行，然后运行结果就是返回结果。一般的作用是将字符串对象转换成更具体的对象（比如数字，list，set，directory等等）。但由于eval实际上会将里面的字符串作为程序的一个小片段进行编译运行，所以可以做一些其他的工作。比如甚至可以偷偷地拿一个字符串，将电脑上的某个文件删除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">eval(<span class="string">"os.remove('data.txt')"</span>)</span><br></pre></td></tr></table></figure>

<p>位运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">11</span> | <span class="number">0b1100</span>)      <span class="comment"># 0b1111 == 15  (11 == ob1011, 1011 | 1100 == 1111)</span></span><br><span class="line">print(<span class="number">11</span> | <span class="number">1100</span>)        <span class="comment"># 0b10001001100 | 00000001011 == 1100 + 3 == 1103</span></span><br><span class="line">print(bin(<span class="number">1100</span>))        <span class="comment"># 0b10001001100</span></span><br><span class="line">print(<span class="number">0b11</span> ^ <span class="number">0b1010</span>)        <span class="comment"># 1001 == 9</span></span><br></pre></td></tr></table></figure>

<p>buildins（Python的内建模块，预定义的功能函数）</p>
<p>max，min，sum都在此中。</p>
<p>decimal模块设置全局精度：</p>
<p>decimal.getcontext( ).prec = 4</p>
<p>获得运行环境</p>
<p>decimal.Decimal(1) </p>
<p>print(decimal.Decimal(1) / decimal.Decimal(<strong>‘7’</strong>))</p>
<p><em># 0.1428571428571428571428571429    (默认精度)</em></p>
<p>关于布尔值（bool）</p>
<p>原本只是一个数字，</p>
<p>如果要用==来判断，那么只有True == 1才会返回True。0 == False才会返回False</p>
<p>如果用if来判断，那么只有特定情况下是返回False。</p>
<p>返回False的情况：</p>
<p>数字0（包括0.0，0.00000等）</p>
<p>空字符串（仅限’’, “”）(前面是一对单引号，后面是一对双引号）</p>
<p>其他诸如：” “(一个空格),   ‘0’,  “‘’”(双引号里面再加一对单引号)等等，都是返回True的。</p>
<p>空值：None</p>
<p>空集合： [ ] , (  ),   {  }</p>
<p>(此外，由于python里的True跟False其实就是1跟0，所以甚至能跟数字进行运算。比如：</p>
<p>True + 3 + 5J  == 4 + 5J</p>
<p>False  + 7.4  ==  7.4        True  +  5.5  ==  6.5</p>
<p>(不过一般意义不大，omit it！）</p>
<p>多个字符串用空格分隔开赋值，相当于加号运算符。例子：</p>
<p>s = “Meaning “ ‘of’ ‘ the life’</p>
<p>s            # Meaning of the life</p>
<p>如果中间是用 逗号 分隔开，那么会生成元组。</p>
<p>s = “Meaning “ , ‘of’ “ the life’</p>
<p>s            # (‘Meaning ‘, ‘of the life’)</p>
<p>关于转义：</p>
<p>在cmd中直接输出，会变成自动带有转义效果的字符串。比如换行会变成\n，\会变成\</p>
<p>然后，如果赋值的时候，反斜杠后面跟的并不是转义的字符，那么反斜杠会直接写入，例子：</p>
<p>x = “C:\py\code”</p>
<p>print(x)    # C:\py\code    因为并没有\p,\c，但建议在使用反斜杠而非转义时，还是直接转义</p>
<p>即：    x = “C:\py\code”    结果会是一样的</p>
<p>同时，无论如何，print(x)，里面的反斜杠会是\，而直接x时候（在cmd），会是\</p>
<p>在字符串前面加一个r，表示不转义。例子：</p>
<p>c = r’c:\py\code’</p>
<p>print(c)        # c:\py\code</p>
<p>三重引号（无论单引号，双引号都可以），可以用于编写多行文本数据。</p>
<p>即’’’ asdzxc…………（包括各种换行）’’’    这时候里面所有行加起来成为一个字符串。</p>
<p>（cmd中换行会变成\n）</p>
<p>而多行文本中的引号都会直接输出，无须转义。（直到遇见三重引号结束的时候）</p>
<p>同时，可以利用三重引号来作为多行注释（对性能影响不大，一般应该还是用于调试阶段）</p>
<p>转换。int( ), str( ) , repr( )</p>
<p>repr函数能将一个对象转换成其字符串形式。</p>
<p>ord将字符转换成ASCII码，chr则将ASCII码转换成字符。</p>
<p>格式化字符串的两种方法：</p>
<p>1.用%d，%s等占位符</p>
<p>“That is %d %s bird!”% (1, ‘dead’)</p>
<p>2.使用占位数组</p>
<p>‘That is {0} {1} bird!’.format(1, ‘dead’)</p>
<p>显然，format紧接着的就是一个数组，从{0}开始慢慢对应替换。format方法是新的格式化方法。</p>
<p>一般除非要进行特殊的格式化，否则直接用%s就行了，因为每种类型的对象都可以转换为字符串。</p>
<p>PS：格式化的结果是一个新的字符串对象，而不是对原本的字符串进行的修改。</p>
<p>其他格式化代码    P194</p>
<p>字符串方法：P186，此处略</p>
<p>Python一共有3个主要类型（以及操作）：</p>
<p>1.数字（整数，浮点数，二进制，分数等）：</p>
<p>支持加法，乘法等等。</p>
<p>2.序列（字符串，列表，元组）：</p>
<p>支持索引，分片，合并等等。</p>
<p>3.映射（字典）：</p>
<p>支持通过键的索引等。</p>
<p>（集合是自成一体的一个分类，不在此中）</p>
<p>每种类型的操作都是相通的，比如：</p>
<p>对于字符串，乘法运算符* 的作用是创建一个字符串的N份拷贝。</p>
<p>s = ‘abc’</p>
<p>s = s * 3            # PS： s * 3  &lt;==&gt;  3 * s</p>
<p>s        # ‘abcabcabc’</p>
<p>那么对于其他的序列sequence来说，<em>的运算也是相同的。比如对于list，之前没对list用过</em>，实际上效果也是一样的：</p>
<p>x = [1, 2, 3] * 3</p>
<p>x            # [1, 2, 3, 1, 2, 3, 1, 2, 3]</p>
<p>可变类型：数字，字符串，元组，不可变集合。</p>
<p>可变类型：列表，字典，可变集合。</p>
<p>-———</p>
<p>list的append与extend：</p>
<p>append是添加一个元素，extend是添加一个iterable的元素（list，tuple等等,并且迭代展开来。</p>
<p>例子：</p>
<p>[1, 2, 3].append([4, 5, 6])        ==&gt;    [1, 2, 3, [4, 5, 6]]</p>
<p>[1, 2, 3].extend([4, 5, 6])        ==&gt;     [1, 2, 3, 4, 5, 6]</p>
<p>分片赋值：</p>
<p>L = [1, 2, 3, 4, 5, 6, 7, 8]</p>
<p>L[2: 4] = [100, 200, 300, 400, 500]</p>
<p>使得L的[2, 3]替换成右边的。结果：[1, 2, 100, 200, 300, 400, 500, 3, 4, 5, 6, 7, 8]</p>
<p>字典的key不一定要是字符串，整数也行。只要是不可变对象就行。</p>
<p>获取不存在的key的值时会报错，然后程序就会结束，避免程序结束：</p>
<p>1.if key1 in dir: … else: …            通过if判断是否存在该key</p>
<p>2.try: …… except KeyError: ……        如果出错就执行except里的语句，然后继续执行。</p>
<p>3.dir.get(key1, 0)                    get方法，获取key1的值，获取不到就返回第二个参数</p>
<p>创建字典的方法：</p>
<p>dir = {‘name’ : ‘xxx’ , ‘age’ : 45}</p>
<p>D = { }</p>
<p>D[‘name’] = ‘xxx’</p>
<p>D[‘age’] = 45</p>
<p>dir = dict(name = ‘mel’, age = 45)        # key必须都是字符串才行</p>
<p>dir = dict( [(‘name’, ‘mel’), (‘age’, 45)])    # 给dict传入一个list对象的时候比较适用</p>
<p>嵌套对象用&gt; , &lt;比较大小时，会一直递归，从左到右比较，走到最深的层次，逐步比较差值。</p>
<p>关于乘法运算符，是返回一个新的对象（重复n次连接起来的），这时即使是重复一个对象，也不会因为原对象引用改变而改变新的对象。但在嵌套可变序列（对象）时，情况会不一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">x = L * <span class="number">4</span></span><br><span class="line">y = [L] * <span class="number">4</span></span><br><span class="line">y2 = [L[:]] * <span class="number">4</span></span><br><span class="line">print(x)            <span class="comment"># [4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]</span></span><br><span class="line">print(y)            <span class="comment"># [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]</span></span><br><span class="line">print(y2)           <span class="comment"># [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]</span></span><br><span class="line">L[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">print(x)            <span class="comment"># [4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]</span></span><br><span class="line">print(y)            <span class="comment"># [[4, 0, 6], [4, 0, 6], [4, 0, 6], [4, 0, 6]]</span></span><br><span class="line">print(y2)           <span class="comment"># [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]</span></span><br></pre></td></tr></table></figure>

<p>对于x = L * 4，是生成了一个新的list，不存在共享引用，因此L改变时，x并不会改变。</p>
<p>但是对于y = [L] * 4,相当于[ … ] * 4生成了一个新的list，而每个[ ]里面又引用了一个外部的list（共享引用），此时L改变时，y也会跟着改变。</p>
<p>解决方法就是拷贝，y2 = [L[:]] * 4,这样就不存在共享引用。</p>
<p>当复合对象包含指向自身的引用，称为循环对象，而这个自身的引用会打印成[…]，避免无限循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; [&#39;hong&#39;]</span><br><span class="line">x.append(x)</span><br><span class="line">print(x[0])         # hong</span><br><span class="line">print(x[1])         # [&#39;hong&#39;, [...]]</span><br><span class="line">print(x[1][0])      # hong</span><br><span class="line">print(x[1][1])      # [&#39;hong&#39;, [...]]</span><br></pre></td></tr></table></figure>

<p>对于sequence：假如 L = [0, 1, 2, 3, 4]    len = 5</p>
<p>1.索引值超过边界时，会发生error        （如L[5]）</p>
<p>2.但分片运算超出边界时，会把超出的数字限制回最大值。</p>
<p>如L[2: 100]    会自动改为L[2: 5]    不会报错</p>
<p>3.但左边界大于右边界时，会返回空sequence。</p>
<p>如：L[3: 1]     ==&gt;  [ ]</p>
<p>（以翻转的方式提取序列是行不通的（ 较低边界值比较高边界值更大， 例如，</p>
<p>L[3:1] ）。你会得到空分片（ [] ），因为Python会缩放分片限制值，以确定较低边</p>
<p>界永远比较高边界小或相等（例如， L[3:1] 会缩放成 L[3:3] ，空的插入点是在偏</p>
<p>移值3处））</p>
<p>但对这部分赋值是可行的，并且是以左边界处进行插入。</p>
<p>如： L[3: 1] = [‘10’, ‘20’, ‘30’, ‘40’, ‘50’]     但不等于L[3] = [‘10’, ‘20’, ‘30’, ‘40’, ‘50’]</p>
<p>结果会是： [0, 1, 2, 10, 20, 30, 40, 50, 3, 4]    (与有边界的数字无关）</p>
<p>如果是L[3]=。。。    则是直接更新list，更新list[3]的值了，而且L[3]的值会变成一个[。。 ] list</p>
<p>L[3] = [‘10’, ‘20’, ‘30’, ‘40’, ‘50’]        ==&gt;    L == [0, 1, 2, [‘10’, ‘20’, ‘30’, ‘40’, ‘50’], 4]</p>
<p>(如果分片赋值的时候，也超出边界，那么仍然按照第二条来执行：</p>
<p>L[10000:200]    = […]    这样就相当于append（超出时是append）</p>
<p>（这种反向（左边界不小于右边界）分片赋值在插入元素时是一个可行的选择）</p>
<p>4.L[2] = [ ]     那么L[2]的值就变成了[ ],即 L == [0, 1, [ ] , 3, 4]</p>
<p>但如果是分片赋值，L[2: 4] = [ ] ,则这里面的值会删除，最后：L == [0, 1, 4]</p>
<p>赋值空列表给一个分片，则会删除该分片</p>
<p>(但如果是第三条的情况下赋值[ ],则不会生效。如L[3: 1] = [ ] ，并不会删除L[3]，不会执行任何操作。</p>
<p>而只有当左边界小于右边界（即正常情况），才会删除）</p>
<p>if state:</p>
<p>state2</p>
<p>try:</p>
<p>statement1</p>
<p>except:</p>
<p>statement2</p>
<p>else:</p>
<p>statement3</p>
<p>finally:</p>
<p>statement4</p>
<p>else可以与if连用，也可以与try-except连用。上述语句else是与try连用，就近原则。</p>
<p>try-except-else-finally的意思是：</p>
<p>如果出现了错误，那么就执行except里的语句，如果没有错误，就执行else里的语句。finally一定执行</p>
<p>关于作用域，global和nonlocal：</p>
<p>（global用于在函数里访问全局同名变量，如果没global，按照LEGB原则，全局变量会被局部变量名覆盖，因而访问不到全局变量。）</p>
<p>（而nonlocal用于在嵌套函数里访问外部函数的同名变量，如果没global，按照LEGB，也是会先访问当前层次的局部变量，访问不到外部函数的同名变量）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y, z = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x1 = <span class="number">123</span></span><br><span class="line">    x = y + z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x1</span><br><span class="line">        x1 = <span class="number">1234</span></span><br><span class="line">    f2()</span><br><span class="line">    print(x1)   <span class="comment"># 1234  f2通过nonlocal把f1的x1给修改了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line">print(x)    <span class="comment"># 3 f1通过global把全局的x给修改了</span></span><br><span class="line">x = <span class="number">100</span></span><br><span class="line">print(x)    <span class="comment"># 100</span></span><br></pre></td></tr></table></figure>

<p>Python的嵌套函数类似于JS的闭包，也可以保存已经结束了的外部函数的变量。如下面，就相当于可以视为一个工厂函数：（同时还能根据类型而做出不同的选择）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maker</span><span class="params">(N)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> X * N</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = maker(<span class="number">3</span>)</span><br><span class="line">print(f(<span class="string">'a'</span>))		<span class="comment"># aaa</span></span><br><span class="line">print(f(<span class="number">5</span>))			<span class="comment"># 15</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        此文用于记录一些常用的Linux命令。主要记录每一个命令的作用，参数的作用。</p>
<h4 id="①ls-英语全文：list。列出目录下的文件。-语法：-ls-选项-文件名或目录名"><a href="#①ls-英语全文：list。列出目录下的文件。-语法：-ls-选项-文件名或目录名" class="headerlink" title="①ls  英语全文：list。列出目录下的文件。  语法： ls [选项] [文件名或目录名]"></a>①ls  英语全文：list。列出目录下的文件。  语法： ls [选项] [文件名或目录名]</h4><p>-a：显示所有文件    –color=when(颜色输出。默认为always。 never：从不  auto：自动)<br>-d：显示目录信息，而非文件<br>-h：文件大小显示为k，M,G<br>-i：显示iNode<br>#####-l：长格式显示（ <strong>ll &lt;==&gt; ls -l</strong>）</p>
<a id="more"></a>

<hr>
<h4 id="②cd。英语全文：change-directory。更新目录-（Shell内置命令）"><a href="#②cd。英语全文：change-directory。更新目录-（Shell内置命令）" class="headerlink" title="②cd。英语全文：change directory。更新目录  （Shell内置命令）"></a>②cd。英语全文：change directory。更新目录  （Shell内置命令）</h4><p>Linux命令：Shell内置命令（无执行文件所在路径）/外部文件（有可执行文件）  Linux绝大部分是外部命令<br>-P:如果切换的是软链接目录，则进入原始的物理目录，而非软链接目录<br>-L:如果切换的是软链接目录，直接进入软链接目录</p>
<hr>
<h4 id="③mkdir-英语全文：make-directories。创建一个空目录"><a href="#③mkdir-英语全文：make-directories。创建一个空目录" class="headerlink" title="③mkdir 英语全文：make directories。创建一个空目录"></a>③mkdir 英语全文：make directories。创建一个空目录</h4><p>-p：递归创建一连串的新目录。  例子：mkdir -p a/b/c</p>
<hr>
<h5 id="④rmdir-英语全文：remove-empty-directories。-删除一个空的目录（只能删目录），如果目录有内容-如其他空目录-，就会报错。"><a href="#④rmdir-英语全文：remove-empty-directories。-删除一个空的目录（只能删目录），如果目录有内容-如其他空目录-，就会报错。" class="headerlink" title="④rmdir 英语全文：remove empty directories。 删除一个空的目录（只能删目录），如果目录有内容(如其他空目录)，就会报错。"></a>④rmdir 英语全文：remove empty directories。 删除一个空的目录（只能删目录），如果目录有内容(如其他空目录)，就会报错。</h5><p>（这个命令不常用，后续一般用rm命令） -p：递归删除</p>
<hr>
<h5 id="⑤touch-英语全文：change-file-timestamps。-触摸，如果文件不存在，创建一个空文件。如果已存在，修改文件的时间戳。"><a href="#⑤touch-英语全文：change-file-timestamps。-触摸，如果文件不存在，创建一个空文件。如果已存在，修改文件的时间戳。" class="headerlink" title="⑤touch 英语全文：change file timestamps。 触摸，如果文件不存在，创建一个空文件。如果已存在，修改文件的时间戳。"></a>⑤touch 英语全文：change file timestamps。 触摸，如果文件不存在，创建一个空文件。如果已存在，修改文件的时间戳。</h5><p>访问时间：Access  数据修改时间：Modify  状态修改时间：Change<br>-a：只修改文件的访问时间<br>-m：只修改文件的数据修改时间<br>-c：<del>只修改状态修改时间</del> 如果文件不存在，不创建新文件。（没有只修改状态修改时间的功能！）<br>-d：把文件时间修改为指定的时间，而非当前时间<br>（注意，不要把touch用作新建文件的命令）</p>
<hr>
<h5 id="⑥stat-英语全文：display-file-or-file-system-status。显示文件或文件系统的详细信息"><a href="#⑥stat-英语全文：display-file-or-file-system-status。显示文件或文件系统的详细信息" class="headerlink" title="⑥stat 英语全文：display file or file system status。显示文件或文件系统的详细信息"></a>⑥stat 英语全文：display file or file system status。显示文件或文件系统的详细信息</h5><p>stat [选项] 文件名或目录名（必须要指定第二个参数）<br>-f:查看文件所在的文件系统信息，而不是查看文件的信息<br>改变三种时间的命令：<br>cat：改变Access Time<br>echo：写入数据，改变Modify Time， Change Time<br>chown： 改变文件所有者。 改变Change Time<br>touch：三种都改（不使用选项时）</p>
<hr>
<h5 id="⑦cat-英语全文：concatenate-files-and-print-on-the-standard-output。连接文件并打印输出到标准输出"><a href="#⑦cat-英语全文：concatenate-files-and-print-on-the-standard-output。连接文件并打印输出到标准输出" class="headerlink" title="⑦cat 英语全文：concatenate files and print on the standard output。连接文件并打印输出到标准输出"></a>⑦cat 英语全文：concatenate files and print on the standard output。连接文件并打印输出到标准输出</h5><p>-A：列出所有隐藏符号(all)<br>-E:列出每行结尾的回车符$ (end)<br>-n:显示行号<br>-T:显示出Tab键 ^|<br>-v:列出所有特殊字符         （即-A &lt;==&gt; -vET）<br>(不论文件内容有多少，都会一次性显示，如果文件太大，上面部分不会显示完全。cat不适合查看太大的文件，有其他命令)</p>
<hr>
<h5 id="⑧：more-英语全文：file-perusal-filter-for-crt-view-in。分屏显示文件内容"><a href="#⑧：more-英语全文：file-perusal-filter-for-crt-view-in。分屏显示文件内容" class="headerlink" title="⑧：more 英语全文：file perusal filter for crt view in。分屏显示文件内容"></a>⑧：more 英语全文：file perusal filter for crt view in。分屏显示文件内容</h5><p>常用快捷键：  空格：向下翻页。  b：向上翻页。  回车键：向下滚动一行<br>/字符串： 搜索指定的字符串。  q：退出<br>?:对于这种持续性命令（more，top等），显示各种可执行操作（即help）</p>
<hr>
<h5 id="⑨：head-英语全文：output-the-first-part-of-files。显示文件开头的几行"><a href="#⑨：head-英语全文：output-the-first-part-of-files。显示文件开头的几行" class="headerlink" title="⑨：head 英语全文：output the first part of files。显示文件开头的几行"></a>⑨：head 英语全文：output the first part of files。显示文件开头的几行</h5><p>-n 行数：显示前[行数]几行（n与行数之间，有无空格均可） 行数默认为10<br>-v：显示文件名（被head操作的文件）<br>注意： -行数 &lt;==&gt; -n 行数。即： head -n 20 .bash_history &lt;==&gt; head -20 .bash_history</p>
<hr>
<h5 id="⑩：tail-英语全文：output-the-last-part-of-files。显示文件结尾内容"><a href="#⑩：tail-英语全文：output-the-last-part-of-files。显示文件结尾内容" class="headerlink" title="⑩：tail 英语全文：output the last part of files。显示文件结尾内容"></a>⑩：tail 英语全文：output the last part of files。显示文件结尾内容</h5><p>-n 行数：显示最后[行数]几行。同样默认为10，与head用法一致<br>-f：监听文件新增内容。使用时，光标会一直存在，当其他终端向该文件追加一些数据时，该命令会监视出来。</p>
<hr>
<h5 id="11：-ln-英语全文：make-links-between-file。在文件之间建立链接。-ln-选项-源文件-目标文件"><a href="#11：-ln-英语全文：make-links-between-file。在文件之间建立链接。-ln-选项-源文件-目标文件" class="headerlink" title="11： ln 英语全文：make links between file。在文件之间建立链接。 ln[选项] 源文件 目标文件"></a>11： ln 英语全文：make links between file。在文件之间建立链接。 ln[选项] 源文件 目标文件</h5><p>-s:建议软链接（默认是硬链接）<br>-f：如果目标文件已存在，删除目标文件后再建立链接文件<br>如果：目标文件没有文件名（即是一个目录），那么新建的文件名跟源文件名一致。<br>ln /root/a /tmp/ &lt;==&gt; ln /root/a /tmp/a   此时/root/a与/tmp/a是硬链接<br>（注意：硬链接没有其他要求，但如果建立软链接，那么源文件必须写绝对路径，不能是相对路径）<br>硬链接：两个文件的iNode相同，其一修改，另一个都会修改。但其中之一删除，iNode文件仍然能访问<br>      （不能跨文件系统(分区），因为不同分区的iNode值重新计算，而且不能链接目录) （不常用）<br>软链接：创建一个新的目标文件，iNode不同，指向源文件（相当于快捷方式）<br>ll查看软链接文件时，权限开头的l表示：软链接。 文件名 -&gt; 指向源文件<br>（软链接可以链接目录，而且可以跨分区）<br>软链接的block写的不是真正的数据，而仅仅是源文件的文件名及iNode号。删除掉软链接，源文件不受影响。删除掉源文件，软连接会失效。但如果改变软链接，那么源文件也会被修改。</p>
<hr>
<h5 id="12：rm-英语全文：remove-files-or-directories。删除文件-目录"><a href="#12：rm-英语全文：remove-files-or-directories。删除文件-目录" class="headerlink" title="12：rm 英语全文：remove files or directories。删除文件/目录"></a>12：rm 英语全文：remove files or directories。删除文件/目录</h5><p>-f：强制删除(force)<br>-i：交互删除（删前会询问，默认就是-i）<br>-r：递归删除，可以删除目录（加了-r才可以删目录）（逐层，直到最底层，逐层删除，逐个询问）<br>rm -rf：递归删除，不询问，强制。<br>（传说中的： rm -rf / ,删除所有，强制执行！）</p>
<hr>
<h5 id="13：cp-英语全文：copyfiles-and-directories。复制文件和目录。-cp-选项-源文件-目的文件"><a href="#13：cp-英语全文：copyfiles-and-directories。复制文件和目录。-cp-选项-源文件-目的文件" class="headerlink" title="13：cp 英语全文：copyfiles and directories。复制文件和目录。  cp[选项] 源文件 目的文件"></a>13：cp 英语全文：copyfiles and directories。复制文件和目录。  cp[选项] 源文件 目的文件</h5><p>-d：如果源文件是软链接，那么目的文件也为软链接（如果不指定，复制的会是源文件）。对硬链接无效<br>-p：保留源文件的属性（所有者，所属组，权限，时间）<br>-r：递归复制，用于目录<br>-a：相当于 -dpr<br>-i：询问，如果目标文件已经存在，询问是否覆盖<br>-l：将目标文件建立为源文件的硬链接，而不是复制源文件<br>-s：……建立为软链接<br>（复制文件时，如果目标’是一个目录，即没有指定文件名，则不改名复制，否则会改名）<br>（执行cp命令后，目标文件的时间会更改为命令的执行时间，而非源文件的时间。用-p或者-a可以解决）</p>
<hr>
<h5 id="14：-mv-英语全文：-move-rename-files-移动文件或者改名。-mv-选-源-目’"><a href="#14：-mv-英语全文：-move-rename-files-移动文件或者改名。-mv-选-源-目’" class="headerlink" title="14： mv 英语全文： move(rename) files 移动文件或者改名。  mv[选] 源 目’"></a>14： mv 英语全文： move(rename) files 移动文件或者改名。  mv[选] 源 目’</h5><p>-f:强制覆盖，如果已存在，直接覆盖<br>-i：交互。……。询问（默认为-i,即mv &lt;==&gt; mv -i）<br>-n:如果已存在，不覆盖<br>-v：显示移动过程<br>（如果要覆盖的是一个非空目录，则无法覆盖。即便是-f也不可以）<br>改名操作：如果源’和目’在同一路径，则为改名操作。 mv mytmp1 mytmp2</p>
<hr>
<h5 id="15：man-英语全文：format-and-display-the-online-manual-pages。帮助手册-man-选项-命令"><a href="#15：man-英语全文：format-and-display-the-online-manual-pages。帮助手册-man-选项-命令" class="headerlink" title="15：man 英语全文：format and display the online manual pages。帮助手册   man [选项] 命令"></a>15：man 英语全文：format and display the online manual pages。帮助手册   man [选项] 命令</h5><p>-f：查看命令拥有哪个级别的帮助<br>-k：查看和命令相关的所有帮助<br>快捷键：上，下，pageUp，pageDown  g：第一页  G：最后一页   q：quit<br>/str:所有str   ?str:向上搜索str   n：搜下一个str<br>N：如果是/str 切换成 ?str ,如果是?str,切换成 /str<br>例子：man -f passwd 有 passwd(1), passwd(5)<br>      那么：man 1 passwd =&gt; passwd(1)<br>其他：whatis &lt;==&gt; man -f<br>apropos  &lt;==&gt; man -k<br>想知道命令在哪：whereis   想知道当前用户是谁： whoami</p>
<hr>
<h5 id="16：info-同样是帮助，但是是一份完整详细的电子书"><a href="#16：info-同样是帮助，但是是一份完整详细的电子书" class="headerlink" title="16：info  同样是帮助，但是是一份完整详细的电子书"></a>16：info  同样是帮助，但是是一份完整详细的电子书</h5><hr>
<h5 id="17：help-只用户获取Shell内置命令的帮助，不常用"><a href="#17：help-只用户获取Shell内置命令的帮助，不常用" class="headerlink" title="17：help  只用户获取Shell内置命令的帮助，不常用"></a>17：help  只用户获取Shell内置命令的帮助，不常用</h5><p>如：ls是外部命令。 help ls，会报错。<br>但绝大多数命令可用 –help获取帮助。  例子： ls –help（输出man的简化版）</p>
<hr>
<h5 id="18：whereis-只能搜索命令，不能索索普通文件"><a href="#18：whereis-只能搜索命令，不能索索普通文件" class="headerlink" title="18：whereis  只能搜索命令，不能索索普通文件"></a>18：whereis  只能搜索命令，不能索索普通文件</h5><p>-b：只查找二进制命令<br>-m：只查找帮助文档（命令的帮助文档）</p>
<hr>
<h5 id="19：which-英语全文：shows-the-full-path-of-shell-commands。列出命令所在路径，如果该命令有别名，则同时显示出别名命令"><a href="#19：which-英语全文：shows-the-full-path-of-shell-commands。列出命令所在路径，如果该命令有别名，则同时显示出别名命令" class="headerlink" title="19：which 英语全文：shows the full path of shell commands。列出命令所在路径，如果该命令有别名，则同时显示出别名命令"></a>19：which 英语全文：shows the full path of shell commands。列出命令所在路径，如果该命令有别名，则同时显示出别名命令</h5><p>如： which mv =&gt; alias mv = ‘mv -i’ /usr/bin/mv<br>which ll =&gt; alias ll = ‘ls -l –color=auto’ /usr/bin/ls</p>
<hr>
<h5 id="20-locate-英语全文-find-files-by-name。按照文件名搜索文件"><a href="#20-locate-英语全文-find-files-by-name。按照文件名搜索文件" class="headerlink" title="20: locate 英语全文: find files by name。按照文件名搜索文件"></a>20: locate 英语全文: find files by name。按照文件名搜索文件</h5><p>只能根据文件名搜索，但是因为locate并不是搜索硬盘空间，而是先建立locate数据库，然后在数据库中搜索，因此：搜索速度快，耗费的系统资源非常小。<br>-i:忽略大小写（ignore）<br>例子：locate mkdir 会搜索出包含mkdir字符串的文件名，当然也包括mkdir命令<br>ps：locate数据库并不会实时更新，而是等用户退出登录或者重启系统时才会更新（因此新创建的文件无法立刻locate查到）<br>locate数据库位置： ll /var/lib/mlocate/mlocate.db (二进制文件)<br>命令： updatedb ： 可以即时更新一次locate数据库（这样可以locate到新文件。命令执行需要一定时间，要等待）<br>同时，部分文件类型或目录，并不会放到locate数据库中，如：<br>光盘，网盘，临时目录等（要么不在Linux系统中，是外来存储的网络存储的，要么是系统的缓存和临时文件，如/tmp下的文件，此时updatedb也没用）</p>
<hr>
<h5 id="21：-find-英语全文：search-for-files-in-a-directory-hierarchy。在目录中查找文件。"><a href="#21：-find-英语全文：search-for-files-in-a-directory-hierarchy。在目录中查找文件。" class="headerlink" title="21： find 英语全文：search for files in a directory hierarchy。在目录中查找文件。"></a>21： find 英语全文：search for files in a directory hierarchy。在目录中查找文件。</h5><p>不仅可按照文件名搜索，还可按照权限，大小，时间，iNode号等来搜索文件<br>（find是在硬盘中进行搜索的，如果指定的搜索范围过大，就会消耗较大的系统资源）<br>语法： find 搜索路径 [选] 搜索内容     （如果路径设定为 /, 那么执行起来就会很慢）<br>如果无选项，则将路径下的所有文件都输出。<br>-name：按照文件名搜索<br>-iname：按文件名，切不区分大小写<br>-inum：按照iNode号搜索<br>（如果是按照文件名。必须是完全匹配才会列出，如： find /root -name a123  此时只会列出名为a123的文件。如果是locate，会列出a123，还可能列出a12345，vca123等）<br>-size[+-] 大小:按文件大小搜索。 +-表示是比[大小]的数字还要大，还是小<br>例：find . -size +25k  当前目录下，大于25k的文件<br>（-size与后续的+或-，要有空格，而 +/-与大小之间无空格，k必须是小写(kb）)<br>千字节(kb)必须用小写k，兆字节(MB)必须用大写M，GB用大写G。<br>如果不写单位，默认单位并不是字节b，而是512byte，即半个kb。<br>如果单位要指定为字节，要用小写c。双字节要用小写w<br>-atime [+-] 时间：根据Access Time。。。  -mtime：…… -ctime：……<br>例子：find . -mtime -5 : 5天内修改的文件。   5：前5~6，这一天内修改的  +5：6天前修改的<br>同时还有amin，mmin，cmin，单位是分钟（time单位是天）<br>按权限： -perm 数字， -perm -数字， -perm +数字<br>按所有者和所属组： -uid 用户id， -gid 用户组id， -user 用户名， -gid 组名， -nouser（没有所有者）<br>例子：find . -user root 所有者是root的文件<br>按文件类型：-type d 查目录  -type f 查普通文件  -type l 查软链接</p>
<p>逻辑运算符：-a 与 ， -o 或 ， -not 非<br>例子：find . -size +2k -a -type f   (大于2kb且是普通文件)<br>      find . -name cangls -o -name bols (文件名是cangls或bols)<br>      find . -name a55 -o -size +3k(文件名为a55或者size大于3kb)<br>      find . -not -name cangls(文件名不为cangls)</p>
<p>find 路径 [选项] 内容 -exec 命令2 {} ;<br>指将find获取的结果放入{}中，再由命令2执行。<br>例：find . -size +2k -exec ls -l {} ;<br>获取size大于2kb的文件，并进行ls -l命令<br>PS：命令2与’{‘必须有空格,’}’和’&#39;之间也必须有空格。<br>而且此处不能-exec ll，推测不能用alias。<br>-ok选项：与-exec基本一致，不过操作前询问一次y/n</p>
<hr>
<h5 id="22-zip-英语全文-package-and-compress-files-压缩文件或目录"><a href="#22-zip-英语全文-package-and-compress-files-压缩文件或目录" class="headerlink" title="22: zip 英语全文:package and compress files.压缩文件或目录"></a>22: zip 英语全文:package and compress files.压缩文件或目录</h5><p>语法： zip [选项] 压缩包名 源文件或目录<br>-r： 压缩目录<br>可以同时压缩多个文件，用空格分开即可。<br>如果已经有同名压缩包，会进行覆盖。如果资源名也是相同，会updating，否则是adding。（压缩包会放在当前路径下）</p>
<hr>
<h5 id="23：unzip-英语全文：list-test-and-extract-compressed-files-in-a-ZIP-archive-列举，测试和提取压缩文件中的文件。"><a href="#23：unzip-英语全文：list-test-and-extract-compressed-files-in-a-ZIP-archive-列举，测试和提取压缩文件中的文件。" class="headerlink" title="23：unzip 英语全文：list,test and extract compressed files in a ZIP archive.列举，测试和提取压缩文件中的文件。"></a>23：unzip 英语全文：list,test and extract compressed files in a ZIP archive.列举，测试和提取压缩文件中的文件。</h5><p>-d: 指定解压位置<br>例子： unzip -d /root/mytmp3 mytest.zip</p>
<hr>
<h5 id="24-gzip-英语全文-compress-or-expand-files-压缩或解压文件-目录"><a href="#24-gzip-英语全文-compress-or-expand-files-压缩或解压文件-目录" class="headerlink" title="24: gzip 英语全文:compress or expand files.压缩或解压文件/目录"></a>24: gzip 英语全文:compress or expand files.压缩或解压文件/目录</h5><p>语法：gzip file1 压缩file1，生成file1.gz（源文件会消失）<br>-c: 将压缩数据输出到标准输出中，保留源文件（可用 &gt; 将输出重定向到一个文件中，这样既可以压缩，又不让源文件消失）<br>例子：gzip -c a123 &gt; a123.gz<br>-r:压缩目录（递归地将目录下的文件分别压缩成xxx.gz）<br>-d:解压（将压缩文件恢复原样）<br>-v:显示压缩文件信息（压缩比）<br>-数字：指定压缩等级，-1等级最低，压缩比最差，-9最高。默认为-6<br>PS：解压时，gzip -d abc &lt;=&gt; gzip -d abc.gz(即前者abc会自动寻找abc.gz文件)<br>文件太小时，压缩等级不同，压缩比也可能相同。</p>
<hr>
<h5 id="25：gunzip-解压。-gunzip-lt-gt-gzip-d"><a href="#25：gunzip-解压。-gunzip-lt-gt-gzip-d" class="headerlink" title="25：gunzip 解压。 gunzip &lt;=&gt; gzip -d"></a>25：gunzip 解压。 gunzip &lt;=&gt; gzip -d</h5><p>gunzip a123操作的同样是a123.gz，即 gunzip a123 &lt;=&gt; gunzip a123.gz<br>解压目录： gunzip -r（将目录下的压缩文件解压，但不会解压打包）<br>如果压缩文件是纯文本，用zcat可以在不解压的情况下查看文本内容</p>
<hr>
<h5 id="26：-bzip2-bz2格式文件的压缩命令（-bz2格式的算法理论上更好，及压缩比更好，但-gz更快）"><a href="#26：-bzip2-bz2格式文件的压缩命令（-bz2格式的算法理论上更好，及压缩比更好，但-gz更快）" class="headerlink" title="26： bzip2 .bz2格式文件的压缩命令（.bz2格式的算法理论上更好，及压缩比更好，但.gz更快）"></a>26： bzip2 .bz2格式文件的压缩命令（.bz2格式的算法理论上更好，及压缩比更好，但.gz更快）</h5><p>-d:解压<br>-k:压缩时保留源文件<br>-v:显示压缩信息 -数组：压缩等级<br>（gzip不支持打包目录，-r也只是分别压缩目录下的每个文件，而bzip根本不支持压缩目录，也没有-r选项）</p>
<hr>
<h5 id="27-bunzip2-等同bzip2-d-解压"><a href="#27-bunzip2-等同bzip2-d-解压" class="headerlink" title="27: bunzip2  等同bzip2 -d 解压"></a>27: bunzip2  等同bzip2 -d 解压</h5><p>-k：保留压缩文件<br>值得注意的是，一定要写明.bz2后缀，即 bunzip a ≠ bunzip a.bz2 , bzip -d同理。<br>如果是纯文本，用bzcat可以在不解压时查看文本内容。</p>
<hr>
<h5 id="28：tar-打包-解打包命令-语法：-tar-选项-f-压缩包名-源文件或目录"><a href="#28：tar-打包-解打包命令-语法：-tar-选项-f-压缩包名-源文件或目录" class="headerlink" title="28：tar 打包/解打包命令   语法： tar[选项][-f 压缩包名] 源文件或目录"></a>28：tar 打包/解打包命令   语法： tar[选项][-f 压缩包名] 源文件或目录</h5><p>-c：打包<br>-f：指定压缩包的文件名（写清后缀）<br>-v：显示打包过程<br>例子： tar -cvf test.tar /root/mytmp2<br>-x: 解压打包<br>-t：测试，即不解压，只是看包中有哪些文件<br>-C：指定解压位置。<br>解压与打包的区别： -xvf 与 -cvf       测试： -tvf<br>可以先tar，再gzip或bzip2，获得 .tar.gz 或者 .tar.bz2的格式<br>也可以一步到位： -z：压缩或者解压.tar.gz格式     -j：压缩或者解压.tar.bz2格式<br>例子： tar -zxvf a.tar.gz 解压<br>       tar -jcvf b.tar.bz2 /tmp/   压缩，压缩包的文件名为 b.tar.bz2<br>常用： -zcvf , -jcvf , -zxvf , -jxvf</p>
<hr>
<h5 id="29-sync-英语全文-flush-file-system-buffers-刷新文件系统缓冲区"><a href="#29-sync-英语全文-flush-file-system-buffers-刷新文件系统缓冲区" class="headerlink" title="29: sync 英语全文:flush file system buffers. 刷新文件系统缓冲区"></a>29: sync 英语全文:flush file system buffers. 刷新文件系统缓冲区</h5><p>作用：将内存中的数据强制向硬盘中保存，避免宕机导致数据丢失（该命令在常规关机时会自动执行） 直接执行，无须任何选项</p>
<hr>
<h5 id="30：-shutdown-英语全文：bring-the-sytem-down-关机和重启-执行权限：超级用户"><a href="#30：-shutdown-英语全文：bring-the-sytem-down-关机和重启-执行权限：超级用户" class="headerlink" title="30： shutdown 英语全文：bring the sytem down 关机和重启   执行权限：超级用户"></a>30： shutdown 英语全文：bring the sytem down 关机和重启   执行权限：超级用户</h5><p>格式： shutdown [选项] 时间 [警告信息]<br>-c：取消已经执行的shutdown命令 shutdown -c<br>-h： 关机   -r：重启<br>shutdown -h now    #现在立刻关机<br>shutdown -h 05:30   （当天的5：30关机，如果时间已过，就是第二天的5：30）<br>shutdown -h 05:30 &amp; (命令会一直占用前端)<br>其他关机重启命令： reboot重启， halt 或者 poweroff ， init 0 关机 ，  init 6 重启 （还是建议用shutdown）</p>
<hr>
<h5 id="31：setup-系统配置工具，配置IP，网卡，防火墙等（Red-Hat专有命令）"><a href="#31：setup-系统配置工具，配置IP，网卡，防火墙等（Red-Hat专有命令）" class="headerlink" title="31：setup  系统配置工具，配置IP，网卡，防火墙等（Red Hat专有命令）"></a>31：setup  系统配置工具，配置IP，网卡，防火墙等（Red Hat专有命令）</h5><hr>
<h5 id="32：ifconfig-查看IP地址信息（也可配置网络接口）-（windows是ipconfig）"><a href="#32：ifconfig-查看IP地址信息（也可配置网络接口）-（windows是ipconfig）" class="headerlink" title="32：ifconfig 查看IP地址信息（也可配置网络接口） （windows是ipconfig）"></a>32：ifconfig 查看IP地址信息（也可配置网络接口） （windows是ipconfig）</h5><p>inet addr：IP地址            netmask：子网掩码<br>broadcast：广播地址/MAC地址/局域网，以太网，物理地址</p>
<hr>
<h5 id="33：-ping-向网络主机发送ICMP请求，测试网络中主机的通信情况-ping-选-IP地址"><a href="#33：-ping-向网络主机发送ICMP请求，测试网络中主机的通信情况-ping-选-IP地址" class="headerlink" title="33： ping 向网络主机发送ICMP请求，测试网络中主机的通信情况         ping [选]IP地址"></a>33： ping 向网络主机发送ICMP请求，测试网络中主机的通信情况         ping [选]IP地址</h5><p>-b：后面加入广播地址，对整个网段进行探测<br>-c 次数：指定ping的次数（中间有无空格均可。如果不指定，会一直ping）<br>-s 字节：指定探测包的大小</p>
<hr>
<h5 id="34：netstat-网络状态查看命令，可以看到本机开放的端口，也可看有哪些客户端连接"><a href="#34：netstat-网络状态查看命令，可以看到本机开放的端口，也可看有哪些客户端连接" class="headerlink" title="34：netstat 网络状态查看命令，可以看到本机开放的端口，也可看有哪些客户端连接"></a>34：netstat 网络状态查看命令，可以看到本机开放的端口，也可看有哪些客户端连接</h5><hr>
<h5 id="35：write-英语全文：send-a-message-to-another-user-向其他用户发送信息"><a href="#35：write-英语全文：send-a-message-to-another-user-向其他用户发送信息" class="headerlink" title="35：write 英语全文：send a message to another user 向其他用户发送信息"></a>35：write 英语全文：send a message to another user 向其他用户发送信息</h5><hr>
<h5 id="36-mail-英语全文：send-and-receive-Internet-mail-发送和接受电子邮件"><a href="#36-mail-英语全文：send-and-receive-Internet-mail-发送和接受电子邮件" class="headerlink" title="36: mail 英语全文：send and receive Internet mail. 发送和接受电子邮件"></a>36: mail 英语全文：send and receive Internet mail. 发送和接受电子邮件</h5><p>ctrl + c 和 ctrl + z的区别：<br>c是强制中断程序的执行，此时进程就会终止。<br>而z是讲任务终止（暂停），但进程并没有结束，只是被挂起。用户可用fg/bg继续前台或后台的任务</p>
<hr>
<hr>
<p>其他常用命令：（选项参数略）<br><strong>①top</strong>  查看系统的整体运行情况（相当于任务管理器）</p>
<p>*<em>②df *</em> 显示磁盘空间使用情况</p>
<p>*<em>③du *</em> 对文件和目录磁盘使用空间的情况</p>
<p><strong>④date</strong> 当前日期和时间<br>例子：将当前时间写入文件：  date &gt; cangls   如果是 echo date &gt; cangls ,写入cangls文件的会是字符串“date”<br>(&gt; , &lt; 用作输出重定向，echo为显示命令，显示后重定向，就是写操作)</p>
<p><strong>⑤ps</strong> 列出当前系统的进程状态  ps -ef   第一个数字是 PID，进程ID。 第二个数字是PPID，父进程的ID</p>
<p><strong>⑥kill</strong>  删除，终止程序。  （kill -数字）<br>kill -1： 终端断线<br>kill -2：中断（同ctrl + c）<br>kill -9: 强制终止<br>……<br>（只有9才可无条件终止进程，其他信号，进程有权利忽略。。）</p>
<p><strong>⑦grep</strong> 文本搜索，用正则表达式搜索，匹配文本<br>-i：忽略大小写  -n：所在行数<br>管道符： |   将两个命令分隔开，前一个的stdout（输出）作为下一个的stdin（输入）<br>例子： ps -ef | grep ping 查找包含ping的进程</p>
<p><strong>⑧awk sed grep</strong> 文本处理。</p>
<p><strong>⑨free</strong> 显示系统内存使用情况，包括物理内存，交换区内存（SWAP），内核缓冲区内存。</p>
<p><strong>⑩clear</strong>  清屏  vim：进行vim文本编辑器</p>
<p>11： <strong>rpm</strong>  安装RPM包。  rpm -ivh 包全名  -i：install  -v：显示详细信息verbose  -h：打印，显示安装进度hash<br>-e：卸载。   rpm -e 包名</p>
<p>12：启动服务等： <strong>service</strong> 服务名 start | stop | restart | status<br>                <strong>systemctl</strong> start | stop | restart | status 服务名</p>
<p>13：<strong>yum命令</strong>  下载相应的rpm包并安装，解决了依赖关系<br>yum list: 列出可安装，已安装的包<br>yum search: 从yum镜像源服务器上查找与关键字相关的所有软件包<br>yum info： 查询执行软件包的详细信息（大小，版本，证书，描述等）<br>yum install：安装  -y：自动回答yes<br>（用yum卸载软件包时，会把依赖包也同时卸载，包括系统允许的必备文件，此时的结果就是，系统崩溃。所以一般不要用yum卸载软件包）</p>
<p>gcc编译器， make：完成对源码包的自动编译    make install：将编译文件进行安装</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装Apache</title>
    <url>/Linux%E5%AE%89%E8%A3%85Apache.html</url>
    <content><![CDATA[<p>记录一下第一次在Linux上安装Apache遇到的问题以及解决过程。</p>
<p>具体步骤可以参考此博文：<br><a href="https://blog.csdn.net/u010297957/article/details/50751656" target="_blank" rel="noopener">https://blog.csdn.net/u010297957/article/details/50751656</a></p>
<p>1.安装有两种方法，<strong>第一种是手动安装</strong>，</p>
<p>步骤：<br>①<strong><em>先下载相关的源码包</em></strong>，包括：Apache HTTP Server（这个就是我们要安装的Apache Server，但它还需要其他依赖包，所以仅有这个并不足够），APR（Apache Server的依赖包，然而这个APR本身又依赖APR-Util和PCRE），APR-Util，PCRE。一共4个源码包。此处用到了wget命令，wget url，下载相应的源码包。</p>
<a id="more"></a>

<hr>
<p>②<strong><em>解压源码包</em></strong>，获得源码文件，用到tar命令，至于选项是-zxvf还是-jxvf则看下载的文件类型是tar.gz，tar.bz2来决定。</p>
<hr>
<p>③<strong><em>要将这些软件解压到/usr/local/ 下</em></strong> (并不强求，但用户软件安装到这个目录是一个好选择)。先创建相应的目录存放文件，如mkdir /usr/local/httpd , mkdir /usr/local/apr , mkdir /usr…/pcre</p>
<hr>
<p>④<strong><em>分别对4个软件进行，配置，编译，安装。</em></strong>用到的命令： ./configure … (./指当前目录下的configure命令，要先进入相应的文件夹)，配置完成之后执行make命令，用于编译源码文件。最后执行make install，安装。（configure的时候要指定相应的依赖包文件）</p>
<hr>
<p>⑤<strong><em>此时Apache已安装完毕，进入bin目录执行./apachectl start ，即可启动Apache服务。</em></strong>至于Apache相应的配置，进入conf命令修改httpd.conf即可。（建议提前对httpd.conf进行备份，避免出错。 cp httpd.conf httpd.conf.bak）</p>
<hr>
<p>⑥<strong><em>在httpd.conf定义相应的监听端口等，然后外网即可通过IP地址访问服务器。</em></strong></p>
<hr>
<p><strong>当中遇到的问题：</strong></p>
<p>①一开始是根据那个Linux教程来安装的，它那里只要求用Apache HTTP Server的源码包，缺少相关的依赖包，因此要先把APR下载安装。</p>
<hr>
<p>②安装APR时又缺少依赖包，需要APR-Util。</p>
<hr>
<p>③下载APR-Util，安装时出错，显示缺少expat.h文件，即缺少expat库，此时需要安装expat开发库。yum install expat-devel。安装完成后再安装APR-Util即可。</p>
<hr>
<p>④再安装APR，成功。此时安装Apache HTTP Server要指定APR和APR-Util的路径，依然报错，显示缺少PCRE。跟前面的错误是相同性质的，不是大问题。</p>
<hr>
<p>⑤下载PCRE，安装，此时又出错，显示：configure: error: You need a C++ compiler for C++ support.因为我的机器默认只安装了gcc，还没有安装gcc-c++，因此要编译C++文件的时候就出错了。所以此时要安装C++环境。yum install -y gcc-c++ (安装gcc同理)。安装完gcc-c++之后，安装PCRE没有任何问题，都是make，make install。</p>
<hr>
<p>⑥最后安装Apache HTTP Server，把上面3个依赖包的路径都指定了，安装成功。</p>
<hr>
<p>⑦在bin中启动了Apache的httpd服务，配置完httpd.conf后，外网可以访问到Apache，有一个默认的index.html，显示it works！表示Apache配置完成。</p>
<hr>
<p>⑧此时想找到这个index.html来做一下简单的修改，但找不到相应的文件在哪。上网查到，httpd.conf文件中，有一个DocumentRoot的路径，表示默认的路径在哪。本文当前的路径是：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/Linux_01.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/Linux_01.jpg" alt="DocumentRoot路径"></a><br>进入htdocs文件夹后，可以看到只有一个index.html，看来默认项目的路径的确是这里。</p>
<hr>
<p>⑨修改index.html，出现中文乱码。一开始设定了GB2312编码，依然无效，然后改为UTF-8，乱码问题解决。推测是vim编辑器本身的编码就是用UTF-8，所以设置html为GB2312并无效果？毕竟在本地直接编写GB2312是没有乱码问题的(—TODO)。然后再新增一个my.html，外网依然能通过改路径访问。Apache的配置和连通性测试到此结束。</p>
<hr>
<p><strong>总结：</strong></p>
<p>1.第一种方法主要是，下载源码包以及相应的依赖包，然后分别进行解压，配置，编译，安装。最关键的是要指定依赖包，因此必须按照顺序，先安装没有其他依赖的包，即先PCRE，再APR,APR-Util，最后才是Apache。安装成功就是配置和启动Apache，配置是在httpd.conf中配置，启动是在bin目录下启动。</p>
<p>2.第二种方法，直接使用yum安装。yum就是自动化安装，它会自动帮你安装相应的依赖包，无须自己手动操作，即我们要安装httpd的时候，它也会自动把PCRE等也安装好了，无须像第一种方法一样，在安装httpd之前还要自己先安装PCRE等。网上的教程也都是说直接用yum list httpd，然后yum install httpd.x86_64就可以了。可是自己实际操作的时候，发现第一步yum list就没有找到相应的包，只有其他的版本，如Lighttpd(light httpd)轻量级的版本等等。也尝试过换镜像源（虽然觉得可能性不大，但还是尝试了一下），后来在镜像源的网站上是可以直接搜到httpd的，可是在Linux上却找不到。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/789.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/789.jpg" alt="阿里镜像源下搜索httpd"></a></p>
<p>继续尝试了一下，mysql，nginx等也是没有相应的包。按理说这些常用的，应该肯定存在包才对。最后查看yum命令的配置文件yum.conf，才发现它有一个exclude名单：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/777.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/777.jpg" alt="yum.conf的exclude名单"></a></p>
<p>可以看到都是最常用的几个服务，想了一下，肯定不是黑名单，那么作用应该是：避免平时误操作，在已经install了这些服务的情况下，又再次安装一次，把之前的数据给搞坏。所以解决方法并不是要修改这个conf，而是在yum的时候显式说明，使得exclude无效，即：<br><code>yum disableexcludes all install httpd</code><br>(当然，也可以修改yum.conf，安装完再改回去。。)</p>
<p>解决了这个问题之后，的确就直接安装成功。在后续的启动和配置服务的时候，也遇到了问题。不过猜想是和第一种方法安装的Apache起冲突了，也懒得如何共存了，直接用最暴力的方法解决：把第一种方法安装的Apache给卸载掉了，remake之后，第二种方法安装的Apache就能成功运动了~至此，两种方法安装Apache都成功。</p>
<p>最后的总结：yum安装的确方便很多，在安装之前先yum list找到相关的源码包，或者直接到镜像源的官网去查找，作用都是一样的。总的来说yum安装要方便简单一些，但手动安装可以自己定制修改源码等等，那个就是更高级的层面了，暂时不考虑。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建记录</title>
    <url>/Hexo%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        Hexo是一个很流行的博客框架。之前一直想构建一个博客，也花费过很多功夫。其实一开始是想着完全自己从零实现，不使用框架，主要是为了学习一遍web开发。很可惜，到了后面愈发感觉力不从心。不套用博客框架自己实现，确实自由度非常广，可是要用到的知识也非常的多。对于后端，我用的是SSM+Redis，前端用的是Bootstrap和jQuery。最后让我放弃的是前端原因，我感觉自己对前端仅限于读懂，或者写一些简单的界面，或者是在别人的界面上进行修改。在找前端模板的过程中，我就想着不如试试Hexo吧，反正学习目的已经达到了，于是记录一下Hexo搭建博客的过程遇到的问题。<strong><em>这里使用的hexo版本是：4.2.0</em></strong></p>
<a id="more"></a>

<h3 id="如何使用Hexo"><a href="#如何使用Hexo" class="headerlink" title="如何使用Hexo"></a>如何使用Hexo</h3><p>​        不同的博客框架有利有弊，如果是新手就直接选Hexo吧，不要去考虑Wordpress，Hugo等等的了，那些以后再慢慢接触，现在Hexo就足够用了！于是我参考了一个<strong><em><a href="http://fanzhenyu.cn/2016/11/30/Github%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">博客</a></em></strong>，大概的步骤都是完全按照它的，所以也无须再照搬一次了。</p>
<h3 id="构建Hexo的过程遇到的问题"><a href="#构建Hexo的过程遇到的问题" class="headerlink" title="构建Hexo的过程遇到的问题"></a>构建Hexo的过程遇到的问题</h3><p>​        只要是上网学过教程的朋友，或者是看书的朋友，都肯定会遇到一个问题：跟着书上/文章上的去做，却发现出错。导致的原因一般有，自己忽略了步骤，版本的变更。无论如何，这些才是学习中最大的困难，所以这篇文章就是记录我在构建Hexo博客的过程中所遇到的问题，以及如何解决。</p>
<h4 id="①-注册GitHub，使用GitHub-Page。本地安装Git，配置好环境变量，本地Git与Github连接。在Git-bash中安装node-js和hexo及其依赖文件。将本地hexo项目托管到GitHub"><a href="#①-注册GitHub，使用GitHub-Page。本地安装Git，配置好环境变量，本地Git与Github连接。在Git-bash中安装node-js和hexo及其依赖文件。将本地hexo项目托管到GitHub" class="headerlink" title="① 注册GitHub，使用GitHub Page。本地安装Git，配置好环境变量，本地Git与Github连接。在Git bash中安装node.js和hexo及其依赖文件。将本地hexo项目托管到GitHub"></a>① 注册GitHub，使用GitHub Page。本地安装Git，配置好环境变量，本地Git与Github连接。在Git bash中安装node.js和hexo及其依赖文件。将本地hexo项目托管到GitHub</h4><p>​        一般程序员都有GitHub，所以前面的步骤基本都可以忽略掉。直到安装hexo的时候，这时候原文有提到需要初始化hexo：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ hexo init hexo</span><br></pre></td></tr></table></figure>

<p>这里就出现了问题，显示：<em>bash: hexo command not found</em>。显然，没有找到hexo命令。对于此类错误，一般有两种可能。第一种可能的错误是没有安装hexo，于是再三确定了一下前面的安装代码是否出错，并没有，基本可以排除。第二种可能的错误是环境变量的设置问题。我们都知道只有把命令设置到环境变量里才可以直接在命令行里调用，或者就是安装的时候安装系统自动添加到了环境变量，只有这样才可以直接使用。于是我们到环境变量里添加hexo的安装路径：F:\XXX\node_modules\.bin    问题解决。</p>
<p>​    除此之外，如果yml配置文件出错（一般是格式错误，记住yml的冒号需要用英文格式，以及冒号后面要加空格即可），那么启动hexo会失败，导致无法访问主页。这时候就要具体地看一下启动的时候的报错信息去检查。</p>
<p>​    只要完成教程一，那么最简陋的hexo就搭建成功了，后续就是完善。</p>
<h4 id="②-全局配置文件的设置，主题配置文件的设置。设置图片，设置菜单，添加几个菜单页面，发布文章。"><a href="#②-全局配置文件的设置，主题配置文件的设置。设置图片，设置菜单，添加几个菜单页面，发布文章。" class="headerlink" title="② 全局配置文件的设置，主题配置文件的设置。设置图片，设置菜单，添加几个菜单页面，发布文章。"></a>② 全局配置文件的设置，主题配置文件的设置。设置图片，设置菜单，添加几个菜单页面，发布文章。</h4><p>​        配置文件处都没什么问题。图片那里值得一提的是，默认的图片路径是 hexo/source/下。而菜单页面看起来也是调用命令hexo new page xxx即可自动生成，在对应的路径下就能看到一个index.md（部署到GitHub的时候会变成index.html）。可是无法访问，一直报错，<strong>Cannot GET /about/%20/</strong>。这里的关键是%20，这是空格的意思！知道了这个，就很容易排查了，问题出在配置文件里。虽然它提供了默认代码，但它的||前后加了空格，导致出错。所以虽然这是默认代码，但我们还是老老实实把它的错误改了吧：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/||home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/||user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/||tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/||th</span></span><br><span class="line">  <span class="comment"># archives: /archives/ || archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment"># sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>

<p>​        这时候一般是可以运行了的，如果还是不行，那么可能是因为你复制了上面教程作者的md文字？可能是由于版本的不同，教程作者的index.md的第一行是：”—“，如果你也跟着加了，那么就是画蛇添足了。我这里用的是Typora，只要在那条虚线下面开始写你的页面内容即可（上面的都是格式配置，一般不会直接显示出来）。于是，这里的问题也解决了。发布文章也是同理。</p>
<p>​        完成教程二，对于博客的关键功能：发布文章，分类查找等等，都已经可以实现，后续可以继续添加更多有趣的功能。</p>
<h4 id="③教程三"><a href="#③教程三" class="headerlink" title="③教程三"></a>③教程三</h4><p>​        教程三是教我们使用外部图床存储图片，添加了一个评论功能，以及文章浏览量，网站访问量，站内搜索等等。这里我个人只建议看浏览量和站内搜索。因为外部图床，其实新手暂时没必要，等到你觉得性能需要提高的时候才考虑，先把网站搭起来吧（其实直接用腾讯云COS就可以做图床了）。。至于评论功能，这个评论功能是过时的，不建议使用。</p>
<p>​        浏览量这里也存在问题，开启了之后只有图标，没有显示具体数据，这是因为hexo next主题中不蒜子脚本链接失效，这时候需要编辑：<strong>/themes/next/layout/_third-party/analytics/busuanzi-counter.swig</strong> 文件，将里面的链接：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js</span></span><br></pre></td></tr></table></figure>

<p>改成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js</span></span><br></pre></td></tr></table></figure>

<p>​        这时候就能看到统计的数据量了。</p>
<p>​        对于站内搜索功能，设置了全局配置文件，发现仍然没有搜索功能，这是因为我们还需要一个步骤，在主题配置文件里找到 <strong>local_search</strong>。显然，还需要把enable的false值：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h4 id="④-添加功能模块"><a href="#④-添加功能模块" class="headerlink" title="④ 添加功能模块"></a>④ 添加功能模块</h4><p>​        教程四的内容我直接跳过了，感觉意义不是很大，但评论功能还是比较有用的，于是直接研究评论功能。一开始按照教程来使用Gitment，无论怎么样都显示Error： Not Found。原因竟然是。。Gitment已经过时了，大概是作者也不维护了，服务器也过期了等等，所以大家跳车吧，转战<strong>Gittalk</strong>。这里的使用的教程是<strong><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">这个</a></strong>。</p>
<p>​        Gitalk中值得注意的问题是：</p>
<p>​            Ⅰ. <strong>comments.swig</strong>处添加一个elseif，这里要注意elseif添加的位置，要与前面的elseif同一级别，自己细心看一下就知道要添加在哪里了，不要添加在endif后面。。</p>
<p>​            Ⅱ. 最常见的错误，<strong>Error: Not Found</strong>。在Gitment就是因为这个而弃坑的，可是在Gitalk依然遇到了这个情况。这里的错误点在于：repo的位置出错。这里的repo值必须是： xxx.github.io，而不能写 <a href="https://github.com/Xxx/xxx.github.io" target="_blank" rel="noopener">https://github.com/Xxx/xxx.github.io</a></p>
<p>​            解决了这两个问题，只要把项目部署到GitHub上，就能成功运行了。至此，hexo搭建基本结束，重要的功能都涵盖了，后续还能进行更多的补充。</p>
<h4 id="⑤-一些其他可能会出现的错误"><a href="#⑤-一些其他可能会出现的错误" class="headerlink" title="⑤ 一些其他可能会出现的错误"></a>⑤ 一些其他可能会出现的错误</h4><p>​        即使是像本人的专业踩坑者，也不可能把所有的坑踩完（否则我应该去应聘测试！）。所以这里只能列举一些我本人遇到的错误，以及如何解决。</p>
<p>​        在关闭hexo server的时候，应该使用ctrl + c，不小心按成了ctrl + z，也就是挂起，导致后续再启动会显示端口占用。这属于Linux的基本命令问题。本来想通过ps，kill等等的命令去解决的，可是都不行。最后使用的是jobs命令。jobs命令可以查找job号（假设为num），这时候我们执行 <strong>stop %num</strong>  ，即可解决。</p>
<p>​        踩完坑在本地修改完，发现打开网址还是没有改变？这个问题很多web开发者应该都曾经遇到，其实最简单的原因就是缓存的原因，浏览器直接读取了缓存的东西，导致服务器新改的东西并没有生效，这时候只需要：<strong>ctrl + F5</strong>，浏览器刷新，可能你就会发现有所改变了，避免了多做无用功。。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>centos环境配置记录</title>
    <url>/centos%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<p>（Tomcat + MySQL + Redis的配置，以及连通性测试）</p>
<p>写在前面:<br>其实大概半年前就已经配置好了Tomcat跟MySQL，项目也部署好了，能够正常的运行。但自从8月底的时候加上了redis，就开始出现了问题。从那时候开始，服务器的CPU一直停留在100，似乎是MySQL与Redis之间出现了冲突。但我当时装了好了Redis，大概只是简单学习了几天就搁置了，所以等到我意识到服务器出现问题的时候，已经是9月下旬的时候了。（中途域名拿去网站备案了，所以项目也是一直搁置的。但中途在研究MySQL的锁机制的时候，确实已经觉得服务器出现了问题，时不时会掉线）对于问题的排查，持续了一整天都没有解决，使用TOP命令，会发现CPU idle space是0，要么是0，要么是100，两个数字之间刷新，但下面的所有进程，就没有CPU超过5%的进程。除了top，诸如netstat，vmstat，df -h，uptime，等等的各种命令都尝试过了，还是没有找出问题。倒是发现在/var/crash中出现了高达25G的系统崩溃碎片，删除了也未果。甚至，一怒之下把这个基础的服务器升级了（1核2G，直接升级为4核8G），结果还是显示100。。说实话，我就那么一个项目，能够把这种升级后的配置也用到CPU100，唯一的可能也只是出现了deadlock了吧。但我排查了许久都失败了，服务器上的数据库也崩溃了无法访问，而且我对于数据库也没有备份的习惯（以后一定要对数据库进行定时备份）。导致只好先对这个出了问题的系统进行snapshot，等待以后需要那部分数据，或者有时间的时候，再回去排查问题吧，至少也要把那部分数据拿回来。<br>然后呢，就是直接把系统重装了，那么就需要重新配置一遍环境。其实因为之前配置这三个的时候都比较轻松，所以心里觉得应该很快能解决的。但没想到遇到了各种各样的问题，所以这次把整个成功的配置过程都写出来记录，包括中间出现了错误如何解决等等。</p>
<a id="more"></a>

<p>最后，在不同的系统之间，在不同的软件安装包之间，都存在差异，而这种差异可能会导致安装的时候也会面临不同的问题，所以仅供参考本文列出的服务器系统版本，以及安装包的版本。<br>本文的主要内容：安装Tomcat，MySQL，Redis的过程，本地连接访问Tomcat，MySQL，Redis的过程。Spring项目整合MySQL并发布的过程（Redis目前只做了连通性测试，还没有整个到项目中)<br>服务器系统版本：CentOS 7.6 64位</p>
<p><strong>step1：服务器安装Tomcat并在本地执行连通性测试</strong><br>这一步其实很简单，但我当中出现了一个比较stupid的错误，导致也卡了很久。总的步骤也很简单：到官网下载RPM包，解压，进入bin目录执行startup.sh即可启动Tomcat，然后在本地进行连通性测试（也就是打开xxx.xxx.xx.xx:8080看是否会出现初始页面而已）。<br>安装完了之后，我还想把tomcat放到Linux的系统服务中（也就是把tomcat的启动脚本拷贝一份放到/etc/init.d/中，然后进行一系列操作诸如chkconfig命令等等），但我尝试过了之后失败了，想想其实服务器也很少关闭，而且只要记住Tomcat的路径就好，我的是放在/usr/local/tomcat下，想处理的时候直接进去该目录执行相关的.sh脚本就好。于是这部分pass。<br>然后连通性分析，第一次的时候就失败了。然后网上都说开通端口，防火墙配置等等的就好，这部分也不难，很快就解决了，在本地也成功看到了Tomcat的初始页面。<br>接下来关键的点就来了，我把本地的war项目复制到了webapps文件夹下，然后关闭tomcat之后重新执行，发现连初始页面都看不到了。当时可能比较晚了，所以我也没想清楚，通过netstat，ps等命令发现tomcat的关闭，开启都存在问题，于是觉得可能还是端口的问题等等的。通过了一顿蜜汁操作之后还是无法访问。当时都怀疑人生了（为什么刚刚还能访问初始页面，突然就不行了？沃不服！）然后到了第二天再redo一次才顿悟，应该是war出现了问题，所以tomcat的开启跟关闭出现了错误，然后才导致了初始页面也无法访问的情况（因为之前的war一直是可以访问的，所以也没考虑这一点）。所以我把webapps下的war给删掉了，包括war解压后的文件夹，再restart一次tomcat，发现确实就可以访问初始页面了。所以：如果tomcat可以正常开启，但加入了错误的war之后，是会导致tomcat也出错的（我开始以为应该是其他项目会可用，只有该自定义war不可用才对，但事情并不是如此）。出错原因也很显然，服务器重装了，MySQL也没了，那么项目指向了MySQL就无法访问了，自然也就全部出错了。所以我得先把MySQL安装好，然后再在本地的项目连通数据库，到时候再进行打包，放置到webapps下，应该就可以成功运行了。</p>
<hr>
<p><strong>step2：服务器安装MySQL并且在本地执行连通性分析</strong><br>我是参照这一篇文章来执行的：<a href="https://blog.csdn.net/u013541411/article/details/89516575" target="_blank" rel="noopener">https://blog.csdn.net/u013541411/article/details/89516575</a><br>其实安装MySQL应该也是一个很简单的流程，但因为第一天的时候，被Tomcat的错误搞到不明所以，还以为是MySQL的问题，也进行了很多无用的排查。所以问题的定位也是非常的关键。<br>但还好这篇文章确实还是可行的，除了在安装server的时候其实还要安装一个其他的软件，但问题不大。错误信息CV一下，答案就出来了。<br>然后本地连通性，排查了好久都不行，最后才发现，是服务器的安全组没有开通3306端口号。第一天的时候很轻松就连通了，因为当时还没有设置安全组。之后安全组设置了开放3306端口号之后就成功了连通。然后对项目执行了连通性测试，也是可行的。再打包，放置到webapps，成功执行。</p>
<hr>
<p><strong>step3：服务器安装Redis并且在本地执行连通性分析</strong><br>参照文章：<a href="https://www.cnblogs.com/zuidongfeng/p/8032505.html" target="_blank" rel="noopener">https://www.cnblogs.com/zuidongfeng/p/8032505.html</a><br>这篇文章是确实可行的，唯一要注意的点是，它的当前目录并不是root，而且存在变化，要看清楚。比如第一条命令是在/usr/local下执行的，如果在root下执行，还得对tar指定解压路径。<br>关于安装到系统服务：第一次的时候我是在root下面tar的，导致有点乱。于是我删掉了重来，第二次在usr/local下开始执行，最后一步差点就成功了。在使用systemctl status redisd查看的时候，发现状态是active(exited)，这种其实有点贼，虽然算是启动成功，但其实跟失败没有区别，所以千万不要看到绿色就觉得是no problems。当然了，在status下面可以看到错误信息：<br><code>/var/run/redis_6379.pid exists, process is already running or crashed</code><br>这个的原因是，如果redis没有正确的关闭（比如直接rm -rf，kill -9等等），那么该文件还是会存在的，导致第二次执行的时候就会出错。这时候要做的也是很简单，先stop/kill等等，再删掉：<br><code>rm -rf /var/run/redis_6379.pid</code><br>然后再start，执行status查看，状态改成了active（running），看来是成功执行了，那么使用redis-cli测试一下，确实可行。<br>接下来对redis增加密码，也是出错了许久。其实添加密码都不难，但是在restart / stop, start的时候都出现了问题。无论是restart还是stop，命令都会卡住，只能ctrl + C。那么显然，就是Redis没有正确关闭了，于是就又会出现上面的问题，又要再rm一次。关键是再次成功启动，发现密码还是没有。仔细一想才明白，上面那篇文章，conf文件并不是redis文件夹下的conf，而是拷贝了一个副本，存到了/etc/redis中，名为6379.conf，所以我们需要改的是6379.conf的内容，也不是Redis文件夹下的redis.conf。改了之后，确实就成功添加了密码。而且还有一点很关键，添加了密码之后，Redis的关闭是存在问题的。比如之前没有密码，直接systemctl stop redisd即可，而有了密码就不能直接这样。这时候我们需要先进入redis-cli，auth（已经有了密码），然后执行：shutdown。在redis-cli里关闭Redis连接，然后quit回到命令行，最后再执行systemctl stop redisd。这时候我们就能成功地退出，然后start也可以成功执行，密码也成功添加了。（退出redisd服务前先进入redis-cli执行shutdown）<br>(或者直接： redis-cli shutdown)<br>最后是连通性分析，也是折腾了许久。首先是给安全组增加6379端口，还有各种防火墙配置，开放端口等等，发现都不行。最后是参考这篇文章的第二点：<a href="https://www.jianshu.com/p/2fa4622fc1d3" target="_blank" rel="noopener">https://www.jianshu.com/p/2fa4622fc1d3</a><br>在配置文件里，默认只能本地访问（127.0.0.1）,把该行注释掉，就成功连通了。</p>
<p>直到这里，三个服务都成功配置，并且能够连通。</p>
<hr>
<p><strong>step4: URL路径简化</strong><br>其实主要就是tomcat的配置文件罢了。之前一直偷懒，感觉能这样就这样，直到今天一定要改，才去花时间搞好了。所幸也不难，估计也就花了一个小时，但还是记录一下。<br>首先就是端口号，web一般默认都是80端口，直接把项目的端口号改为80，就不需要端口了。当然，应该是可以换端口号，然后设置其他默认端口号的，懒得深究。<br>接着就是省略项目名，其实对于docBase跟appBase我还是不太懂，目前来看，大概就是。appBase就是项目解压的路径，也就是tomcat就是从这里面寻找项目的。然后docBase就是我们想要的，增加了一个Context标签，附上docBase属性，就使得默认项目是webapps/xxx，而不是webapps<br>最后就是默认的主页，其实我也知道是welcome-list，可是有点奇怪的是，我在最上面写了我的目的网址，可他还是优先访问最下面的index.jsp。不是很懂这个优先级，最后直接索性把下面的全部注释掉，只留下我的mainPage.html。然后也成功了，最后，只需要输入自己的域名，就能直接进入我的网站主页。</p>
<hr>
<p>总结：最关键的还是要懂得原理。处理Redis问题的时候显然比前两者快，因为真的动脑子了。<br>一开始修改了redis.conf，发现redis-cli里根本没有改变密码，然后联想到启动redis的脚本（也就是拷贝到/etc/init.d/的redisd脚本），原本应该是要指定配置参数的，但并不需要，应该是直接写到了代码里。于是查看了一下脚本的代码，才意识到，代码里的conf并不是redis.conf，然后就修改了正确的conf文件。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
</search>
