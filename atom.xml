<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hong&#39;s Blog</title>
  
  <subtitle>Like life,like coding</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hongscar.cn/"/>
  <updated>2020-02-18T07:15:51.058Z</updated>
  <id>https://hongscar.cn/</id>
  
  <author>
    <name>Hong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大学流水账</title>
    <link href="https://hongscar.cn/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E6%80%BB%E7%BB%93.html"/>
    <id>https://hongscar.cn/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E6%80%BB%E7%BB%93.html</id>
    <published>2020-02-18T03:57:36.000Z</published>
    <updated>2020-02-18T07:15:51.058Z</updated>
    
    <content type="html"><![CDATA[<p>​     时光荏苒，大学毕业的瞬间，给我的感觉便只有四个字，恍如隔世。毕业已经有一段时间，其实答辩结束的时候就已经可以开始写这篇总结，但还是各种因素，迟迟未能动手，最终还是拖到了今天。无论如何，习惯总结的我，对于大学毕业这么一个里程碑，肯定是不能错过的。而且自己的大学，真的有太多的话想说，这篇总结会好好地回顾了我四年的大学生活，自我评价，当然还有未来的展望。</p><a id="more"></a><p>​     我很想把大学，再一次地拿去和高中比较一番，因为高中给我留下了很多深刻的经历，而大学也一样，这两段经历又给了我截然不同的感受。高中时代的很多记忆碎片我大抵都还记得，只是没有必要在这里仔细述说。印象中高中三年的我，基本就是一直坐在课室，坚持走着课室饭堂宿舍的三点一线，偶尔参加一些小活动而已。当时的我大概是自然而然的，而高中毕业之后才发现那个能一直专注的愣头青般的我已经渐渐远去。当时的自己也没有太多的迷茫，大概只有对大学的憧憬，因此即使高中有很多遗憾，我还是很快就投入到大学生活中去。到了大学，再也没有人管，感觉自己一下子变得很自由。即便是上课，也不是固定的课室固定的座位，衣服也不必再穿校服。突然想到了大一最开始的时候，觉得一切都是那么的不可思议，甚至在有一次去课室的途中，心中感慨了一句，大学真的自由，自由真好啊！可惜这个自由的生活，我还是没有适应好。我大部分的时候还是宅在了宿舍，并且在宿舍也没有进行有效的学习。制定过不少的计划，基本都是开头坚持了几天就结束。这真的导致了我整个大学过得是很失败的。如果可以重来，那该多好呢？可惜，一切都没有重来。</p><p>​     大一的我还处于懵懂状态，上学期还保留有挺大的学习热情，只是制定了不少的学习计划却没有好好执行。大一没有什么专业课，只有一门C++。老师确实讲得很烂，但自己也努力得不够。还记得大一的寒假，我在家还在努力地学习C++，如果当时都再坚持一下就好了。大一下学期基本就是萎靡的一个学期，基本整个学期都在玩LOL。上学期积累下来的C++基础，优势也不复存在。下学期各种重要的知识，诸如继承，多态等等的东西，都没有学会，这也为后续放弃C++埋下了伏笔。还记得刚入学的时候还想过要转专业，最后也是在怠惰中放弃。倒不是说转专业是好是坏，但这肯定是一次奋斗的经历，就这么失去了其实也是有点可惜的。总的来说，大一就是迷糊，课程就是按部就班地完成，课余也尝试听了一些讲座，编程比赛的总结会等等。还记得那时候也有过豪言壮志，大学一定要参加一次比赛，不然大学不就浪费了么！回首，只剩下唏嘘。都说大一应该好好放松，不要太着急，其实这才是最大的骗局吧，有多少人就这么一直放松到毕业呢？还记得大一上学期，我就一直觉得自己太懒了，也不好好学习，心理上也一直强制自己去学习。所以也有过让自己早起去湖边读英语的经历，这也让我的四级考了很高的分数。只是这种那种的热情，在后面也慢慢地消散罢了。</p><p>​     大二，课程比较繁多。大二确实是很累的一年，因为要接触到很多的专业课，而且大都很重要。然而我基本也就是按部就班地完成了专业课的学习，并没有深入理解。考试成绩还挺好的，不仅没有挂科，而且大部分都是85分以上，我也是从那时候开始觉得自己比较适合考试的。其实大二的时候，相比大一的懵懂，自己也开始想得更多的事情。比如，我开始接触手机软件编程，又或者是web编程。大一的时候基本就是在玩，并且顺便学了一下c++，但大二的时候就开始觉得自己要接触一些实用性的东西，比如切实地投入到有意义的开发当中（手机/网页端的开发）。然后同样也是半途而废吧，没有坚持到最后。当时自我的批判是，看完了书，却没有自己切实地实践一下。比如我看完了一整本web开发的书籍，我应该跟着书上的例子来写一遍的，但我并没有，这使得我在后续再接触web的时候，跟没有学过web是没有太大区别的。如果是用高中的东西来类比，大概就是，看完了一章数学，却一道题也没有做，没有及时巩固？其实大二这一年，自己学习的时间是多了的，玩游戏的时间也少了。也可能是内容太多了，然后自己没有选择一个方面认真钻研，这也是导致失败的原因之一。比如数据结构大作业，一开始我想做一个爬虫软件，然后学习了一下爬虫，同样地也只是但当涉猎，没有深入。后来做一个管理系统，又想学qt，中途觉得困难又去研究了一下mfc，结果也是都没有好好掌握。操作系统和编译原理那种课程我倒是连想法都没有，可能是太难，因而都是做完作业便了事。下学期的专业课就更多了，而且甚至每一门都有实验课，导致印象中，3月开学，从4月开始便是每周至少3天要在实验室。大二下学期我也挺认真学的，数据库，离散数学，算法，UML我都有认真去学，不过同样地也只是完成课业的程度。比如数据库，当时仅仅是完成了老师给的实验，用sql server来进行数据的插删改查，然后就没有继续下去，也就是没有巩固。当时大概应该至少的，将自己大一的C++的大作业进行改进，比如数据从本地存储，改为数据库存储。这样在后续的数据库操作中印象都会更加深刻。同时还有很多种数据库也值得去深入学习，比如mysql，redis，MongoDB等等。大三的时候，有一次中学同学来学校找我聊天，说到他最近的一个项目用了三种数据库，因为他觉得这样可以分别利用不用数据库的优点，但面试官认为这样会使得程序太过臃肿。当时我比较感慨的一点就是，数据库对于计算机软件的必不可缺的，然而当时的我只掌握了mysql（sql server已经被我搁置了）。就觉得自己很多东西都学了，却没学精，然后该学的也没有学，大概是我自己也没有静下来想自己应该学哪些东西？或者是哪些东西重要性很高，最好就应该去学？同样的，算法也只是看懂了考试题，也没有说去OJ刷题，也没有想过在自己写的程序里用算法优化。还有OS，一直说要学习一下linux，同样也只是完成了实验课便结束了。总而言之，大二下学期就这么按部就班地过去了，不能说没有认真学习，每门专业课都能达到学校的要求（不仅仅是及格），但就是没有进一步的自我思考自我反馈。而且看到成绩挺好的时候还会有膨胀感，自己对大学考试的套路模式也渐渐了如指掌，考试真的就是填表放假般的轻松了，但这种膨胀感显然没有让我感觉到危机感。不过，大二下的自己还遇到了其他的问题，所以当时能坚持下来已经算是不错的结果。大二的自己感觉学了挺多东西，打算暑假巩固一波，也就是切实地去写点手机软件，网页等。然后被家里赶去学车了，整个暑假基本也就在驾校渡过，因此大二就这么结束了。</p><p>​     大三，其实是最难过的一年。刚开学就说要分方向，然而自己前面埋下的隐患，自己对所有专业课都只是能够考好试的水平，然后自己课外学习的东西也没有学得比较好。反复再三，就报了数字媒体和手机开发。数字媒体是自己直觉上应该是最感兴趣的方向，而手机开发和数字媒体是互相选择的，因此就选了两个方向。然而第一节课就让我产生了挫败感，老师第一节课讲的内容我就完全听不懂，讲了一堆什么小波分析，傅立叶变换。而且其实事先就知道数媒是最难的方向之一，当时跟室友都在犹豫要不要放弃换方向，但最后还是没有换。然后就开始了一个学期的数媒煎熬时期。我现在还清楚地记得，数媒一共两门课，一门就叫数字媒体，一门叫计算机图形学。计算机图形学要求一个大作业，而数媒要求4个大作业。而且事后我觉得，每一个数媒大作业的难度都比图形学的要难。也不知道是不是老师的问题，还是这个方向的确要学的东西太多太难。第一个大作业，我和两个同学钻研了两个星期，竟然连其中的一个功能都实现不出来。我还记得要求是做一个图形处理软件，可以选择一个图片，然后点按钮就可以进行相应的图片操作，比如旋转，放大缩小，降噪等等。反正有很多功能，底层都是对图片的像素点，通过算法进行处理。总而言之，我们三个人从头到尾就一直卡在了旋转这一部分。后来，后面的一些功能倒是可以实现出来，只是实现的方式有点stupid，但旋转最终实现的效果还是不尽人意。更恐怖的是，第一个大作业还没完成，第二个大作业就来了。第二个大作业好像是研究GPU对图形处理的效率等等，然后学习什么CUDA。然后当时我们三个稍微了解了一下，就回去继续做第一个大作业。当时其实已经都第二个大作业了，但看到同学，见面还是调侃，“你今天旋转了吗？”。之后，第二个大作业没过两个星期，老师就布置下来第三个大作业，自己制作一个视频，情节场景等都是自己设计。这个制作视频并不是所谓的用手机拍下来然后对视频处理，而是完完全全地用代码来生成。首先就是用软件建模，构建出各种的物体，人物，设置场景，每个动作设定等等，然后再连接起来等等。这个的难度当时在我看来就比前两个大作业都要难得多了，横向对比一下图形学的大作业，图形学的大作业是要求建模，构建物体，然后构建场景，将物体布置在场景中，然后调整比例等等。构建物体当中还有很多细节我也忘记了，反正就是什么色彩，光照，渲染，设置光源等。最终的成果就是一个多彩的场景。这个其实工作量已经不多不少，而制作一个视频相当于就是制作一个场景的数十倍吧，而这仅仅是数媒的四个大作业之一。然后也就稍微学了一下unity3D和3ds，但想想那个工作量，还是望而却步。这个时候时间大概来到了11月，我觉得一整个学期都只学数媒，大概也是很累人的吧。然而大三还是有别的课程需要去搞的，软件架构，项目管理，安卓，ios开发，每一个都需要大作业。现在回想当时是真的煎熬，到底是如何熬过来的。图形学大作业也是teamwork，不过全部都是我一个人做的便是。临近寒假，数媒的第四个大作业也分发下来，看来是要我们寒假的时候好好把四个大作业都做了。第四个是将传感器连接到软件中，当时好像是用leapmotion。大致就是要我们开发一个游戏，可以用外接传感器来操控的。寒假的时候真的很短，反正转眼就开学，四个倒是都做完了，不过质量感人，我甚至答辩都不敢去了。我跟室友说，我不去了，挂科就挂科，这学期也不学数媒这个方向了，再也不想接触数媒老师。不过最后还是没有挂科，甚至不是最后一名。至此数媒噩梦到此结束，然后新的噩梦又到来，那便是找实习。找实习其实有一个很麻烦的点就是，我刚刚放弃了数媒，却又要找实习，那么数媒的影响到底有多大呢？大二上学期的时候学了java，当时就开始放弃了c++，决定将java当作主语言。而数媒是要用c/c++/c#这种语言的，然后大三上的时候基本都是在写c++，但现在找实习，又不是找数媒相关的，c++又难。于是我便又要重新把java捡了回来，并且是搁置了半年的情况下。大三上的课程对于找实习的重要性实在太高，选了web方向的同学，对于java web的知识又了解，大作业中又有锻炼，而我这种重新来的，甚至需要复习一遍java，然后再重学web，然后学各种诸如ssh的框架等。错过了最佳的找实习时间段，然后就要兼顾学校的课程压力。最终搞完一个麻烦的手机开发实训便结束了大三。</p><p>​     大四，大学的最后一年。找实习找得太久，当中也想过很多事情。我也是事后才发现，自己整个大学一直就在错过。大一其实是最该好好放松的一年，同时也应该大一就大致想一下整个大学的路。结果我大一只有无所事事的上学期还有沉迷游戏的下学期。大二其实应该要具体地掌握些什么，事实上我也开始学了，然而并没有深入，使得大二真的只能用按部就班来形容。大三分方向，真的应该提前就了解好，如果我提前了解多一点数媒，读一下数媒的课本，知道他真的这么难，也许我就换了一个更值得的方向，大三下找实习的时候也就不至于因为掌握得不够好而没有找到好实习。因为学的方面挺多，却没有学精，唯一一个花了很久时间钻研的方向，最终还是不敢继续下去而放弃。大三刚开始的时候，我还有很多突然心血来潮般的想法。比如如果当初没有学软件就好了，还不如直接选个数学靠谱（因为自己大二对离散数学也很喜欢）。比如大学还是应该多学点东西啊，比如考点什么证，结果自己还是只稍微涉猎。又比如突然觉得出国真的很好啊，如果早一点想到这些，大一的时候就更努力一点去提一下绩点了。感觉自己整个大学，没有很好的规划。最终还是找到了一个不错的实习，虽然并没有学到太多东西，但也是第一次社会经历。也是因为没学到太多东西，感觉自己的大学太遗憾了，于是希望毕设能改变自己，学到东西，然后选择了区块链为题目。我也不可以说没学到东西，只是这东西真的挺烦人的，使得我毕设虽然没太多体力活，但还是耗到了最后一刻。中间也想过很多事情，最终决定了考研，于是也就安心地放下了找工作的念头，然后准备毕设的事情。毕设结束前夕，一直在为毕设而烦恼。然而毕设结束的那一刻，每个人都会有一个念头，“啊，这样就毕业了吗？”是的，毕设这门大学最后一课，就这么结束了。答辩完的那天是6月8号，正好是高考的最后一天。我还记得那天早上早早地就出发，一路上狂风暴雨，去到课室的时候，裤子都快要湿到膝盖那里了，更不用说鞋子。那几天刮台风，似乎从小到大，我从来没有见过这么大的台风。答辩完的时候已经是下午2点，我原本想回宿舍睡觉，但发现并不能睡着，结果只是在床上小憩了10来分钟便下床。我走到阳台看着外面的狂风暴雨，心境在渐渐地变化。我很想回家，但又不想回家。答辩完到离校的这段日子，是我在学校里最无所事事的一段时光。我每天习惯地打开电脑，但发现什么都不想做，只是看一下论坛，看一下直播，等待吃饭的时间，和交心的朋友一起去饭堂吃饭。大学毕业的伤感远远超出我的想象，那是高中的时候完全无法体会到的情绪。我很喜欢在微博上发一些感慨，并不是想给谁看，我只想给我自己看。离别的日子匆匆而来，然而校园里依旧那么宁静。在华工的最后一个晚上，我们宿舍三个人都不约而同地失眠。第二天似乎还是和往常一样，看直播，吃饭，只是下午多了个拿毕业证的事情。然后我们就各奔东西，有人没有感觉，有人悲痛欲绝，有人还在等待释怀，但我们都不能回头。我走的时候宿舍只剩下一个人了，室友说要送我到楼下，我说不用了。他静静地站在门口看着我离开，而我不敢回头，就这么离开。最后跟我大学最重要的朋友在地铁里分别，带着信物，我终究还是回到了家，于是，大四也就这么结束了。</p><p>​     四年的大学生活转瞬即逝，回顾了一整遍，感觉也没有想象中的混，但最终的结果自己肯定是不太满意。比如从大一的时候没有制定好整个大学的基本规划，对于考研出国考公务员等事情，我都是后知后觉，没有事先考虑好，以至于错过了最好的时机。对于学习，也没有很好的规划，没有确定好自己的方向，导致大学似乎学了很多，但又没有深入，然后又好像什么都没有学过。对于做人，我曾经试过无数次想要改变自己的性格，比如内向型人格的我，总是被教导要开朗外向一点，而我也想过很多次要变得开朗，但最后我才发现，做我自己就好，没必要为了谁而改变什么。其实我在大学里，真的变了很多，至少我自己是这么觉得的。我觉得我的大学，似乎也没有那么的不堪，继续向前就好。</p><p>​     当然，大学里也养成了很多坏习惯，比如拖延症，作息不规律，做事拖拉，不能坚持等，希望早点成为更好的自己吧。这就是我的大学。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​     时光荏苒，大学毕业的瞬间，给我的感觉便只有四个字，恍如隔世。毕业已经有一段时间，其实答辩结束的时候就已经可以开始写这篇总结，但还是各种因素，迟迟未能动手，最终还是拖到了今天。无论如何，习惯总结的我，对于大学毕业这么一个里程碑，肯定是不能错过的。而且自己的大学，真的有太多的话想说，这篇总结会好好地回顾了我四年的大学生活，自我评价，当然还有未来的展望。&lt;/p&gt;
    
    </summary>
    
    
      <category term="life" scheme="https://hongscar.cn/categories/life/"/>
    
    
      <category term="life" scheme="https://hongscar.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud笔记(二)</title>
    <link href="https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%BA%8C.html"/>
    <id>https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%BA%8C.html</id>
    <published>2020-02-18T03:29:39.000Z</published>
    <updated>2020-02-18T08:18:39.252Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​        上一部分对Spring Boot跟Spring Cloud有了基本的认识，同时也添加了Eureka注册中心，使得最基本的服务注册，服务发现都可以实现。但这肯定不够，所以这里继续补充关于Spring Cloud的知识。</p><a id="more"></a><h3 id="二-添加Ribbon实现负载均衡"><a href="#二-添加Ribbon实现负载均衡" class="headerlink" title="二. 添加Ribbon实现负载均衡"></a>二. 添加Ribbon实现负载均衡</h3><p>关键点：当Client可以用Eureka Server定位到多个服务列表，应该选择哪一个？比如这里的例子，我们启动两个Provider，注册到Eureka Server上。此时Consumer去调用Provider（不再直接调用某一IP，端口，而是符合的服务列表，在这里只要是Provider服务即可）。此时我们需要实现负载均衡，避免某一个Provider服务过载，导致出错。</p><p>步骤：</p><p>先引入依赖，Ribbon。据说引入了spring-cloud-starter-netflix-eureka-client就可以，因为client已经包含了Ribbon，但我前面不需要引入client也可以实现，所以这里直接引用Ribbon，应该引用Client也行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（单独取其一即可）</p><p>然后给RestTemplate添加一个@LoadBalanced注解，表明该RestTemplate要使用负载均衡算法（这里当然就是直接默认的负载均衡算法，具体的参数配置后面再说）值得一提的是，@LoadBalanced只能用于setter方法处，所以是不能在构造方法上使用该注解的。</p><p>然后改了一下Controller，主要是增加了一个LoadBalancerClient，还有RestTemplate的获取地址不再是硬耦合IP+端口，而是具体的服务名即可。同时还增加了一个log-user-instance，但这个主要是用于记录日志，方便观察到底是哪个Provider被调用了，所以这个并不是关键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MovieController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieController</span><span class="params">(DiscoveryClient discoveryClient, LoadBalancerClient lbc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.discoveryClient = discoveryClient;</span><br><span class="line">        <span class="keyword">this</span>.loadBalancerClient = lbc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，RestTemplate不能改成构造注入，否则加不了@LoadBalanced。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://microservice-provider-user/"</span>) + id, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user-instance"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ServiceInstance&gt; <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> discoveryClient.getInstances(<span class="string">"microservice-simple-provider-user"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/log-user-instance"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logUserInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="string">"microservice-simple-provider-user"</span>);</span><br><span class="line">    MovieController.LOGGER.info(<span class="string">"&#123;&#125;:&#123;&#125;:&#123;&#125;"</span>, serviceInstance.getServiceId(),</span><br><span class="line">                               serviceInstance.getHost(), serviceInstance.getPort());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getForObject里原本是直接写上了IP+端口的，成为了具体的服务名即可。而user-instance是上一章的遗留问题，当时没能查看到这个网页，原来是忘记写GetMapping了。最后一个log-user-instance就是拿来记录日志的，不用管。</p><p>然后测试，先启动Eureka，再启动两个Provider（先启动一个，修改yml里的端口号再启动一个。这样就相当于通过两个端口启动了两个Provider。当然这有点蠢，如何在不修改配置的情况下启动多个？<a href="https://blog.csdn.net/forezp/article/details/76408139" target="_blank" rel="noopener">https://blog.csdn.net/forezp/article/details/76408139</a></p><p>最后启动Consumer，这时候调用localhost:8010/user-instance等等的都是可行的，但在调用localhost:8010/user/1 的时候出现了问题，表示找不到该hostname：</p><p><strong><em>I/O error on GET request for “<a href="http://user-service/hi&quot;" target="_blank" rel="noopener">http://user-service/hi&quot;</a>: user-service; nested exception is java.net.UnknownHostException: microservice-provider-user</em></strong></p><p>显然，就是调用/user/{id}的时候，下面的getForObject找不到那个host。找了很多解决方法，比如是不是hostname写错了，但其实这个逻辑并不通。因为user-instance都可行了，说明确实就是这个hostname。然后网上说要导入client包，导了也不行。接着又想是不是不能同时使用构造注入跟设值注入？发现也不是，看我上面的代码，就是同时使用两种注入方式。</p><p>最后的解决方法是一个我很早就看到了的错误，需要加入@LoadBalanced注解。这个参数我当然知道有何作用，而且我第一时间就加了，错在哪？因为我最后才发现，我在Application启动类就已经注入了RestTemplate，然后我改Ribbon的时候是在Controller里再注入一次RestTemplate，然后@LoadBalanced等等都是在Controller里进行的。所以，由于先启动的肯定是Application启动类，这时候就已经进行了@RestTemplate的注入操作了，后面在Controller里的其实已经是废设，自然那个@LoadBalanced也是没有任何效果的。于是我把Controller里的RestTemplate去掉了注入，在Application启动类里的注入增加了@LoadBalanced，就成功了。然后再测试了一下把Application启动类的注入彻底去掉，在Controller里重新加回注入跟@LoadBalanced，也成功。</p><p>负载的效果可能不是很明显，因为我测试的方式比较stupid，就是一次一次调用，看是不是轮流调用两个Provider，确实如此。当然肯定不是严格按照1：1的，在数据很大的时候应该会有小许偏差，但总体上比例就会是在1：1左右。</p><p>chapter5剩下的内容：Ribbon负载均衡的配置，包括Java类配置和属性配置（yml）两种方式。其中Java类需要注意不能放在@ComponentScan所能scan的包，不然就公用配置了。一般来说yml更简洁更方便。还有脱离Eureka使用Ribbon的方法（其实就是client包改成了ribbon，然后yml里增加一下ribbon的属性参数）。最后还有一个Lazy加载跟Hungry加载（即只要项目启动就加载，避免第一次调用时响应过慢）这些内容看起来都不难，而且现在不关键，就先不敲代码尝试了.</p><h3 id="三-使用Feign实现声明式的REST调用"><a href="#三-使用Feign实现声明式的REST调用" class="headerlink" title="三.  使用Feign实现声明式的REST调用"></a>三.  使用Feign实现声明式的REST调用</h3><p>使用Feign实现声明式的REST调用，并且配置REST的部分参数。</p><p>使用RestTemplate虽然已经可以满足所有功能，但比较繁琐（url高度耦合到每一个Mapping处，比如要写一遍Service名，多个参数的时候url会更加的臃肿）</p><p>使用Feign的好处：让编写Web Service客户端更加简单，因为它支持Spring MVC注解，JAX-RS注解，整合了Eureka，Ribbon。也就是说，只要使用Feign注解来替代，那么就能在实现Spring MVC的同时，也自动实现负载均衡。</p><p>使用步骤：</p><p>①添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>②创建一个Feign接口，添加@FeignClient（这个FeignClient，用于注入到Controller中，替代RestTemplate进行Restful API的映射设计，以及自动实现负载均衡）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"microservice-simple-provider-user"</span>,</span><br><span class="line">            configuration = &#123;FeignConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">FooConfiguration</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">UserFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestLine</span>(<span class="string">"GET /&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③注入到Controller中：（值得注意的是，由于是接口对象，那么就没办法实现一个setter去注入了，会报错但其实是可行的，因为是通过注解自动生成的FeignClient对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserFeignClient userFeignClient;</span><br></pre></td></tr></table></figure><p>④最后就是调用：url都已经被封装到接口里了，使得URL更加的简洁，同时后面多参数的时候会更加明显。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">    turn userFeignClient.findById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于配置，只需要定义一些Feign的配置类，然后在接口的@FeignClient的configuration属性指明即可。</p><p>（PS：配置类最好不写@Configuration注解，如果写了，那么不要放在@ComponentScan所扫描的包中，否则会成为全局配置，被所有@FeignClient共享，除非你确实想要成为全局配置。但是由于@FeignClient的configuration属性就可以直接指明，一般没有必要写这个注解）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contract <span class="title">feignContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> feign.Contract.Default();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasicAuthRequestInterceptor <span class="title">basicAuthRequestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"user"</span>, <span class="string">"password"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的两个配置类都已经被添加到UserFeignClient中，第一个把contract改成了feign的原生默认契约，使得可以使用feign自带的注解（如@RequestLine），第二个相当于为Feign添加拦截器，这样                当一些接口需要进行给予Http Basic认证才能调用，就需要上面的认证信息。</p><p>同时上面还有Spring cloud官网文档上写的Feign的配置属性，可以学习。</p><p>除了使用Java类配置，用yml配置也是可以的，跟Ribbon一样，用yml配置更加的简洁。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">config:</span></span><br><span class="line"><span class="attr">feignName:</span><span class="comment"># 改成default就是全局配置</span></span><br><span class="line"><span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">loggerLevel:</span> <span class="string">full</span></span><br><span class="line"><span class="attr">decode404:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>果不其然。。目前还没看出Feign的好处，因为我们这里只是相当于用feign替代了RestTemplate的Restful设计，然后还能增加一些超时，日志的配置而已，关键还是要自定义feign，可以彻底增强Restful API的操作，比如相同的API，不同角色的用户会发生不同的行为。</p><p>话说中间在Console看到了一个错误：Batch update failure with HTTP status code 401; discarding 1 replication tasks，显然就是注册服务到Eukera Server失败，网上的解决方法是在Server处的yml配置还是要在defaultZone增加那个user，password，增加了之后就可以了。</p><h3 id="四-手动创建Feign"><a href="#四-手动创建Feign" class="headerlink" title="四. 手动创建Feign"></a>四. 手动创建Feign</h3><p>前面对Consumer使用了Feign，感觉也只是替代了RestTemplate的Restful设计，稍微加了一些日志配置，意义不大。但如果是手动创建，将能完成更强的逻辑。</p><p>接下来对Provider服务手动创建Feign。</p><p>首先，导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之前对于Security包，我只在Eureka Server处添加了该依赖包，但在其他地方添加感觉没有必要，不仅需要同样的用户密码，而且如果密码不同，还可能导致无法注册到Eureka的情况。所以这次需要对Provider额外再增加一个security，感觉会在认证这里出现问题，事实也是如此的。但主要问题在于对Security的配置不熟悉，知道了哪些属性起到什么作用就好。</p><p>首先我们需要给Provider的Security添加配置（其实之前Eureka的Security也有配置，不过只是禁用了一下CSRF：</p><p>之前的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable();</span><br><span class="line">        <span class="keyword">super</span>.configure(http);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（可以看出来主要是注解@EnableWebSecurity。然后配置的导入，要么@Configuration，要么在启动类里Import(xxx.class)，都是一样的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// all request need HTTP Basic auth</span></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated().and().</span><br><span class="line">            formLogin().and().httpBasic();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A password encoder that does nothing Useful for testing with plain text</span></span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomUserDetailsService userDetailsService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CustomUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"user"</span>.equals(username))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SecurityUser(<span class="string">"user"</span>, <span class="string">"password1"</span>, <span class="string">"user-role"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"admin"</span>.equals(username))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SecurityUser(<span class="string">"admin"</span>, <span class="string">"password2"</span>, <span class="string">"admin-role"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这里的配置类，具体说一下。configure方法，这个其实就是登录功能。不要看起来很复杂，其实and就是起连接作用。然后authorizeRequests就是要验证request的意思，anyRequest就是每一个请求都要验证，没有例外。authenticated：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ExpressionUrlAuthorizationConfigurer&lt;H&gt;.ExpressionInterceptUrlRegistry</span><br><span class="line">    authenticated() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.access(<span class="string">"authenticated"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概也就是通过验证的意思，其他的还有denyAll，rememberMe等等的功能。formLogin就是以一个登录界面显示，而不是弹窗。最后就是表明要基于HTTP Basic来验证。</p><p>至于passwordEncoder方法，这是一个明文编码器，因为涉及密码的时候都是要加密的，但这里只是测试，所以就用一个不作任何操作的密码编辑器就好。</p><p>验证的过程需要我们根据用户账号和密码，如果通过了就返回一个UserDetails的对象，这是一个接口，所以我们需要手动创建一个实现类，重写相关方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurityUser</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityUser</span><span class="params">(String username, String password, String role)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.role = role;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        Collection&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        SimpleGratedAuthority authority = <span class="keyword">new</span> SimpleGrantedAuthority(role);</span><br><span class="line">        authorities.add(authority);</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（下面还有一些setter，getter就省略了。。虽然我中途有一个错误就是写错了getter，当时自动生成的getPassword方法竟然返回的是null，而不是password，使得我一直密码登录不通过。最后还是一步一步调试才发现是getter出现了问题）</p><p>其实关键的方法也没什么，getAuthorities主要是对role的配置而已，因为这是需要返回Collections对象，所以看起来不太一样，其实就是一个getter。但下面这4个方法其实挺关键的，看方法名就大概知道是什么作用，是否锁定账号，是否允许登录。IDEA默认生成的这4个方法是返回false的，这会导致：即使账号密码一致，也会一直卡在登录的界面。</p><p>接着的内部类CustomUserDetailsService就是注入一个自定义的Bean。这里就是登录验证的地方，首先获取登录界面的user参数（loadUserByUsername)，然后根据账号密码去进行匹配，生成一个UserDetails的对象并返回。如果这里出错（即没有预设的Username），那么就会返回一个null，登录直接失败。当我们通过了验证，返回一个UserDetails之后，这时候我们会再调用第二个configure方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.userDetailsService(<span class="keyword">this</span>.userDtailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，就是将登录界面的密码与UserDetails进行匹配。如果密码一致，则登录成功。否则会显示：Not granted any authorities(我就是因为getter写错了导致一直显示Not granted any authorities)</p><p>最后一切成功，Provider成功注册到Eureka，没有因为多增加一个Security而导致无法注册。同时Provider服务本身也增加了认证机制，使得可以根据不同的账号密码（一般应该是根据用户名，获取role，然后做出不同的工作，但这里只是为了演示Feign的根据情况做出不同处理的作用，所以只是print了一下role。）</p><p>两个Security的配置信息关键在于：</p><p>Eureka Server的配置无须做出改变：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-discovery-eureka-ha</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line"><span class="attr">user:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">hong</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8761</span></span><br></pre></td></tr></table></figure><p>而对于Provider服务，为了注册到Eureka的认证，还是注入Bean的方法比较好（其实yml好像也是一样的，但不要在defaultZone里乱写）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DiscoveryClientOptionalArgs <span class="title">discoveryClientOptionalArgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DiscoveryClientOptionalArgs discoveryClientOptionalArgs = </span><br><span class="line">        <span class="keyword">new</span> DiscoveryClientOptionalArgs();</span><br><span class="line">    List&lt;ClientFilter&gt; additionalFilters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    additionalFilters.add(<span class="keyword">new</span> HTTPBasicAuthFilter(<span class="string">"hong"</span>, <span class="string">"root"</span>));</span><br><span class="line">    discoveryClientOptionalArgs.setAdditionalFilters(additionalFilters);</span><br><span class="line">    <span class="keyword">return</span> discoveryClientOptionalArgs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后Provider服务的自身认证机制，就直接写在自己的Security配置类里就好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CustomUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"user"</span>.equals(username))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SecurityUser(<span class="string">"user"</span>, <span class="string">"password1"</span>, <span class="string">"user-role"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"admin"</span>.equals(username))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SecurityUser(<span class="string">"admin"</span>, <span class="string">"password2"</span>, <span class="string">"admin-role"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>给consumer service也使用自定义Feign Client。</p><p>改成了使用FeignClient的默认配置，然后创建了两个Feign Client（一个UserClient，一个AdminClient），绑定到同一个service（Provider），但使用不同的账号去访问（User/Admin)，于是也会得到不同的效果，在Provider控制台也会显示出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MoviewController</span><span class="params">(DiscoveryClient discoveryClient, Decoder decoder,</span></span></span><br><span class="line"><span class="function"><span class="params">                        LoadBalancerClient loadBalancerClient, Client client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.discoveryClient = discoveryClient;</span><br><span class="line">    <span class="keyword">this</span>.loadBalancerClient = loadBalancerClient;</span><br><span class="line">    userUserFeignClient = Feign.builder().client(client).encoder(getEncoder()).</span><br><span class="line">        decoder(decoder).requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"user"</span>,</span><br><span class="line">        <span class="string">"password1"</span>)).target(UserFeignClient<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">                                 "http://microservice-simple-provider-user");</span><br><span class="line">    adminUserFeignClient = Feign.builder().client(client).encoder(getEncoder()).</span><br><span class="line">        decoder(decoder).requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"admin"</span>,</span><br><span class="line">        <span class="string">"password2"</span>)).target(UserFeignClient<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">                                 "http://microservice-simple-provider-user");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user-user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findByIdUser</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userUserFeignClient.findById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"admin-user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findByIdAdmin</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> adminUserFeignClient.findById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于decoder，encoder这部分纠结了好久，最后甚至用到了阿里巴巴的JSONObject包自实现了一个（当然，是上网cv下来的，但搞依赖包也烦了一小会）。可是最后才发现，这部分就没意义，反正都能映射到provider服务就好了，然后在provider的控制台也是会把结果打印出来的。所以关键在于：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestInterceptor(new BasicAuthRequestInterceptor("xxx", "xxxx")).target(xx.class, "x");</span><br></pre></td></tr></table></figure><p>requestInterceptor传入 一个BasicAuthRequestInterceptor，表示账号密码，target就是目标服务。</p><p>PS:中途还把id改成了String，其实没什么影响，不过懒得改回去了，万物皆可String</p><p>之后的日志配置跟多参数，我感觉一开始是头脑清醒的，结果中间就不知道做什么了。</p><p>首先，前面是要先把自定义的FeignClient给注释掉的，然后再在controller里定义了两个，直接在controller里调用相应的FeignClient。结果我改成多参数的时候，首先要先把那个原本的FeignClient弄回来，其实那时候是注释掉了三个地方，结果我只改回了两个，然后启动类的注释忘记去掉了，于是一直在莫名其喵。最后还是还原成之前的代码，然后对比了一下才发现忘记一个注释了，所以前面做的很多就是无用功。</p><p>本章节剩下的部分，主要是多参数Feign跟上传文件。其实我觉得还蛮重要的，但我认为作者这里偷懒了，它的代码根本就不能实现，只是画个饼。更关键的是，由于版本的原因，它的代码存在1.x的代码（与2.x不兼容），而我导入2.x的包却没有相关的jar包，搞得我还得上网找一个自实现的Decoder。然后也尝试就这个包换成1.x，发现更恐怖了，整个项目不兼容。总而言之，这部分真的只能搁置。但好歹，最后总算解决了那个不能识别注解的问题。网上都说是Feign默认注解有问题，那个@RequestLine不行。我怀疑他们用的都是1.x。而2.x恰恰相反，就是要使用这个默认注解，然后使用@RequestLine而不是@RequestMapping。总而言之，烦了一整天这个问题。但我觉得主要还是，一开始没有耐心地考虑问题，主要一开始我用@RequestLine确实不可行，于是我也想着改。但其实我当时出错的原因不是这个，而是其他。。所以，一开始对错误的范围认知有误，导致后面也一直错，确定问题的范围真的很关键！不过还好，最后虽然无法生成User，但还是成功将多参数传到了Provider服务。说明Feign多参数的传递还是可行的，而且多次的尝试也让我对整个微服务的架构有了更多的认识（Provider跟Consumer真的是很关键的两个角色）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;​        上一部分对Spring Boot跟Spring Cloud有了基本的认识，同时也添加了Eureka注册中心，使得最基本的服务注册，服务发现都可以实现。但这肯定不够，所以这里继续补充关于Spring Cloud的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/tags/Spring-Cloud/"/>
    
      <category term="Spring Boot" scheme="https://hongscar.cn/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud笔记(一)</title>
    <link href="https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%B8%80.html"/>
    <id>https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%B8%80.html</id>
    <published>2020-02-18T01:37:59.000Z</published>
    <updated>2020-02-18T03:47:30.297Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​        Spring已经渐渐地成为了Java程序员的必备技能，尤其是Java Web方向。同时，Spring也一直在发展，由于Spring存在配置臃肿的问题，所以就出现了Spring Boot框架，用于简化新Spring应用的初始搭建以及开发过程。近年来微服务架构也越来越火，所以在Spring Boot的基础上又出现了Spring Cloud。如果你是常年使用Spring的Java Web程序员，那么Spring Boot跟Spring Cloud很值得一学。</p><p>​        本系列文章并非是完整的教程，我阅读的是<strong><em>”<a href="http://www.ityouknow.com/spring-cloud.html" target="_blank" rel="noopener">纯洁的微笑</a>“的博客</em></strong>：。以及书籍<strong><em>《Spring Cloud与Docker微服务架构实战》by周立</em></strong>。相信每一位学习编程的朋友都遇到过一个问题，跟着书上/教程上一步一步走，结果却不一样。有的时候是版本的问题，有的时候是自己的操作出现纰漏，也可能是教程本身也存在纰漏。无论如何，学习是一个挖坑再填坑的过程，在这个过程中我们的技术也会快速提高。所以这篇文章就是记录我在学习Spring Cloud过程中所遇到的问题，以及如何解决（虽然也有构建步骤，但目前写得比较简单，建议结合上面推荐的博客，书籍使用）。如果有朋友也遇到了类似的问题，可以参考一下。</p><a id="more"></a><p>​        此处使用的Spring Boot版本：2.2.1.RELEASE，Spring Cloud版本：2.2.0.RELEASE。虽然我阅读的主要教程是上面的书籍，但我自己敲的demo项目跟书上有一点不同。书上把每一个章节的项目都分开，比如一个章节是学Feign，一个章节是Hystrix，并没有把它们都结合在一起，我认为这样缺少了一个很重要的工作：整合。然而整合却是必不可少的，既然都使用到了微服务架构，那么自然是要使用多个模板组件。所以我一共只写了一个项目，代码依次在上一个章节代码的基础上继续增加，既要保证功能完好，又要保证功能之间可以兼容。除此之外，书上目前的版本还是Spring Cloud 1.x，毫无疑问已经过时，所以我也改成了2.x。虽然我认为做出的这两个改变是值得的，但确实在学习过程中也遇到了不少的坑，所以也特地记录了下来。</p><h3 id="二-前置知识"><a href="#二-前置知识" class="headerlink" title="二. 前置知识"></a>二. 前置知识</h3><p>​        Spring Boot是Spring的一套快速配置框架，而Spring Cloud是一个基于Spring Boot实现的云应用开发工具。所以，Spring Boot可以离开Spring Cloud独立使用开发项目，而Spring Cloud不能离开Spring Boot，属于依赖的关系。所以如果你还是使用Spring，而非Spring Boot，那么至少要了解Spring Boot与Spring的区别。可以参考这篇文章入门：<a href="http://www.ityouknow.com/springboot/2016/01/06/spring-boot-quick-start.html" target="_blank" rel="noopener">http://www.ityouknow.com/springboot/2016/01/06/spring-boot-quick-start.html</a></p><p>​        可以看到，Spring Boot项目的构建非常简单，无须再考虑各种诸如xml，数据库，配置文件的配置，更多的只需要注解，达到了非常简便的效果。项目的结构也跟Spring相差无几：</p><p>src / main / java ： 主程序入口</p><p>src / main / resources ： 配置文件</p><p>src / test / java ： 测试</p><p>​        在java / com / xx / xxx里的主目录（即与model，service，controller等packages同级的目录），要有一个Application.java，这个其实就是Spring Boot框架的入口，相当于Spring里的XML配置。不过这里抛弃了XML，使用了注解的方式：@SpringBootApplication。目前要引入jar包所需要的Maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实大部分在Maven默认项目里都已经添加好了，剩下的只需要添加支持web的模块：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来对于Controller层的开发也很简单：@RestController，@RequestMapping即可（方法返回String类型，不需要什么ModelAndView）</p><p>@RequestMapping是指Controller里的方法都以JSON格式输出，无须再写Jackson等配置了。</p><p>对于测试：@Test，@BeforeEach （对于JUnit5，@Before and @After no longer exists； use @BeforeEach and @AfterEach instead）</p><p> PS：主要是原本的Before跟After注解就是在每一个Test方法执行时都会执行，改得更加符合其作用</p><hr><p>​         微服务架构需要有多个modules，如果你愿意的话，你可以把一个modules当作一个项目来操作，但到了微服务这一块，这种做法就比较愚蠢，于是最好是尝试把多个modules放到同一个project中（使用的是IDEA）。参考网址:<a href="https://blog.csdn.net/sinat_30160727/article/details/78109769" target="_blank" rel="noopener">https://blog.csdn.net/sinat_30160727/article/details/78109769</a></p><p>遇到的问题：</p><p>①子module跟父module的pom.xml有什么异同？</p><p>父module的pom如下，可以看到包含了Spring Boot的基本信息，还有子modules的构成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span><span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hongscar<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>microservicesimpleprovideruser<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>microservicesimpleconsumermovie<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至于子module，之前该怎么样就怎么样，但parent元素无须做出改动，即：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hongscar<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>microservice-simple-provider-user<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>②写好src/main/java之后，程序无法运行，显示错误：<strong><em>Your ApplicationContext is unlikely to start due to a @ComponentScan of the default package.</em></strong></p><p>解决:因为之前错误的父子module关系，导致我的子modules其实还是有默认package的，比如之前的package都是com.hong.microservice-xxxx-provider之类的。但实际上正确的操作，这时候子module的src/main/java，是没有任何package的，即在java目录下创建一个A.java，会没有package语句。而SpringBoot的Application.java确切地说，并不是要放在根目录，而是要放在所有其他类/包的同级/父级目录，是不能够直接放在src/main/java目录下的，必须手动创建一个包把它放进去。<strong>SpringBoot在写启动类的时候如果不使用@ComponentScan指明对象扫描范围，默认指扫描当前启动类所在的包里的对象，如果当前启动类没有包，则在启动时会报错</strong>。（因为默认并没有包，所以就报错了）</p><p>解决方案也很显然，自己手动创建了一个basic的package，然后其他的package跟Application.java都放进去，如下图：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\7668ab2525ea4b3fa93aff24dacadac7\clipboard.png)</p><p>③Test无法通过，但直接运行可以通过</p><p>解决：看清楚是@Before还是@BeforeEach。至于其他的，目前其实可以直接运行，但如果测试代码出错，后面会踩坑，可以尝试到时候解决，也可以提前把测试代码删掉了避免踩坑（但你知道是测试代码哪里出错了吗）</p><p>④创建第二个MicroService的时候，Test又无法通过，而且不是@BeforeEach的问题。报错：</p><p><strong><em>java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration, you need to use @Context</em></strong></p><p>解决：可能是因为存在了多个service，无法默认指定等等的（毕竟多个module的配置其实我还不是很熟悉），这时候最好就是直接在测试类上面显示指明要测试的是哪个类，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpirngBootTest</span>(classes = MicroserviceSimpleConsumerMovieApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MicroserviceSimpleConsumerApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextsLoad</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加之后，测试也可以运行了，但还是不通过。然后才知道，test目录下的包默认是要跟java下的是一样的。所以，既然java目录下的Application.java的路径是 basic/Application.java (basic是我们自己添加的package），所以test下也需要添加一个名为basic的package（必须名字也为basic）</p><p>⑤<strong><em>Caused by: java.lang.IllegalArgumentException: Not a managed type</em></strong></p><p>无论是哪个服务，对于domain层的配置都要重复编写。@Entity等等的。</p><p>over，运行通过（尽管第一个service的测试还是存在问题，但毕竟我对MockMvc的语法一无所知(问题③))</p><h3 id="三-添加Eureka"><a href="#三-添加Eureka" class="headerlink" title="三. 添加Eureka"></a>三. 添加Eureka</h3><p>​        微服务架构的核心思想就是分离各个服务，每一个服务单独作为一个module/project。那么服务如何被其他项目/服务调用？这时候就要用到Eureka，服务注册中心。服务把自己注册到Eureka上，然后其他服务可以在Eureka上发现并调用，这就是微服务的基本机制。</p><p>步骤：</p><p>pom.xml添加Eureka依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种maven依赖直接去maven repository查找就能找到，还能找到每一个版本。这里值得注意的是，添加的是server，不要错误地添加了client包。同时Spring Cloud的版本号比较特别:upside_down_face:，使用英语记录版本 ，以下是Spring Cloud英语版本对应的Spring Boot版本：</p><table><thead><tr><th>Spring Cloud版本</th><th>Spring Boot版本</th></tr></thead><tbody><tr><td>Hoxton</td><td>2.2.x</td></tr><tr><td>Greenwich</td><td>2.1.x</td></tr><tr><td>Finchley</td><td>2.0.x</td></tr><tr><td>Edgware</td><td>1.5.x</td></tr><tr><td>Dalston</td><td>1.5.x</td></tr></tbody></table><p>添加完依赖包，其实就可以运行了。然后要把服务注册到Eureka。这时候才是版本冲突的地方。<strong><em>ERROR org.springframework.boot.SpringApplication - Application run failed</em></strong></p><p>一般这种<strong><em>Application run failed</em></strong>，基本就是<strong><em>版本号冲突</em></strong> 的问题了。看了一下，我写的还是书上的Edgware.RELEASE，参考官网的改成了HOXTON.RELEASE，就解决了这个问题。</p><p>然后又有其他的错误， <strong><em>Failed to start component [NonLoginAuthenticator [StandardEngine[Tomcat] .StandardHost[localhost] .TomcatEmbedded。。。</em></strong></p><p>网上查到的也是更加奇怪，说是SDK里的servlet-api.jar与log4j.jar起冲突了。其实关于前面的版本号为什么非要添加到Eureka才出问题已经挺奇怪了，这里就更奇怪了，怎么突然就两个jar起冲突了？唯一的解释只能是Eureka毕竟是带有记录功能的，所以就包含了log4j.jar，然后就与servlet-api.jar冲突了。可是我的SDK里却没有这个东西，去External libraries找到了这个东西，然后去掉，竟然真的就可以了。所以说，编程还是需要多积累经验。</p><p>效果图：可以看到MicroService已经注册到了Eureka上</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\416ac9ad64524e5587540f1317ff5bdb\clipboard.png)</p><h3 id="四-把多个服务注册到Eureka上"><a href="#四-把多个服务注册到Eureka上" class="headerlink" title="四. 把多个服务注册到Eureka上"></a>四. 把多个服务注册到Eureka上</h3><p>看起来很简单，但却遇到了非常多的问题。首先打开consumer服务的时候，发现pom.xml报错了。想当然的以为又只是IDEA抽风了而已，因为直接运行是可行的，但后来发现确实不是如此。</p><p>maven之前欠下的债算是要还了，每当我有一个知识点掌握得含糊不清，得过且过，也许我可以安逸地度过很久，甚至是几年，但总会有再栽跟头的一天。之前我对maven，真的就是把它当作了一个简单的eclipse的import path的功能了，目的实现了就行了，什么&lt;dependencyManagement&gt;，完全不想去弄清楚。之前创建子module之间的依赖，我其实就搞不懂为什么能直接用cn.hongscar.xx来引用依赖？难道因为是项目内部就可以直接引用？没有去想。</p><p>首先项目一直会出现今天早上的那个错误，显然就是servlet-api.jar的问题，才发现这东西会一直存在，即使删掉了，maven也会把它自动下载回来。很显然，删掉是很愚蠢的操作，但当时毕竟只想立竿见影，我一直以来都是这么做的，显然正确的操作是添加一个maven的例外。所以正确的操作是添一个&lt;exclusions&gt;在&lt;dependency&gt;里。这确实就可行了，但真的是如此吗？首先，确实是添加了&lt;exclusions&gt;就可以工作了，但为什么maven会 自动把servlet-api.jar下回来，难道这还需要时机？得看你手速快不快，在它把servlet-api.jar下回来之前运行？实际上，就是因为项目本身就存在问题，所以每次rebuild，reimport的时候就把jar包搞回来了。无论如何，&lt;exclusions&gt;显然是更好的选择。</p><p>关于我要的目标，其实Maven的基本命令就已经包括了：</p><p>-v :查询Maven版本</p><p>compile： 编译，把Java源文件编译成.class文件</p><p>test：测试项目，测试test目录下的测试用例</p><p>package：将项目打包成jar包</p><p>clean：删除target文件夹（删除缓存，重新生成）</p><p>install：将当前项目放到Maven的本地仓库中，供其他项目使用</p><hr><p>我想要的就是把项目安装到本地仓库里，总不能把项目delete了重新创建一次吧。然后在install的过程中查看到底出现了什么问题，这才是解决问题的核心。而不是，clean，complie统统乱点一遍。</p><p>然后在install的过程中就能看到问题了：</p><p><strong><em>Failure to … in … was cached in the local repository, resolution will not be reattempted until the update interval of nexus has elapsed or updates are forced.</em></strong></p><p>首先是Hoxton.RELEASE文件已经缓存了，并且还在使用，就不能update了。这时候真的就是简单粗暴就好，删了，让它重新下载，这个问题就解决了。</p><p>接下来的问题更离谱，说是测试代码有问题，所以不能成功build。想起来昨天不懂测试语法，想着项目能正常运行就好，测试代码就没管，没想到就这里埋下了大坑。于是把测试代码全部注释掉，同时rebuild一次（更新classes文件夹），果然，build就成功了。maven本地仓库也就成功出现了该模块。所以，项目到底如何加到maven本地仓库，为什么之前出错，都是有迹可循的，真的不仅仅就是奇怪的经验那么简单。当然，经验是否有用？至少从中能知道，测试代码并不是那么的人畜无害，在正式的build，install（项目打包过程），测试代码也是关键的一环，它有权终止整个过程，尽管你的主程序没有出错，只是测试代码写错了。</p><p>其实很多时候，把很多东西都归结于经验，确实有种给自己诡辩的嫌疑。就像是看到pom.xml报错了，第一时间想的是不是IDEA抽风了，完全不去想到底什么原因。诚然，”奇怪“的情况是存在的，但并不能一概而论，很多时候，经验不能成为一个完美的借口。</p><p>结果图：    可见两个service都成功添加到Eureka中。</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\ce4e44b59c174470b6c93659c446a68d\clipboard.png)</p><h3 id="五-构建高可用的Eureka-Server"><a href="#五-构建高可用的Eureka-Server" class="headerlink" title="五. 构建高可用的Eureka Server"></a>五. 构建高可用的Eureka Server</h3><p>​        先从搭建两个Eureka Server互相注册复制开始。根据书上的例子，首先需要修改hosts文件。然后先去了解了一下hosts文件是什么（位置：C:\Windows\System32\drivers\etc，如果是Linux，是在/etc/hosts)，主要就是平时我们上网都要输入域名，然后传递到DNS服务器再进行映射，而DNS服务映射到具体的IP地址是需要时间的。这时候我们可以在hosts文件里自定义一些domain name（可以是自定义，可以是公开的），以及对应的IP地址，那么当我们下次输入这个domain name的时候，就直接映射到IP地址，跳过了DNS，因此速度也就更快。比如GitHub.com的IP地址是192.30.255.113。那么添加一行：</p><p>192.30.255.113          github.com</p><p>即可使得下次输入GitHub.com就能自动映射到对应的IP addr。</p><p>平时我们用的localhost跟127.0.0.1也是如此。127.0.0.1默认就是本地的IP地址，而localhost就是写在hosts里的域名。但在hosts里可以看到这一行是被注释掉的，为什么？因为下面还有一行注释：</p><p># localhost name resolution is handled within DNS itself. </p><p>也就是说，DNS服务器内部已经把这个写好了，成为了约定，这样就避免了你把localhost乱搞成了其他东西。所以并不是说注释是无效的，而是这一行直接成为了DNS的默认约定配置吧。</p><p>OK，然后修改hosts是要给127.0.0.1新增几个新域名（peer1跟peer2）</p><p>然后在application.yml里的配置，使用— 可以将yml文件分成多段，由一个spring:profiles来决定（在后续启动的时候传入这个参数，表示要使用哪段yml文件），如果没有指定spring:profiles，则无论是传入哪个参数，都会生效。</p><p>启动的时候需要：<code>java  -jar  xxx.jar  --spring.profiles.active=peer1  /  peer2</code></p><p>显然，首先我们需要将项目打包成jar文件，然后再分别启动（spring.profiles参数分别为peer1和peer2)</p><p>这时就出现了第一个问题，如何打包成jar文件？</p><p>联想到昨天吃的亏，印象中maven里就包含了这个操作，确实如此。但成功打包之后，却无法运行，显示：xxx没有主清单属性</p><p>那么到底是什么是主清单属性？其实也很好猜，就是找不到主类。网上看的大致说法是，maven的打包jar操作是有点特殊的，跟普通的java方式打包生成的目录是不太一致的。于是又尝试了一下mvn install，mvn clean等等命令，都不行。</p><p>但在中途也学到了一手：给mvn的命令增加一个-e参数，可以显示详细的错误信息：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\f79896cb50244bd9a4ee628f91b6f279\m9[}r825q@__et~4i[bn4gi.png)</p><p>比如这里的错误信息是can’t not delete，那是因为我打开了几个cmd，然后文件正在使用，无法进行mvn clean，把cmd窗口关闭了之后重新clean就可以了。</p><p>之后添加了一个叫maven-shade-plugin的插件，还是不行（为什么要添加这些额外的插件，还是有思考的，基本就是要把MainClass的路径也写进入，一并打包）</p><p>这时候感觉maven的plugins操作还是不太好用，直接用mvn install -e查看为什么出错，发现是：</p><p><strong><em>Caused by: org.codehaus.plexus.component.configurator.ComponentConfigurationException: Cannot find ‘resource’ in class org.apache.maven.plugins.shade.resource.ManifestResourceTransformer</em></strong></p><p>完全没有头绪，但在网上有一个很好的帖子：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\23013a70274447fa83613416658d4d9f\clipboard.png)</p><p>简单概括就是：SpringBoot本身是存在一个打包插件，而这个另外加的shade反而形成了冲突。那么久好办了，把SpringBoot的打包插件去掉？一看，pom.xml并没有该插件，但该service是依赖了provider service的，看了一下provider service的pom.xml，确实存在这个插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>于是想着那就删掉这个！但结果还是不行？可能是别的地方还存在这个插件的导入？毕竟我在最初对maven的版本管理是很混乱的。但我确实暂时不想深究这个问题，直接换了另一种做法：那就不用这个shade插件了，直接使用springboot自带的打包插件。然后给当前pom.xml加上了上述插件（看来依赖是不会继承plugins的），这时候mvn clean，mvn install，成功，如图：</p><p><img src="C:%5CUsers%5C44567%5CDesktop%5Cnew_images%5Csb_6.png" alt="img"></p><p>PS：此时我并没有立刻启动Eureka Server节点，而是查看了一下MANIFEST.MF文件，发现确实增加了大概的“主清单属性”，如图：（之前是没有Spring-Boot-Classes等等属性的）</p><p>PPPS：对了，vs code打开了MF文件之后就死机了。。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Manifest-Version:</span> <span class="number">1.0</span></span><br><span class="line"><span class="attr">Created-By:</span> <span class="string">Maven</span> <span class="string">Archiver</span> <span class="number">3.4</span><span class="number">.0</span></span><br><span class="line"><span class="attr">Build-Jdk-Spec:</span> <span class="number">12</span></span><br><span class="line"><span class="attr">Implementation-Title:</span> <span class="string">microservice-eureka</span></span><br><span class="line"><span class="attr">Implementation-Version:</span> <span class="number">1.0</span><span class="string">-SNAPSHOT</span></span><br><span class="line"><span class="attr">Main-Class:</span> <span class="string">org.springframework.boot.loader.JarLauncher</span></span><br><span class="line"><span class="attr">Start-Class:</span> <span class="string">basic.EurekaApplication</span></span><br><span class="line"><span class="attr">Spring-Boot-Version:</span> <span class="number">2.2</span><span class="number">.1</span><span class="string">.RELEASE</span></span><br><span class="line"><span class="attr">Spring-Boot-Classes:</span> <span class="string">BOOT-INF/classes/</span></span><br><span class="line"><span class="attr">Spring-Boot-Lib:</span> <span class="string">BOOT-INF/lib/</span></span><br></pre></td></tr></table></figure><p>这时候已经猜到成功了，然后按照很前面的命令启动了两个Eureka Server节点，确实如此：</p><p><img src="C:%5CUsers%5C44567%5CDesktop%5Cnew_images%5Csb_7.png" alt="img"></p><p><img src="C:%5CUsers%5C44567%5CDesktop%5Cnew_images%5Csb_8.png" alt="img"></p><p>peer1看起来一开始报错，但其实很正常，因为peer2还没开始运行，后面peer2运行起来之后，二者就成功互相复制了。效果如图：</p><p><img src="C:%5CUsers%5C44567%5CDesktop%5Cnew_images%5Csb_9.png" alt="img"></p><p><img src="C:%5CUsers%5C44567%5CDesktop%5Cnew_images%5Csb_10.png" alt="img"></p><p>虽然启动成功了，似乎也成功复制了，但与预期有一点不同（peer1复制了peer2，但peer2没有复制peer1，仍然复制的peer2，配置文件似乎没有写错）</p><p>DS Replicas有点奇怪，但Instances currently确实都是二者成功复制了。</p><p>有说法是。DS Replicas是指从哪里同步数据，测试先启动peer2，再启动peer1会不会发生改变。（这也是我的个人想法，所以按理说，peer2处的DS Replicas应该是peer1才对）</p><p>可是较换peer1跟peer2的启动顺序，Instances currently依然是复制了，但DS Replicas依然二者都是peer2，所以与启动顺序无关。(可能是根据yml的顺序来决定，后面的就是最后的DS，毕竟这两个peer其实都指向同一个IP）。可能是peer1和peer2的复制顺序真的不是简单的顺序复制吧，网上说如果真的是那样，那就变回了中心化组件，跟微服务架构背道而驰。</p><h3 id="六-给Eureka-Serer增加一个认证"><a href="#六-给Eureka-Serer增加一个认证" class="headerlink" title="六. 给Eureka Serer增加一个认证"></a>六. 给Eureka Serer增加一个认证</h3><p>首先添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实只要添加了这个依赖，那么此项目在运行时就需要登录。（如果是Server，那么登录Server控制台需要登录，其他服务想注册到此Server也要登录。如果是Service，那么使用Service的时候也要登录）如果不在yml里配置用户名跟密码，默认用户名就是user，密码会在运行时随机生成，打印在控制台。</p><p>然后一开始在yml的配置里出现了问题，其实不用查也可以猜到，是版本的原因，2.x换成下面的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line"><span class="attr">user:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">user</span><span class="comment"># Default user name.</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">aaa</span><span class="comment"># Password for the default user name.</span></span><br><span class="line"><span class="attr">roles:</span> <span class="string">xxx</span><span class="comment"># Granted roles for the default user name.</span></span><br></pre></td></tr></table></figure><p>所以最后的yml配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-discovery-eureka-ha</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line"><span class="attr">user:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">hong</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">kk111</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">serviceUrl:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8761</span></span><br></pre></td></tr></table></figure><p>值得注意的是，前面是否需要加 xx:yy@localhost:8761/eureka/ ，好像加不加都无所谓。。</p><p>然后一开始遇到了奇怪的错误，最后把密码删掉了也不行。最后翻GitHub以前的记录，才发现，我连两个false还有port都没有配置，所以最基本的配置一定要记忆清楚。。</p><p>接下来是要将服务注册到需要认证的Eureka Server。一开始遭遇到了问题：<strong><em>com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server</em></strong></p><p>很显然，就是说不能注册到任何已知的服务器。网上搜到的答案都是针对Eureka Server本身不需要注册（最开始那两个false参数），但显然这里我的错误就是service无法通过Eureka Server的认证。</p><p>尝试了几次都不行，最后通过“内华达穷举法”，才发现问题是CSRF。只要把CSRF禁用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable();</span><br><span class="line">        <span class="keyword">super</span>.configure(http);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于到底是在yml里设置security参数，然后在defaultZone里增加${…}:${…}@local…，还是直接注入一个DiscoveryClientOptionalArgs的Bean，都可以达到认证的效果，如下：</p><p>方法①：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.netflix.discovery.DiscoveryClient.DiscoveryClientOptionalArgs;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DiscoveryClientOptionalArgs <span class="title">discoveryClientOptionalArgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DiscoveryClientOptionalArgs discoveryClientOptionalArgs = </span><br><span class="line">        <span class="keyword">new</span> DiscoveryClientOptionalArgs();</span><br><span class="line">    List&lt;ClientFilter&gt; additionalFilters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    additionalFilters.add(<span class="keyword">new</span> HTTPBasicAuthFilter(<span class="string">"hong"</span>, <span class="string">"kk111"</span>));</span><br><span class="line">    discoveryClientOptionalArgs.setAdditionalFilters(additionalFilters);</span><br><span class="line">    <span class="keyword">return</span> discoveryClientOptionalArgs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法②：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-simple-provider-user</span></span><br><span class="line"><span class="attr">jpa:</span></span><br><span class="line"><span class="attr">generate-ddl:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">hibernate:</span></span><br><span class="line"><span class="attr">ddl-auto:</span> <span class="string">none</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">platform:</span> <span class="string">h2</span></span><br><span class="line"><span class="attr">schema:</span> <span class="string">classpath:schema.sql</span></span><br><span class="line"><span class="attr">data:</span> <span class="string">classpath:data.sql</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line"><span class="attr">user:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">hong</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">kk111</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">serviceUrl:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">$&#123;xxx.name&#125;:$&#123;xxx.password&#125;@localhost:8761/eureka/</span> </span><br><span class="line"><span class="comment"># xxx是 spring.security.user</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>二者无论是单独使用，还是一起使用，都可以达到认证的效果。</p><h3 id="七-关于Eureka的元数据metadata"><a href="#七-关于Eureka的元数据metadata" class="headerlink" title="七. 关于Eureka的元数据metadata"></a>七. 关于Eureka的元数据metadata</h3><p>metadata包括标准元数据（自带的，可在服务之间传递信息），还有自定义元数据（一般不会改变客户端的行为，相当于参数传递，给一个参考值）</p><p>其实这部分的工作并不多，但主要是让我意识到了，版本控制真的不容易，即便是引入了Maven。之前我在主项目里没有引入spring-boot，然后在provider跟Eureka中都分别引入了。其实没有必要，在主项目引入，然后provider就不必引入了，即使引入了也会被视为duplicate。</p><p>同时我需要解决@RestController返回的是XML而不是JSON的问题，发现问题是因为Eureka-Server引入了Jackson-dataformat-xml这个包，所以自然地去exclude掉就好（需要在maven里慢慢找这个包到底从属于哪个包，当然如果记忆好的话，确实是引入Eureka之后才出现这个问题，自然也就是在Eureka-Server的包里了）</p><p>然后发现Provider跟Consumer的返回类型都正常了，但Eureka下的apps（测试自定义metadata的入口）依然是XML类型。一看发现项目仍然存在Jackson-dataformat-xml，应该是Eureka Server也自己引入了spring-cloud-eureka-server的原因，所以我把它去掉了（想着这样直接获取主项目的就好），但这时项目却无法运行了。原因是找不到Jackson-dataformat-xml，猜测是因为Eureka  Server没有导入这个包了，于是主项目的exclude就出现了问题（现在回想这个逻辑是不对的，为什么?)。但并不是，把exclude删掉了也不行。才发现哪个找不到Jackson-dataformat-xml，是指项目需要这个，但却不存在。所以说，其实项目还是需要这个包的，尤其是在使用metadata的时候？于是我把这个给彻底去掉了，这样就不可运行了。所以只好主项目依旧exclude，Eureka Server依然导入spring-cloud-eureka-server，但不exclude（此时子项目跟父项目存在不同，当然就以子项目的来覆盖）</p><p>所以最后provider等服务是返回JSON了，但apps却仍然是XML。不过想想，毕竟我对apps还不太了解，也不是我自己手动写的@RestController，所以返回XML其实也无可厚非。</p><p>PS：最后有一个点，Consumer注入了Provider的依赖，这两个之间是不能同时注入同一个Bean的（会冲突），而且其实只要Provider存在这个依赖，那么Consumer也就存在。所以Consumer没有注入注册Bean，也没有在yml里编写认证用户密码，同样是可以注册到Eureka的。相反，在Provider已经写了认证机制，在Consumer再写一遍，会使得Consumer无法认证，无法注册到Eureka。</p><p>Eureka部分到此结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;​        Spring已经渐渐地成为了Java程序员的必备技能，尤其是Java Web方向。同时，Spring也一直在发展，由于Spring存在配置臃肿的问题，所以就出现了Spring Boot框架，用于简化新Spring应用的初始搭建以及开发过程。近年来微服务架构也越来越火，所以在Spring Boot的基础上又出现了Spring Cloud。如果你是常年使用Spring的Java Web程序员，那么Spring Boot跟Spring Cloud很值得一学。&lt;/p&gt;
&lt;p&gt;​        本系列文章并非是完整的教程，我阅读的是&lt;strong&gt;&lt;em&gt;”&lt;a href=&quot;http://www.ityouknow.com/spring-cloud.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;纯洁的微笑&lt;/a&gt;“的博客&lt;/em&gt;&lt;/strong&gt;：。以及书籍&lt;strong&gt;&lt;em&gt;《Spring Cloud与Docker微服务架构实战》by周立&lt;/em&gt;&lt;/strong&gt;。相信每一位学习编程的朋友都遇到过一个问题，跟着书上/教程上一步一步走，结果却不一样。有的时候是版本的问题，有的时候是自己的操作出现纰漏，也可能是教程本身也存在纰漏。无论如何，学习是一个挖坑再填坑的过程，在这个过程中我们的技术也会快速提高。所以这篇文章就是记录我在学习Spring Cloud过程中所遇到的问题，以及如何解决（虽然也有构建步骤，但目前写得比较简单，建议结合上面推荐的博客，书籍使用）。如果有朋友也遇到了类似的问题，可以参考一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/tags/Spring-Cloud/"/>
    
      <category term="Spring Boot" scheme="https://hongscar.cn/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>验证docker的例子</title>
    <link href="https://hongscar.cn/%E9%AA%8C%E8%AF%81docker%E7%9A%84%E4%BE%8B%E5%AD%90.html"/>
    <id>https://hongscar.cn/%E9%AA%8C%E8%AF%81docker%E7%9A%84%E4%BE%8B%E5%AD%90.html</id>
    <published>2020-02-17T15:50:35.000Z</published>
    <updated>2020-02-17T15:01:46.559Z</updated>
    
    <content type="html"><![CDATA[<p>根据前面的docker知识点，可以使用这些知识点，结合例子来实际操作一遍。</p><p>其实最开始看阮一峰大佬博客的时候，就已经遇到了一个问题：需要用浏览器访问。而我之前一直都直接在命令行里操作，一时间不知道该怎么办。当然了，没有浏览器就真的不行吗，也许不是，根据网上的说法，直接使用curl命令也可以，只是没那么方便，于是还是先下定决心要搞一个可视化界面。这里用到的是VNC。</p><a id="more"></a><p>关于VNC的环境配置，其实也遇到了很多问题，但当时忘记总结了，现在回过头来发现当时的浏览器记录没了（不要问我为什么浏览器记录会没了= =），只能凭印象地稍微说几句。一开始想着直接给服务器安装GNOME桌面，设置了优先使用桌面启动而非控制台，然而一点用处也没有。于是我又回归到VNC上，VNC其实也有很多种，但似乎不同版本之间都是可通的。这里值得一提的是，VNC也是简单的C-S架构，所以我们不能仅仅在本地安装了VNC-Client，就觉得可以连上了，更关键的还要在服务端也安装一个VNC-Server。当时随便找了一个TigerVNC，在CentOS上直接用yum install就可以安装的，建议先用<code>yum list | grep tigervnc</code>，然后把tigervnc跟tigervnc-server都安装了就好。</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_1.png" alt="img"></p><p>第一次启动vncserver的时候，会让我们设置client登录到server需要的密码，需要输入两次，密码不会显示出来，都是常见的情况。然后是最关键的一步，需要指定端口。tigervnc-server默认开启的是5901端口，可以用netsta -tlnp查看是否存在该端口。这时候我在vncviewer（client）仍然无法ping通，一直显示time-out，其实就是没有连接到。找了很多方法都不行，后来突然想到了之前配置redis的时候也是如此，防火墙，配置文件全都到位了，就是不行，结果直接去腾讯云服务器上的端口管理设置了一下就可以了。于是我也就过去尝试地添加了一个5901端口，竟然就连通了，吃惊，如下：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_2.png" alt="img"></p><p>连接上了之后就好办了许多，看阮一峰大佬的例子也一直水到渠成，包括他使用docker安装WordPress的例子，看评论里还有部分朋友是前两个方法无法ping通，而我成功三个方法都完美无差错，感觉还是可以的。于是VNC的部分到此结束。</p><p>可是仅仅靠一个博客的例子也太简单了，于是继续按照书上的例子来加深印象。书上用的是nginx的例子，各种参数我大概都理解是什么意思，–volume其实就是-v，-p是端口映射等等的。然后就遇到了一个老生常谈的问题，在映射目录下加了一个html文件，确实可以访问，可是出现了中文乱码。中文乱码真的是经典问题，那么接下来就来具体诉说如何解决这个中文乱码的问题。（题外话，如果前面偷懒直接用curl而不用vnc，就会忽略掉中文乱码这个错误）</p><p>以往解决中文乱码，很简单，修改配置文件，mysql等数据库就是这样处理的。那么，我们现在的本机（其实就是localhost，有一些翻译成宿主机），完全就没有安装nginx，全靠一个仓库提供的nginx image，然后在docker里运行，那么哪里找到配置文件呢？</p><p>我主要参考的是这篇文章：<a href="https://blog.csdn.net/wangfei0904306/article/details/77623400" target="_blank" rel="noopener">https://blog.csdn.net/wangfei0904306/article/details/77623400</a></p><p>很显然， 主要用到的就是-v参数，第一个是映射到nginx的默认目录，使得当前的html页面就可以直接被nginx访问到。第二个是把主配置文件nginx.conf映射过去，第三个是子配置文件目录conf.d。我还是先把话说在前面了，这段代码是有问题的，不然也没必要特意开一篇文章：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_3.png" alt="img"></p><p>然后另一个问题又来了，那位博主是在宿主机也安装了nginx，所以他能直接拿现成的nginx.conf，conf.d来用，可我并没有。我可选的操作有：①直接上网，比如把博主的这两个配置文件下过来。②那就安装一次nginx。③把nginx image里的配置文件拿出来，然后改造。显然，前两种虽然也能解决问题，但有点蠢，显然不是最优解，第三种方法才是最合适的。用到的命令也很简单，首先启动container，然后进入container：（参数似乎不能乱）</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_4.png" alt="img"></p><p>然后就是复制文件的命令docker cp：（当时学的时候没看得是什么用处，现在彻底懂了）</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_5.png" alt="img"></p><p>于是成功把配置文件都拿出来了，然后呢？按照代码运行，出错，预期之内。下面是排错过程：</p><p>①把后面两个-v都去掉，看能否运行。结果是可以的，说明，错误确实就在后面两个-v的映射过程。</p><p>②加上后面的参数，又报错。这里值得一提的是，启动一般不会有报错信息，除非你把image名写错了，那么如何查看容器是否启动出错了？docker container ls -all。这可以列出所有的container，包括隐藏的container。而且有一项关键的属性是，status，可以根据该属性的值判断是否启动成功。当status为UP，说明容器启动成功。如果status是exited，说明启动了一下就退出，那自然就是出错了。还有一种情况，status是created，这也被我遇到了，直觉地想就是一直卡在了创建阶段，自然也是出错的时候。</p><p>③把所有的容器都关闭了，并且也删除了，再访问该IP地址（在这之前都是通过浏览器访问的），竟然还可行？这一点有点匪夷所思，因为container确实已经关闭了，甚至都已经删掉了，可在VNC的browser上却可以访问。一开始以为是缓存的问题，后来换成无痕浏览也有这个问题（换成无痕浏览倒是减少了这个情况）。这其实让我很无语，所以浏览器也不是万能的，它不仅卡，还可能本身就有问题！那么此时应该怎么办？curl。</p><p>④接下来就是具体地看代码哪里出错的地方了。首先有一个有趣的地方，目录映射是通过一个冒号完成的。然后冒号前后似乎不能加空格，加了会报错。（虽然直觉上不会，但我测试的时候，只有第一个-v，是应该可以正常运行的，可有空格就会报错，没有就不会报错，也许还有其他干扰我没注意到，但我懒得继续测试了）第二个错误的点，幸好我当时选择的是第三种解决方法，所以我刚刚进入了容器内部，查看了文件目录结构，我发现它的目录是 /etc/nginx/nginx.conf，而非/etc/nginx/nginx.conf:ro，这可能是版本的原因，也许以后还会变，但只要知道如何操作就行。同时由于我懒，我用的是参数”$PWD/…”，所以记得一定要在正确的目录调用该命令。不然后面就遇到了这种错误，我进入了conf.d目录，修改了配置文件，然后直接就在那里启动命令，PWD是错的，那么命令自然也会错了，最终的命令如下：（还是顺便提一下吧，”&quot;真的就是最简单的换行符而已，所以如果你喜欢，你可以全部写在一起，都是可行的，只是可读性不高）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker run \</span><br><span class="line"></span><br><span class="line"> --name myNginx \</span><br><span class="line"></span><br><span class="line"> -d -p 96:80 \</span><br><span class="line"></span><br><span class="line"> -v <span class="string">"<span class="variable">$PWD</span>/"</span>:/usr/share/nginx/html \</span><br><span class="line"></span><br><span class="line"> -v <span class="string">"<span class="variable">$PWD</span>/nginx.conf"</span>:/etc/nginx/nginx.conf \</span><br><span class="line"></span><br><span class="line"> -v <span class="string">"<span class="variable">$PWD</span>/conf.d/"</span>:/etc/nginx/conf.d  \</span><br><span class="line"></span><br><span class="line">nginx:my</span><br></pre></td></tr></table></figure><p>⑤这时候可以成功启动，通过docker container ls -all就可以看到status是UP。可是，还是乱码。关于配置文件的修改，我是在default.bak里增加了一行 charset: utf-8。结果，原来最后的原因就是错误三。我把整个容器重新关了删了再启动，然后无痕浏览，总算没有乱码了。至此，解决Docker中的nginx中文乱码问题到此解决。</p><p>⑥PS：中间还遇到一些非常weird的错误，比如WARNING: IPv4 forwarding is disabled. Networking will not work.原因可能是前面操作docker不当，导致“ default the ipv4 forwarding is not turned on in the image from docker to prevent any security vulnerabilities. ”即Docker处于安全考虑默认关闭该设置。解决方法是：<a href="https://blog.csdn.net/Kohang/article/details/85125054" target="_blank" rel="noopener">https://blog.csdn.net/Kohang/article/details/85125054</a> 好吧，实际上只要你上网搜一下上面的WARNING，你就会看到无数篇一模一样的解决方法。还好，这次是可行的答案，不然。</p><p>其实这个例子也不是简单的中文乱码问题，因为跟乱码相关的东西，其实就一行charset: utf-8。从这个例子中，学到的不仅仅是如何解决中文乱码，更多的是：如何获取container中的文件到宿主机，-v映射具体是什么，如何查看container是否正常运行等等。关于-v映射，我在修改default.conf的时候，先进行了备份：cp default.conf default.conf.bak，然后再对default.conf进行修改，如果出错了可以直接删掉，把default.conf.bak改回原名即可。最后我进入container内部查看的时候，发现对应的映射目录，存在的就是两个文件，default.conf和default.conf.bak。所谓的映射，其实就是把宿主机的文件放入容器的指定路径。</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_6.png" alt="img"></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_7.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据前面的docker知识点，可以使用这些知识点，结合例子来实际操作一遍。&lt;/p&gt;
&lt;p&gt;其实最开始看阮一峰大佬博客的时候，就已经遇到了一个问题：需要用浏览器访问。而我之前一直都直接在命令行里操作，一时间不知道该怎么办。当然了，没有浏览器就真的不行吗，也许不是，根据网上的说法，直接使用curl命令也可以，只是没那么方便，于是还是先下定决心要搞一个可视化界面。这里用到的是VNC。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://hongscar.cn/categories/Docker/"/>
    
    
      <category term="Debug" scheme="https://hongscar.cn/tags/Debug/"/>
    
      <category term="Docker" scheme="https://hongscar.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>JSON笔记</title>
    <link href="https://hongscar.cn/JSON%E7%AC%94%E8%AE%B0.html"/>
    <id>https://hongscar.cn/JSON%E7%AC%94%E8%AE%B0.html</id>
    <published>2020-02-17T15:28:29.000Z</published>
    <updated>2020-02-17T16:01:24.280Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是阅读《JSON必知必会》所做的笔记。虽然JSON的内容比较少，但做成记录也是极好的。</p><p>JSON是一种数据交换格式。JavaScript Object Notation</p><p>JSON独立于编程语言。</p><p>JSON需要用双引号包裹key-value。当值是字符串时，必须使用双引号。如果是<strong>数字，布尔值，数组，对象，null</strong>等其他数据类型，则不应该被双引号包裹。多个key-value之间用逗号来分割。</p> <a id="more"></a><p>可以在双引号内部使用单引号，空格等特殊字符(即英文数字以外的其他字符).但这不是一种好的选择，因为使用空格和特殊字符忽略了可移植性。</p><p>PS：JSON的key<strong>必须用双引号包裹</strong>。如果没有双引号，那这并不是一个JSON对象，而是一个JavaScript对象。而且在JavaScript中，可以使用单引号来代替双引号，但JSON必须使用双引号。</p><p>在传递数据时，需要提前告知接收方数据是什么类型，这就涉及到媒体类型。（又称，互联网媒体类型，内容类型Content-type，MIME类型）它使用”类型/子类型”这种格式来表示，比如text/html。</p><p>JSON的MIME类型是：application/json</p><p>JSON的对象数据类型可以嵌套。比如一个JSON可以作为另一个JSON的key-value</p><p>\用作转义。</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/json_1.png" alt="">          </p><p>（上面的例子： \n表示换行，而\n就是普通的字符串\n）</p><p>JSON的布尔类型只允许小写形式<strong>true或false</strong>。用1和0，TRUE,FALSE都会报错。</p><p>(PS：用1和0不是报错，但这时候变成了数字类型，而不是布尔类型。而用大写的TRUE跟FALSE，True等，则会直接报错) </p><p><strong>对于JSON的null属性，也必须是小写。（而且JSON没有undefined，那是JS的）</strong></p><p>JSON的数组类型，用[ ]包裹。数组的每一项用逗号隔开，而且，数组里可以是任意合法的JSON数据类型。比如同时具备字符串和数字。[“qqq”, 234, null, “rrr”]</p><p>但最好不要这样做，<strong>应该使得数组的每一项都是相同的数据类型</strong></p><p>（因为在大多数编程语言里，都是如此的。提高可移植性）</p><p>JSON Schema：定义JSON数据的数据要求。比如哪些字段是必填的，哪个字段有哪些要求，最大长度为多少，哪个字段必须是什么数据类型等等。</p><p>PS：JSON Schema同样需要用双引号包裹。</p><p>例子：</p><p> <img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/json_2.png" alt=""></p><p>这就是一个Schema文件。</p><p>在验证JSON的时候，JSON Schema Lint。</p><p>一方面输入JSON Schema，一方面输入JSON。</p><p>预防网络攻击：</p><p>1.JSON中存储的数组，应该放在对象中，使其成为非法的js，否则一个JSON只存储了一个数组，这时候它既是合法的JSON，也是合法的js，进行CSRF攻击则可以运行js，获取JSON里的敏感信息。CSRF，cross-site request forgery，（sea-surf）跨站请求伪造。</p><p>例子：不好的做法：(虽然最外面没加花括号，但它是合理的，这称为顶层JSON数组)</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"user"</span>: <span class="string">"bobbarker"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"phone"</span>: <span class="string">"555-555-5555"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>正确的做法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"info"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"user"</span>: <span class="string">"bobbarker"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"phone"</span>: <span class="string">"555-555-5555"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>XSS，cross-site scripting</em></strong>，跨站脚本攻击（注入攻击，通过向网站注入恶意代码来实现）</p><p>JSON是一个脚本，要代表对象再进行操作，需要将其转换成对象，并装入内存中。</p><p>在JavaScript中，使用eval( )函数可以将文本转换成对象。</p><p>当JSON被拦截并修改成恶意代码，用eval函数会直接变成调用JSON的脚本。比如JSON被修改成alert方法，eval方法本该是把JSON文本变成对象，但这里会直接调用了alert方法，即JSON如果被修改成一个脚本，eval方法就会变成执行该脚本。</p><p>正确的方法是，使用JSON.parse( )函数来替代eval。该函数仅会解析JSON，而不会执行脚本。所以如果JSON被修改成脚本，该parse就不会通过，报错并且不会执行脚本。</p><p>当用户之间的信息传递是用JSON传递的时候，必须要用eval，这个时候就可能出现，JSON里存在脚本，进行注入攻击。</p><p>可以使得信息中不能包含HTML，或者把HTML字符转码，比如把&lt;div&gt;转成&amp;lt;div&amp;gt;等</p><p>抵御注入攻击的关键：找出可能的注入点，并加入一些额外的步骤来加以防范。</p><p> JSON本身不构成什么威胁，它只是文本。</p><p><strong><em>在定位JSON安全问题的时候，应该记住以下三件事。</em></strong></p><p>①不要使用顶级数组。顶级数组是合法的Javascript脚本，它们可以用&lt;script&gt;标签链接并使用。</p><p>②对于不想公开的资源，仅允许使用HTTP POST方法请求，而不是GET方法。GET可以通过URL来请求，甚至可以放在&lt;script&gt;标签链接中。</p><p>③使用JSON.parse()来代替eval()。eval()函数会将传入的字符串编码并执行，这会使你的代码易被攻击。</p><p> 尽管Javascript的XMLHttpRequest对象看上去和XML有关，但实际上我们使用它来发起HTTP请求。在它包含XML的名字命名时，XML是在发起这类请求时最常用的数据交换格式。然而XMLHttpRequest并不仅限于使用XML，用于请求JSON是完全可以的。</p><p>从Web Api上获取JSON数据：（一个例子）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myXMLHttpRequest = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"http://api.openweathermap.org/data/2.5/weather?lat=35&amp;lon=139"</span>;</span><br><span class="line"></span><br><span class="line">myXMLHttpRequest.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myXMLHttpRequest.readyState === <span class="number">4</span> &amp;&amp; myXMLHttpRequest.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> myObject = <span class="built_in">JSON</span>.parse(myXMLHttpRequest.responseText);</span><br><span class="line">        <span class="keyword">var</span> myJSON = <span class="built_in">JSON</span>.stringify(myObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myXMLHttpRequest.open(<span class="string">"GET"</span>, url, <span class="literal">true</span>);</span><br><span class="line">myXMLHttpRequest.send();</span><br></pre></td></tr></table></figure><p>序列化：将对象转换成文本的过程。    反序列化：将文本转换成对象的过程</p><p>序列化：JSON.stringify( )                 反序列化：JSON.parse( )</p><p>浏览器一般对资源共享有限制，只允许来自同一域名的资源。</p><p>CORS，cross-origin resource sharing，跨域资源共享。</p><p>可以在响应头加上Access-Control-Allow前缀的属性，来控制，哪些HTTP方法可用，哪些域名可用等等。（在对抗CSRF时，设置只允许POST，则避免了CSRF的恶意GET方法。而且设置只允许同一域名可以获取资源，这样可以避免外部获取资源）</p><p>CORS,JSON-P</p><p> JSONP（JSON with Padding）是资料格式JSON的一种使用模式，可以让网页从别的网域索要资料。由于同源策略，一般来说位于server1.example.com的网页无法与不是server1.example.com的服务器沟通，而HTML的&lt;script&gt;元素是一个例外。利用&lt;script&gt;元素 的这个开放策略，网页可以得到从其他来源动态产生的JSON资料，而这种使用模式就是所谓的JSONP。用JSONP抓到的资料并不是JSON，而是任意的JavaScript，用JavaScript直译器执行而不是用JSON解析器解析。</p><p>JSON-P的padding（内联），就是将JavaScript加入JSON文档。如：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getTheAnimal(</span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">"animal"</span>: <span class="string">"cat"</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>内联于JSON文档的JavaScript调用了一个函数，函数参数是JSON。函数参数提供了一个将数据传递给函数的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章是阅读《JSON必知必会》所做的笔记。虽然JSON的内容比较少，但做成记录也是极好的。&lt;/p&gt;
&lt;p&gt;JSON是一种数据交换格式。JavaScript Object Notation&lt;/p&gt;
&lt;p&gt;JSON独立于编程语言。&lt;/p&gt;
&lt;p&gt;JSON需要用双引号包裹key-value。当值是字符串时，必须使用双引号。如果是&lt;strong&gt;数字，布尔值，数组，对象，null&lt;/strong&gt;等其他数据类型，则不应该被双引号包裹。多个key-value之间用逗号来分割。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://hongscar.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JSON" scheme="https://hongscar.cn/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>docker笔记</title>
    <link href="https://hongscar.cn/docker%E7%AC%94%E8%AE%B0.html"/>
    <id>https://hongscar.cn/docker%E7%AC%94%E8%AE%B0.html</id>
    <published>2020-02-17T15:02:23.000Z</published>
    <updated>2020-02-17T15:24:58.428Z</updated>
    
    <content type="html"><![CDATA[<p>记录docker学习的笔记。本文主要是参考了阮一峰的Docker教程，：<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html。在阅读完这篇Docker教程的过程中所做的笔记，用我自己的语言整理了一遍。" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html。在阅读完这篇Docker教程的过程中所做的笔记，用我自己的语言整理了一遍。</a></p><a id="more"></a><h3 id="Docker出现的原因，解决了哪些问题，如何解决的，有哪些应用？"><a href="#Docker出现的原因，解决了哪些问题，如何解决的，有哪些应用？" class="headerlink" title="Docker出现的原因，解决了哪些问题，如何解决的，有哪些应用？"></a>Docker出现的原因，解决了哪些问题，如何解决的，有哪些应用？</h3><p>软件开发的一个大难题，就是环境配置，经常出现各种因为环境配置而出现的错误。（我相信你在编写maven项目的时候就已经被各种依赖包的版本给困扰到了，环境变量同样如此）比如安装一个python应用，计算机必须要有python引擎，还要有各种依赖，可能还要配置环境变量。除此之外，随着软件的迭代还有运行环境的升级，一些老旧的模块可能与当前环境不兼容。开发者常常会说：“它在我的电脑上是没有问题的”（It works on my machine)，换言之，在其他电脑能不能运行，我不确定，我也不想管。环境变量如此麻烦，换一台机器就要重来一次，十分浪费时间。于是有人在想，能不能从根本上解决问题，比如软件可是带着环境变量一起安装？也就是说，在安装的时候，把原始环境一模一样地复制过来。</p><p>一种可行的解决方法，虚拟机。直接去现场对机器进行配置，或者去客户家配置电脑环境，并不现实，但使用虚拟机就可以达到模拟运行系统的效果，直接把开发时的最终环境一起打包，就可以彻底还原软件的原始环境。</p><p><strong>但这个方案存在一些缺点：</strong></p><p>①资源占用多。一个虚拟机是需要一定的内存和磁盘空间的，所以即使你的项目只有1MB，续集你依然要几百MB才能运行。</p><p>②冗余步骤多。一个虚拟机是一个完整的操作系统，所以一些系统级别的操作步骤，往往都不能跳过，比如用户登录。</p><p>③启动慢。启动的时候就跟启动一台电脑的时间一样。</p><p><strong>显然，为了保存运行环境，直接copy一个虚拟机，并不可取，因为我们需要的只是一些必要的环境变量，一些组件，而非一个彻底完整的操作系统。</strong>所以，我们需要的是一个虚拟的“小型虚拟机”，里面只包含我们的程序所需要的组件即可。这种东西就叫做：Linux容器(Linux Containers,LXC)</p><p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。因为的进程级别的，相比虚拟机就有很多的优势，比如：启动快，资源占用少，体积小。因为它只需要占用需要的资源，包含要用到的组件。总而言之，有点像轻量级的虚拟机。</p><p>Docker，就是一种LXC的封装，提供了简单易用的容器使用接口。Dockers将应用程序与该程序的依赖，一起打包在一个文件里面(image)。运行这个文件，就会生成一个虚拟容器(container)。程序在这个虚拟容器里运行，就好像在真实的物理机器上运行。有了Docker就无须担心环境问题。用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理，复制，分享，修改，就像管理普通的代码一样。</p><p><strong><em>Docker的主要用途：</em></strong></p><p>①提供一次性的环境。无论是开发环境，单元测试环境，还是其他，都可以轻松提供。</p><p>②提供弹性的云服务。因为Docker容器可以随开随关，很适合动态扩容和缩容。</p><p>③组建微服务架构。容器可以存放多个服务，还有它们的各种依赖。所以一台机器就可以跑多个服务，在本机就可以模拟出微服务架构。</p><h3 id="Docker重要概念："><a href="#Docker重要概念：" class="headerlink" title="Docker重要概念："></a>Docker重要概念：</h3><p>image文件：Docker把应用程序及其依赖，都打包在image文件里面。一个image文件可以通过继承另一个image文件，进行拓展。这是一个二进制文件</p><p>container：容器文件，通过image文件生成的实例，本身也是一个文件，称为容器文件。</p><p>（二者的关系，image就像class，container就像是具体的对象）</p><p>Dockerfile：它是一个文本文件，用于配置image。Docker根据该文件生成二进制的image文件（也就是说，我们要生成image文件，实际上是通过生成Dockerfile文件来指定依赖）</p><p>(而且，Dockerfile的文件名必须就叫Dockerfile，这样也使得后续用Dockerfile构建image的时候，直接指定Dockerfile的路径即可，那个参数是【path】，所以无法指定具体的文件名）</p><p>编写Dockerfile文件的过程：</p><p>1.在项目的根目录，新建一个文件 .dockerignore    (就是忽略的路径），（可选）</p><p>.git node_modules npm-debug.log</p><p>2.创建一个文本文件Dockerfile，写入：    （举例）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FROM node:8.4 COPY . /app WORKDIR /app RUN npm install --registry=https://registry.npm.taobao.org EXPOSE 3000</span><br><span class="line"></span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure><p>每一行的含义：</p><p>FROM：表明要继承哪个image，这里继承的官方的node image，版本号是8.4（默认library/…)</p><p>COPY：将当前目录下的所有文件，（除了.dockerignore里提到的），都copy到image文件里的/app目录</p><p>WORKDIR：指定工作路径</p><p>RUN……：启动成功之后会运行的命令，这里是运行npm install安装依赖</p><p>EXPOSE：将容器暴露特定的端口号，允许外部连接这个端口</p><p>CMD：在容器成功启动后，会自动执行该命令</p><p>（ps：RUN和CMD有什么区别？RUN命令是在image文件的构建阶段执行，执行的结果都会打包进入image文件。而CMD命令则是在容器启动成功后执行。另外，一个dockerfile可以包含多个RUN命令，但只能有一个CMD命令。同时，指定了CMD命令之后，docker container run命令就不能附加命令，否则它会覆盖掉CMD命令，也就是docker run的CMD命令把dockerfile里的覆盖了。）</p><h3 id="Docker常用命令："><a href="#Docker常用命令：" class="headerlink" title="Docker常用命令："></a>Docker常用命令：</h3><p>①列出本机的所有image</p><p><code>docker image ls    /     docker images</code></p><p>删除image文件</p><p><code>docker image rm 【imageName】</code></p><p>从Docker仓库抓取具体image到本地（默认是官方仓库，可配置国内的镜像文件）</p><p><code>docker image pull 【path/.../imageName】</code>    （前面默认的path是 library/，是官方仓库的默认组）</p><p>②通过image生成container实例，并运行该实例</p><p><code>docker container run 【imageName】</code>        （如果本地无法找到，会自动去仓库抓取，即pull）</p><p>列出本地的container：</p><p><code>docker container ls    [ -all ]        /    docker ps</code></p><p>删除container：    </p><p><code>docker container rm 【containerID】</code></p><p>docker container run的一些参数：</p><p>例子：<code>docker container run -p 8000:3000 -it koa-demo /bin/bash</code></p><p>-p：容器的3000端口，映射到本机的8000端口</p><p>-it：容器的Shell映射到当前的Shell，然后你在本机窗口输入的命令，就会传入容器中</p><p>/xxx：容器启动之后，内部第一个执行的命令。这里是启动Bash，保证用户可以使用Shell</p><p>退出容器：先ctrl+c停止进程，在ctrl+d退出容器。</p><p><code>docker contain kill</code>：终止容器运行</p><p>退出之后，容器文件并不会删除，所以需要手动rm，但应该删除，下次再由image创建。可以在运行时增加一个参数–rm，表明容器终止运行后自动删除容器文件。</p><p>③使用Dockerfile文件，创建image文件：</p><p><code>docker image build -t xxx .</code>(docker image build，-t表明image文件的名字，  “.”表示当前路径）</p><p>（xxx可以指定版本号，格式为 xxx:yyy，放在冒号之后。如果不指定版本号，默认为latest）</p><p>（ps：   docker image build == docker build）</p><p>④一些有用的命令</p><p><code>docker container start</code></p><p>（docker container run命令是新建容器，每运行一次，就会新建一个容器，如果同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器（当然，没有–rm参数了），那么就要使用docker container start命令，用于启动已经生成，已经停止运行的容器文件。</p><p><code>docker container stop</code></p><p>（docker contain kill是向容器里面的主进程发出SIGKILL信号，而docker container stop是发出SIGTERM信号，然后过一段时间再发出SIGKILL信号。这两个信号的的差别是，如果进程收到SIGTERM信号，可以自行进行收尾清理工作，但也可以不理会这个信号。而如果收到SIGKILL信号，就会强行立即终止，那么正在进行中的操作会全部丢失。也就是说，kill是强制性立即关闭，而stop会给一定的时间让container把收尾工作完成，如果超出一定时间后还没完成收尾，那么才强制结束）</p><p><code>docker container logs</code></p><p>用于查看容器的输出，即容器里Shell的标准输出。如果容器docker run的时候没有使用-it参数，就要用这个命令查看输出。（或者是显式指定要运行在后端的时候）</p><p><code>docker container exec</code></p><p>docker container exec命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令.</p><p><code>docker container cp</code></p><p>用于从正在运行的Docker容器里面，将文件拷贝到本机。</p><p>写法：<code>docker container cp 【containerID】:【/path/to/file】</code></p><p>-—-</p><h3 id="实例：使用Docker架设WordPress网站（需要WordPress容器和MySQL容器）"><a href="#实例：使用Docker架设WordPress网站（需要WordPress容器和MySQL容器）" class="headerlink" title="实例：使用Docker架设WordPress网站（需要WordPress容器和MySQL容器）"></a>实例：使用Docker架设WordPress网站（需要WordPress容器和MySQL容器）</h3><p>方法一：自己自建WordPress容器</p><p>步骤：</p><p>①通过官方的PHP image，构建一个PHP container    例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">--rm \// 停止运行后，自动删除容器文件</span><br><span class="line">--name wordpress \// 容器的名字  </span><br><span class="line">--volume <span class="string">"<span class="variable">$PWD</span>/"</span>:/var/www/html \</span><br><span class="line">// 将当前目录（<span class="variable">$PWD</span>)映射到/var/www/html（即Apache对外访问的默认目录）  </span><br><span class="line">php:5.6-apache// image名，说明装的是PHP 5.6版本，并且自带apache服务器</span><br></pre></td></tr></table></figure><p>②之后在当前目录下创建的文件，都会直接被Apache服务器提供给外界访问，所以直接把WordPress安装包拷贝到此处，就可以通过容器访问到WordPress的安装界面</p><p>所以这一步很简单，wget下载，然后tar -xvf解压即可。</p><p>（遇到的小问题，由于太多国人使用WordPress了，大概是导致别人服务器都炸了，于是WordPress已经默认屏蔽了大陆的IP，所以直接wget是不可行的。解决就是在windows自己找资源，再传）</p><p>③使用MySQL image来构建MySQL container，例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">-d \  </span><br><span class="line">--rm \  </span><br><span class="line">--name wordpressdb \  </span><br><span class="line">--env MYSQL_ROOT_PASSWORD=123456 \ </span><br><span class="line">--env MYSQL_DATABASE=wordpress \  </span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p>每行参数的含义：</p><p>-d：容器启动后，在后台运行（这时候要查看输出就需要用logs</p><p>–rm， –name：自动删除，容器名</p><p>–env：向容器进程传入一个环境变量MYSQL_ROOT_PASSWORD，该变量会作为MySQL的根密码，同时还传入一个MYSQL_DATABASE，容器里面的MySQL会根据该变量创建一个同名的数据库</p><p>④定制Container，也就是Dockerfile</p><p>此时WordPress容器和MySQL容器都已经有了，但二者并没有链接到PHP Container中。我们需要先在PHP image的基础上，安装mysqli的拓展，然后启动Apache。Dockerfile文件如下：</p><p><code>FROM php:5.6-apache RUN docker-php-ext-install mysqli CMD apache2-foreground</code></p><p>然后再基于Dockerfile创建一个image文件（包含了mysqli拓展的PHP image）</p><p><code>docker build -t phpwithmysql .</code>    （该image文件名为phpwithmysql）</p><p>⑤WordPress容器链接mysql</p><p>PHP container已经增加了mysqli的拓展，而对于WordPress，在启动的时候连接即可。启动命令如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">--rm \  </span><br><span class="line">--name wordpress \  </span><br><span class="line">--volume <span class="string">"<span class="variable">$PWD</span>/"</span>:/var/www/html \// --volume  == -v  </span><br><span class="line">--link wordpressdb:mysql \  </span><br><span class="line">phpwithmysql</span><br></pre></td></tr></table></figure><p>新加的那行，表示WordPress容器要连接到wordpressdb容器，冒号表示该容器的别名为mysql。最后还要修改一下wordpress目录的权限，让容器可以将配置信息写入这个目录（/var/www/html)</p><p><code>chmod -R 777 wordpress</code></p><p>接着，在启动PHP container的时候，命令行会返回一个对外开放的IP地址，比如172.17.0.2,直接访问即可出现WordPress的安装界面。</p><p>总结：PHP image（web server） + wordpress.tar.gz(到/var/www/html) + mysql链接</p><p>方法二：</p><p>方法一需要自己创建WordPress容器，还是有点麻烦，实际上Docker已经提供了官方的WordPress image，直接用那个即可。</p><p>步骤：</p><p>①新建并启动MySQL Container（跟方法1一样）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">-d \  </span><br><span class="line">--rm \  </span><br><span class="line">--name wordpressdb \  </span><br><span class="line">--env MYSQL_ROOT_PASSWORD=123456 \  </span><br><span class="line">--env MYSQL_DATABASE=wordpress \  </span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p>②然后基于官方的WordPress image，创建WordPress Container</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">-d \  --rm \  </span><br><span class="line">--name wordpress \  </span><br><span class="line">--env WORDPRESS_DB_PASSWORD=123456 \  </span><br><span class="line">--link wordpressdb:mysql \ </span><br><span class="line">wordpress</span><br></pre></td></tr></table></figure><p>（方法一，我们需要给php image增加mysqli拓展，然后启动php container，作为我们自己创建的WordPress image，然后再link数据库，实际上，直接一个wordpress即可（调用官方Docker）</p><p>但是，上面指定了-d，也就是在后台运行，所以前台看不到输出，此时需要inspect命令查看输出。</p><p><code>docker container inspect wordpress</code></p><p>找到IPAddress字段，那就是对外开放的IP地址，直接访问即可。</p><p>此时虽然用了官方的WordPress image，简化了很多不必要的步骤，但还是存在一些问题。比如，每次新建容器，返回的IP地址不能保证相同，导致需要更换IP地址来访问WordPress。WordPress安装在容器里面，本地无法修改文件。解决方法如下:</p><p>创建WordPress Container的命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">-d \  </span><br><span class="line">-p 127.0.0.2:8080:80 \  </span><br><span class="line">--rm \  </span><br><span class="line">--name wordpress \  </span><br><span class="line">--env WORDPRESS_DB_PASSWORD=123456 \  </span><br><span class="line">--link wordpressdb:mysql \  </span><br><span class="line">--volume <span class="string">"<span class="variable">$PWD</span>/wordpress"</span>:/var/www/html \  </span><br><span class="line">wordpress</span><br></pre></td></tr></table></figure><p>只新加了两行参数：</p><ul><li>-p 127.0.0.2:8080:80：将容器的 80 端口映射到127.0.0.2的8080端口。</li><li>–volume “$PWD/wordpress”:/var/www/html：将容器的/var/www/html目录映射到当前目录的wordpress子目录。</li></ul><p>这样我们就固定了IP地址，同时还指定了一下端口的映射，还有容器的文件目录映射。（容器会把文件默认放到Apache的默认路径，然后再映射到wordpress子目录，使得本地也可以修改文件）</p><p>方法三：</p><p>方法二主要是，分别启动两个容器，然后在启动时，在命令行里提供容器之间的连接信息。还有一种更简单的方法，就是使用Docker Compose。关键点：定义一个YAML格式的配置文件，在里面写好多个容器之间的调用关系，只需要一个命令就可以同时启动/关闭这些容器。</p><p>步骤：</p><p>①安装，pass</p><p>②创建yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysql:</span>    </span><br><span class="line"><span class="attr">image:</span> <span class="string">mysql:5.7</span>    </span><br><span class="line"><span class="attr">environment:</span>     </span><br><span class="line"><span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span>     </span><br><span class="line"><span class="bullet">-</span> <span class="string">MYSQL_DATABASE=wordpress</span> </span><br><span class="line"><span class="attr">web:</span>    </span><br><span class="line"><span class="attr">image:</span> <span class="string">wordpress</span>    </span><br><span class="line"><span class="attr">links:</span>     </span><br><span class="line"><span class="bullet">-</span> <span class="string">mysql</span>    </span><br><span class="line"><span class="attr">environment:</span>     </span><br><span class="line"><span class="bullet">-</span> <span class="string">WORDPRESS_DB_PASSWORD=123456</span>    </span><br><span class="line"><span class="attr">ports:</span>    </span><br><span class="line">    <span class="bullet">-</span> <span class="string">"127.0.0.3:8080:80"</span>    </span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/var/www/html</span>    </span><br><span class="line">    <span class="attr">volumes:</span>     </span><br><span class="line">    <span class="bullet">-</span> <span class="string">wordpress:/var/www/html</span></span><br></pre></td></tr></table></figure><p>（显然，一个是mysql容器，一个是web容器）</p><p>启动：<code>docker-compose up</code>        （同时启动两个容器，此时就可以访问127.0.0.3到安装界面）</p><p>关闭：<code>docker-compose stop</code></p><p>关闭之后，容器文件还是存在的，写在里面的数据也不会丢失。下次再启动的时候，还可以复用。如果要删除，需要先暂停两个容器，然后调用删除命令：</p><p><code>docker-compose rm</code></p><p>首先是自定义image，然后启动，连接。后续的改进是，可以直接用官方或者别人写好的image来进行启动，连接。最后的方法是，直接使用docker-compose，不需要在启动命令的时候写一堆参数，直接写到yml文件里即可，同时还能保存容器信息，进行复用。自此，Docker的基本示例到此结束。</p><p>参考：<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p><p>PS：    （很多情况下可以省略image ， container等关键字）</p><p>docker image build  == docker build</p><p>docker container run == docker run（即使是run image，也是构建出container）</p><p>docker container rm = docker rm</p><p>docker container stop = docker stop</p><p>进入容器，除了exec，还可以用attach：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_8.png" alt="img"></p><p>删除所有容器（包括已经结束了的）：</p><p><code>docker rm -f $(docker ps -a -q)</code></p><p>删除所有image：</p><p><code>docker rmi -f $(docker images)</code></p><p>导出容器为压缩包：</p><p><code>docker export 【options】 container_id &gt; xxx.tar</code>    (&gt; xxx其实不是必须的）</p><p>导入容器：</p><p><code>docker import xxx.tar container_name</code></p><p>Dockerfile一些常用指令：</p><p>FROM：表示基本的image（一般是Docker Hub或者其他仓库别人制作好的image），在此基础上进行修改调整。FROM必须在其他指令之前。</p><p>RUN：启动成功之后会执行的命令</p><p>CMD：容器启动成功之后执行的（区别上面看RUN与CMD的区别，记住多条CMD只会执行一条，所以如果启动时docker run存在CMD命令，那么会直接把Dockerfile的CMD命令全部忽略掉）</p><p>ADD：添加源文件到目的路径。如果路径不以斜杠结尾，被视为文件。如果源文件是可识别的压缩包格式，docker还会自动解压</p><p>ARG：设置构造参数    ENV：设置环境变量</p><p>（ARG与ENV的区别：ARG设置的是构建时的环境变量，在容器运行时是不会存在这些变量的。ENV主要就是运行时的环境变量）</p><p>COPY：与ADD类似，但不支持URL和压缩包（ADD除了文件，还可以是URL或压缩包）</p><p>EXPOSE:声明暴露的端口</p><p>LABEL：为镜像添加元数据metadata</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录docker学习的笔记。本文主要是参考了阮一峰的Docker教程，：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html。在阅读完这篇Docker教程的过程中所做的笔记，用我自己的语言整理了一遍。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html。在阅读完这篇Docker教程的过程中所做的笔记，用我自己的语言整理了一遍。&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://hongscar.cn/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://hongscar.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码阅读</title>
    <link href="https://hongscar.cn/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html"/>
    <id>https://hongscar.cn/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html</id>
    <published>2020-02-17T03:51:39.000Z</published>
    <updated>2020-02-17T14:51:14.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言："><a href="#一-前言：" class="headerlink" title="一. 前言："></a>一. 前言：</h3><p>​        在准备面试的过程中，发现HashMap源码是很常见的考点，于是进行了仔细的学习。以前都说读源码是快速提高Java水平的好途径，在阅读了HashMap的部分重要源码之后真的是深有体会，于是写下此篇文章做记录。具体内容包括，HashMap的构造方法，put，get方法，以及put&amp;get所需要的hash方法，还有扩容时所需要的resize方法。我们将对这几个方法的源码进行阅读，理解它的逻辑，以及一些巧妙的设计。</p><a id="more"></a><h3 id="二-HashMap原理："><a href="#二-HashMap原理：" class="headerlink" title="二. HashMap原理："></a>二. HashMap原理：</h3><p>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。<br><strong>常用的方法有</strong>：<br>构造方法，可以定义initialCapacity初始容量，factor负载因子。threshold = initialCapacity * factor<br>put，get，二者需要用到hash方法，也就是散列函数。<br>resize：放数组容量不足时，元素个数大于threshold时，就要扩容。<br>HashMap使用数组链表来存储数据（数组的每一项都是一个链表），JDK1.8开始，当链表的长度到达一定程度，就会把该链表转换成红黑树。</p><hr><h3 id="三-①-构造方法："><a href="#三-①-构造方法：" class="headerlink" title="三. ① 构造方法："></a>三. ① 构造方法：</h3><p>构造方法一共有4个：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_1.png" target="_blank" rel="noopener" title="HashMap构造方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_1.png" alt="HashMap构造方法" title="HashMap构造方法"></a><br>显然，第一个就是没有参数，此时会设置默认的负载因子factor。<br>对于第二个，实际上就是将float参数设置为默认的负载因子default_factor。<br>对于第四个，是传入一个Map对象进行初始化。我们重点看第三个构造方法：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_2.png" target="_blank" rel="noopener" title="第三个构造方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_2.png" alt="第三个构造方法" title="第三个构造方法"></a><br>前面的都是判断一下边界值，就省略了。<br>HashMap有几个关键的成员属性：<br><em>initialCapacity</em>：初始容量大小（数组大小，但后面会改变）<br><em>factor</em>：负载因子<br><em>threshold</em>：initialCapacity * factor（到达这个值的时候，哈希数组会扩容）<br>（初始化之后，后续用size表示哈希数组里的元素个数，当size超过threshold之后，扩容）<br>然后我们发现一行关键的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br></pre></td></tr></table></figure><p>点进入看<em>tableSizeFor</em>的函数逻辑：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_3.png" target="_blank" rel="noopener" title="tableSizeFor"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_3.png" alt="tableSizeFor" title="tableSizeFor"></a><br>可以看到这个方法的目的：<strong>returns a power of two size for the given target capacity</strong></p><p>也就是说，<strong>哈希数组的长度，永远是2的幂次方</strong>，至于为什么，请看后面的<strong>question1</strong>.<br>关于这个算法的逻辑，用下图可以说明：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_4.png" target="_blank" rel="noopener" title="tableSizeFor算法的逻辑"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_4.png" alt="tableSizeFor算法的逻辑" title="tableSizeFor算法的逻辑"></a><br>连续的n |= n &gt;&gt;&gt; 1, 2, 4, 8, 16，通过这样，最多可以让连续32位为1.不管capacity是多少，比如它是1011，减去1之后是1010，第一个不为0的位是第4位，那么这个算法会返回10000.<br>（这里的关键是<strong>或运算</strong>，因为第一位是1，1和任何数字进行或运算都为1，因此，n&gt;&gt;&gt;1，会使得n的前2位变为2，然后再执行n&gt;&gt;&gt;2，就是前4位，再执行n&gt;&gt;&gt;4，就是前8位。）如果数字没有那么高位，那么高位全是0，并且n&gt;&gt;&gt;x全部都为0，因而或运算为0，高位没有任何影响，看下图例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_5.png" target="_blank" rel="noopener" title="高位运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_5.png" alt="高位运算" title="高位运算"></a><br>这个算法，巧妙地通过了位运算，返回了一个不小于capacity 的最小2的幂次方。至于为什么要-1，是防止capacity已经是2的幂次方的情况，比如是10000，如果不减1，那么返回的将会是100000.减去1，使得初始的capacity改为1111（1111和1001，1101等都是一样的）。<br>以上的情况都是在capacity不为0的情况考虑的，而当capacity为0的时候，无论经过几次运算，都为0，那么最后的capacity将为1（最后有一个n+1的操作），所以也是符合预期结果的。<br>这样，我们就得到了一个2的幂次方的capacity，即哈希数组的长度（所以比如，当我们传入的capacity为12，最终生成的数组长度会是16.）<br>结果：<br> // 如果没有指定initialCapacity, 则不会给threshold赋值, 该值被初始化为0<br> // 如果指定了initialCapacity, 该值被初始化成不小于initialCapacity的最小的2的次幂</p><hr><h3 id="四-②put方法："><a href="#四-②put方法：" class="headerlink" title="四. ②put方法："></a>四. ②put方法：</h3><p>可以看到，put方法其实还有两个参数，但put方法并没有重载方法，所以如果我们需要改变后两个参数，应该使用putVal方法自己修改，但一般不需要，在下文看putVal的方法里我们就知道着两个参数是什么作用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**接下来关键是看putVal的方法实现：（逐行分析，中文注释）</p><p>**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">//创建一些后面需要的变量，略</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"><span class="comment">//如果哈希数组为空，即还没初始化，先resize一次，resize后面再看，这里只需要知道</span></span><br><span class="line"><span class="comment">//会创建一个默认长度的哈希数组即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//如果哈希数组该index没有元素，即没有发生碰撞，直接插入一个newNode即可。</span></span><br><span class="line"><span class="comment">//这里的(n - 1) &amp; hash的原理，查看后面的question2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//说明已经有元素，发生了碰撞，然后我们就沿着链表/红黑树去插入Node</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">//我们首先会查看第一个元素（在第一个元素时就能确定它是链表还是数组）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"><span class="comment">//这里的p是上文的p = tab[i = (n - 1) &amp; hash]，即第一个元素，如果第一个元素跟待插入</span></span><br><span class="line"><span class="comment">//的元素是相同的，即key相同（hash肯定是已经相同的了），然后我们只需要更改p的值</span></span><br><span class="line"><span class="comment">//即可。这里的逻辑是，把p赋值给新创建的Node e，然后跳出整个循环之后，再判断e</span></span><br><span class="line"><span class="comment">//是否位null，如果e为null，那么直接进行value的替换即可，否则，往后看。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="comment">//判断该index项是链表还是红黑树，如果是红黑树再进入putTreeVal，此处略</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//说明是链表，并且第一个元素也不相等，所以我们就遍历链表，然后插入到链表的最</span></span><br><span class="line"><span class="comment">//后，并且，如果链表长度过长，还会引起链表树化的操作。如果是整个数组的长度过</span></span><br><span class="line"><span class="comment">//大，那么还要对数组进行resize。（PS：这里的元素相等是指key，链表里的key都是互</span></span><br><span class="line"><span class="comment">//不相等的，只是它们发生hash冲突导致都放在数组的同一个index上。所以如果在中间</span></span><br><span class="line"><span class="comment">//发现了相同的key，那么就跟前面一样，其实也是e = p的逻辑，然后在后续直接覆盖</span></span><br><span class="line"><span class="comment">//value即可。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//p.next为null，那么直接将p.next新建一个newNode即可。即已经到达链表的最后。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line"><span class="comment">//这是指链表长度大于等于TREEIFY_THRESHOLD的时候，进行树化。默认是8.注意这</span></span><br><span class="line"><span class="comment">//里为什么是&gt;= THREIFY_THRESHOLD，看起来是7个就可以树化，但实际上还是8个</span></span><br><span class="line"><span class="comment">//的。具体的看后面的question4.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="comment">//如果遇到了相等的key，那么就是覆盖value。注意此时并未到链表的最后，所以这里的</span></span><br><span class="line"><span class="comment">//e不等于null。而上面的(e = p.next) == null，上面逻辑的e会是null。这个e后面马上用到</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line"><span class="comment">//这里的p = e实际上就是 p = p.next，因为并没有执行for循环里的两个if，如果执行了其</span></span><br><span class="line"><span class="comment">//中一个，都会直接break跳出循环。（个人觉得这个p = e放在for判定语句里可读性更好</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="comment">//这就是前面一直说的e，如果存在相同的key，那么e就不是null，此时直接覆盖value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">//这就是第三个参数，表示已有相同的key时是否更新。onlyIfAbsent默认是false，所以这</span></span><br><span class="line"><span class="comment">//里的if是一定会触发，即一定会覆盖value。如果手动将onlyIfAbsent改为true，那么就是</span></span><br><span class="line"><span class="comment">//只有当oldValue为null的时候，才能改变key的value，否则都不会改变。</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line"><span class="comment">//这个在HashMap是空方法，在LinkedHashMap的时候才会被重写并使用。</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="comment">//覆盖了value（或者不覆盖），就把oldValue返回，方法结束。因此插入一个相同key的</span></span><br><span class="line"><span class="comment">//元素，实际上是更新该key的value，方法的逻辑在这里已经完成，不会改变HashMap的</span></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//最外层的if-else循环结束</span></span><br><span class="line">    ++modCount;</span><br><span class="line"><span class="comment">//到达了这里，说明不存在相同的key，所以插入了一个新的key，改变modCount以及</span></span><br><span class="line"><span class="comment">//哈希数组的元素个数size</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line"><span class="comment">//如果改变了之后，哈希数组的元素个数大于threshold，此时发生碰撞的概率较大，因此</span></span><br><span class="line"><span class="comment">//进行resize，即对哈希数组进行扩容，后面会讲到。</span></span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">//同样是LinkedHashMap的东西，此处为空方法。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要是这么几个步骤：</strong><br>如果当前table为空，先进行初始化<br>查找插入的键值对是否存在，存在的话，先进行赋值，后续将更新旧的键值对<br>不存在，插入链表尾部，如果链表长度大于一个阈值，进行链表转化树的操作<br>如果size大于一个阈值，进行扩容<br>PS：threshold在初始化的时候，值为2的幂次方（在tableForSize那里可以看到），但threshold应该是capacity * factor，当size大于threshold的时候才执行resize。那么会不会因此而导致初始化的时候threshold并不受factor的影响？<br>（比如我们初始化的时候，capacity传参是10，factor是0.75，在tableForSize里，我们知道threshold会被赋值为不小于10的2的幂次方，即16.然后根据put的逻辑，应当是++size &gt; threshold的时候才扩容，那么初始化的threshold是16，而不是预期的值16 * 0.75 = 12？）<br>实际上并不是的，上面的threshold实际上就不应该是哈希数组的长度（所以JDK源码在构造方法里，把2的幂次方赋值给threshold确实有迷惑的意思）。在put方法的第一个步骤，即“如果当前table为空，先进行初始化”。那么我们再看一下这一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure><p>当table为空，那么要先resize，即数组是在这里才进行建立的。在resize里面，是把threshold赋值给了另一个叫newCap的变量（看变量名可知，显然就是新的哈希数组的长度），然后threshold又会被改变为newCap * factor。所以threshold虽然确实是2的幂次方，但确实并不是代表哈希数组的长度，仍然是作为扩容的判断点（<strong>虽然是个无聊的问题，但感觉是JDK源码的变量具有迷惑性！</strong>）至于resize的源码，继续看。</p><hr><h3 id="五-③get"><a href="#五-③get" class="headerlink" title="五. ③get"></a>五. ③get</h3><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_6.png" target="_blank" rel="noopener" title="get方法的源码"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_6.png" alt="get方法的源码" title="get方法的源码"></a><br>get方法显然简单很多。首先判断是否存在该key，如果不存在，返回null。<br>getNode的逻辑体也是比较简单，先查找第一个元素，看key值是否相等。至于为什么需要“always check first node”，显然，因为<strong>JDK1.8可能是链表，可能是红黑树，需要进行判断</strong>。<br>如果当第一个first就是相等的，那么就直接返回。如果不在，判断是否是红黑树，如果是，使用另一套逻辑，如果不是，就是简单的链表遍历，对比，e = e.next，应该很好理解，此处略。</p><hr><h3 id="六-④hash"><a href="#六-④hash" class="headerlink" title="六. ④hash"></a>六. ④hash</h3><p>首先给出<strong>HashMap计算哈希码的整体步骤</strong>：<br><em>1.获取key的hashCode</em><br><em>2.对hashCode进行处理（hash方法），主要是高16位不变，而低16位与高16位进行异或操作</em><br><em>3.对capacity进行取模（使用了 hash &amp; (n - 1)进行优化）</em><br>在put和get方法中，可以看到都需要对key进行hash运算：</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_7.png" target="_blank" rel="noopener" title="put方法的hash运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_7.png" alt="put方法的hash运算" title="put方法的hash运算"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_8.png" target="_blank" rel="noopener" title="get方法的hash运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_8.png" alt="get方法的hash运算" title="get方法的hash运算"></a></p><p>因为<strong>hashcode就是为了HashMap而生的</strong>，在学习重写equals时为何要重写hashCode的时候我们就已经知道了。那么HashMap里到底如何重写hashCode方法呢，如下：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_9.png" target="_blank" rel="noopener" title="HashMap中的hashCode方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_9.png" alt="HashMap中的hashCode方法" title="HashMap中的hashCode方法"></a><br>嗯。。。很简单的异或运算，结合了key和value的hashCode，没什么特别的。结合value同样是减少碰撞。这个就是步骤1.</p><p>那么接下来看一下步骤2，HashMap自定义的hash方法：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_10.png" target="_blank" rel="noopener" title="HashMap中自定义的hash方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_10.png" alt="HashMap中自定义的hash方法" title="HashMap中自定义的hash方法"></a><br>从逻辑上看，就是hash本身与hash右移16位的结果进行异或。<br>h &gt;&gt;&gt; 16的结果：高16位全部变成0，原本高16位的处于低16位。<br>h ^ ( h &gt;&gt;&gt; 16)的结果：<br>1.高16位不变。<strong>因为0与任何数进行异或，返回的都是那个数本身</strong>。0 ^ 1 = 1, 0 ^ 0 = 0<br>2.低16位于原本的高16位进行异或。<br>步骤3对capacity取模，很好理解，不能超出哈希数组的范围。第二步的意义何在？看<strong>question3</strong>.</p><hr><h3 id="七-⑤resize"><a href="#七-⑤resize" class="headerlink" title="七. ⑤resize"></a>七. ⑤resize</h3><p>在put的过程中，当size超出了threshold，那么就需要进行resize扩容。逻辑比较复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//oldCap表明，table里原本已经存在key-value</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">//如果oldCap都已经扩容到最大了，那么就直接将threshold设为最大值，只好任你碰撞</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line"><span class="comment">//没有超出最大值，那么就安心扩容为原来的 2倍。值得注意的是newCap跟newThr都扩</span></span><br><span class="line"><span class="comment">//容为 2倍，仔细看 if 语句的判定。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line"><span class="comment">//这个就是我们前面所说的，当初始化的时候，会将threshold仅仅作为一个变量赋值给</span></span><br><span class="line"><span class="comment">//newCap，然后后面又把newCap*factor赋值给threshold</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line"><span class="comment">//这里就是调用new HashMap( )的情况，一个构造参数也没有的时候，直接赋默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//当上面第一个if里面没有执行里面的两个子if语句时，newThr仍然没有变化，即为0.需要在这里再对threshold进行修改。</span></span><br><span class="line"><span class="comment">//（比如上面的： else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span></span><br><span class="line"><span class="comment">//                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)，此时newCap可能超出了MAX，那么</span></span><br><span class="line"><span class="comment">//newThr就仍然为0.又或者是 else if (oldThr &gt; 0)  newCap = oldThr;中，即初始化带int参数的时</span></span><br><span class="line"><span class="comment">//候，这里仍然没有对threshold进行赋值。）</span></span><br><span class="line"> <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"><span class="comment">//这段代码就是普通地判断threshold是否会超出MAX而已</span></span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"><span class="comment">//我们已经将新数组的各种参数（capacity，threshold等）都设置好了，接下来需要将原</span></span><br><span class="line"><span class="comment">//本的数组元素放入到新的哈希数组中。显然，因为这个操作，使得resize方法是一个极</span></span><br><span class="line"><span class="comment">//其耗费时间的方法，所以在大概知道元素个数的时候，不应该使用默认值16，而是显式</span></span><br><span class="line"><span class="comment">//定义HashMap的初始容量，减少resize次数，可以显著地提高效率</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//这里table中存放的只是Node的引用, 将oldTab[j]=null只是清除旧表的引用, 但是真正的</span></span><br><span class="line"><span class="comment">//node节点还在, 只是现在由e指向它。所以这里主要是提醒JVM，这里可以被GC清理了</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 如果该存储桶里面没有元素, 就直接将它放到新表的目标位置</span></span><br><span class="line">    </span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果是树，则根据红黑树的逻辑拆分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line"><span class="comment">// 不是红黑树，那么就是链表。因此我们需要把该链表放入新的哈希数组的位置。</span></span><br><span class="line"><span class="comment">//主要是获取整条链表（即使只有 1个元素，结构仍然是链表）。</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//设置了两个链表，原因是根据不同情况，插入到不同的链表，最后再根据结果赋值</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;<span class="comment">//第n位为0</span></span><br><span class="line"><span class="comment">// 我们知道hash &amp; (n - 1)就是原本的位置，那么hash &amp; n是什么？原本的哈希值为n - 1</span></span><br><span class="line"><span class="comment">//位，当它扩容之后，它的哈希值位n - 1或者n位，即第n位要么是0，要么是1，而</span></span><br><span class="line"><span class="comment">//hash &amp; n就是能获取第n位的值，在后面我们会解释为什么</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;<span class="comment">//第n位为1</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);<span class="comment">//此处do-while刚好使得循环至少执行1次</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;<span class="comment">//根据0还是1决定赋值哪个</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于resize的最后那一部分：<br>在JDK1.7之前，都是直接再计算一次hash，然后放入新的哈希数组位置（index,bucket）。<br>但在JDK1.8中，代码得到了改进，看一下官方注释：<br><strong><em>Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</em></strong><br>大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。（n - 1位哈希码，变成n - 1位或 n位）<br>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_11.png" target="_blank" rel="noopener" title="resize时hash位置的变化"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_11.png" alt="resize时hash位置的变化" title="resize时hash位置的变化"></a><br>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_12.png" target="_blank" rel="noopener" title="resize后index的变化"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_12.png" alt="resize后index的变化" title="resize后index的变化"></a><br>因此，<strong>我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</strong>可以看看下图为16扩充为32的resize示意图：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_13.png" target="_blank" rel="noopener" title="resize整个示意图"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_13.png" alt="resize整个示意图" title="resize整个示意图"></a><br>那么，<strong>为什么 hash &amp; n就是可以获得第n位的值呢？</strong><br>首先我们必须知道，n是一个2的幂次方数，它的二进制i形式是00……1000……<br>易知，0 &amp; x = 0，1 &amp; x = x，而我们就是想要hash值的第n位的x值。<br>因此，hash &amp; n，刚好就是取到了新的hash值的第n位的x值。<br>故得出结论:    （最后的if，else判断）<br>如果 (e.hash &amp; oldCap) == 0 则该节点在新表的下标位置与旧表一致都为 j<br>如果 (e.hash &amp; oldCap) == 1 则该节点在新表的下标位置 j + oldCap</p><hr><hr><h3 id="八-中间遗留出来的questions："><a href="#八-中间遗留出来的questions：" class="headerlink" title="八. 中间遗留出来的questions："></a>八. 中间遗留出来的questions：</h3><p><strong>question1：哈希数组的长度为什么需要是2的幂次方？</strong><br>ans：因为在映射的时候，需要执行(n - 1) &amp; hash，当n不为2的幂次方的时候，n的个位为1，(n - 1)的个位则为0，又因为0 &amp; x = 0，因此使得最后一位必定是0，即浪费了1个位的空间，碰撞的几率也会增大。而如果n是2的幂次方，那么(n - 1)的个位必定是1，1 &amp; x = x，即根据hash的个位来决定，而不是一定返回0，因此能降低碰撞几率，充分利用每一个位。</p><hr><p><strong>question2： （n - 1 ) &amp; hash的原理？</strong><br>ans：因为n是2的幂次方，因而(n - 1)的值位000……1111（若干个1.(n - 1) &amp; hash，即返回hash的低<br>⌈log2(n - 1)⌉ （2为底）位的值，即hash &amp; n。如下图：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_14.png" target="_blank" rel="noopener" title="hash &amp; (n - 1)"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_14.png" alt="hash &amp; (n - 1)" title="hash &amp; (n - 1)"></a><br>使用(n - 1) &amp; hash而不使用hash % n的好处：<br>位运算是计算机最快的运算，因此效率更高。同样因为n是2的幂次方，因而该算法也不会出现超出取模范围的错误。</p><hr><p><strong>question3：为什么要将低16位与高16位进行异或操作？</strong><br>ans：先看一下源码的代码注释：<br><strong><em>Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don’t benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</em></strong><br>设计者认为<strong>(n - 1) &amp; hash很容易发生碰撞</strong>，因为如果不对hash进行其他处理，那么hash起作用的仅仅是⌈log2(n - 1)⌉，比如当n为16的时候，hashCode起作用的仅仅是低4bit的有效位，那么当然容易碰撞了。因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是<strong>把高16bit和低16bit异或了一下</strong>。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。（即通过h ^ (h &gt;&gt;&gt; 16)，<strong>间接让高16位也参与计算，从而让键值对分布均匀，降低hash碰撞</strong>）</p><p>如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞<strong><em>(we use trees to handle large sets of collisions in bins)</em></strong>，在JEP-180中，描述了这个问题：<br><strong><em>Improve the performance of java.util.HashMap under high hash-collision conditions by using balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class.</em></strong><br>之前已经提过，在获取HashMap的元素时，基本分两步：<br>首先根据hashCode()做hash，然后确定bucket的index；<br>如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。<br>在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是<strong>O(1)+O(n)</strong>。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。<br>因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了<strong>O(1)+O(logn)</strong>了，这样在n很大的时候，能够比较理想的解决这个问题。</p><hr><p><strong>question4：为什么判定条件是”binCount &gt;= TREEIFY_THRESHOLD - 1”，但树化的条件仍然是bitCount &gt;= TREEIFY_THRESHOLD - 1?</strong><br>ans：这里：binCount &gt;= TREEIFY_THRESHOLD - 1，看起来是大于等于7就会树化，但其实并不是的。因为在刚执行完p.next = newNode(…);此时binCount仍然还没有执行完++。所以仍然是链表中元素的个数大于等于TREEIFY_THRESHOLD（默认是8），才会树化。<br>举例：当元素个数为1的时候，即只有p，此时binCount为0，然后执行p.next = newNode(…)。if判断失效，然后才执行binCount++（即添加完p.next之后，里面已经有k个元素了，但if判断的时候的binCount值为k - 1，只有到下一轮循环才改成k。<br>当链表一共有6个元素的时候，此时binCount为6（已经是下一轮循环），执行p.next = newNode,一共有7个元素。if判断（6 &lt; = 7)，所以不会树化，循环结束，binCount为7.然后下一轮循环，添加元素，为8，此时 7 &lt;= 7，为真，树化。<br>PS：Hash冲突是指不同对象的hashCode通过hash算法后得出了相同定位的下标，这时候采用链地址法，会将此元素插入至此位置链表的最后一位，形成单链表。当存在位置的链表长度 大于等于 8 并且当前数组容量超过64时，HashMap会将链表 转变为 红黑树，这里要说明一点，往往后者的条件会被大多数人忽略，当桶数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长。这个时候应该优先扩容，而不是立马树化。毕竟高碰撞率是因为桶数组容量较小引起的，这个是主因。容量小时，优先扩容可以避免一些列的不必要的树化过程。</p><hr><h3 id="九-其他一些常见问题："><a href="#九-其他一些常见问题：" class="headerlink" title="九. 其他一些常见问题："></a>九. 其他一些常见问题：</h3><p><strong>1. 什么时候会使用HashMap？他有什么特点？</strong><br>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p><p><strong>2. 你知道HashMap的工作原理吗？</strong><br>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。HashMap是非线程安全的，在多线程的操作下会存在异常情况，可以使用HashTable或者ConcurrentHashMap进行代替</p><p><strong>3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</strong><br>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p><p><strong>4. 你知道hash的实现吗？为什么要这样实现？</strong><br>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p><p><strong>5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong><br>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p><p><strong>6. JDK1.8之前，HashMap在并发的情况下会出现问题，比如同时put的时候甚至会引起死循环，导致CPU使用率100%，为什么？</strong><br>因为JDK1.8之前的resize方法是需要rehash的，导致在旧链表迁移到新链表的时候，如果在新链表的数组索引相同，会导致链表元素倒置，在JDK1.8中不需要rehash，直接根据新增的1bit是0还是1，决定是在原本位置还是增加capacity的位置，不会倒置。<br>而JDK1.8之前的transfer，以JDK1.7为例，当两个线程同时resize的时候，由于链表倒置，有可能出现循环链表的情况，导致无限循环，耗尽CPU算力。具体看这里：<a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a><br>HashMap是非线程安全的，在多线程的操作下会存在异常情况，比如类似于数据库的更新丢失（两个线程同时put，可能会导致其中一个put失效）。可以使用Hashtable或者ConcurrentHashMap进行代替。（Hashtable的效率太低，不推荐使用）<br>PS：回到本题的主干：存放数据时发现正在扩容会怎么样。<br>对于JDK1.7，应该就是同时resize，导致死循环。对于JDK1.8，则不会出现死循环。（1.7是头插法，导致会倒置，形成循环链表。而<strong>1.8增加了tail指针，使用尾插法</strong>，时间复杂度仍然是O(1)，但不会倒置，因而不会出现死循环。）。1.8中hashmap的确不会因为多线程put导致死循环，但是依然有其他的弊端，比如数据丢失等等。因此多线程情况下还是建议使用concurrenthashmap。</p><p>参考网站：<br><a href="https://segmentfault.com/a/1190000015812438" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015812438</a><br><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a><br><a href="https://juejin.im/post/5a7719456fb9a0633e51ae14" target="_blank" rel="noopener">https://juejin.im/post/5a7719456fb9a0633e51ae14</a><br><a href="https://juejin.im/post/5c7f69dff265da2dea054fdc" target="_blank" rel="noopener">https://juejin.im/post/5c7f69dff265da2dea054fdc</a><br><a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="noopener">https://blog.csdn.net/fan2012huan/article/details/51097331</a><br><a href="https://blog.csdn.net/zhuqiuhui/article/details/51849692" target="_blank" rel="noopener">https://blog.csdn.net/zhuqiuhui/article/details/51849692</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言：&quot;&gt;&lt;a href=&quot;#一-前言：&quot; class=&quot;headerlink&quot; title=&quot;一. 前言：&quot;&gt;&lt;/a&gt;一. 前言：&lt;/h3&gt;&lt;p&gt;​        在准备面试的过程中，发现HashMap源码是很常见的考点，于是进行了仔细的学习。以前都说读源码是快速提高Java水平的好途径，在阅读了HashMap的部分重要源码之后真的是深有体会，于是写下此篇文章做记录。具体内容包括，HashMap的构造方法，put，get方法，以及put&amp;amp;get所需要的hash方法，还有扩容时所需要的resize方法。我们将对这几个方法的源码进行阅读，理解它的逻辑，以及一些巧妙的设计。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://hongscar.cn/categories/Java/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁的判断</title>
    <link href="https://hongscar.cn/MySQL%E9%94%81%E7%9A%84%E5%88%A4%E6%96%AD.html"/>
    <id>https://hongscar.cn/MySQL%E9%94%81%E7%9A%84%E5%88%A4%E6%96%AD.html</id>
    <published>2020-02-17T03:50:57.000Z</published>
    <updated>2020-02-17T14:51:39.286Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>本文的最终解决的问题：<strong>如何判断一条SQL语句用到了哪些锁？</strong><br>（特别地，这里考虑的是<em>MySQL</em>数据库的锁机制）</p><p>首先，我们需要先对<em>MySQL</em>的事务机制，锁机制，索引机制都总结一遍。</p><a id="more"></a><hr><h3 id="二-事务隔离级别："><a href="#二-事务隔离级别：" class="headerlink" title="二. 事务隔离级别："></a>二. 事务隔离级别：</h3><p><strong>RU：Read UnCommitted<br>RC：Read Committed<br>RR：Repeatable Read （default）<br>Serializable</strong></p><p>总结：<br>RU可以读取未提交的数据，因此存在脏读的问题。<br>RC只能读取已经提交的数据，因而解决了脏读的问题，但存在不可重复读的问题<br>RR保证了可以重复读的问题。<br>RR与Serializable都解决了大部分的问题，因此默认就是RR。（当然，在需求高性能的情况下，会使用RC）</p><p>查看MySQL的隔离级别：<br>select @<a href="https://github.com/tx_isolation" target="_blank" rel="noopener">@tx_isolation</a> // 查看当前会话的事务隔离级别<br>select @<a href="https://github.com/global" target="_blank" rel="noopener">@global</a>.tx_isolation //查看系统全局的隔离级别<br>设置隔离级别：<br><em>set session/global transaction isolation level xx;</em><br>(xx can be <strong>read uncommitted, read committed, repeatable read, serializable</strong>)</p><hr><h3 id="三-锁机制："><a href="#三-锁机制：" class="headerlink" title="三. 锁机制："></a>三. 锁机制：</h3><p>MySQL锁的类型：（有多种分法）<br>①根据锁的兼容情况，可以分为4种：<br><strong><em>Shared locks，Exclusive locks</em></strong>（共享锁，排他锁，即S锁，X锁，在其他数据库也有这两种）<br><strong><em>Intention Locks</em></strong>：意向锁，分为共享意向锁IS，共享排他锁IX锁。（作用后续说，<strong>针对MySQL的行锁而出现</strong>）</p><p>②根据锁的锁定范围，可以分为三种：<br><strong><em>表锁 Table Locks，行锁 Record Locks，页锁 Page Locks</em></strong><br>（在MyISAM中为Table Locks，而在<strong>InnoDB中只有Record Locks</strong>。Page Locks存在于BerkeleyDB）<br>表锁和行锁的区别：<br><strong>表锁的开销较小，不会产生死锁，锁定范围大，但并发度最低<br>行锁的开销较大，可能产生死锁，锁定范围较小，并发度更高</strong><br>页锁此处不解释（我也不会）</p><p>③InnoDB下的Lock Type：<br>由于目前重点使用的MySQL引擎一般是InnoDB，因此对InnoDB进行更细致的了解。<br><strong>InnoDB的行级锁（InnoDB不存在表级锁，只是在特定情况下看起来像是表级锁的形式而已）：</strong><br><em>1.Record Locks：A record lock is a lock on an index record.</em> 即锁定一个index的record。<br><em>2.Gap Locks：A gap lock is a lock on a gap between index records, or a lock on the gap before the first or after the last index record.</em> 即锁定record之间的的间隙。<br>（Gap Locks存在于RR与Serializable，不存在于RC。RU一般不会用，不考虑，而且也没有）<br><em>3.Next-Key Locks:A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.(3 = 1 + 2)</em><br><del>PS：此处有一个小test，事务隔离级别是与系统全局的设置有关的（即使两个Session transaction isolation level都设置为RC，但如果Global transaction isolation level设置为RR，那么就按照RR的情况来执行，即此时存在Gap Locks。所以不清楚Session level有何作用）</del></p><hr><p>不同情况的加锁情况：<br>要考虑这个问题，先整理一些基础知识：</p><p><strong><em>①首先要了解锁之间的兼容性（S锁，X锁，IS锁，IX锁）：</em></strong></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_1.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_1.png" alt="MySQL中InnoDB引擎中锁的兼容性"></a><br>PS：这是<strong>仅限于Table-level的compatibility</strong>，网上传的很多都忽略了这个。</p><p><strong>关于意向锁：主要是用于解决行锁和表锁的冲突。</strong>试想一下，当事务A锁住了表中的一行（假设为S锁)，而事务B需要申请整个表的X锁。那么事务B需要做的事情：<br>1.判断表是否被其他表锁锁住（无论X,S），这个很简单.<br>2.判断表中的每一行是否被行锁锁住（无论X,S，因为X与二者均不兼容）。<br><strong>如果只有X,S锁，那么我们需要逐行检查，如果有1个亿的data，那么就需要查询1亿行。</strong><br>如果添加了意向锁呢？意向锁的作用方式：<br>当一个事务需要获取一个<strong>行锁</strong>的X锁，先获取一个IX锁。<br>当一个事务需要获取一个<strong>行锁</strong>的S锁，先获取一个IS锁。<br>（记住，<strong>上面的表格是仅限表锁的情况</strong>，如果需要获取表锁的X/S锁，那么不需要获取IX,IS锁。另外，<strong>IX,IS锁是数据库后台自动获取的，无须我们显式调用</strong>）<br>这个时候，当另一个事务，要申请X锁，第一步依然是判断是否被其他表锁锁住。<br>第二步就改成了，判断该表是否存在IX,IS锁。（如果存在IX，IS锁，说明该表存在X，S锁，不管是哪一行）<strong>仅仅通过判断是否存在意向锁，就省去了遍历所有行的操作。</strong><br>（PS：如果另一个事务要申请的是S锁，同样如此，只是不需要判断IS锁，而是判断IX锁）<br>记住：<strong>意向锁与表级的X锁不兼容，但与行级的X锁是兼容的</strong><br>（不然你先获取了IX锁，如何继续获取X锁呢？）</p><hr><p><strong><em>②数据库的并发控制协议</em></strong></p><p><em>MVVC：Multi-Version- Concurrency Control。</em>即基于多版本的并发控制协议。<br>它最大的好处：读操作不加锁，读写不冲突，可以极大地增强并发性。<br><em>Lock-Based Concurrency Control。</em>即基于锁的并发控制。<br>（如果我们每一种操作都需要获取lock，由lock来完全实现并发控制，那么并发性会相当地差。其实也就是相当于Serializable，完全串行化执行。所以<strong>现阶段，大部分的数据库都不会是完全的基于lock去实现并发控制，而是实现了MVVC模式</strong>）</p><p>在MVVC并发控制中，读操作可以分为两种；<strong>snapshot read</strong>(快照读）,<strong>current read</strong>(当前读）<br>所谓snapshot，就是系统在某一个时刻的印象，所以此时读取到的不一定是最新的数据，可能是某个历史版本的数据，那么这时候就不需要加锁。（因为本来就不一定是最新的数据，那么两次snapshot read不一致也是很正常的，所以怎么能算是脏读幻读呢（滑稽）！）<br>current read就不一样了，它就是要读取系统最新的数据，所以此时需要对读操作进行加锁，然后再基于Lock-Based去进行并发控制。</p><p><strong>在MySQL InnoDB中，snapshot read又称简单的select</strong>，一般形式为：<br>select <em>from table where ？; # 存在例外，后面分析<br>current read：<br>select</em> from table where ? lock in share mode || for update || for share(8.0之后的版本)<br>(如果直接显式要lock了，那么都lock了，当然就是要current read，而不是读取snapshot了）<br>insert，update，delete（这些操作当然不能读snapshot，不然你update一个已经被delete掉的数据吗)<br>(从底层源码来说，update，delete都包含一个current read，而insert，需要检查unique key冲突）</p><hr><p><strong><em>③聚簇索引（cluster index）：</em></strong></p><p>这是由MySQL<strong>自动生成</strong>的一个index（无法人为控制），它一般是直接把主键设置为cluster index，所以又称主键index。<br>（如果表没有创建主键？那么按照以下规则来创建cluster index：（一般还是要显式给表一个PK）<br>1.会用一个唯一的非空的index列，作为cluster index<br>2.如果没有这样的index，那么InnoDB会隐式生成一个主键来作为cluster index<br>其他人为定义的索引，称为辅助索引（secondary index），也可以称为非聚簇索引。<br>关于这两个index的具体区别，查找时的路径有何不同，可以参考这篇文章：<br><a href="https://www.cnblogs.com/rjzheng/p/9915754.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9915754.html</a><br>关键点：每创建一个index，那么就会生成一个B+树，因此index不能乱加，会导致index的时候需要同时维护多个index，导致效率低下）</p><p>PS：这里有一个关键点，就是<strong>cluster index是无论如何都会存在的。</strong>（不管你有没有创建其他index，每个表都会存在一个cluster index）<br>根据网上很多的文章，都提及到一个内容：InnoDB只有在使用index的时候才是使用行锁，否则会变成表锁。<strong>这句话是错误的</strong>。因为即使我们没有创建index，在select的时候也没有使用index列，那么一样会使用一个隐式创建的cluster index去寻找数据，所以<strong>InnoDB只存在行锁，不存在表锁。</strong><br>官方文档：<br><strong><em>Record Locks<br>A record lock is a lock on an index record. For example, SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE; prevents any other transaction from inserting, updating, or deleting rows where the value of t.c1 is 10.<br>Record locks always lock index records, even if a table is defined with no indexes. For such cases, InnoDB creates a hidden clustered index and uses this index for record locking. See Section 15.6.2.1, “Clustered and Secondary Indexes”.</em></strong><br>可是很多人表示自己亲自测试过，发现确实是整个表都锁住了呀，难道不是表锁吗？这主要是因为对底层了解不足，只开了两个session发现无法同时select就感觉是整个表都锁起来，是不正确的。这时候最正确的做法是：查看MySQL的状态表，查看当前存在的锁，然后<strong>直接查看锁的类型</strong>。毕竟网上说的都不权威，但MySQL它自己创建的表是最权威的！<br>我们这里创建两个session，发现存在lock，waiting的情况，这时候在另一个无须waiting的session执行： <strong>use information_schema;</strong> 进入到MySQL自带的information_schema数据库中<br>然后执行： <strong>select* from innodb_locks;</strong> 即可找到当前存在的locks。<br>（也可以使用 <strong>show engine innodb status;</strong>查看，不过可读性较差，需要仔细观察）<br>下面给出两个命令的结果：（第一个是select* from innodb_locks;)</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_2.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_2.png" alt="select* from innodb_locks的显示结果"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_3.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_3.png" alt="show engine innodb status的显示结果"></a></p><hr><p>PS：<strong>MySQL8.0与之前的版本不一致（5.7及以前）</strong>。如下：（如果不是使用8.0可以跳过）<br>MySQL5.7及之前，可以通过information_schema.innodb_locks查看事务的锁情况，但，只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。<br>MySQL8.0删除了information_schema.innodb_locks，添加了performance_schema.data_locks，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁，也就是说即使事务并未被阻塞，依然可以看到事务所持有的锁（不过，正如文中最后一段所说，performance_schema.data_locks并不总是能看到全部的锁）。表名的变化其实还反映了8.0的performance_schema.data_locks更为通用了，即使你使用InnoDB之外的存储引擎，你依然可以从performance_schema.data_locks看到事务的锁情况。<br>那么为何RECORD LOCKS会表现出类似于表锁的形式？这是因为InnoDB在没有使用index的时候，会使用cluster index（所以依然是行锁）此时会生成record locks和gap locks，并且是把每一个record，每一个gap都锁住，表现形式就像是整个表都被锁住的情况（但仍然是行锁）。<br>有的人可能觉得，这不是在挑文字游戏？并不，因为只有在特定情况下，才会出现这种情况，当我们修改一些其他参数，或者使用不同的index，都会出现不同的情况，到那时候就不再是整个表都锁住了。这个在最后的时候会详细说明，现在只需要知道，<strong>InnoDB，绝对不存在Table locks。</strong></p><hr><hr><h3 id="四-不同情况的加锁处理分析"><a href="#四-不同情况的加锁处理分析" class="headerlink" title="四. 不同情况的加锁处理分析"></a>四. 不同情况的加锁处理分析</h3><p>有了这些准备，我们开始讨论不同情况的加锁处理分析（加不加锁，加哪种锁）</p><p>此处参考了大佬的文章：<a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">http://hedengcheng.com/?p=771</a><br><strong>情况①：简单的snapshot read: select* from table where id = 1;</strong><br>这时候<strong>一般不加锁</strong>。但上文也说了，存在例外，那就是当事务隔离级别为Serializable的情况下，由于每一个操作都完全串行化，因而也不存在snapshot了，该操作会升级为current read，因而需要加锁。（同时，Serializable的情况下，MySQL的并发控制协议会从MVVC降级为Lock-Based。一般除非系统冲突非常严重，否则不采用Serializable）</p><p>有了第一个情况，可以发现<strong>加锁的情况是要考虑其他因素的，不能仅仅是给一个SQL语句就问获得了什么锁，还要考虑很多种情况</strong>。一般而言，需要考虑以下几种情况：（假设搜寻的字段为id）<br><strong>1.id是否为主键？<br>2.当前系统的隔离级别是什么？<br>3.id如果不为主键，那么它是否存在index？<br>4.如果id存在secondary index，那么这个index是否是unique index？<br>5.两个SQL的执行计划是什么，索引扫描？全表扫描？</strong>（这里我是参照大佬的文章来写的，但个人认为第五点其实跟前面的重叠了。如果id为主键，那么就是采用了cluster index，即全表扫描。如果id不存在index，同样是采用cluster index。如果id存在index，无论是否是unique，都为索引扫描。）</p><p>现在给定一个表：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_4.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_4.png" alt="测试所用的表结构"></a><br>对于上面的几种情况，不一定每一种都排列组合一遍，把关键的点get到即可。<br>下面通过<strong>8种情况</strong>来考虑：</p><hr><p><strong>①~④：RC级别<br>⑤~⑧：RR级别</strong></p><hr><h4 id="①搜寻字段是主键-PK）"><a href="#①搜寻字段是主键-PK）" class="headerlink" title="①搜寻字段是主键(PK）"></a>①搜寻字段是主键(PK）</h4><p><code>delete from testN where id = 10;</code><br>此时其他事务无法访问id = 10这一行记录<br>情况最简单，直接在主键上id = 10的记录上加上X锁即可（在id字段上锁）。</p><hr><h4 id="②字段不是主键，但存在一个unique-index。"><a href="#②字段不是主键，但存在一个unique-index。" class="headerlink" title="②字段不是主键，但存在一个unique index。"></a>②字段不是主键，但存在一个unique index。</h4><p><code>delete from testN where name = &#39;abc&#39;;</code><br>同样无法访问name = ‘abc’这一行记录，但同时在id和name1字段上锁。<br>这种情况下，由于存在index，所以会在index上查询，这时候会给unique index加上X锁。同时当select的时候，如果没有指定secondary index的字段（*号也不行），那么还会到cluster index里去顺序查找。具体看图：（在上面最开始讲到cluster index里的文章就有具体说明）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_5.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_5.png" alt="聚簇索引"></a><br>所以这个时候，除了给secondary unique index进行加锁，还会对cluster index进行加锁。<br>所以此处是给id，name1字段都加上了锁。（当然，被加锁的record依然是那一条，因为unique）</p><p>为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：<code>update t1 set id = 100 where name = ‘d’;</code>此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。</p><hr><h4 id="③字段不是主键，而且字段存在一个index，但并不是unique-index"><a href="#③字段不是主键，而且字段存在一个index，但并不是unique-index" class="headerlink" title="③字段不是主键，而且字段存在一个index，但并不是unique index"></a>③字段不是主键，而且字段存在一个index，但并不是unique index</h4><p><code>delete from testN where number = 12;</code><br>这种情况其实跟第②种情况是类似的，只是可能锁住多个record（因为不是unique index）<br>同样也是对number（index列）进行了加锁，然后还会对cluster index列加锁。<br>PS：看起来②和③可以归并在一起，但在RR的时候可以看到很大的不同。</p><hr><h4 id="④字段不是主键，而且不存在index。"><a href="#④字段不是主键，而且不存在index。" class="headerlink" title="④字段不是主键，而且不存在index。"></a>④字段不是主键，而且不存在index。</h4><p>此时会使用cluster index进行扫描，即全表扫描。而且会把所有的record都锁住。因为该条件无法通过索引快速过滤（暂且把cluster index视为很特殊的index吧，不然你都不需要自己创建index了），这时候在存储引擎层面就会将所有的记录加锁后返回，然后由MySQL Server层进行过滤。这是由于MySQL的实现所决定的。（在实际的实现中，进行了一些优化，在过滤条件中，如果发现不满足条件，那么在中途就会把不满足条件的记录释放锁。这样避免了把所有record都锁住导致的低并发，但也违背了二阶段锁的约束。这样最终持有锁的，会是满足条件的记录。但那大概是在事务提交执行的过程中，所以本地编写事务但不commit，依然会表现为全部记录加锁）</p><hr><h4 id="⑤搜寻字段是主键-PK）"><a href="#⑤搜寻字段是主键-PK）" class="headerlink" title="⑤搜寻字段是主键(PK）"></a>⑤搜寻字段是主键(PK）</h4><p>跟①没有区别</p><hr><h4 id="⑥字段不是主键，但存在一个unique-index。"><a href="#⑥字段不是主键，但存在一个unique-index。" class="headerlink" title="⑥字段不是主键，但存在一个unique index。"></a>⑥字段不是主键，但存在一个unique index。</h4><p>跟②没有区别</p><hr><h4 id="⑦字段不是主键，而且字段存在一个index，但并不是unique-index"><a href="#⑦字段不是主键，而且字段存在一个index，但并不是unique-index" class="headerlink" title="⑦字段不是主键，而且字段存在一个index，但并不是unique index"></a>⑦字段不是主键，而且字段存在一个index，但并不是unique index</h4><p>有区别了，为什么？RR相对于RC，解决的问题是幻读，不可重复读。为何⑤跟⑥的加锁却没有任何改变？幻读，不可重复读是指当前事务，连续执行两次current read，返回了不同的数据。而⑤和⑥都是unique index，能够保持唯一性，不用担心值会发生改变（改变值需要X锁，与S锁不兼容）。<br>那么在⑦的时候，字段存在了index，但该index并不是unique index，这时候问题就出现了，如果还是按照③的做法，那么就可能出现幻读跟不可重复读的情况。<br>举一个例子，按照我们上面给的table的来示例：（假设采用③的只对record进行加锁的模式）<br>字段名为： id， name1，number1， age (PK为id）<br>执行的current read的语句为：<br>select <em>from testN where number1 = 18 for update;(number1是非unique index列)<br>那么假如当我们在另一个session执行：insert into testN values(xx,xx,18,xx); commit;<br>这时候该session中的 transaction是可以成功提交的，因为并没有gap lock，而只是把原本符合条件的 record给锁住了，而不是把所有number1=18的都锁住。<br>这时候再次执行 select</em> from testN where number1 = 18 for update;就会出现幻读。</p><p>因此，<strong>此时会锁住符合记录与相邻记录的间隔。这个就称为间隔锁：gap locks</strong><br>假如：字段的取值是：12，32，18，18，20，24，30.选择的条件是 id = 18<br>那么除了锁住两个18的记录，还会锁住12与18，18与20之间的间隔（有序性）<br>所以此时锁住的范围：record locks： 18， 18<br>gap locks： [12, 18) ∪ [18, 20)所以整体锁住的范围就是： <strong>[12, 20)</strong></p><hr><h4 id="⑧字段不是主键，而且不存在index。"><a href="#⑧字段不是主键，而且不存在index。" class="headerlink" title="⑧字段不是主键，而且不存在index。"></a>⑧字段不是主键，而且不存在index。</h4><p>⑧跟⑦不一样的地方是，⑦会把符合条件的record的与前后record的间隔都给锁住，而⑧由于是全表搜索（无index，只有cluster index），因此⑧首先是把所有的records都锁住，然后再把所有records的间隔都锁住（包括±∞）。假如age列（非index列）一共有20，22，30等三个值，那么由行锁record locks和间隔锁gap locks锁住的范围为：<br><strong>(-∞, 20) ∪ [20, 22) ∪ [22, 30) ∪ [30, +∞）（因为表现为整个表都锁住了，所以容易误以为是表锁）</strong><br>（虽说误以为是表锁是错误的理解，但确实要<strong>尽量避免</strong>这种情况，因为这种情况需要加很多锁。当该非index列有n个records的时候，需要加n个record locks，(n+1)个gap locks，一共需要（2n+1)个锁，开销是极其大的。所以尽量通过index来查询，避免加入过多的锁，影响性能。</p><hr><h3 id="附：测试"><a href="#附：测试" class="headerlink" title="附：测试"></a>附：测试</h3><p>数据以上面的testN的数据为例，事务自动提交设置为否：set autocommit = 0（除了在阐述③如何引起幻读的情况下，需要commit，其余都无须commit，只需要显示到被锁住即可。并且这一步会放到最后执行，前面的每一项测试，在测试完毕之后，都执行rollback，避免事务对数据的更改）<br>初始数据：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_6.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_6.png" alt="初始数据"></a><br>确保环境：（1~4在RC，5~8在RR。虽说应该是global才生效，但直接把session跟global都设置一遍) （两个终端都设置）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_7.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_7.png" alt="初始环境(1~4RC,5~8RR)"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_8.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_8.png" alt="初始环境(1~4RC,5~8RR)"></a></p><hr><h4 id="情况①："><a href="#情况①：" class="headerlink" title="情况①："></a>情况①：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_9.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_9.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_10.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_10.png" alt="B终端"></a><br><strong><em>结论：①确实只锁住了id为10的那条记录，其他所有都没有锁。\</em></strong></p><hr><h4 id="情况②："><a href="#情况②：" class="headerlink" title="情况②："></a>情况②：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_11.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_11.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_12.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_12.png" alt="B终端"></a><br><strong><em>结论：②确实也是只把name1=’abc’该列锁住了。没有其他任何的锁。\</em></strong></p><hr><h4 id="情况③："><a href="#情况③：" class="headerlink" title="情况③："></a>情况③：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_13.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_13.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_14.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_14.png" alt="B终端"></a><br><strong>结论：③，number1为20有两个记录，这两个确实都被锁住了。而且其他都没有锁住，没有gap locks</strong></p><hr><h4 id="情况④："><a href="#情况④：" class="headerlink" title="情况④："></a>情况④：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_15.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_15.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_16.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_16.png" alt="B终端"></a><br><strong>结论：④理论上是锁住所有record，但在判定不符合之后就把锁释放了（即那个违背了二阶段锁的优化操作），所以最后只把age为22的锁住了。</strong></p><hr><p>RC环境转RR环境：<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_17.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_17.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_18.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_18.png" alt="B终端"></a></p><hr><h4 id="情况⑤："><a href="#情况⑤：" class="headerlink" title="情况⑤："></a>情况⑤：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_19.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_19.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_20.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_20.png" alt="B终端"></a><br><strong>结论：⑤与①相同，没有任何变化。</strong></p><hr><h4 id="情况⑥："><a href="#情况⑥：" class="headerlink" title="情况⑥："></a>情况⑥：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_21.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_21.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_22.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_22.png" alt="B终端"></a><br><strong>结论：Ⅵ与②相同，没有任何变化。</strong></p><hr><h4 id="情况⑦："><a href="#情况⑦：" class="headerlink" title="情况⑦："></a>情况⑦：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_23.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_23.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_24.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_24.png" alt="B终端"></a><br><strong>锁住18，与预期相同。</strong>18相邻的元素为12，20，因而把 [12, 18)∪ [18, 20)给锁住了。（锁的范围是左闭右开，因而12无法insert，但20是可以insert的）</p><p><strong>下面再测试锁住20的情况。</strong><br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_25.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_25.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_26.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_26.png" alt="B终端"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_27.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_27.png" alt="B终端"></a><br><strong>锁住20，同样跟预期相同，会把[18, 20) ∪ 20 ∪ [20, 40)都锁住</strong></p><p><strong>假设选择的值是最小/最大，是否也像no index的情况下，锁住±∞？</strong><br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_31.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_31.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_32.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_32.png" alt="B终端"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_33.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_33.png" alt="B终端"></a><br>答案是会的。所以也跟预期一样。</p><p><strong>结论：⑦与③不同，在RR的情况下会使用gap locks，锁住间隔。</strong></p><hr><h4 id="情况⑧："><a href="#情况⑧：" class="headerlink" title="情况⑧："></a>情况⑧：</h4><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_28.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_28.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_29.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_29.png" alt="B终端"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_30.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_30.png" alt="B终端"></a><br>表就像完全锁住一样，因为record locks &amp; gap locks 把整个表都锁住了。<br><strong>结论：⑧在RR的情况下，会把所有的record都锁住，也会把所有的gap锁住。</strong></p><hr><p>最后，测试RC环境下，③可能会导致<strong>幻读</strong>的情况：（RR已经确定不会出现幻读）<br>环境参数：（RR改回RC）<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_34.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_34.png" alt="A终端"></a></p><p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_35.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_35.png" alt="B终端"></a></p><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_36.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_36.png" alt="A终端"></a></p><p>中间，在另一个终端B执行：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_37.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_37.png" alt="B终端"></a><br>可见session1的lock并没有锁住session2创建number1为18的值。只要unique行没有duplicate，那么就可以insert，insert更多例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_38.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_38.png" alt="B终端"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_39.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_39.png" alt="A终端"></a></p><p>PS：<strong>以上讨论的是什么时候加锁</strong>。至于加什么锁，应该很好判断。如果是select lock in share mode，那就是加S锁，select for update，就是加X锁。</p><hr><hr><p><strong><em>当范围比较的时候，又有所不同！当范围比较的时候，又有所不同！</em></strong></p><p>(上面考虑的都是等值筛选的情况） 以下就不考虑等值的情况<br>使用数据：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_40.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_40.png" alt="使用数据"></a></p><hr><h4 id="①使用PK的情况（cluster-index）"><a href="#①使用PK的情况（cluster-index）" class="headerlink" title="①使用PK的情况（cluster index）"></a>①使用PK的情况（cluster index）</h4><p>SQL句子： （用4个句子来解释）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select* from testf where pid &gt; 30 for update;</span><br><span class="line">select* from testf where pid &gt; 33 for update;</span><br><span class="line">select* from testf where pid &gt; 50 for update;</span><br><span class="line">select* from testf where pid &lt; 30 for update;</span><br></pre></td></tr></table></figure><p><strong>对于RC：</strong><br>句子1：首先符合条件的记录为pid = 33， pid = 47.对这两个records加上X锁。<br>句子2：首先符合条件的记录为pid = 47，对着一个record加上X锁。<br>句子3：没有符合条件的记录。<br>句子4：两个符合，加锁。<br>此时执行select：句子1可以获取pid = 11，12，的记录，句子2可以获得11，12，33，句子3全部可以<br>此时执行insert：除了相同的pid（duplicate），没有任何限制。(但insert相同的pid时，还是会起冲突哦。先是waiting获得lock，然后获得了之后才发现，duplicate，insert失败。即添加被record lock锁住的记录，仍然要waiting，而其他就无须获取锁的就直接duplicate。下同）<br><strong>对于RR：（增加gap locks）</strong><br>句子仍然对符合的records加上X锁，之后，开始增加gap locks：<br>句子1：<br>gap locks：对于 pid &gt; 30，因而需要找一个左边界，找一个左边最接近30的record，在这里即为22.因此，gap locks的范围： [22, 33) ∪ [33, 47) ∪ [47, ＋∞)<br>对于insert，不能insert record locks &amp; gap locks范围里的pid。合理。<br>对于select，也还是跟RC情况一样。因为被record locks锁住的在RC就不能访问，而被gap locks锁住的范围无法insert，因而select也肯定是empty set。那么，就不会出现幻读。<br>句子2：<br>与句子1的唯一区别是，33刚好就在表里，那么左边界到底是22还是33？<br>好的，答案是33，因为判定条件≠33啊。剩下的也就一样了，gap locks：[33, 47)∪[47, +∞)<br>句子3：<br>这个有点特别的是，没有record。但其实是一样的，找边界，因而这里这里的边界显然就是47，gap locks： [47, +∞)<br>句子4：<br>值得注意的是，左边界是无穷，右边界显然是33.但这里的右边界竟然是闭合的！<br>所以此处gap locks：(-∞, 33],因而只能insert 34之后的pid。所以select的时候就只能select 47了，33是不可以的。insert也不能包括33.</p><hr><h4 id="②不使用PK，使用unique-index"><a href="#②不使用PK，使用unique-index" class="headerlink" title="②不使用PK，使用unique index"></a>②不使用PK，使用unique index</h4><p>修改了一下表的结构跟数据：num具备一个unique index<br>测试了一下，<strong>发现跟PK一模一样。懒得说。（内部实现实际上有区别的，如果说要什么区别的话，那就是上面刚开始说的①和②的区别啊！②会先给unique index加锁再给cluster index加锁。</strong><br>(其实就是cluster index那一篇拓展文章)</p><hr><h4 id="③不使用PK，使用non-unique-index-从这里开始很特别。"><a href="#③不使用PK，使用non-unique-index-从这里开始很特别。" class="headerlink" title="③不使用PK，使用non-unique index 从这里开始很特别。"></a>③不使用PK，使用non-unique index 从这里开始很特别。</h4><p>直接讨论RR：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select* from testf where num &gt; 200 for update;</span><br><span class="line">select* from testf where num &gt; 150 for update;</span><br><span class="line">select* from testf where num &gt; 400 for update;</span><br><span class="line">select* from testf where num &lt; 250 for update;</span><br></pre></td></tr></table></figure><p>对于句子1：<br>终端A：<br><a href="hhttps://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_41.png"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_41.png" alt="A终端"></a></p><p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_42.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_42.png" alt="B终端"></a><br>显然，select还是只把符合的记录给锁住了，即只锁住了300，100跟200均可select。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_43.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_43.png" alt="B终端"></a><br>对于insert，依然是找到相应的边界值（这里显然是200），于是锁住了[200, +∞)，因而可以insert 199</p><p>对于句子2：（<strong>看起来应该会跟句子1一样，但结果……</strong>）<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_44.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_44.png" alt="A终端"></a></p><p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_45.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_45.png" alt="B终端"></a><br><strong>select竟然全部记录都获取不到了，除了不存在的空记录</strong>。那么insert呢？<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_46.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_46.png" alt="insert情况"></a></p><p>既然已经是所有record都上锁了（record locks），那么理应把record之间的间隔也上锁（RR），结果insert确实如此，全部都无法insert。<br>（而句子1跟句子2的区别，仅仅只有150跟200，200存在于里面，而150不在。<strong>推测：索引为B+树类型，所以当存在相同的元素时，就可以直接根据B+树的有序性进行合理上锁，即对符合条件的记录上锁</strong>。那么如果不存在相同的元素，即不存在150，而且又不是unique index，仅仅是使用了一个non-unique index并且被动地去cluster index中查找，这时候就会把所有记录上锁，因为cluster index是一个特殊的index，具体的细节我也不懂，得去看源码。但现在只需要知道，<strong>cluster index无法标记到相同的元素，就无法进行定位了，然后就直接把所有record都锁了，当然在RR下还有gap locks</strong>）</p><p>对于句子3：<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_47.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_47.png" alt="A终端"></a></p><p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_48.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_48.png" alt="B终端"></a><br>可见，由于里面没有符合条件的记录，所以select没有被阻塞。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_49.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_49.png" alt="B终端"></a></p><p>可是，insert却是会被阻塞的。而且阻塞范围就是寻找边界。这里上锁的区域是[300, ＋∞)<br>（虽然400不存在于表中，但由于没有符合的记录，就没有把record给上锁了，所以也仅仅是添加了gap locks。但gap locks包含300，却只能search不能insert。看来只能看源码才能切实看懂了！先记住罢！）</p><p>对于句子4：<br>跟句子2是一样的，select全部锁住了，毫无意外的话，insert应该也会被全范围的gap locks给锁住。（// TODO = =！）<br>确实如此，就不贴图了。</p><p>本来不想测试RC的，但RR的结果有点出人意料，所以现在再把RC也测试一遍：<br>句子1：<strong>select还是一样，符合条件的锁住。insert没有任何阻塞</strong>（因为不存在gap locks）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_50.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_50.png" alt="B终端"></a><br>句子2：跟RR的不一样，并不会全部锁住，而且也不会把记录都锁住。<br>select依然是符合条件的才锁住。而insert依然是没有任何阻塞（没有gap locks）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_51.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_51.png" alt="B终端"></a><br>句子3：还是一样。select该锁的锁，insert无阻塞。<br>句子4：一样。pass<br>（RC的insert无阻塞是毫不意外的，首先RC不存在gap locks，至于已经存在的record则会因为PK/cluster index而产生冲突，并不是因为gap Locks）</p><hr><h4 id="情况④：不使用PK，也不使用index"><a href="#情况④：不使用PK，也不使用index" class="headerlink" title="情况④：不使用PK，也不使用index"></a>情况④：不使用PK，也不使用index</h4><p>RC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select* from testf where num &gt; 200 for update;</span><br><span class="line">select* from testf where num &gt; 150 for update;</span><br><span class="line">select* from testf where num &gt; 400 for update;</span><br><span class="line">select* from testf where num &lt; 250 for update;</span><br></pre></td></tr></table></figure><p>句子1：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_52.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_52.png" alt="B终端"></a><br>select全部锁住了，而且不仅仅是记录，包括gap。而RC是不存在gap locks的。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_53.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_53.png" alt="B终端"></a><br>而insert却是依旧跟预期一样，毫无阻塞（因为RC没有gap locks）</p><p>句子2：select也是一样全部阻塞。而insert也是毫无阻塞</p><p>句子3：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_54.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_54.png" alt="B终端"></a><br>select毫无阻塞，因为没有找到记录。insert也是毫无阻塞。</p><p>句子4：还是那样，select完全阻塞，insert没有阻塞。</p><p>RR：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select* from testf where num &gt; 200 for update;</span><br><span class="line">select* from testf where num &gt; 150 for update;</span><br><span class="line">select* from testf where num &gt; 400 for update;</span><br><span class="line">select* from testf where num &lt; 250 for update;</span><br></pre></td></tr></table></figure><p>句子1：<br>select依然全部被阻塞（RC都阻塞， RR岂有不阻之理？）<br>insert也是全部阻塞，因为RR多了gap locks，自然也就全部范围都锁住了。<br>句子2跟句子4显然结果也会是一样的。<br>那么再看句子3，竟然也是全部阻塞。</p><p>上面都是详细的推导环节，虽然还有所疑惑，但至少结果是没有错的，先总结了吧（关于insert并发这个，以后再说吧。这个应该满足了select/delete/update与insert之间的所有关系了，只差并发insert这一环节） PS : insert还有一个insert意向锁</p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>分两大类情况：等值筛选（id = x），范围筛选（id &gt; x)<br>以下操作只考虑select跟insert（delete跟update约等于select。）</p><p>先看<strong>等值筛选</strong>：</p><p><strong><em>① RC / RR + PK</em></strong></p><p>锁住该条记录的。select，insert均不能使用相同的字段值（insert是因为同名，select是因为锁）</p><p><strong><em>② RC / RR + Unique Index</em></strong></p><p>跟①一样，只是底层实现有所不同（先对Unique Index的记录加锁，再对cluster index的记录加锁）</p><p><strong><em>③ RC + Non-unique Index</em></strong></p><p>锁住所有符合条件的记录（因为不是unique，可能选出多条记录）</p><p><strong><em>④ RC + No index(无索引）</em></strong></p><p>锁住所有的记录（MySQL优化后，对判断不满足条件的记录，进行释放锁操作。违背了2PL协议）</p><p><strong><em>⑤ RR + Non-unique Index</em></strong></p><p>锁住符合条件的记录，并且新增gap locks。会锁住记录与其相邻记录的中间间隔（按照有序排列）<br>gap locks一般按照 左闭右开的原则。</p><p><strong><em>⑥ RR + No index</em></strong></p><p>锁住所有的记录，具备gap locks。因为所有记录都锁住，所以从-∞到＋∞其实都被锁住了。<br>n条记录时，n个Record Locks， n + 1 个gap locks，一共 2n+1 个锁。</p><p><strong>范围筛选</strong>：（PS：如果两个select都是S锁，那当然是可以同时存在的，S锁之间兼容）</p><p><strong><em>① RC + PK / Unique Index / Non-Unique Index</em></strong></p><p>(RC条件下，只要使用Index，无论是Unique Index还是Non-Unique）<br>锁住符合的记录，可以select没有锁的记录，insert无限制。</p><p><strong><em>② RR + PK / Unique Index</em></strong></p><p>锁住符合的所有记录，还有gap locks。同样是可以select没有锁的记录，insert无限制。</p><p><strong><em>③ RR + Non-unique Index</em></strong></p><p><strong>Ⅰ. 当表中存在比较的值（即id &gt; x, table存在 id = x的记录）</strong></p><p>同①</p><p><strong>Ⅱ. 当表中不存在比较的值（id &gt; x, table不存在id = x的记录）</strong></p><p>select全部阻塞（除了不存在的记录），insert全部阻塞（record已经阻塞，加上gap必然的结果)</p><p><strong>Ⅲ. 当select返回的是empty set （例子：where id &gt; 100，而table中不存在id大于100的记录）</strong></p><p>同① （其实跟 Ⅰ 也是等价的，只是符合的记录为empty set）</p><p><strong><em>④ RC + No Index</em></strong></p><p><strong>Ⅰ. select返回的值非空</strong></p><p>select完全阻塞（包括不存在的记录也无法select），insert无阻塞（RC不存在gap）</p><p><strong>Ⅱ. select返回的是empty set</strong></p><p>select跟insert都没有阻塞</p><p><strong><em>⑤ RR + No index</em></strong></p><p>select跟insert必定全部阻塞。</p><p>PS：在RR的情况下，对于并非全锁的情况，Gap Locks的边界值考量方法都是一样的（都是找左右相邻最近的，即使你是empty set，那么就找table中最大/最小的那个当边界，都是一样的，此处略）<br>并且，此处主要考虑的是RC跟RR级别下的情况。<strong>对RU跟Serializable并无太多讨论</strong>。而且只考虑了select与insert，select与select之间的冲突（据说select跟delete，update都是一个形式，那么就略了），还剩下的是Insert与Insert之间的冲突，即并发插入，TODO吧。</p><p>PPPS：写完之后再整理，想到了大佬文章里的第五点，<strong>SQL语句的执行计划是什么？是索引扫描还是全表扫描？</strong>我当时认为这点可以忽略，因为我认为cluster index必定存在，所以即使是全表扫描也是等同于索引扫描，只是扫描cluster index的时候存在一点特殊（就是上文提到的那点）现在看来，cluster index虽然是index，但确实是特殊的index，当我们需要使用全表扫描，<strong>即使是使用了cluster index，也是不能完全等同于索引扫描的</strong>。想想最后在范围搜索那里，出现的意外情况无法理解的，应该就是这一点了吧。（因为当时的注意力主要在考虑InnoDB是否存在表锁，然后最后的主要论据就是必定存在cluster index，所以必定有索引，表现出表锁的特征其实是行锁加间隔锁的作用等等……实际上，这一点倒是没有错，但cluster index是特殊的index也不可忽视！）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;本文的最终解决的问题：&lt;strong&gt;如何判断一条SQL语句用到了哪些锁？&lt;/strong&gt;&lt;br&gt;（特别地，这里考虑的是&lt;em&gt;MySQL&lt;/em&gt;数据库的锁机制）&lt;/p&gt;
&lt;p&gt;首先，我们需要先对&lt;em&gt;MySQL&lt;/em&gt;的事务机制，锁机制，索引机制都总结一遍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://hongscar.cn/categories/MySQL/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>JVM知识整理</title>
    <link href="https://hongscar.cn/JVM%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html"/>
    <id>https://hongscar.cn/JVM%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html</id>
    <published>2020-02-17T03:48:09.000Z</published>
    <updated>2020-02-17T14:51:51.277Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-类的生命周期：加载→连接→初始化→使用→销毁"><a href="#一-类的生命周期：加载→连接→初始化→使用→销毁" class="headerlink" title="一. 类的生命周期：加载→连接→初始化→使用→销毁"></a>一. 类的生命周期：加载→连接→初始化→使用→销毁</h3><h5 id="连接-包括："><a href="#连接-包括：" class="headerlink" title="连接 包括："></a>连接 包括：</h5><p>①验证（确保被加载的类的正确性）<br>②准备（为静态变量分配内存，并将其初始化为默认值（指0，false，null等），同时将static final值转换为具体的常量<br>③初始化：为静态变量执行赋值语句（static，非final），执行静态块<br>PS：初始化只有在对类主动使用时才会执行，包括以下：<br>①new<br>②访问静态域的时候<br>③反射（如Class.forName)<br>④初始化某个类时，其父类也会初始化<br>⑤运行main方法时，该类加载</p><a id="more"></a><hr><h5 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器:"></a>类加载器:</h5><p><em>①Bootstarp ClassLoader</em>（启动类加载器，由C++实现的类，无法获取实例）<br>负责加载JDK下/lib的类库（如java.*等关键类，是最底层的Class Loader)</p><p><em>②Extension ClassLoader</em>（拓展类加载器<br>负责加载JDK下 /lib/ext目录，即额外的类库</p><p><em>③Application ClassLoader</em>（应用程序类加载器负责加载用户类路径的类，即ClassPath</p><p><em>④其他自定义的类加载器    User Class Loader</em><br>PS：这里的加载器并不是通过继承组成的关系，而是组合。    ②③④都继承自java.lang.ClassLoader</p><hr><h4 id="question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）"><a href="#question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）" class="headerlink" title="question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）"></a>question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）</h4><p>ans：双亲委派模型：当一个Class loader收到了加载类的请求，它不会立刻加载，而是先交给父类加载器加载，但父类加载器找不到那个类，才传递回给子类加载器。即优先在Bootstarp中加载，然后是Extension，然后就才是Application。<br>这样做的好处：<br>①只有1个classloader加载了类，防止内存中会出现同样的字节码<br>②增强了安全性，避免用户自己定义了java预定义的类并成功覆盖。比如用户自定义了一个java.lang.Object的类，这时候它会优先从Bootstrap中加载，而Bootstrap中加载的是java预定义的Object类，而不是用户自定义的Object类，这样就避免了用户的Object类覆盖。如果是先从Application Class loader中加载，那么就是先加载用户自定义的Object类，而Java预定义的Object类被覆盖掉。</p><hr><hr><h3 id="二-JVM的内存结构："><a href="#二-JVM的内存结构：" class="headerlink" title="二. JVM的内存结构："></a>二. JVM的内存结构：</h3><p><strong>JDK1.6： Heap + PermGen（Method Area）永久区，方法区 + Stack + Program Counter Register</strong><br>同时：<strong>①Stack = JVM Stack + Native Method Stack</strong><br>Stack用于描述Java方法执行的内存模型，每个方法执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表，操作栈，动态链接，方法出口，基本类型和对象的引用等等。每一个方法从被调用直至执行完成的过程，就对应一个栈帧在JVM Stack中从入栈到出栈的过程。<br>（Native同理，只是作用与本地方法）<br>PS：如果线程请求的栈深度大于JVM所允许的深度，抛出StackOverflowError。<br>如果JVM Stack可以动态拓展，拓展时无法申请到足够的内存，抛出OutOfMemoryError</p><hr><p><strong>②Heap = Young Generation年轻代 + Old Generation 老年代</strong><br><strong>Young = Eden + From Survivor  + To Survivor</strong><br>通过各种参数可以控制各区域的内存大小，进而达到JVM调优效果<br>-Xms， -Xmx：设置Heap的最小，最大空间的大小<br>-XX:NewSize， -XX:MaxNewSize： 设置年轻代最小，最大空间的大小<br>-XX:PermSize, -XX:MaxPermSize： 设置永久区最小， 最大空间的大小<br>-Xss：设置每个JVM Stack的大小<br>（PS：Perm是永久区，要设置老年代只能通过 Heap - Young来间接控制）<br>PS：在Heap区中，有可能抛出OutOfMemoryError</p><hr><p><strong>③Program Counter Register</strong><br>较小的内存空间，是当前字节码的行号指示器（用于分支，跳转等待）<br>如果执行的是Java方法，记录正在执行的JVM字节码的指令地址。<br>如果是Native方法，那么为空（Undefined）<br>（此区域是JVM唯一无OutOfMemoryError的区域，因为一般不会在这里抛异常）</p><p><strong>④PermGen（Method Area）方法区，永久区</strong><br>用于存储已经被JVM加载的类信息，常量，静态变量，JNI编译后的代码·<br>（会抛出OutOfMemoryError）<br>PS：Heap 和Method Area在线程间是会共享资源的，而Stack和Counter是线程私有的。</p><hr><p><strong><em>JDK各版本的区别： (1.6 ~ 1.8)</em></strong><br>JDK1.6中，各种常量池是放在方法区中的<br>JDK1.7中，常量池放在Heap中，此时：Heap = Young + Old + 各种常量池<br>（PS：关于常量池，这里还有一个TODO，即intern那中问题，看《JVM入门到放弃》）<br>JDK1.8:常量池依然在Heap中，但永久区/方法区被移除，改为使用metaSpace（元空间）</p><hr><hr><h4 id="question2：移除永久区PermGen的原因"><a href="#question2：移除永久区PermGen的原因" class="headerlink" title="question2：移除永久区PermGen的原因"></a>question2：移除永久区PermGen的原因</h4><p>①永久区一直只存在于HotSpot JVM，而JRockit VM没有永久区，为了融合两个JVM而做出的调整，无须继续配置永久区<br>②永久区内存经常不够用，或者发生内存泄漏，抛出OutOfMemoryError：PermGen<br>③永久区会为GC带来不必要的复杂度，并且回收效率偏低</p><hr><h4 id="question3：元空间metaSpace和永久区的区别？"><a href="#question3：元空间metaSpace和永久区的区别？" class="headerlink" title="question3：元空间metaSpace和永久区的区别？"></a>question3：元空间metaSpace和永久区的区别？</h4><p>元空间并不在VM中，而是使用本地内存，默认情况下，仅受本地内存的限制。（可以通过配置参数来控制meta Space，默认情况下，最大空间没有限制，即内存的上限）。配置参数：<br>-XX：MetaspaceSize， -XX：MaxMetaspaceSize    初始空间大小，最大空间大小<br>-XX：MinMetaspaceFreeRadio， -XX：MaxMetaspaceFreeRadio：<br>在GC之后，最小/最大的Metaspace剩余空间容量的百分比</p><hr><h4 id="question4：常量池为什么要移动到Heap"><a href="#question4：常量池为什么要移动到Heap" class="headerlink" title="question4：常量池为什么要移动到Heap"></a>question4：常量池为什么要移动到Heap</h4><p>因为方法区的回收比较困难，会导致过多严重的bug，所以从1.7开始就把常量池移动到Heap，为后续移除PermGen做出准备（在JDK1.8已把PermGen移除）</p><hr><h3 id="三-GC算法："><a href="#三-GC算法：" class="headerlink" title="三. GC算法："></a>三. GC算法：</h3><p><strong>①标记-清除 Mark-Sweep</strong><br>缺点：效率不高，且会产生大量的内存碎片<br><strong>②复制算法 Copying</strong><br>缺点：会使内存缩小一半，不能直接用在Old，因为持续复制长生存期的对象会导致效率降低<br><strong>③标记-压缩 Mark-Compact</strong> （在①的基础上，清除完之后还对碎片进行压缩）<br><strong>④分代收集Generational Collection</strong> 即年轻代用 复制算法，老年代用标记清除/压缩</p><hr><p><strong>垃圾回收器</strong>：<br>①Serial，串行收集器。最古老，最稳定，效率高。但会产生较长的停顿<br>②ParNew，即Serial的多线程版本<br>③Parallel，于ParNew类似，但更关注系统的吞吐量<br>④CMS（Concurrent Mark Sweep）<br>重视服务的响应速度，希望系统停顿时间最短，但会产生大量的空间碎片，降低吞吐量。<br>⑤G1（Garbage-First）<br>满足了GC停顿时间要求，同时又具备高吞吐量的特征<br>（收集器之间可以组合使用，如Young使用A，Old使用B）</p><p>MinorGC：对年轻代进行GC。特点：频繁，回收速度快<br>MajorGC：对老年代进行GC。<br>FullGC：全堆范围的GC</p><hr><h4 id="question5：什么情况下会出现内存溢出-泄漏？"><a href="#question5：什么情况下会出现内存溢出-泄漏？" class="headerlink" title="question5：什么情况下会出现内存溢出/泄漏？"></a>question5：什么情况下会出现内存溢出/泄漏？</h4><p>虽说Java有GC，无须我们手动释放资源，但在运行时还是可能出现对象可达，但不会被使用的情况，这时候就会导致内存泄漏。例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/jvm_1.png" target="_blank" rel="noopener" title="Java内存泄漏例子"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/jvm_1.png" alt="Java内存泄漏例子" title="Java内存泄漏例子"></a><br>内存溢出的可能原因：<br>①内存泄漏导致Stack内存不断增大，引发OutOfMemory（Stack处）<br>②大量jar，class文件加载，装载类的空间不足，溢出 （Class Loader处）<br>③操作大量对象，导致Heap空间不足，溢出（Heap处）<br>④nio直接操作内存，内存过大导致溢出（内存处）<br>（同理应该MetaSpace溢出也是一样的）<br>解决方法：查看是否有内存泄漏，设置参数增大空间，代码是否存在死循环生成过多对象</p><hr><h4 id="question6：JVM从Young到Old的晋升条件是什么"><a href="#question6：JVM从Young到Old的晋升条件是什么" class="headerlink" title="question6：JVM从Young到Old的晋升条件是什么"></a>question6：JVM从Young到Old的晋升条件是什么</h4><p>①对象在Eden出生，经过一个MinorGC还存活，就被Survivor容纳，在From和to中复制交换。如果经过[MaxTenuringThreshold]（默认是15）次交换还存活，进入Old<br>②如果对象大小等于Eden的二分之一，直接分到Old。如果Old也分配不下，做一次MajorGC<br>（如果小于Eden的二分之一，但没有足够的空间，进行MinorGC）<br>③MajorGC之后，如果Survivor仍然放不下，则放到Old<br>④动态年龄判断。如果大于等于某年龄的对象超过survivor空间的一半，则这些对象全部都直接进入Old（无须达到MaxTenuringThreshold)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-类的生命周期：加载→连接→初始化→使用→销毁&quot;&gt;&lt;a href=&quot;#一-类的生命周期：加载→连接→初始化→使用→销毁&quot; class=&quot;headerlink&quot; title=&quot;一. 类的生命周期：加载→连接→初始化→使用→销毁&quot;&gt;&lt;/a&gt;一. 类的生命周期：加载→连接→初始化→使用→销毁&lt;/h3&gt;&lt;h5 id=&quot;连接-包括：&quot;&gt;&lt;a href=&quot;#连接-包括：&quot; class=&quot;headerlink&quot; title=&quot;连接 包括：&quot;&gt;&lt;/a&gt;连接 包括：&lt;/h5&gt;&lt;p&gt;①验证（确保被加载的类的正确性）&lt;br&gt;②准备（为静态变量分配内存，并将其初始化为默认值（指0，false，null等），同时将static final值转换为具体的常量&lt;br&gt;③初始化：为静态变量执行赋值语句（static，非final），执行静态块&lt;br&gt;PS：初始化只有在对类主动使用时才会执行，包括以下：&lt;br&gt;①new&lt;br&gt;②访问静态域的时候&lt;br&gt;③反射（如Class.forName)&lt;br&gt;④初始化某个类时，其父类也会初始化&lt;br&gt;⑤运行main方法时，该类加载&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://hongscar.cn/categories/Java/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>数据库三级封锁协议</title>
    <link href="https://hongscar.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.html"/>
    <id>https://hongscar.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.html</id>
    <published>2020-02-17T03:46:44.000Z</published>
    <updated>2020-02-17T14:52:12.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>数据库并发会导致各种问题（即多线程下导致的同步问题），需要用lock来解决。</p><p>一般会导致的问题：<strong><em>脏读，不可重复读，第一类更新丢失，第二类更新丢失</em></strong></p><p>为了解决这些问题，需要使用锁机制，数据库一般有三级封锁协议。本文阐述了这些问题具体是什么，锁机制如何解决这些问题。</p><a id="more"></a><h3 id="二-数据库并发导致的问题"><a href="#二-数据库并发导致的问题" class="headerlink" title="二. 数据库并发导致的问题"></a>二. 数据库并发导致的问题</h3><hr><p>①<strong><em>脏读</em></strong>（<em>dirty read</em>）：事务A update了data，事务B读取了update后的data，此时事务A rollback，导致B读取的是错误的数据，即dirty data</p><hr><p>②<strong><em>不可重复读</em></strong>（<em>unrepeatable read</em>）：B读取了data，A读取了data并且进行了update，此时B再次读取data，两次获取到的data并不一致。</p><hr><p>③<strong><em>第一类更新丢失</em></strong>：A读取了data①，B读取了data并且进行update，commit。A同时又对data进行update，而这个update是在①的基础上操作的，最终B的更新就会被丢失。</p><hr><p>④<strong><em>第二类更新丢失</em></strong>：B读取了data，A读取了data。B对data进行update，然后commit。接着A又对data进行update，commit。同样的，B的更新会被丢失。</p><hr><h3 id="三-数据库的锁机制"><a href="#三-数据库的锁机制" class="headerlink" title="三. 数据库的锁机制"></a>三. 数据库的锁机制</h3><p>数据库有两种锁，S锁和X锁：<br><strong>S锁（shared）：事务可读不可写。（其他事务可以同时添加S锁）</strong><br><strong>X锁（exclusive）：事务可读可写。（其他事务不可以同时添加任何锁）</strong><br>锁之间的兼容性，设定有两个锁a1，a2，用f(a1, a2)来表示两个锁的兼容性，如果f = 1，则表示兼容。如果f = 0，则不兼容。<br>f(s, s) = 1;其他诸如：f(x, x)= f(x, s)= f(s, x) = 0;<br><strong><em>即X锁不能与其他锁同时存在。而s锁与s锁之间可以同时存在。</em></strong></p><hr><p><strong>1.一级锁协议：</strong>事务T修改数据R之前，先加X锁，直到事务结束时释放（无论是正常结束commit还是非正常结束rollback）<br>作用：可防止 更新丢失问题。<br>不能防止： 脏读，不可重复读，幻读等。<br>PS：任何数据库都至少满足一级锁的协议，因为更新丢失是不能接受的错误，所以更新丢失一般只存在于理论讨论中，实际应用中基本不会出现这个问题。</p><hr><p><strong>2.二级锁协议：</strong>在一级锁的条件下，T在读取R之前先加S锁，读完后释放。<br>作用：可防止更新丢失，脏读。<br>不能防止： 不可重复读，幻读。</p><hr><p><strong>3.三级锁协议：</strong>在一级锁的条件下，T在读取R之前先加S锁，事务结束后释放。<br>作用：可防止 更新丢失，脏读，不可重复读，幻读。</p><hr><hr><h3 id="四-具体例子来说明锁的作用机制："><a href="#四-具体例子来说明锁的作用机制：" class="headerlink" title="四. 具体例子来说明锁的作用机制："></a>四. 具体例子来说明锁的作用机制：</h3><h5 id="①不使用锁导致的更新丢失问题："><a href="#①不使用锁导致的更新丢失问题：" class="headerlink" title="①不使用锁导致的更新丢失问题："></a>①不使用锁导致的更新丢失问题：</h5><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_1.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_1.jpg" alt=""></a></p><h5 id="②使用一级锁解决更新丢失问题："><a href="#②使用一级锁解决更新丢失问题：" class="headerlink" title="②使用一级锁解决更新丢失问题："></a>②使用一级锁解决更新丢失问题：</h5><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_2.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_2.jpg" alt=""></a><br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_3.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_3.jpg" alt=""></a></p><h5 id="③为什么一级锁不能解决脏读问题："><a href="#③为什么一级锁不能解决脏读问题：" class="headerlink" title="③为什么一级锁不能解决脏读问题："></a>③为什么一级锁不能解决脏读问题：</h5><p>脏读例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_4.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_4.jpg" alt=""></a><br>用一级锁的情况：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_5.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_5.jpg" alt=""></a></p><h5 id="④使用二级锁解决脏读问题："><a href="#④使用二级锁解决脏读问题：" class="headerlink" title="④使用二级锁解决脏读问题："></a>④使用二级锁解决脏读问题：</h5><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_6.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_6.jpg" alt=""></a></p><h5 id="⑤为什么二级锁不能解决不可重复读问题："><a href="#⑤为什么二级锁不能解决不可重复读问题：" class="headerlink" title="⑤为什么二级锁不能解决不可重复读问题："></a>⑤为什么二级锁不能解决不可重复读问题：</h5><p>不可重复读例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_7.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_7.jpg" alt=""></a><br>使用二级锁的情况：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_8.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_8.jpg" alt=""></a></p><h5 id="⑥三级锁解决不可重复读："><a href="#⑥三级锁解决不可重复读：" class="headerlink" title="⑥三级锁解决不可重复读："></a>⑥三级锁解决不可重复读：</h5><p>三级锁相当于，完全串行化。即一个事务开始了，其他事务都完全不能开始进行，无论是读还是写。因此就上述的例子，一定是A完全执行完毕，才轮到B执行。那么就必定不会出现不可重复读的问题。（三级锁的完全串行化，也就是，为了解决并行化带来的问题，直接不使用并行，改为串行执行。）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;数据库并发会导致各种问题（即多线程下导致的同步问题），需要用lock来解决。&lt;/p&gt;
&lt;p&gt;一般会导致的问题：&lt;strong&gt;&lt;em&gt;脏读，不可重复读，第一类更新丢失，第二类更新丢失&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了解决这些问题，需要使用锁机制，数据库一般有三级封锁协议。本文阐述了这些问题具体是什么，锁机制如何解决这些问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://hongscar.cn/categories/MySQL/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>Github的简要操作</title>
    <link href="https://hongscar.cn/Github%E7%9A%84%E7%AE%80%E8%A6%81%E6%93%8D%E4%BD%9C.html"/>
    <id>https://hongscar.cn/Github%E7%9A%84%E7%AE%80%E8%A6%81%E6%93%8D%E4%BD%9C.html</id>
    <published>2020-02-17T03:14:58.000Z</published>
    <updated>2020-02-17T06:17:42.730Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下IDEA项目提交到GitHub的整体操作:（主要是清晰每一步的作用，而不是死记硬背）<br><strong>step1:</strong><br>IDEA的GitHub<strong>连通配置</strong>。（这个就在setting-git那里，但一般配置一次就不再需要了，pass）<br><strong>step2：</strong><br>将本地的项目连接到GitHub。 <em>VCS — Import into Version</em> Control （会让你创建一个仓库）<br>然后再将项目切实地与该仓库连接。<em>VCS — Import into Version Control — Create Git Repository</em><br>（有一次没有Create，右键项目甚至没有git操作）</p><a id="more"></a><p><strong>step3：</strong><br>连接了之后，就是提交操作了，提交其实一共有3个步骤，不要胡乱pull跟push就什么都不会了。<br><strong>PS：只要IDEA的项目已经成功执行了步骤1和2，那么之后其实就不需要前面两个步骤了。</strong><br>①<strong>VCS — Git — add</strong><br>作用，把本地发生改变了的代码添加到branch中，其实就是先把你的代码都commit到本地的一个分支了，但这里还没有提交。<br>②<strong>VCS — Git — Commit File</strong><br>第一步的操作只是add到工作环境，还没添加到本地仓库，这里把所有add的文件commit到本地操作<br>③最后就是提交到远程仓库。这个最后一步才是pull跟push的地方。<br><strong><em>先pull，再push即可</em></strong>。<br>pull的作用其实就是先跟远程仓库的代码对比，因为可能别人已经commit过，与你的代码产生冲突，这时候你需要解决这些冲突再commit，不然你把别人的代码覆盖了怎么办？<br>push就是最后的提交代码了，一般pull成功的话push也就没有问题。</p><p>但是，在第一次创建的时候，可能会存在问题，好像是因为不在同一个项目里，无论是change分支，还是git pull —allow-unrelated-histories啊等等的，都不行。<br>其实第一次创建，又不可能conflict（唯一可能conflict的地方只有一个readme文件而已。。）<br>所以干脆直接强制push即可: <strong>git push -u origin master -f</strong> (-f 很显然，就是force）</p><p>其他常用操作：<br>查看远程仓库： git remote -v (remote就是远程的意思）<br>添加远程仓库： git remote add (nick_name) (repository-url)<br>删除仓库（注意是删除与仓库的连接而已)：git remote remove nick_name<br>（一般nick_name都叫origin了，不知为何，先这样记着）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下IDEA项目提交到GitHub的整体操作:（主要是清晰每一步的作用，而不是死记硬背）&lt;br&gt;&lt;strong&gt;step1:&lt;/strong&gt;&lt;br&gt;IDEA的GitHub&lt;strong&gt;连通配置&lt;/strong&gt;。（这个就在setting-git那里，但一般配置一次就不再需要了，pass）&lt;br&gt;&lt;strong&gt;step2：&lt;/strong&gt;&lt;br&gt;将本地的项目连接到GitHub。 &lt;em&gt;VCS — Import into Version&lt;/em&gt; Control （会让你创建一个仓库）&lt;br&gt;然后再将项目切实地与该仓库连接。&lt;em&gt;VCS — Import into Version Control — Create Git Repository&lt;/em&gt;&lt;br&gt;（有一次没有Create，右键项目甚至没有git操作）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Github" scheme="https://hongscar.cn/categories/Github/"/>
    
    
      <category term="Github" scheme="https://hongscar.cn/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>阅读Servlet的源码</title>
    <link href="https://hongscar.cn/%E9%98%85%E8%AF%BBServlet%E7%9A%84%E6%BA%90%E7%A0%81.html"/>
    <id>https://hongscar.cn/%E9%98%85%E8%AF%BBServlet%E7%9A%84%E6%BA%90%E7%A0%81.html</id>
    <published>2020-02-17T03:14:10.000Z</published>
    <updated>2020-02-18T07:15:40.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>在写SSM项目的过程中，遇到了一些小问题，不知道如何解决。其实对于框架的很多问题，很多时候都是因为框架的封装性，然后自身没有理解框架的内部逻辑而导致的。于是这次想花点时间好好读一下Servlet的源码，这样可以更好地理解JavaWeb底层，遇到问题也能更加地游刃有余。当然此次阅读源码只是比较浅显的，先看官方文档，然后在有目的性地读一部分源码来感受文档的内容。如果要认真看那肯定要看很久，目前还没这个时间。<br>    <strong>首先是Servlet API包含了两个软件包，javax.servlet和javax.servlet.http</strong>，为什么会有两个呢，因为早先设计该规范的人认为Servlet是一种服务模型，不一定要依赖于某种网络协议之上，于是就抽象出了一个javax.servlet，同时再提供一个基于HTTP协议上的接口拓展。但目前看来，似乎还没有发现有其他协议上实现的Servlet技术。</p><a id="more"></a><hr><h3 id="二-HTTPServlet抽象类"><a href="#二-HTTPServlet抽象类" class="headerlink" title="二. HTTPServlet抽象类"></a>二. HTTPServlet抽象类</h3><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/1.jpg" alt="img">)](<a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/1.jpg" target="_blank" rel="noopener">https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/1.jpg</a>)<br>官方解析：<br>    <em>Provides an abstract class to be subclassed to create an HTTP servlet suitable for a Web site.A subclass of HttpServlet must override at leat one method usually one of these: doGet,doPost,doPut,doDelete.</em><br>    提供一个抽象类，使得它的子类可以更方便地创建一个标准HTTP Servlet。子类必须至少实现以下方法的其中一个：<strong>doGet，doPost，doPut，doDelete</strong><br>    <strong>标准Servlet接口有一个service方法</strong>，即service的标准服务方法。但是service方法没必要override，因为HTTPServlet已经把service方法写好了，把标准的HTTP请求通过它们的HTTP request类型(即请求的doXXX)，分别转发到具体的处理方法中。比如类型是doGet，就转发到doGet方法中。<br>HttpServlet里的service方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    String method = req.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// servlet doesn't support if-modified-since, no reason</span></span><br><span class="line">        <span class="comment">// to go through further expensive logic</span></span><br><span class="line">        doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">        <span class="keyword">if</span> (ifModifiedSince &lt; (lastModified / <span class="number">1000</span> * <span class="number">1000</span>)) &#123;</span><br><span class="line">            <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                    <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                    <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">            maybeSetLastModified(resp, lastModified);</span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">        <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        可以看到是通过Java反射的机制，获取了HttpServletRequest的方法，返回了一个method的字符串，根据method来判定到底是属于哪一个doXXX，再分别调用doXXX方法。这里我钻了一下牛角尖，HttpServletRequest里有多个方法，getMethod方法的内部逻辑是如何返回的呢。HttpServletRequest只是一个接口，寻找了很久只找到了一个实现类HttpServletRequestWrapper，然而还是没有具体的getMethod实现。最后知道了这个HttpServletRequest是由J2EE的容器来实现的，比如Tomcat，webLogic。看来我们是不能得知getMethod的具体逻辑了，只需要知道它可以返回HTTP报文头的method是什么就行。<br>​        然后如果是METHOD_XXX方法，就调用doXXX方法。好几个方法都没有特别，直接调用。但HEAD方法和GET方法多了一个逻辑，用于验证文件是否已经被修改。HEAD和GET都是获取服务器上的资源，但HEAD不需要返回消息体，只请求返回报文头，空的消息体，也就是说，它可以用于检测资源是否有效，是否存在，网站是否有篡改等。当需要这类操作的时候，就不需要用GET了，用HEAD即可。如果本地有缓存文件，和要GET的文件是相同的，没有修改过的，那么此时就会返回状态码304，表示文件没有被修改。虽然返回304的时候已经做了一次数据库查询，但可以避免接下来更多的数据库查询。对于HEAD方法，只返回HTTP报文头，更是降低了带宽的消耗。<br>​    最终到达了doXXX的方法，以GET方法为例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String protocol = req.getProtocol();</span><br><span class="line">    String msg = lStrings.getString(<span class="string">"http.method_get_not_supported"</span>);</span><br><span class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">"1.1"</span>)) &#123;</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里有个特别的地方是，虽然doXXX方法有具体的实现，但它是无论如何都会返回错误的，即sendError。这是避免了具体子类直接调用HttpServlet的doXXX方法。因此子类必须重写至少1个doXXX方法，然后再通过HTTP的method判断要调用哪个doXXX方法，进而调用子类重写的doXXX方法。</p><hr><h3 id="三-Servlet-ServiceConfig接口"><a href="#三-Servlet-ServiceConfig接口" class="headerlink" title="三. Servlet, ServiceConfig接口"></a>三. Servlet, ServiceConfig接口</h3><p>​    一个Java Servlet具有生命周期，这个生命周期定义了一个Servlet如何被载入并被初始化，如何接受请求并对请求的响应，如何从服务中被清除等等。Servlet的生命周期被javax.servlet.Servlet这个接口所定义。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/5.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/5.jpg" alt="img"></a><br>​    所有的Java Servlet都会直接或间接地实现javax.servlet.Servlet接口，这样它才能在一个servlet引擎中运行。servlet引擎是web服务器按照Java Servlet API定制的拓展。Servlet引擎提供网络服务，能够理解MIME请求，并提供一个运行Servlet的容器。<br>​    只有实现了Servlet接口的才是Servlet，然后才包含Servlet的生命周期。当然，继承了HttpServlet，就是继承了GenericServlet，就是实现了Servlet接口。<br>​    ServletConfig就是用于获取Servlet的配置，比如初始化参数，参数名等等，还可以获取该Servlet的ServletContext对象。</p><hr><h3 id="四-ServletContext接口"><a href="#四-ServletContext接口" class="headerlink" title="四. ServletContext接口"></a>四. ServletContext接口</h3><p>​    Servlet上下文，服务器会为工程建立一个全局唯一的ServletContext对象，工程内部所有的Servlet都共享这个对象，可以用于读取全局配置参数，搜索资源文件等等。</p><hr><h3 id="五-ServletRequest接口等"><a href="#五-ServletRequest接口等" class="headerlink" title="五. ServletRequest接口等"></a>五. ServletRequest接口等</h3><p>ServletRequest接口，请求时产生的对象，ServletResponse接口，响应时产生的对象。<br>SingleThreadModel接口，使得Servlet成为单线程。（只接受1个请求）<br>GenericServlet类，实现了Servlet接口，使得编写Servlet更方便。<br>ServletInputStream，ServletOutputStream抽象类，继承InputStream，OutputStream<br>ServletException，UnavailableException类，没什么好说的。</p><hr><h3 id="六-Filter接口"><a href="#六-Filter接口" class="headerlink" title="六. Filter接口"></a>六. Filter接口</h3><p>​    用于对request，response等任务进行过滤，一般是用doFilter方法来过滤，可以通过FilterConfig的对象来获取Filter的初始化参数。包含了destroy，init，doFilter方法。<br>生命周期：当有Servlet的service方法要被执行时，被init，直到所有的service方法已经执行完毕doFilter，或者过了一定的时间之后，就会执行destroy方法。<br>​    对具体实现类的基本要求：<br>①要对request进行验证检查。<br>②对request和response可以选择自定义实现类去包装<br>③当有多个过滤方法的时候，需要用到过滤链FilterChain，并且在当前的Filter没执行完之前，当前的数据都不会被通过。执行完之后会继续执行chain里的下一个filter<br>④在过滤链调用下一个filter的时候，就要直接设置当前的response header（避免窜数据）<br>FilterChain的多个filter执行顺序在web.xml的filter-mapping里控制<br>FilterConfig，对Filter的初始化配置参数等等。</p><hr><h3 id="七-RequestDispatcher接口"><a href="#七-RequestDispatcher接口" class="headerlink" title="七. RequestDispatcher接口"></a>七. RequestDispatcher接口</h3><p>​    直译就是请求分发器。具备两个方法，forward和include。<br>定义了一个对象，从客户端接受请求之后，需要将请求发给服务器。有的时候需要传递给另一个资源去响应。比如用户请求资源A，A可以在接受请求后，在A上面做一些准备工作，再从A转发转发大都B，由B去响应例子。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/2.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/2.jpg" alt="img"></a><br>第一个request就是A的准备工作，第二个就是转发到B，由B去响应。</p><p>include不是转发，是包含某个资源，比如Servlet，JSP，HTML页面<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/3.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/3.jpg" alt="img"></a></p><hr><h3 id="八-HttpServletRequest，HttpServletResponse接口"><a href="#八-HttpServletRequest，HttpServletResponse接口" class="headerlink" title="八. HttpServletRequest，HttpServletResponse接口"></a>八. HttpServletRequest，HttpServletResponse接口</h3><p>继承ServletRequest，ServletResponse接口，用于处理一个HTTP格式的请求/响应<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/4.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/4.jpg" alt="img"></a><br>主要方法，setAttribute，getAttribute(继承得来的),getSession等等。Response同理。</p><hr><h3 id="九-HTTPSession接口"><a href="#九-HTTPSession接口" class="headerlink" title="九. HTTPSession接口"></a>九. HTTPSession接口</h3><p>创建一个HTTP会话。<br>方法主要是获取Session的参数(ID，creationTime，最长存在时间等等),以及setAttribute。。</p><p>HttpSessionBindingListener接口。HTTPSession监听器，添加到Session中，监听Session，此处是监听binding，绑定事件。<br>还有其他的Session的Listener，比如Attribute，Activation监听器。（也就是HttpSessionAttributeListener,HttpSessionActivationListener）</p><p>HttpSessionBindingEvent类，实现了HttpSessionBindingListener接口。只多了两个成员属性。<br>HttpUtils类，收集HTTP Servlet使用的静态的有效方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;在写SSM项目的过程中，遇到了一些小问题，不知道如何解决。其实对于框架的很多问题，很多时候都是因为框架的封装性，然后自身没有理解框架的内部逻辑而导致的。于是这次想花点时间好好读一下Servlet的源码，这样可以更好地理解JavaWeb底层，遇到问题也能更加地游刃有余。当然此次阅读源码只是比较浅显的，先看官方文档，然后在有目的性地读一部分源码来感受文档的内容。如果要认真看那肯定要看很久，目前还没这个时间。&lt;br&gt;    &lt;strong&gt;首先是Servlet API包含了两个软件包，javax.servlet和javax.servlet.http&lt;/strong&gt;，为什么会有两个呢，因为早先设计该规范的人认为Servlet是一种服务模型，不一定要依赖于某种网络协议之上，于是就抽象出了一个javax.servlet，同时再提供一个基于HTTP协议上的接口拓展。但目前看来，似乎还没有发现有其他协议上实现的Servlet技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Servlet" scheme="https://hongscar.cn/categories/Servlet/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>在vscode配置Java环境遇到的问题</title>
    <link href="https://hongscar.cn/%E5%9C%A8vscode%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://hongscar.cn/%E5%9C%A8vscode%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html</id>
    <published>2020-02-17T03:13:59.000Z</published>
    <updated>2020-02-17T06:20:12.587Z</updated>
    
    <content type="html"><![CDATA[<p>​        之前一直把vscode当作一个sublime的强化版，仅仅把它当作一个编辑器而已。虽然一直也清楚这是一个很好的IDE，但却没有好好利用，可能是因为之前一直觉得IntelliJ IDEA已经满足了我的需求罢。直到最近，IDEA真的是变本加厉，只要一输入（拿着键盘随便乱敲），那么CPU就会暴增。cpu暴增一般情况下倒没什么所谓，反正没有超100就行吧（刚打开的时候还真的会升到100），可是我这破电脑只要CPU稍微高一点，风扇就开始呜呜呜地，像一台发电机。明天等待工具到了真的要把它拆开来除一下灰尘，但无论如何，IDEA过于臃肿已经是显而易见的问题了，还是需要认真考虑一下如何使用vscode吧。说实话，真的没想到我这么快就会想跟IDEA说再见，还记得当时刚开始学C++，非要听信那个菜比老师，用vs2010，体验极差，而我竟然用了两年多。大二的时候开始学Java，一开始是使用Eclipse，感觉也是比vs2010提升了一个档次。后来接触到了IDEA，真的是感觉神仙一样的软件，各种智能补全。当然了，中途还因为学数媒的原因，下载了一个vs2013，那个的体验其实也很好的，反正真的应该大一的时候就直接用vs2013，而不是那脑残的vs2010。总而言之，技术永远是在进步的，需求也是在增加的，对于用户，程序员，都是一样的。</p><a id="more"></a>        其实还考虑过优化IDEA，但参照了一下网上的做法，无论是修改JVM参数，还是关闭所有代码检查，都无济于事。说实话，一开始也不抱什么希望，因为我是只要键入就会飙升，那真的不太行。<pre><code>然后开始搞vscode，突然想到了以前也尝试过，未遂。当时遇到的问题就是，它说我的JDK指向路径是空的，是version 0，可我指向的确切就是我一直使用的JDK8，我的IDEA都是在使用这个的。其实比较麻烦的是，我对vscode的各种参数，各种setting，包括快捷键，真的是几乎一无所知。当时仅仅也只是下载了几个plugins，当个普通的编辑器就完事了。最无奈的是，一直显示我没有配置JDK，或者准确地说应该是配置失败，但我直接使用一个Code Runner的插件时，直接使用alt+B就能成功运行了，可即便如此，还是不能直接点最上方的运行/ 调试，点了就报错。如果这个插件可以调试我可能就这样先暂时用着了，可是它似乎真的只能run，那只好继续处理。既然说是这个JDK有问题，那我便直接去下一个JDK吧，我下载了一个JDK12，修改了JAVA_HOME，重启电脑。结果发现java -version仍然是1.8。经过了许久的处理才发现，我以前在配置JDK的时候太过不求甚解了，导致遗留下来了很多错误。就是说，虽然这样做可以运行，但并不是正确的做法。比如JAVA_HOME其实就是用于存放JDK的一个路径，之后如果要放到ClassPath，或者Path等等的，都可以引用这个参数，%JAVA_HOME%，后面紧接着/bin，/lib等等的，差不多也就是可重用可维护了，以后如果要换JDK，直接改JAVA_HOME就行了。可我当时在ClassPath里使用了这个参数，在Path里却没有，说明当时根本就没有理解这个参数的作用。然后我把Path的绝对路径改成了JAVA_HOME，发现仍然不行。再仔细一看，原来这个根本就没有用上，因为上面还有3个不知道是什么的JavaPath，有什么AdoptOpenJDK，有Oracle commons files等等。在一台电脑上如果存在多个JavaPath，那么是最上方（win7应该就是最左方）的生效。所以我一直以为整台电脑都使用了的E盘的library下的JDK，原来根本就没有，我的环境变量竟然一直是OpenJDK，也就是说classpath跟path使用了两个不同的JDK罢了。把以前的蜜汁path都去掉之后，再把自己新增的%JAVA_HOME%/bin移动到了最上方，这下总算就成功了，java -version也成功改成了12。那么IDEA里一直用的1.8，会不会因此不能运行？答案是不会，因为IDEA根本就不需要环境变量的那个Path参数，那个是在cmd里，全局里生效的，相当于IDEA是在本地自己使用了另一个JDK。我一开始觉得JDK有点奇怪，使用java -verbose查看JDK路径，我还好奇为什么会是在C盘的一个OpenJDK里，原来是当时留下的各种错误啊。JDK总算配置好了，但vscode依然不能运行，显示不能找到主类。这会我又没有动脑子，直接去改参数瞎搞。其实这个问题我在看编程思想的第一章就应该碰到过了，因为vscode毕竟不是传统的IDEA，它本体就是一个编辑器，非常轻量级，只有40M，但它可以通过各种plugins来增强功能罢了。因此，可能就是vscode确实就是直接使用环境变量里的ClassPath跟Path，直接命令行运行程序的，而IDEA这种还有更多的改进。那么直接在cmd里编译运行java程序会有一个什么经典的问题呢，就是package。最开始学java 的时候都尝试过cmd里编译运行，结果有一天会发现，自己明明第一个程序在cmd里是可行的，但在eclipse或者IDEA把代码复制过去便是找不到主类的。唯一的区别便是package，package其实就是一个文件夹，对于javac，java命令，这个还没智能到直接跳入到相应的位置去执行正确的文件，所以当时我们的解决方案是这样的，直接删掉package语句，然后就可以运行了，但显然并不是长远之计，难道以后写的程序都不加package了吗？于是正经的方案是这样的，给命令增加一个-d参数，还有一个什么什么的，忘记了，然后就可以根据package语句进入相应的路径去执行正确的文件了。所以，在vscode里也是要对基本的命令进行修改，比如默认是java test，那么就改成 java -d …… test。所以最后是在settings里增加这段代码：</code></pre><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/vscode_1.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/vscode_1.png" alt="settings代码"></a><br>        进入相应的$dir，然后再进行javac跟java，那么就大功告成（看起来还是跟-d有所区别的）至于其他的注释，便是针对其他的语言，这里无须理会。最后把vscode进行reload，程序就成功运行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        之前一直把vscode当作一个sublime的强化版，仅仅把它当作一个编辑器而已。虽然一直也清楚这是一个很好的IDE，但却没有好好利用，可能是因为之前一直觉得IntelliJ IDEA已经满足了我的需求罢。直到最近，IDEA真的是变本加厉，只要一输入（拿着键盘随便乱敲），那么CPU就会暴增。cpu暴增一般情况下倒没什么所谓，反正没有超100就行吧（刚打开的时候还真的会升到100），可是我这破电脑只要CPU稍微高一点，风扇就开始呜呜呜地，像一台发电机。明天等待工具到了真的要把它拆开来除一下灰尘，但无论如何，IDEA过于臃肿已经是显而易见的问题了，还是需要认真考虑一下如何使用vscode吧。说实话，真的没想到我这么快就会想跟IDEA说再见，还记得当时刚开始学C++，非要听信那个菜比老师，用vs2010，体验极差，而我竟然用了两年多。大二的时候开始学Java，一开始是使用Eclipse，感觉也是比vs2010提升了一个档次。后来接触到了IDEA，真的是感觉神仙一样的软件，各种智能补全。当然了，中途还因为学数媒的原因，下载了一个vs2013，那个的体验其实也很好的，反正真的应该大一的时候就直接用vs2013，而不是那脑残的vs2010。总而言之，技术永远是在进步的，需求也是在增加的，对于用户，程序员，都是一样的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IDE" scheme="https://hongscar.cn/categories/IDE/"/>
    
    
      <category term="IDE" scheme="https://hongscar.cn/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>记一次服务器CPU100%的问题</title>
    <link href="https://hongscar.cn/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8CPU100%%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://hongscar.cn/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8CPU100%%E7%9A%84%E9%97%AE%E9%A2%98.html</id>
    <published>2020-02-17T03:13:34.000Z</published>
    <updated>2020-02-17T06:23:03.444Z</updated>
    
    <content type="html"><![CDATA[<p>PS：写在前面，这篇文章最后<strong>并没有解决</strong>服务器CPU100%的问题，仅仅是记录在尝试过程中学到的知识点。</p><p>​    今天原本打算使用redis连接项目，正好网站备案通过了，正打算先测试一下域名是否可用，结果反而整个项目都不可用了。想着应该又是tomcat那边的问题，先上服务器看了一下，感觉服务器的卡顿越来越厉害了，时不时就会卡住然后断开连接。想想腾讯云也不至于这么烂，于是查了一下原因。虽说最后没有解决，但当中的过程还是学习到了很多。目前先把出错的服务器保存了一个snapshot，然后对服务器进行重载。先把这个问题放下，以后再回去解决。（主要是我数据库没有进行备份，数据还在上面，而数据库也出问题了，完全无法connect，自然也无法备份了。但保存了snapshot，那么数据库文件还在里面，等到需要那部分数据的时候，就对snapshot进行载入，然后再修复错误去获取数据吧，现在先放下这个问题）</p><a id="more"></a>    首先就是先运行了一下top命令，意外地发现%id为0，即CPU idle space为0，也就是CPU使用率竟然是100？那肯定是出现问题了，而且这样的话断开连接也不足为奇了，那么CPU 100%到底是从什么时候开始的，先查看了一下腾讯云的监控记录：<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_1.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_1.png" alt="腾讯云的监控记录"></a></p><p>​    （吃惊）竟然一直是100的？我服务器上也没运行几个程序，也就一个tomcat（而且因为网站备案的原因，甚至直接stop了），还有mysql跟redis，但又没有事务读写，怎么会出现问题呢？于是我调了一下时间，调到5月初直到现在，看看是否一直都是100，还是在什么时候变成了100：</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_2.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_2.png" alt="更久之前的监控数据"></a></p><p>把鼠标指到确切的转折点，可以看到，是8月30号这天开始飙升的，而且之后就一直高居不下，那么8月30那天我在服务器上做了什么呢。翻了一下日记，我在8.30这天学习了Redis，也就是在服务器上装了Redis。虽说没什么道理，但确实如此，没有任何其他理由。等一下我还要在我刚刚重装的服务器上安装mysql跟redis，看一下还会不会出现100的问题。如果会，再重装，只安装redis。虽说后面会换另一台服务器去单独做MySQL跟redis服务器，但这个问题肯定还是要解决的。</p><hr><p>那么在解决的过程我使用了哪些命令，又遇到了哪些子问题，继续去处理的，现在列一个清单。</p><p>①首先去查询top的用法<br>top命令虽然是我实习的时候用得最熟练的命令，但时间过去太久了，我也记不清它的很多数值是什么意思。然后知道了%Cpu就是CPU的使用情况，其中：%us表示用户空间程序的CPU使用率，%sy表示系统（Kernel）的CPU使用率，%ni表示用户空间且通过nice调度过的程序的CPU使用率。<br><em>CPU time = user space time + system space time</em><br>至于nice调度，其实就是进程的优先级，大致先知晓即可。<br>%id：空间的CPU（我就是这里一直是0，也就是idle space为0，CPU使用率100）</p><p>②除了CPU，还有可能是内存的问题<br>    对着top使用回车（刷新），发现CPU idle space很奇怪，会变化，而且要么是0，要么是100，显然是出现了一个错误的进程，然后突然导致100，而且还是一直生成，短暂过后又结束。最坑的是，使用top并找不到一个高CPU使用率的进程，所以完全不理解为何是100？可能是top显示的只是用户进程，不显示系统进程？<br>    于是继续对磁盘进行查看，使用了df -h命令。图片没有存，但大概是，磁盘空间大小是50G，已经使用了41G。虽然安装软件的时候没有想太多，但毕竟只安装了几个软件，不至于这么大的空间，因而对这块还是存有疑惑。然后再查看了腾讯云的磁盘监控（对了，腾讯云的监控出错了，然后还得执行一段命令才能查看，但就是很简单地copy执行一次即可，就在腾讯云官方上的代码）。最后的磁盘监控结果是这样的：</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_3.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_3.png" alt="磁盘监控结果"></a></p><p>当时的磁盘读写一直很大，我就猜测是MySQL出现了错误，然后一直在编写错误日志？</p><p>③处理MySQL中的问题<br>    首先，我当时安装MySQL并没有直接安装服务service，这确实不是一个好的选择，tomcat也是如此。平时偶尔想对服务进行处理，使用systemctl，结果显示没有此service。然后还得去安装路径里自己调用shell脚本，然后还得找到这个安装路径，又是locate又是find，又是whereis的。<br>    然后想先看一下错误日志在哪，以往每次打开文件都是vim，实际上用head跟tail是一个很好的选择。不然突然一下子出现一大串文字的体验也是很差劲的。<br>    不过尝试了很多次，都无法彻底关闭mysql。这也就是安装法的最差劲的地方吧。找到了mysqld进程，都直接kill -9了，依然没有用处。如果是安装服务，直接systemctl stop即可。</p><p>④其他命令<br>因为top没有看到高CPU利用率的进程，于是还尝试了一些其他命令。<br>vmstat：查看系统负载<br>pidstat：查看进程使用磁盘的情况<br>pidstat -d 1：<br>netstat -na | grep 80 查找<em>80</em> 的端口（看是否开放，正在使用）</p><p>⑤finally<br>    其实没有解决问题，所以只能用最笨的方法，重装系统。虽然重装系统很快，一分钟就结束了，但还是很不好。首先必须得对服务器进行snapshot备份，毕竟数据库的数据也取不出来（感觉出错的原因主要就是MySQL跟redis的错）。然后数据至少存在了snapshot当中，等到需要那部分数据或者有空的时候，再new一个服务器去尝试解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：写在前面，这篇文章最后&lt;strong&gt;并没有解决&lt;/strong&gt;服务器CPU100%的问题，仅仅是记录在尝试过程中学到的知识点。&lt;/p&gt;
&lt;p&gt;​    今天原本打算使用redis连接项目，正好网站备案通过了，正打算先测试一下域名是否可用，结果反而整个项目都不可用了。想着应该又是tomcat那边的问题，先上服务器看了一下，感觉服务器的卡顿越来越厉害了，时不时就会卡住然后断开连接。想想腾讯云也不至于这么烂，于是查了一下原因。虽说最后没有解决，但当中的过程还是学习到了很多。目前先把出错的服务器保存了一个snapshot，然后对服务器进行重载。先把这个问题放下，以后再回去解决。（主要是我数据库没有进行备份，数据还在上面，而数据库也出问题了，完全无法connect，自然也无法备份了。但保存了snapshot，那么数据库文件还在里面，等到需要那部分数据的时候，就对snapshot进行载入，然后再修复错误去获取数据吧，现在先放下这个问题）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://hongscar.cn/categories/Linux/"/>
    
    
      <category term="Debug" scheme="https://hongscar.cn/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>关于链表的一些疑惑</title>
    <link href="https://hongscar.cn/%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E6%83%91.html"/>
    <id>https://hongscar.cn/%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E6%83%91.html</id>
    <published>2020-02-17T03:13:20.000Z</published>
    <updated>2020-02-17T06:19:44.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>​        链表想通的时候，感觉很简单，比数组还简单，只需要维护一个next指针，然后对指针进行操作即可。但有的时候也会遇到想不通的情况，这时候即便是非常简单的问题，都很难解决。所以这篇文章总结一下链表可能遇到的疑惑，下次遇到的时候查阅即可，无须每次都进行艰难的debug。</p><a id="more"></a><h5 id="当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？"><a href="#当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？" class="headerlink" title="当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？"></a>当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？</h5><p>出现这个疑惑是在一个非常简单的题目：<strong><em>反转一个链表</em></strong>。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" target="_blank" rel="noopener" title="反转链表"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" alt="反转链表" title="反转链表"></a><br>当时就觉得很奇怪，理应是非常简单的，却感觉不会做，画了很久的图，最后还用了4个指针才完成了，代码也是略显复杂。然后一看标准答案，果然跟预期的一样，十分简洁，但当时没有深究，于是后面总是要还的。因为一个地方不明白，后面肯定还会出现，这时候只会更加麻烦。<br>接下来看一下当时看不懂的标准答案：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" target="_blank" rel="noopener" title="答案"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_2.png" alt="答案" title="答案"></a></p><p>当时的疑惑很简单，curr.next指向了prev，但紧接着，prev就又发生了改变，那么curr.next不会改变吗？这看起来有点违反直觉，一开始觉得应该是二者指向了相同的地址，然后地址发生了改变，二者也就同时改变，但其实并不是这样的。这里最关键的就是引用的概念了。这里实际上是两个引用，curr.next跟prev，而curr.next = prev表示的是，curr.next指向了prev引用指向的对象。之后prev指向了其他的对象，并不会对curr.next造成影响。</p><hr><p>但是有的地方看起来是会发生改变，为什么？<br>首先要确定，到底改变的是对象，还是一个引用指向了其他的对象。<br>立刻想到的就是遍历，移除某个元素的例子：（移除所有val等于某个值的结点）</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" target="_blank" rel="noopener" title="链表移除某个元素的例子"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_3.png" alt="链表移除某个元素的例子" title="链表移除某个元素的例子"></a></p><p>这里对current操作，最后为什么head也会改变？<br>首先解答一个很简单的问题，为什么要有current，而不是直接在head上操作。因为我们在中间会将current后移（current = current.next)，这就导致了我们最后如果返回的是current，那么current已经移到了最后，即使前面的结果是正确的，也没有意义。<br>为什么要提这个问题？因为我一开始对于这个就想错了。我最开始对current引用的理解是，在current上操作，避免对head发生改变。但我们确实就是希望head发生改变啊，毕竟我们最后返回的就是改变后的head。所以我们确实就是通过current指向了head，然后改变current的中间结构，同时也成功地改变了head的中间结构，但我们要获取最终的链表，那么就需要获取头结点，所以才不对head进行操作。所以我们仅仅是保留了最初的头指针而已，如果上面的答案，是对head操作，最后返回的是current，作用也是一样的。<br>接下来就是问题的关键了，那么为什么会跟着改变？看起来current只是一个对象的引用罢了。这就是引用跟对象的区别了，这里的current确实是一个引用，但current.next却是一个实打实的存在于内存中的对象。所以，current.next = current.next.next，是直接在对象上发生改变，那么自然head.next(也就是现在的current.next）也会跟着改变了。而current = current.next，就是引用指向了其他的对象，也就是current引用指向了current.next。由于是引用指向了其他对象，那么显然也不会对head发生改变了。（所以关键就是确定到底是改变引用指向，还是改变对象）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;​        链表想通的时候，感觉很简单，比数组还简单，只需要维护一个next指针，然后对指针进行操作即可。但有的时候也会遇到想不通的情况，这时候即便是非常简单的问题，都很难解决。所以这篇文章总结一下链表可能遇到的疑惑，下次遇到的时候查阅即可，无须每次都进行艰难的debug。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Datastructure" scheme="https://hongscar.cn/categories/Datastructure/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>关于Mysql的optimize语句</title>
    <link href="https://hongscar.cn/%E5%85%B3%E4%BA%8EMysql%E7%9A%84optimize%E8%AF%AD%E5%8F%A5.html"/>
    <id>https://hongscar.cn/%E5%85%B3%E4%BA%8EMysql%E7%9A%84optimize%E8%AF%AD%E5%8F%A5.html</id>
    <published>2020-02-17T03:13:08.000Z</published>
    <updated>2020-02-17T06:19:29.178Z</updated>
    
    <content type="html"><![CDATA[<p>看到了一个optimize的语句，想尝试一下，但发现这个语句默认只在MyISAM引擎的表上执行，在InnoDB可能会出现错误，于是的确出现了错误：<br><em>Table does not support optimize, doing recreate + analyze instead</em></p><p>查找网上的解法，看到了这篇文章:<a href="https://blog.csdn.net/e421083458/article/details/39522513" target="_blank" rel="noopener">https://blog.csdn.net/e421083458/article/details/39522513</a><br>看样子是只需要在启动mysqld进程的时候，增加—skip-new参数即可。但下面还要一个shell脚本一键完成，因此想先尝试shell脚本。</p><a id="more"></a><p>可是发现在shell脚本里仍然不可执行，网上有说即使是用户root，可能也会因为一些错误而导致并非100%具备root的权限，因此尝试改了一下权限（权限在mysql.user表中），仍然不行。</p><p>无奈，只好使用第一种方法了。由于不是用systemctl启动的mysql，因此需要找到mysqld的启动进程我感觉以后装service还是直接装服务类型的程序，而不是用.sh文件启动的服务，那个太麻烦了（主要是我没有去刻意记住程序的位置，每一次都要locate，whereis去定位文件位置）。</p><p>然后发现关闭失败，即使找到process ID，kill -9，也无法关闭。然后我发现了一个很好的mysql管理命令：<code>mysqladmin -u root -p command</code><br>即使用root用户去运行mysql的某个“command”，启动命令之后先输入password，即可执行。<br>然后这里是关闭，所以是：mysqladmin -u root -p shutdown。没有显示异常。<br>再查找一下mysqld是否还存在：ps aux | grep mysqld，确实不存在了。<br>再在本地的navicat尝试连接数据库，连接失败。好了，数据库确实关闭了。</p><p>接下来我们启动mysqld，直接进行/xxx/xxx/mysqld 仍然显示错误，需要用root权限去启动，就跟直接调用shutdown时候出现的错误一样，那就简单了，直接继续用mysqladmin即可：<br><code>mysqladmin -u root -p /xxx/xxx/mysqld —daemin=xxx —skip-new</code><br>结果发现竟然不可以，推测是mysqladmin只能直接调用相关命令？其实增加参数肯定是可以的，但我不会啊！emm，那么换种思路，直接在调用mysqld脚本的时候增加user参数就好辣，于是：<br><code>/usr/sbin/mysqld —deamonize —pid-file=/xxx/xx/xx/xxx/mysqld.pid —skip-new —user=root</code><br>然后就启动成功了（其实刚刚shutdown的时候也直接加这么个参数就行了吧）</p><p>既然已经重新使用—skip-new参数去启动mysqld了，那么应该就能使用optimize命令了？</p><p>回到本地，用navicat继续调用optimize table <code>article</code>; 结果，竟然还是不行。错误信息：<br><em>[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column ‘information_schema.PROFILING.SEQ’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by”</em></p><p>然后发现原因是这个：<br><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/optinnodb_1.png" alt="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/optinnodb_1.png)"><br>即navicat的版本问题？！那么就直接在服务器上执行一遍吧。</p><p>然后再服务器上optimize table，果然没有任何错误。成功执行。（虽然只是个简单的命令，还是折腾了许久）<br>关于optimize的作用：当 您的库中删除了大量的数据后，您可能会发现数据文件尺寸并没有减小。这是因为删 除操作后在数据文件中留下碎片所致。Discuz! 在系统数设置界面提供了数据表优化的功能，可以去除删除操作后留下的数据文件碎片，减小文件尺寸，加快未来的读写操作。您只要在做完批量删除，或定期（如 每一两个月）进行一次数据表优化操作即可。</p><p>参考链接：<br><a href="https://www.cnblogs.com/Alight/p/3585646.html" target="_blank" rel="noopener">https://www.cnblogs.com/Alight/p/3585646.html</a><br><a href="https://blog.csdn.net/chuixue24/article/details/86624792" target="_blank" rel="noopener">https://blog.csdn.net/chuixue24/article/details/86624792</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到了一个optimize的语句，想尝试一下，但发现这个语句默认只在MyISAM引擎的表上执行，在InnoDB可能会出现错误，于是的确出现了错误：&lt;br&gt;&lt;em&gt;Table does not support optimize, doing recreate + analyze instead&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;查找网上的解法，看到了这篇文章:&lt;a href=&quot;https://blog.csdn.net/e421083458/article/details/39522513&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/e421083458/article/details/39522513&lt;/a&gt;&lt;br&gt;看样子是只需要在启动mysqld进程的时候，增加—skip-new参数即可。但下面还要一个shell脚本一键完成，因此想先尝试shell脚本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://hongscar.cn/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis笔记</title>
    <link href="https://hongscar.cn/Redis%E7%AC%94%E8%AE%B0.html"/>
    <id>https://hongscar.cn/Redis%E7%AC%94%E8%AE%B0.html</id>
    <published>2020-02-17T03:12:55.000Z</published>
    <updated>2020-02-17T03:28:21.548Z</updated>
    
    <content type="html"><![CDATA[<p>chapter1.</p><p>Redis没有表和Schema（Schema就是数据库对象的集合，这个集合包含了各种对象如：表、视图、存储过程、索引等</p><p>Redis用 key-value存储数据，所有的key必须是string类型</p><p>Redis的命令不区分大小写，但存储的数据区分（包括key-value）</p><a id="more"></a><p>chapter2.</p><p><strong>数据类型：（一个key只对应一种类型的value）</strong></p><p>1.string        </p><p>（关于双引号，应该默认是字符串，加引号保证空格的存在。单引号也可以）</p><p>SET    执行成功返回OK</p><p>（如果键值已经存在，那么覆盖先前的值。可以用EXIST命令来测试key的存在性。也可以用SETNX，即当key不存在时set。 set if not exist。如果设置成功，SETNX返回1.否则返回0）</p><p>命令选项：NX，XX（存在时候才set）</p><p>从Redis 2.6.12版本开始，SET命令的行为可以通过一系列参数来修改：</p><p>EX second：设置键的过期时间为second秒。SET key value EX second效果等同于 SETEX second value</p><p>PX millisecond： 设置键的过期时间为millisecond毫秒。SET key value PX m == PSETEX m value</p><p>NX：只有在键不存在时，才对键进行设置操作。SET key value NX == SETNX key value</p><p>XX：只有在键存在时，才对键进行设置操作。</p><p>选项例子：</p><p>redis 127.0.0.1:6379&gt; SET not-exists-key “value” <strong>NX</strong> OK      # 键不存在，设置成功</p><p>redis 127.0.0.1:6379&gt; SET exists-key “value” <strong>XX</strong></p><p># EX 和 PX 可以同时出现，但后面给出的选项会覆盖前面给出的选项 redis 127.0.0.1:6379&gt; SET key “value” <strong>EX 1000 PX 5000000</strong> OK</p><p>redis 127.0.0.1:6379&gt; SET key-with-expire-and-NX <strong>“hello” EX 10086 NX</strong> OK            //我猜是EX时hello。NX时10086</p><p>GET    不存在时返回    (nil)</p><p>STRLEN    计算字符串长度</p><p>APPEND    向一个字符串末尾追加字符串。如果该字符串不存在，先新建一个空字符串，再append</p><p>SETRANGE     参数： stringA， int， stringB</p><p>对stringA从偏移量int开始，直到结尾，用stringB替换（偏移量从0开始）</p><p>同理，如果stringA不存在，也是先new一个空字符串。如果int为0，那么就是new。</p><p>如果int不为0，前面的字符为 \x00     (好像是C++里的空字符）</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\7edf3f2832d645dca2c218773e8e0077$5pwjcaa(}cs.png)</p><p>\xhh表示十六进制，\x00 == 0x00， \x77 == 0x77。代码的作用应该就是看一下res地址对应的起始两个字节的值是否为0x00和0x77，对应于ascii字符的NULL和w。</p><p>OBJECT命令：可以查看value的内部编码形式    使用形式：OBJECT ENCODING stringA</p><p>（OBJECT还有其他功能，略）</p><p>string的三种编码形式：</p><p>①<strong>int</strong>。存储64位有符号整数表示的字符串</p><p>②<strong>embstr</strong>。长度小于等于44子节点字符串（使得在内存使用和性能方面更有效率）</p><p>③<strong>raw</strong>。长度大于44字节的字符串</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\801aa6d8307c4dea977870465435f2f2\clipboard.png)</p><p>2.列表 list    （就是stack，queue，array等等的）</p><p>LPUSH     key1     value1    value2</p><p>往 key1中添加 value1，value2值。返回添加元素之后key1的值。</p><p>如果key1已经存在，就是在后面继续添加，反之新建再insert</p><p>RPUSH    (将value添加到list的右端）</p><p>LINSERT         key1     BRFORE / AFTER        value1</p><p>添加到value1的前面/后面</p><p>只有当list存在才添加。 LPUSHX, RPUSHX</p><p>LRANGE        获取一定范围里的value</p><p>LRANCE     key1    int1        int2</p><p>即获取int1 ~ int2中的元素。index从0开始（跟数组一样）</p><p>（如果int2为 -1，表明读到结尾。所以 [0, -1] 就是输出所有value。</p><p>[2, -1]就是从第3个元素开始，输出到结尾）</p><p>获取某个index下的value：</p><p>LRANCE     key1    index1        index1     即可。</p><p>也可以： LINDEX       key1    index    </p><p>LPOP        RPOP        删除一个元素</p><p>list的index定义：从左到右： 0 ~ N - 1    从右到左：    -1 ~ -N</p><p>（所以0 ~ -1 表示整个列表）</p><p>​    </p><p>LTRIM    key1    int1        int2</p><p>删除key1中int1 ~ int2 之外的value</p><p>例子：LTRIM    key1    1    -1</p><p>即删除index为1到结尾以外的所有元素，即，只删除index为0的元素</p><p>LSET     key1    int        value</p><p>设置index为int的值，更改为value</p><p>LPOP和RPOP有对应的阻塞版本，即当list为空时，阻塞版本会将客户端阻塞。</p><p>BLPOP        BRPOP</p><p>同时还要设置超时时间，如果为0，表示永久等待。（在任务调度场景十分有用）</p><p>例子：</p><p>worker1&gt;        BRPOP     que1    0</p><p>worker2&gt;        BRPOP     que1    0</p><p>两个终端，阻塞执行。</p><p>此时对que1添加一个value1，worker1先执行，解除阻塞，把value1删除。</p><p>然后再对que1添加value2，value3，此时worker2解除阻塞，把value2删除。</p><p>最后que1里剩下了value3(先添加value2，立即删除，所以是剩下value3）</p><p>3.哈希 HASH 类型</p><p>相当于Map类型，即key里面还存储了其他的key-value，但存储实现方式是hashing。</p><p>（Redis本身其实就相当于一个hash。Redis的数据对象也可以再次使用hash，只要字段和值都是string类型。为了与Redis的key区分，hash里的“key-value”应该说成    “field-value”）</p><p>HMSET    key1    field1    value1    field2    value2    ……</p><p>设置多个hash字段，以及属性。（其实field-value集就是key1的value）</p><p>HMGET    key1    field1    field2    ……</p><p>获取多个hash的value</p><p>HGET    HSET    （获取/设置单个）</p><p>HEXISTS        是否存在某个字段</p><p>HGETALL    获取所有field和value    （阻塞，hash特别大时会导致Redis阻塞）</p><p>HDEL    删除field</p><p>可以用HSCAN替代HGETALL，此处略。</p><p>4.集合    SET类型</p><p>集合，SET，与Java一样，唯一，无序。（可用于去重）</p><p>SADD    添加</p><p>SISMEMBER    测试一个value是否在SET中</p><p>SREM    删除</p><p>SCARD    获取集合中成员的数量</p><p>SMEMBERS    列出所有value</p><p>同理，SMEMBERS会导致阻塞，可以改用SSCAN。略</p><p>集合间的操作：     SINTER        KEY        [KEY …]    交集</p><p>​    SUNION    KEY        [KEY …]        并集</p><p>​     SDIFF        差集</p><p>将集合运算的结果保存到K中：SINTERSTORE  K   KEY  [KEY…]</p><p>SUNIONSTORE    SDIFFSTORE</p><p>SET的编码，有两种方式：</p><p>intset    ：    对于value全是整数，且元素个数小于set-max-intset-entries时(默认为512）</p><p>（可以节省占用空间）</p><p>hashtable：    intset不适用时的默认编码</p><p>5.有序集合    SORTED SET类型</p><p>有序。    实现方式为：每个value还要拥有一个用于排序的权重。</p><p>ZADD    key1    weight1    value1    weight2    value2 ……    添加。</p><p>（与SET命令类似，可以使用NX,XX等选项）</p><p>ZREVRANGE        key1    int1        int2        [WITHSCORES]</p><p>获取排序。int1 ~ int2的value，0 ~ -1 即整个，和list一样。</p><p>WITHSCORES可选，表示 是否要列出 weight权重。</p><p>ZINCRBY    key1    int    value1</p><p>给value1的权重增加int</p><p>ZREVRANK    key1    value1</p><p>获取value1的排名（第一为 0）</p><p>ZSCORE        key1    value1</p><p>获取value1的权重</p><p>ZUNIONSTORE    合并两个SORTED SET。略</p><p>ZRANGEBYSCORE   key   MIN   MAX(从小到大），    ZREVRANGEBYSCORE</p><p>ZCOUNT KEY MIN MAX（指定范围内的成员个数）</p><p>集合之间的操作：ZINTERSTORE, ZUNIONSTORE    (没有ZDIFFSTORE, ZUNION）</p><p>6.HyperLogLog （HLL）类型</p><p>唯一计数类型。虽然可以用SET来计数，但需要考虑内存消耗和性能下降问题。</p><p>如果我们不需要获取SET的内容，只想获得不同value的个数，就可以考虑用HLL</p><p>PFADD    添加</p><p>PFCOUNT     统计数量</p><p>PFMERGE    添加多个</p><p>HLL对象的两种存储方式：</p><p>Sparse（稀疏）：对于长度小于hll-sparse-max-bytes（默认为3000）的HLL，采用此。</p><p>（存储效率更高，但可能会消耗更多的CPU资源）</p><p>Dense（稠密）：当Sparse不适用时。</p><p>7.Geo类型</p><p>存储地理位置相关的数据类型</p><p>GEOADD,    GEOPOS（获取），    GEODIST(比较距离）</p><p>等等。略</p><p>key的管理。</p><p>DBSIZE:    显示数据库的size，即数据库一共有多少个key</p><p>获取所有的key：</p><p>KEYS *</p><p>scan 0</p><p>KEYS的后面的参数是 正则表达式，scan后面的参数是cursor，游标，不懂。</p><p>删除key：</p><p>DEL        UNLINK        </p><p>(二者都可以同时删除多个，并且返回删除的key数量）</p><p>UNLINK主要用于执行大KEY的异步删除（即非阻塞？）当删除string以外的数据类型，当数量很大时，很可能导致服务器延迟，此时应该用UNLINK（UNLINK会在另一个线程，而不是主事件循环线程中执行删除操作，因此不会阻塞事件的处理。）</p><p>EXISTS    判断是否存在某个key</p><p>TYPE    获取key的（值）数据类型</p><p>RENAME        former_name        new_name    重命名</p><p>迁移键      （其实这些比较复杂少用的，到时要用到肯定还是上网查的，目前还没用到死记硬背真的没必要！倒是几种基本类型的常用操作确实值得记忆一下！）</p><p>①MOVE  KEY  DB    （redis内部可以有多个DB，用于内部迁移。但一般一个数据库即可！</p><p>②dump + restore</p><p>③migrate</p><p>（只需知道②是非原子性的，而③是原子性的即可！）</p><p>遍历键：keys ，或者scan（渐进式，游标。。）</p><p>关于多数据库，实际上是一个废弃的功能。并不能实现0号数据库是正式数据库，而1号数据库是测试数据库等等的想法。Redis已经在逐渐弱化这个功能，例如Redis的分布式实现Redis Cluster只允许使用0号数据库，留着只为了向下兼容。而且因为Redis是单线程的，所以使用的还是一个CPU，如果其中一个存在慢查询，那么依然会影响其他数据库（甚至会导致业务问题的定位非常困难）</p><p>PS:如果真的要使用多个数据库的功能，完全可以在一台机器上部署多个Redis实例，彼此之间使用端口号来进行区分（计算机一般有多个CPU，这样既保证了业务之间不会受到影响，又合理地使用了CPU资源）</p><p>清除所有数据：flushdb，flushall（后者是清除所有数据库） 慎用，会把所有数据都删掉，而且会阻塞。别乱用。！！！</p><p>chapter3.</p><p>数据特性：</p><p>1.位图 bitmap</p><p>(也称位数组或位向量），是由比特位bit组成的数组（其值只有0或者1）可用于记录每个用户是否属于某个表（使用过某个功能）等等。</p><p>（bitmap并不是一种新的数据类型，它实际的底层数据是字符串。）</p><p>-————————–</p><p>bitmap vs SET</p><p>显然，bitmap用于计数，而SET也可以，那么二者有什么区别呢？</p><p>对于bitmap：无论用户是否使用过某个功能，每个用户都需要占用bitmap中的1个比特（0/1）</p><p>对于SET：假设另起一个8字节的整型来存储用户ID（表示使用过某个功能），那么只有当用户使用过该功能，才需要存储该用户ID（一个ID 8字节）</p><p>假设有20亿个用户，某功能有80%的用户使用过。那么：</p><p>对于bitmap：需要在内存中分配20亿个bit，即大约250MB</p><p>对于SET：需要 20e x  80%  x  8   大约是12.8G</p><p>结论：当一个功能比较流行，更密集，即如果使用bitmap，1的概率更大的时候，用bitmap更好。反之，如果一个功能比较稀疏，使用人数较少，那么直接使用SET会更好（比如上述例子改为1%）</p><p>-—————————</p><p>SETBIT     key1    value1    1 / 0</p><p>对key1的value1设置相应的bit值，0或者1</p><p>GETBIT    key1    value1</p><p>查询value1对应的bit值，返回0或者1</p><p>BITCOUNT    key1</p><p>查询key1中所有的value，bit为1的个数。</p><p>BITOP    [OPERATOR]        result    key1    key2</p><p>BITOP用于进行位操作，包括：AND,OR,XOR,NOT（NOT只需要指定1个key，其他2个）</p><p>即对key1和key2进行位操作，然后将结果存储在result键中。</p><p>2.设置key的过期时间</p><p>除了使用DEL或者UNLINK删除key，还可以通过设置key的超时时间让Redis自动地删除key</p><p>EXPIRE        key1    int</p><p>将键key1的超时时间设置为int</p><p>TTL        key1</p><p>查看key1在过期前的剩余时间。</p><p>如果该key并没有过期时间，那么将返回-1.</p><p>如果该key已经过期，那么将返回-2</p><p>当key过期之后是否立刻删除？</p><p>并不，但当客户端试图访问过期key时，Redis会立即将其从内存中删除。（被动过期）</p><p>而对于那些已经过期但还没被访问的key，有一个基于概率的算法来进行主动删除。（略）</p><p>当发现有太多已经过期的key没有被删除时，可以通过执行SCAN命令来触发被动过期</p><p>如何清除一个key的过期时间？</p><p>1.PERSIST        使一个key成为持久的key</p><p>2.当key的value被替换或者删除。包括SET,GETSET, *STORE等等的命令会清除过期时间</p><p>（但修改list，set，hash的元素并不会清除过期时间，因为修改元素的操作并不会替换key所关联的值对象）</p><p>3.被另一个没有过期时间的key重命名</p><p>3.SORT命令</p><p>当我们需要获取一个Redis列表或者集合的已排序副本，或者以某种非权重的顺序对SORTED SET中的元素进行排序时候，就需要用到SORT命令</p><p>SORT key1        对    list    /    set/    sorted set 进行排序</p><p>（默认只能对数字排序，int/ double）</p><p>对于字符串，需要加ALPHA修饰符。</p><p>SORT key1    ALPHA</p><p>SORT    key1    ALPHA    LIMIT    int1        int2</p><p>排序之后，获取int1 ~ int2的元素。（index从0开始）</p><p>除了默认数字排序以及ALPHA，还可以通过其他key的权重来进行排序。</p><p>SORT     key1    BY    key2~x（用通配符表示多个）</p><p>（此处key2的value，hong123_104 &gt; hong123_455 &gt; hong123_333 &gt; 200 &gt; 365）</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\ab95885bd2bc4ec9bbadda92013433f6\clipboard.png)</p><p>用处：</p><p>比如A_userid是一个用户的记录。 count_userid是一个用户的使用次数。（每一个userid都有对应）</p><p>那么当我们需要对A_userid的value进行排序（里面的value并不是使用次数，比如，是消费总额），而我们是希望通过“使用次数”这个属性来排序，那么就用到了 BY 修饰符。</p><p>SORT     key1     BY        key2*    DESC/ASC(默认ASC）GET    xxx        STORE    key3</p><p>GET选项：表示要获取哪一个类型的值，比如是key2，key1里的*，而不一定是value</p><p>（GET可使用多次）</p><p>STORE选项：把GET得到的结果存储到key3</p><p>4.管道    pipeline</p><p>Redis客户端与服务端使用RESP协议进行通信，大致的通信过程如下：</p><p>1，客户端向服务端发送一个命令</p><p>2，服务器接受该命令并放入执行队列（Redis是单线程的执行模型）</p><p>3，命令执行</p><p>4，服务器将命令执行的结果返回到客户端</p><p>第2，3步耗费的时间取决于Redis服务器（一般较短），主要的时延还是1，4步的网络传输。</p><p>使用pipeline好处：客户端将多个命令打包在一起，并将它们一次性发送，而不再等待每个单独命令的执行结果。同时，pipeline是在服务器执行完所有的命令后再返回结果。</p><p>因此即使是执行多个命令，第1，4步也只发生一次，所以总的执行时间会大大减少。</p><p>使用方法：在Redis-cli中加入    –pipe选项</p><p>5.Redis事务        transaction</p><p>关键命令：</p><p>MULTI：用于组装一个命令，表示命令的开始部分。</p><p>EXEC：用于执行一个事务</p><p>DISCARD：取消事务</p><p>WATCH：用于监视key。当这些key在事务执行之前发生改变，那么事务将被取消。</p><p>Redis事务与关系数据库事务的区别：Redis事务没有回滚。</p><p>所以当所有正确的命令入队列之后，如果在执行过程发生错误，位于发生错误命令之后的其他命令将继续执行，而不会回滚。</p><p>6.发布订阅    PubSub</p><p>即终端分为了发布者和订阅者。订阅者可以订阅指定的频道（发布者），当发布者发送信息时，会一次性发送给所有的订阅者，同时发布者也可以单独给某位订阅者发送信息（类似公众号的模式）</p><p>命令：</p><p>SUBSCRIBE    订阅        (如果该频道从未被订阅过，那么会自动创建该频道）</p><p>UNSUBSCRIBE    取消订阅</p><p>PUBLISH        发布信息（一个发布者可以是多个频道的所有者，因此需要选择发布到哪个频道）</p><p>7，Lua脚本</p><p>略</p><p>chapter4.</p><p>Redis常用场景：</p><p>1.存储Session。</p><p>Session一般存储在外部存储系统，如果一个web服务器宕机，其他服务器仍然可以从外部存储中获取Session并继续服务。而与关系数据库相比，Redis的访问延迟非常低（存储在内存），所以用于存储Session非常合适。同时Redis的对key过期机制非常契合Session的有效期。</p><p>2.分析，排行，队列，最新的N个记录等等</p><p>这些功能使用SQL也可以做到，但SQL查询要比Redis查询慢得多。</p><p>3.缓存</p><p>因为Redis是基于内存的数据存储系统，所以在关系数据库前面增加Redis作为缓存，通常能够加速数据库的查询过程。</p><p>例如，在查询关系数据库之前，先在Redis中查找记录。如果找到就直接使用，如果找不到就从关系数据库中查找，并将记录放置到Redis中。在向关系数据库写入时，我们也将记录写入Redis。同时为了限制缓存的大小，可以设置过期时间，或者LRU等等的收回策略。</p><p>Redis的缺点：</p><p>因为Redis默认将全部数据都放在内存中，所以Redis的容量有限，不能作为单一的数据库来存储大量的数据（虽然有一些基于云的Redis提供了使用SSD作为数据存储后端的选项）。</p><p>其次，因为Redis事务并不完全符合关系数据库的ACID规范。如果要使用完全符合ACID规范的事务，就不能使用Redis。</p><p>其他命令：</p><p>FLUSHALL：删除所有的数据库的所有keys。</p><p>CONFIG SET XXX XX    设置conf配置文件，将XXX的属性值改成XX</p><p>同理还有 CONFIG GET XXX</p><p>INFO MEMORY    查看Redis的内存使用情况</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\2d1e6c0c369b432aa5976bc06ebecf77\clipboard.png)</p><p>普通Java程序使用Redis：使用Jedis即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring程序使用Redis：<a href="https://blog.csdn.net/Evankaka/article/details/50396325" target="_blank" rel="noopener">https://blog.csdn.net/Evankaka/article/details/50396325</a></p><p>依赖包，除了redis.clients，还需要：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>chapter5：</p><p>Redis复制，从一个Redis服务器，将data全部复制到另一个。略    INFO REPLICATION</p><p>chapter6：</p><p>由于Redis是在内存中存储数据的，所以当服务器重新启动时，所有的数据都将丢失。所以我们需要：像上一章一样复制复制备份到另一个服务器，或者持久化到disk。</p><p>持久化到磁盘的机制：RDB, AOF</p><p>RDB：可以看做是Redis在某一个时间点上的快点（snapshot），适合于备份和错误恢复</p><p>AOF：一个写入操作的日志，将在服务器启动时被重新放。</p><p>使用RDB的操作：</p><p>CONFIG SET SAVE “900 1”    （还是使用CONFIG SET修改配置文件）</p><p>永久启用RDB：cat conf/redis.conf | grep “^save”</p><p>RDB的结果会生成yige.rdb文件。二进制形式。略</p><p>由于RDB并不能提供非常强的一致性，虽然可以定期将数据保存到RDB，但在崩溃时，保存的时刻到崩溃时刻中间的数据将会丢失。</p><p>AOF是一种只记录Redis写入命令的追加式文件，因为每个写入命令都会被追加到文件中，所以AOF的数据一致性更高。</p><p>启用AOF持久化：CONFIG SET APPENDONLY YES</p><p>永久启动： cat conf/dis.conf | grep “^appendonly”</p><p>二者可以同时使用。</p><p>chapter7：高可用和集群Redis</p><p>当Redis的数据越来越大的时候，安全性会受到损害（宕机的时候恢复的时间越来越长）同时key越来越多，内存的使用率越来越大，内存的大小成为了性能的瓶颈。因此配置多个node（多个Redis服务器的集群），可以增加安全性和可用性。</p><p>略</p><p>chapter8：生产环境部署</p><p>即在Linux上部署Redis，成为真正的服务器，可不仅仅是一个测试demo。这个时候还需要配置各种参数，如客户端连接参数，数据库本身参数，key的管理，LRU，LFU等等的算法策略，还有日志。</p><p>略</p><p>chapter9：管理Redis</p><p>即Redis服务上线之后，对日常的Redis进行运维操作。</p><p>查看参数，备份，监控内存使用情况，监控客户端等等。</p><p>chapter10：Redis的故障诊断</p><p>chapter11：使用Redis模块拓展Redis    略略略</p><p>————————–Redis Dev &amp; Ops</p><p>chap2：</p><p>keys *， dbsize：</p><p>dbsize直接获取Redis内置的一个变量，时间复杂度为1</p><p>而keys会遍历所有键，所以时间复杂度是n（当Redis保存了大量键的时候，就不应该使用）</p><p>exists key，    del key，        </p><p>expire key seconds（设置过期时间</p><p>ttl key ：返回剩余过期时间。  大于等于0就是剩余值，-1是没设置过期时间，-2是键不存在</p><p>type key，  object encoding key   ： type是返回键的类型，object encoding是返回内部编码实现类型</p><p>（根据具体情况计算性能，底层选择不同的类型：</p><p>string字符串： raw，    int，        embstr</p><p>hash哈希：    hashtable，        ziplist</p><p>list列表：        linkedlist，        ziplist</p><p>set集合：    hashtable，        intset</p><p>zset有序集合（Sorted Set）：    skiplist，    ziplist</p><p>incr key：使key自增1.（如果不是整数，会报错。如果不存在这个key，创建一个，默认值为0，incr后就是变成1。 必须是整数，浮点数也会报错）</p><p>Redis使用了单线程 + IO Multiplexing（多路复用）模型来实现高性能的内存数据库服务</p><p>（所谓的IO Multiplexing，指由N个client要访问，然后IO根据哪个client ready了，就选择那个（就像是一个电路图：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\1e1c5c3688d74413b43baa95057179b0\clipboard.png)</p><p>IO Multiplexing主要是可以提高连接数。但始终还是单线程，因此如果其中一个命令的执行时间特别长，那么就会造成其他命令的阻塞。所以Redis是面向快速执行场景的数据库。</p><p>（内存的处理速度是磁盘IO的10万倍，所以Redis的效率是很快的，能达到每秒万级别）</p><p>（内存是100ns， Disk seek是10 000 000ns）</p><p>①字符串类型  string：</p><p>key都是字符串类型，字符串可以是字符串，数字，二进制（图片，音频，视频</p><p>（所以 set  1  123也是可行的。key为1，value为123）</p><p>set 选项： ex秒级过期时间， px 毫秒级， nx：键必须不存在，才可以设置成功。 xx：与nx相反</p><p>例子：setnx hello redis    (nx可以用作分布式锁的一种实现方案，因为只有一个可以set成功）</p><p>mset ： 批量设置值            例子： mset key1 value1 [key2 value2 ……]</p><p>get,  mget同理。</p><p>批量命令可以提升开发效率。如n次get，需要n次网络时间+n次命令时间。</p><p>而mget只需要1次网络时间+n次命令时间</p><p>（批量操作发送的命令数是有节制的，否则可能造成Redis阻塞或者网络阻塞）</p><p>del key [key ……]    del可以删除多个。 </p><p>incr,decr</p><p>incrby  key  increment(指定自增数值，可为负数）        decrby  key  decrement    （不能为浮点数</p><p>incrbyfloat  key  increment（每次增加的值为浮点数，同时key也能为浮点数，不然执行一次就没了）</p><p>append key  value    在尾部追加值</p><p>strlen  key        字符串长度</p><p>getset        设置，并且返回原来的值</p><p>setrange    key    offset    value    设定offset偏移值的那一位，字符由value替代（从0开始</p><p>例子： set redis  pest        setrange  redis  0  b    get  redis   ==》  best</p><p>getrange  key  start  end    (偏移量从0开始。 [start,  end]        （没有-1）</p><p>总结：del，mset，mget这三个的时间复杂度为O(n)，getrange为O(n),n是字符串的长度，如果字符串不是很长，可以视为O(1)。其他都是O(1)</p><p>字符串内部编码:  int,  embstr(小于等于39个字节的字符串） ， raw（大于39个字节）</p><p>②哈希 hashing</p><p>即value本身又是一个键值对。</p><p>设置值： hset  key   field  value    （同样还有hsetnx。相当于set和setnx的区别</p><p>获取值： hget  key   field      （一个key存储多个  field - value）</p><p>删除field： hdel  key  field1  [field2 ……]    返回成功删除field的个数</p><p>计算field的个数：   hlen  key</p><p>批量set/get  :  hmget  key  field [ field …]    hmget  key field  value [ field  value……]</p><p>hexists  key  field    判断是否存在</p><p>hkeys  key    获取所有的field（感觉叫hfields更恰当，但确实是hkeys</p><p>hvals    key</p><p>hgetall     key        获取所有的field-value</p><p>（当哈希元素比较多，hgetall可能会阻塞。如果只需要获取部分，可以使用hmget。如果一定要获取全部field-value，可以使用hscan，该命令会渐进式地遍历哈希类型。）</p><p>hincrby   key   field   increment    给key.field增加increment（可以为负数）    hincrbyfloat</p><p>hstrlen    key   field</p><p>总结：hdel，hmget，hmset是O(k)，k是field的个数。hgetall，hkeys， hvals是O(n)，n是field的总数</p><p>其他都为O(1)</p><p>哈希内部编码：ziplist（压缩列表）：当元素个数小于hash-mmmax-ziplist-entries(默认是512），同时所有值都小于hash-max-ziplist-value(默认是64字节），就使用ziplist（结构更紧凑，节省内存）</p><p>hashtable（哈希表）：当无法满足ziplist时，ziplist的读写效率会下降，而hashtable的读写为O(1)</p><p>ps：对于一个用户的各种信息属性，可以单独用不同的key，但这样用户信息性差，一般不会使用这种方案。比较好的方案是使用哈希类型，提高内聚性，控制在ziplist之内，有效减少内存空间的使用。（必须的时候使用hashtable也不是不行）</p><p>哈希类型是稀疏的，而关系数据库是完全结构化的，当在关系数据库增加新的列，所有行都要设置值（如果没有指定就设置为NULL）。但可以做复杂的关系查询，而Redis比较困难。</p><p>③列表 list</p><p>rpush，lpush（二者都可以插入多个）    linsert key before | after  pivot  value</p><p>lrange key  start  end 查找</p><p>……</p><p>懒了，其实各种类型的操作就略过吧，上面已经看过一次了，把上面的复习一遍就好。主要看它举的实例并理解。</p><p>chap3：各种功能topic</p><p>①慢查询</p><p>Redis有一个表专门记录命令执行较长的命令（只包含执行时间，不包含客户端等待时间）</p><p>参数：slowlog-log-slower-than    (超出该值则记录，单位是微秒。）</p><p>1 秒 = 1000 毫秒 = 1000 000微秒    （即默认是10毫秒）</p><p>slowlog-max-len ：慢查询日志的最大记录，如果超出上限，则最早insert的那条删除。</p><p>（slowlog-max-len设置大一点，不会耗费很多内存空间的）</p><p>设置命令：config xx int        持久化到配置文件：    config  rewrite</p><p>获取日志： slowlog  get  [n]    // n表示指定条数</p><p>slowlog len  ： 获取慢查询日志列表的当前长度</p><p>slowlog reset：重置（即clear</p><p>②redis shell</p><p>redis-cli的各种参数：</p><p>-h  ： host    -p： port        -a： auth        </p><p>-r 重复执行n次：  redis-cli -r 3 ping    </p><p>(即重复执行3次ping命令，ping命令会测试服务器的连通性，如果连通，返回PONG）</p><p>-i 表示每隔几秒执行一次命令（与-r连用，单位是秒）</p><p>例子：redis-cli -a xxx -r 10 -i 1 info | grep used_memory_human    每隔1秒输出内存的使用量</p><p>-x：将stdin读取，作为redis-cli的最后一个参数，例如；</p><p>echo “gogogo” | redis-cli -a xxx -x set hello    # 之后hello的值就被设置为”gogogo\n”</p><p>值得注意的是，echo输入，会存在一个换行符，进入redis-cli里再set才不会有换行符。</p><p>–scan和–pattern ：扫描指定模式的keys，相当于使用scan命令</p><p>–slave：将当前客户端模拟成一个子节点，然后获取当前Redis结点的更新操作。</p><p>（可以用于记录当前连接Redis结点的一些更新操作）</p><p>（在一个客户端中使用redis-cli –slave -a xxx，然后其他客户端的更新，当前都会有命令记录）</p><p>–rdb：请求Redis实例生成并发送RDB持久化文件，保存在本地。</p><p>–pipe：把批量的命令一次发送到一个管道中，一次执行</p><p>–bigkeys：使用scan命令获取占用内存比较大的键值。（这些键可能是系统的瓶颈）</p><p>–eval ： 执行指定的Lua脚本</p><p>–latency :测试到目标Redis的网络延迟   redis-cli  -h  {另一台机器的host IP}  –latency</p><p>–latency-history :上面的只有一条记录，而这个是每执行15秒就生成另一条记录（可以用作对比），同时也可以使用-i参数来控制间隔时间。</p><p>-latency-dist   使用统计图表的形式从控制台输出信息</p><p>info  ： redis-cli  info    输出redis的所有信息（很长，配合| grep使用）</p><p>redis-cli –stat：实时获取Redis的重要统计信息（比info少很多，但可以实时查看一些增量的数据）</p><p>–raw ， –no-raw    使得返回的结果是原始格式 / 不是原始格式</p><p>当存储中文时，保存在redis里的中文会被转义成16进制。此时无论是命令行时get还是进入redis-cli之后get，返回的结果都是二进制格式，如： \xe4\xbd\xa0\xe5\xa5\xbd</p><p>如果使用–raw，则返回原始格式，即中文： redis-cli –raw get hello (–raw必须在get前面）</p><p>PS:但是在进入redis-cli之后的get好像无法指定参数，所以不能返回raw，只能在命令行时指定–raw</p><p>③redis-server</p><p>redis-server是Redis的启动脚本。可选参数只有：–test-memory，用于检测当前的OS能否稳定地分配指定容量的内存给Redis（防止因为内存问题造成Redis崩溃）</p><p>（检测时间较长，但输出passed this test表示检测完毕。 单位是MB，所以1024就是1G）</p><p>一般只是用于调试跟测试，快速沾满机器内存做一些边界测试</p><p>④redis-benchmark</p><p>用于为Redis做基准性能测试</p><p>-c：表示客户端的并发数量（默认50）</p><p>-n：表示客户端的请求总量（默认是100000）</p><p>例子：redis-benchmark  -c  100  -n  20000，代表100个客户端同时请求Redis，一共执行20000次。</p><p>-q：只显示 requests per second信息。</p><p>-r：插入更多的键。如-r 10000，插入10000个随机的键（仅作测试使用）</p><p>-P：表示每个请求的pipeline的数据量（默认是1）</p><p>（我发现恰当指定pipeline的值，比默认是1要快。）</p><p>-k：表示客户端使用使用keepalive，1为使用，0为不使用，默认是1</p><p>-t 指定命令测试</p><p>–csv：按照csv格式输出，可以到处到excel等（注意是两条杠）</p><p>⑤Pipeline</p><p>Redis客户端的一条命令的4个过程：发送命令，命令排队，命令执行，返回结果。</p><p>（第一步跟第四步称为Round Trip Time，RTT，往返时间）</p><p>虽然有部分批量操作的命令，但大部分命令都没有批量命令，此时需要使用pipeline，一次过发送多个命令，减少RTT的次数（由于Redis的处理速度很快，只要Pipeline包含的命令数不是太多，就能有效提升效率）</p><p>（高级语言的客户端中基本都支持Pipeline。比如Jedis。）</p><p>提升的结论：</p><p>1.一般Pipleline的执行速度会比逐条执行要快（Redis的性能瓶颈是网络，即RTT）</p><p>2.客户端和服务端的网络时延越大（即RTT越大），那么Pipeline的提升效果越明显。</p><p>原生批量命令与Pipeline的区别：</p><p>1.原生批量命令是原子的，而Pipeline是非原子的。</p><p>2.原生批量是一个命令对应多个key，而Pipeline是支持多个命令的</p><p>3.原生批量是Redis服务端支持实现的，而Pipeline需要服务端和客户端的共同实现。</p><p>Ps：Pipeline一次组装的命令个数不能太多，否则会增加客户端的等待时间，以及网络阻塞，可以将一次包含大量命令的Pipeline拆分成多次较小的Pipeline来完成。</p><p>Pipeline虽然只能操作1个Redis实例，但即使在分布式Redis的场景中，也可以作为批量操作的重要优化手段。</p><p>⑥事务</p><p>Redis提供了简单的事务功能，但又跟关系数据库的事务不太一样。它无法保证很多方面的数据一致性，因为需要复杂事务的业务不应该放在Redis中实现。</p><p>multi：开启一个事务（事务里不可以嵌套事务</p><p>……中间执行的各种命令都会输出QUEUED，即存储在事务里，但还没开始执行。</p><p>exec：执行事务。        discard：取消事务</p><p>Redis的事务不提供回滚功能，如果执行出错，那么会出现问题：</p><p>1.当命令出现语法错误</p><p>此时Redis在执行每一条命令之前就已经发现了，因而这时候执行exec会显示错误。然后每一条语句都会失效。（因为根本就没有去执行，并不是回滚）</p><p>2.当命令出现运行时错误</p><p>有一些语句，不存在语法错误，但在运行时才会出现错误，这时Redis在检查语句的时候是不能发现的，只能在执行的时候才发现。比如对于SET跟SORTED SET，对一个SET使用SSET的ZADD操作，并不属于语法错误，但在运行时会出错。这时候事务不会回滚，因而在出错之前的语句，仍然已经执行成功，而且出错之后的语句也会执行！无论如何，这种问题只能靠程序员自己避免。</p><p>watch： 使得客户端监控1个或者多个键，有效期直到执行了unwatch或者exec。</p><p>当客户端A监控的这些keys，只要有其中一个被修改了(除非是在A的事务中进行修改的），那么该客户端A下的第一个事务不会执行。（返回nil）</p><p>小细节点：</p><p>1.如果是在当前客户端A的事务中修改了被监控的值，那么是可以成功执行的，因为要保证的是，在执行事务的时候，该值不会在事务在之外发生了变化。</p><p>2.如果是在当前客户端A的事务之外修改了被监控的值，那么也是不可以执行的。如果是在其他客户端B中修改，那么一定不能执行（即使是在B的事务环境中执行，也不行）</p><p>3.准确地说，并不是执行exec会取消，而是当事务（即multi）结束的时候，watch的键会取消。所以，如果执行了multi……discard，这时候其实watch已经失效了。后面如果继续使用multi，是可以执行事务的。所以单独地使用exec / discard(即在没有multi的前提下运行这两条命令），watch是仍然存在的。</p><p>⑦Lua</p><p>语法省略。</p><p>Redis使用Lua的方法：eval，evalsha</p><p>eval当作命令的时候：  eval  脚本内容  key个数  key列表  参数列表</p><p>例子：eval ‘return “hello “ .. KEYS[1] .. ARGV[1] ‘  1  redis  world</p><p>输出：”hello redisworld”</p><p>如果Lua脚本较长，可以使用–eval直接执行文件</p><p>evalsha：将Lua加载到Redis，得到该脚本的SHA1检验和，之后evalsha使用SHA1作为参数就可以直接执行对应的Lua脚本，避免每次都发送Lua脚本的开销，而且脚本也能常驻在服务端了。</p><p>script load：将脚本内容加载到Redis内存中：redis-cli script load “xxx”        返回SHA1值。</p><p>执行脚本： evalsha  脚本SHA1值  key个数  key列表  参数列表</p><p>Lua的redis.call可以实现对Redis的访问：</p><p>redis.call(“set”, “hello”, “world”)        redis.call(“get”, ”hello”)</p><p>pcall也可以调用Redis，但如果call执行失败，脚本会直接结束，而pcall会忽略错误继续执行（根据具体的情况进行函数的选择）</p><p>Lua对于Redis的好处：</p><p>1.Lua在Redis中的原子执行的，执行中途不会插入其他命令</p><p>2.Lua可以自定制命令，并且可以将这些命令常驻在Redis内存中，达到复用的效果</p><p>3.Lua可以将多条命令一次性打包，有效地减少网络开销。</p><p>举一个Lua的例子：</p><p>假设有user1,user2,user3,user4这几个键，分别对应一个数字。</p><p>如get user1 =》 123    ，user2 = 444 , user3 = 743 , user4 = 814</p><p>有一个列表，存储了这几个键：</p><p>lpush  hot  user1, user2, user3, user4</p><p>现在我们需要对列表内所有的键对应的值进行+1操作，并且保证是原子执行，返回操作的个数。</p><p>Lua脚本：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\a8de5b73eb2142e490223c07e13bee29\clipboard.png)</p><p>执行Lua脚本： redis-cli  -a  xxx  –eval  my.lua  hot（即执行my.lua脚本，第一个key参数是hot列表）</p><p>Redis管理Lua脚本：</p><p>script load：将Lua脚本加载到Redis</p><p>script exists sha1 [sha1 …]：判断sha1是否已经加载到内存</p><p>script flush：清除Redis内存以及加载的所有Lua脚本（此时需要重新load</p><p>script  kill：杀掉正在执行的Lua脚本（如果Lua比较耗时，或者存在死循环等问题，就可以考虑kill</p><p>ps：Redis提供了一个参数，是Lua脚本的超时时间，但仅仅是当Lua脚本超过该时间之后，向其他命令发出BUSY的信号，但并不会停止掉服务端和客户端的脚本执行。其他命令会收到“Busy Redis is busy running a script”的错误。</p><p>但是，如果Lua脚本正在执行写操作，那么script kill将不能生效，此时只能使用shutdown save停掉Redis服务。（如果是死循环的重复写操作，那么只能shutdown save了）</p><p>⑧bitmap，HyprtLogLog，订阅，GEO等等（上面的笔记有</p><p>chap4：客户端</p><p>Redis的CS模型：</p><p>Redis制定了RESP（Redis Serialization Protocol，Redis序列化协议），实现客户端与服务端的正常交互。这种协议简单高效，能被机器解析，同时也容易理解。</p><p>发送命令的格式：先指定参数个数（前面加一个*，然后每一个参数前面用$加数字，表示该参数的长度。）</p><p>例子：SET hello world</p><p>底层发送的命令格式：(下面的各种参数与\r\n之间是没有空格的，只是这里增加以下可读性</p><p>*3 \r\n $3 \r\n SET \r\n $5 \r\n hello \r\n $5 \r\n world \r\n</p><p>上面的每一部分解释：</p><p>首先，每一part都是单独的一行(\r\n就是换行了），然后*3表示有3个参数， $3表示第一个参数的长度3，第一个参数是SET。$5表示第二个参数长度5，第二个参数是hello.第三个的长度也是$5,值为world</p><p>返回结果的格式：</p><p>有5种：</p><p>1.状态回复： 在RESP中，第一个字节是 +</p><p>2.错误回复：在RESP中，第一个字节是 -</p><p>3.整数回复：在RESP中，第一个字节是  :</p><p>4.字符串回复：在RESP中，第一个字节是 $</p><p>5.多条字符串回复：在RESP中，第一个字节是  *</p><p>从redis-cli.c的源码的 cliFormatReplyTTY方法，可以看到一共有这几种执行结果：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\8cc4710fe2404a6582bb758a14fd3161\clipboard.png)</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\a3fbdf67f35f4db3a293a700bf15f534\clipboard.png)</p><p>一共有REDIS_REPLY_ERROR,  STATUS,  INTEGER,  STRING, NIL, ARRAY</p><p>Jedis的重要类，重要方法，重要功能等等：</p><p>1.基本连接： Jedis</p><p>但默认是直连，于是每一次都要新建/关闭TCP的开销，资源无法控制（无法限制Jedis对象的个数)，Jedis线程不安全。而使用连接池，可以事先初始化好Jedis连接，降低TCP的开销。而且借用和归还到连接池的操作都是在本地进行的，只有少量的并发同步开销。</p><p>2.Jedis连接池：JedisPool</p><p>一般还有它的配置类GenericObjectPoolConfig类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"poolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"1000"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（此处的JedisPoolConfig是GenericObjectPoolConfig的子类，只有一个默认构造方法，初始化一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolConfig</span> <span class="keyword">extends</span> <span class="title">GenericObjectPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JedisPoolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setTestWhileIdle(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setMinEvictableIdleTimeMillis(<span class="number">60000L</span>);</span><br><span class="line">        <span class="keyword">this</span>.setTimeBetweenEvictionRunsMillis(<span class="number">30000L</span>);</span><br><span class="line">        <span class="keyword">this</span>.setNumTestsPerEvictionRun(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:书上列了一堆GenericObjectPoolConfig的属性，因为BaseObjectPoolConfig还有很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericObjectPoolConfig</span> <span class="keyword">extends</span> <span class="title">BaseObjectPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericObjectPoolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseObjectPoolConfig</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_LIFO = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_FAIRNESS = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_MAX_WAIT_MILLIS = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFALUT_MIN_EVICTABLE_IDLE_TIME_MILLIS = <span class="number">1800000L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NUM_TESTS_PER_EVICTION_RUN = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_TEST_ON_CREATE = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_TEST_ON_BORROW = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_TEST_ON_RETURN = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFALUT_TEST_WHILE_IDLE = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_BLOCK_WHEN_EXHAUSTED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_JMX_ENABLE = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_JMX_NAME_PREFIX = <span class="string">"pool"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_JMX_NAME_BASE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_EVICTION_POLICY_CLASS_NAME = <span class="string">"org.apache.commons.pool2.impl.DefaultEvictionPolicy"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lifo = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> fairness = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxWaitMillis = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> minEvictableIdleTimeMillis = <span class="number">1800000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> softMinEvictableIdleTimeMillis = <span class="number">1800000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numTestsPerEvictionRun = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> String evictionPolicyClassName = <span class="string">"org.apache.commons.pool2.impl.DefaultEvictionPolicy"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnCreate = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnBorrow = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnReturn = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testWhileIdle = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeBetweenEvictionRunsMillis = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> blockWhenExhausted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> jmxEnabled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> String jmxNamePrefix = <span class="string">"pool"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.看一下当时在Spring下自己的项目的Redis完整配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"poolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"300"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"1000"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"poolConfig"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6379"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"xxx.xx.xx.xxx"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"xxxx"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"100000"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"database"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- org.springframework.data.redis.core.RedisTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisTemplate"</span> <span class="attr">class</span>=<span class="string">"com.hong.utils.redis.MyRedisTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashKeySerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"keySerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"valueSerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashValueSerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"methodCacheInterceptor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.support.SimpleCacheManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"caches"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.hong.utils.redis.RedisUtil"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"redisTemplate"</span> <span class="attr">ref</span>=<span class="string">"redisTemplate"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"common"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisUtil"</span> <span class="attr">class</span>=<span class="string">"com.hong.utils.redis.RedisUtil"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"redisTemplate"</span> <span class="attr">ref</span>=<span class="string">"redisTemplate"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- name属性的值,是用于等会的注解当中 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"common"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还是很好理解的，首先JedisPoolConfig是连接池的配置。</p><p>然后JedisConnectionFactory就是连接的配置（连接池要预先创建连接，那么自然需要一个Factory去创建连接，而至于hostName，password，timeout，port等等的，确实就应该写在factory里了，同时还传入了poolConfig配置，database就是默认是第一个数据库吧，也没什么好说的）</p><p>然后是RedisTemplate，这个也很显然，就跟JdbcTemplate，就是封装了原生的Redis API，然后提供了更易操作的方法接口罢了。我们看一下方法：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\3e927f8193dc487b9d462e096537527a\clipboard.png)</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\a5493d3d73cb441ca0a50ab95ad2323f\clipboard.png)</p><p>方法确实很多哈，这里也没必要截完了，反正都是封装好了的Redis原生API，不妨随意选择一个方法去查看？就选keys方法吧，返回所有的键，很简单的方法逻辑，这里重在理解方法的主要构成，没必要选择太复杂的方法逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keys</span><span class="params">(K pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(pattern);</span><br><span class="line">    Set&lt;<span class="keyword">byte</span>[]&gt; rawKeys = (Set)<span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;Set&lt;<span class="keyword">byte</span>[]&gt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Set&lt;<span class="keyword">byte</span>[]&gt; doInRedis(RedisConnection connection) &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.keys(rawKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.keySerializer != <span class="keyword">null</span> ? SerializationUtils.deserialize(rawKeys, <span class="keyword">this</span>.keySerializer) : rawKeys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看不出什么，但感觉关键就是把具体的参数传到execute方法，然后再执行，再看几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Object&gt; <span class="title">execRaw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (List)<span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;List&lt;Object&gt;&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">List</span><span class="params">(Object)</span> <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> connection.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">    <span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> </span>&#123;</span><br><span class="line">            connection.del(<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;rawKey&#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，都是把不同的参数传到了execute方法。所以说就是对execute方法进行重载咯！我们查一下，确实，一堆的execute重载方法：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\bf4ed38156ac4f6f811fff3169568859\clipboard.png)</p><p>那我们还是继续拿keys指向的那个execute来看一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; action, <span class="keyword">boolean</span> exposeConnection, <span class="keyword">boolean</span> pipeline)</span> </span>&#123;</span><br><span class="line">Assert.isTrue(initialized, <span class="string">"template not initialized; call afterPropertiesSet() before using it"</span>);</span><br><span class="line">Assert.notNull(action, <span class="string">"Callback object must not be null"</span>);</span><br><span class="line"></span><br><span class="line">RedisConnectionFactory factory = getConnectionFactory();</span><br><span class="line">RedisConnection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (enableTransactionSupport) &#123;</span><br><span class="line"><span class="comment">// only bind resources in case of potential transaction synchronization</span></span><br><span class="line">conn = RedisConnectionUtils.bindConnection(factory, enableTransactionSupport);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">conn = RedisConnectionUtils.getConnection(factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> existingConnection = TransactionSynchronizationManager.hasResource(factory);</span><br><span class="line"></span><br><span class="line">RedisConnection connToUse = preProcessConnection(conn, existingConnection);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> pipelineStatus = connToUse.isPipelined();</span><br><span class="line"><span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">connToUse.openPipeline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RedisConnection connToExpose = (exposeConnection ? connToUse : createRedisConnectionProxy(connToUse));</span><br><span class="line">T result = action.doInRedis(connToExpose);</span><br><span class="line"></span><br><span class="line"><span class="comment">// close pipeline</span></span><br><span class="line"><span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">connToUse.closePipeline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> any other connection processing?</span></span><br><span class="line"><span class="keyword">return</span> postProcessResult(result, connToUse, existingConnection);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!enableTransactionSupport) &#123;</span><br><span class="line">RedisConnectionUtils.releaseConnection(conn, factory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面两行Assert，普通的断言语句。然后后面的几行就很显然了，先获取ConnectionFactory，然后再在try-catch块里获取connection。具体的怎么getConnectionFactory这种是涉及到比较复杂的很多类的跳转的，但本质上都只是设计模式的运用，此处可以不管。接下来的就是Redis的操作了，先判断一下事务同步管理器，连接预处理等等的，最后再放入pipeline执行（因为keys是一个批处理操作，原子性的）。最后再返回postProcessResult。话说再刷新了一下，这段代码更新了，这个var11确实没有存在的必要，直接return postPro…即可。但总体来说，确实也是获取到ConnectionFactory，然后生成连接，再操作。那么，RedisTemplate的作用确实也跟我们预期的一样。</p><p>除此之外，网上也有提到，Redis可以直接存储Java对象，那么就需要序列化跟反序列化。    在Spring中，是通过StringRedisSerializer跟JdkSerializationRedisSerializer实现的。那么，RedisTemplate下面传入的两个蜜汁property也是可以理解了。至于传入connectionFactory，那是当然的了，我们上面看源码也已经看到了，RedisTemplate是需要调用connectionFactory生成连接的）</p><p>接下来最后这两个，MethodCacheInterceptor跟RedisUtil。我第一次使用的时候，直接拿RedisUtil当作RedisTemplate使用了，只是简单的set，get，那确实是足够的（RedisUtil是我的自定义类，只有最简单的set，get，remove）。其实认真一点看类名，就知道它的作用了，MethodCacheInterceptor，Redis的作用是什么？就是Cache。那么Method，Interceptor？显然，就是对方法进行拦截，确定哪些属性要考虑缓存的问题。如果需要，那么就要用到RedisUtil（基本就是最简单的set，get，remove，所以使用一个迷你版的RedisUtil就可以满足RedisTemplate的功能了）</p><p>至于MethodCacheInterceptor，是自己写的方法，我们看一下这份网上cv的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodCacheInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = Logger.getLogger(MethodCacheInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; targetNamesList; <span class="comment">// 不加入缓存的service名称</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; methodNamesList; <span class="comment">// 不加入缓存的方法名称</span></span><br><span class="line">    <span class="keyword">private</span> Long defaultCacheExpireTime; <span class="comment">// 缓存默认的过期时间</span></span><br><span class="line">    <span class="keyword">private</span> Long xxxRecordManagerTime; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> Long xxxSetRecordManagerTime; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodCacheInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File f = <span class="keyword">new</span> File(<span class="string">"D:\\cacheConf.properties"</span>);</span><br><span class="line">            <span class="comment">//配置文件位置直接被写死，有需要自己修改下</span></span><br><span class="line">            InputStream in = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="comment">//InputStream in = getClass().getClassLoader().getResourceAsStream(</span></span><br><span class="line"><span class="comment">//"D:\\lunaJee-workspace\\msm\\msm_core\\src\\main\\java\\com\\mucfc\\msm\\common\\cacheConf.properties");</span></span><br><span class="line">            Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">            p.load(in);</span><br><span class="line">            <span class="comment">// 分割字符串</span></span><br><span class="line">            String[] targetNames = p.getProperty(<span class="string">"targetNames"</span>).split(<span class="string">","</span>);</span><br><span class="line">            String[] methodNames = p.getProperty(<span class="string">"methodNames"</span>).split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加载过期时间设置</span></span><br><span class="line">            defaultCacheExpireTime = Long.valueOf(p.getProperty(<span class="string">"defaultCacheExpireTime"</span>));</span><br><span class="line">            xxxRecordManagerTime = Long.valueOf(p.getProperty(<span class="string">"com.service.impl.xxxRecordManager"</span>));</span><br><span class="line">            xxxSetRecordManagerTime = Long.valueOf(p.getProperty(<span class="string">"com.service.impl.xxxSetRecordManager"</span>));</span><br><span class="line">            <span class="comment">// 创建list</span></span><br><span class="line">            targetNamesList = <span class="keyword">new</span> ArrayList&lt;String&gt;(targetNames.length);</span><br><span class="line">            methodNamesList = <span class="keyword">new</span> ArrayList&lt;String&gt;(methodNames.length);</span><br><span class="line">            Integer maxLen = targetNames.length &gt; methodNames.length ? targetNames.length</span><br><span class="line">                    : methodNames.length;</span><br><span class="line">            <span class="comment">// 将不需要缓存的类名和方法名添加到list中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; targetNames.length) &#123;</span><br><span class="line">                    targetNamesList.add(targetNames[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; methodNames.length) &#123;</span><br><span class="line">                    methodNamesList.add(methodNames[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object value = <span class="keyword">null</span>;</span><br><span class="line">        String targetName = invocation.getThis().getClass().getName();</span><br><span class="line">        String methodName = invocation.getMethod().getName();</span><br><span class="line">        <span class="keyword">if</span> (!isAddCache(targetName, methodName))       <span class="comment">// 不需要缓存的内容</span></span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();               <span class="comment">// 执行方法返回结果</span></span><br><span class="line">        Object[] arguments = invocation.getArguments();</span><br><span class="line">        String key = getCacheKey(targetName, methodName, arguments);</span><br><span class="line">        System.out.println(key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (redisUtil.exists(key))             <span class="comment">// 判断是否有缓存</span></span><br><span class="line">                <span class="keyword">return</span> redisUtil.get(key);</span><br><span class="line"></span><br><span class="line">            value = invocation.proceed();                       <span class="comment">// 写入缓存</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> String tkey = key;</span><br><span class="line">                <span class="keyword">final</span> Object tvalue = value;</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (tkey.startsWith(<span class="string">"com.service.impl.xxxRecordManager"</span>)) &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, xxxRecordManagerTime);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tkey.startsWith(<span class="string">"com.service.impl.xxxSetRecordManager"</span>)) &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, xxxSetRecordManagerTime);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, defaultCacheExpireTime);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否加入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAddCache</span><span class="params">(String targetName, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetNamesList.contains(targetName)</span><br><span class="line">                || methodNamesList.contains(methodName)) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建缓存key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCacheKey</span><span class="params">(String targetName, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Object[] arguments)</span> </span>&#123;</span><br><span class="line">        StringBuffer sbu = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sbu.append(targetName).append(<span class="string">"_"</span>).append(methodName);</span><br><span class="line">        <span class="keyword">if</span> ((arguments != <span class="keyword">null</span>) &amp;&amp; (arguments.length != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                sbu.append(<span class="string">"_"</span>).append(arguments[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sbu.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRedisUtil</span><span class="params">(RedisUtil redisUtil)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先第一个是构造方法，里面就是对Interceptor的配置，比如过期时间啊，要拦截哪部分的方法啊等等的。这段代码显然有点糙（毕竟上面的都是优雅的源码，这个虽然也是网上大佬写的，但还是有差距哈）。然后invoke方法，这个是最关键的方法。我们的这个类实现了MethodInterceptor接口，这个接口就是只有这么1个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implement this method to perform extra treatments before and</span></span><br><span class="line"><span class="comment">     * after the invocation. Polite implementations would certainly</span></span><br><span class="line"><span class="comment">     * like to invoke &#123;<span class="doctag">@link</span> Joinpoint#proceed()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation the method invocation joinpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result of the call to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Joinpoint#proceed()&#125;, might be intercepted by the</span></span><br><span class="line"><span class="comment">     * interceptor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable if the interceptors or the</span></span><br><span class="line"><span class="comment">     * target-object throws an exception.  */</span></span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注释也可以看得出来，用于对方法在before或者after进行加强（此处有点像AOP）。而对于invoke方法，前面首先是要读取配置辣，然后try-catch也是比较显然的，判断是否有缓存，如果有，直接return，如果没有，写入缓存（其实这里的interceptor的invoke方法写得不够好，应该要分情况去缓存的，这个大概只是一个demo，还要修改很多，但这里暂时不讨论）。后面的这个Thread我没看懂是为何，既然用到了RedisUtil，应该跟它demo的逻辑有关系，但跟整体的Cache关系不大，略。至于其他的方法，都是辅助这个invoke方法的，比如判断是否要写入缓存，是否存在键等等，关键还是invoke。</p><p>至此，对当时Spring整合Redis的全部配置文件，每一个导入的类作用是什么，为什么要有这些property，应该是能有比较清晰的认知了。</p><p>4.Jedis的一些重要方法</p><p>其实最关键的框架也就是上面的第3点了。这一部分还有的就是Pipeline，调用Lua脚本等等，也是直接调用就行（看着方法名，方法参数来就行，只要对Redis的原生操作足够熟悉）。</p><p>Pipeline就直接使用Pipeline类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pipeline</span> <span class="keyword">extends</span> <span class="title">MultiKeyPipelineBase</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pipeline.MultiResponseBuilder currentMulti;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Response&lt;T&gt; <span class="title">getResponse</span><span class="params">(Builder&lt;T&gt; builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.currentMulti != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">super</span>.getResponse(BuilderFactory.STRING);</span><br><span class="line">            Response&lt;T&gt; lr = <span class="keyword">new</span> Response(builder);</span><br><span class="line">            <span class="keyword">this</span>.currentMulti.addResponse(lr);</span><br><span class="line">            <span class="keyword">return</span> lr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getResponse(builder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClient</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Client <span class="title">getClient</span><span class="params">(<span class="keyword">byte</span>[] key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Client <span class="title">getClient</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isInMulti()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.discard();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.sync();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用Lua是在Jedis下的方法：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\60fbd8249e904bc3a36241008b228f76\clipboard.png)</p><p>看了一下，RedisTemplate搜eval竟然没有相关方法。然后再搜了一下script，就出来了：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\c46dfa03d3e647adb313655d32a4e859\clipboard.png)</p><p>显然，这个就是调用脚本的总方法了。原来没有eval是因为，RedisTemplate还有更大的野心，它要一个方法来执行所有的跟Redis兼容的脚本。。那么看来Jedis也有其他的调用脚本的方法，此处就不再赘述。</p><p>客户端管理的API</p><p>client list：列出与Redis服务端相连的所有客户端连接信息。下面的客户端的属性：</p><p>标识：id，addr，name，fd（socket的文件描述符，如果fd=-1，表示客户端不是外部客户端，而是Redis内部的伪装客户端）</p><p>输入缓冲区： qbuf， qbuf-free。缓冲区会动态调整，只是要求每个客户端缓冲区的大小不能超过1G。如果超过了，客户端将会被关闭。而且缓冲区不受maxmomory控制，假设一个Redis实例设置了maxmemory为4G，已经存储了2G，但是如果此时输入缓冲区使用了3G，加起来就超过了maxmemory的限制，可能会产生数据丢失，键值淘汰，OOM等情况。</p><p>导致输入缓冲区过大的主要原因：Redis的处理速度跟不上输入缓冲区的输入速度，并且每次进入输入缓冲区的命令包含了大量的bigkey，从而造成了输入缓冲区过大的情况。或者是Redis发生了阻塞，短期内不能处理命令，造成客户端输入的命令积压在了输入缓冲区。</p><p>监控输入缓冲区的方法：</p><p>1.client  list（收集qbuf和qbuf-free，找到可能出现问题的客户端）</p><p>2.info clients，找到最大的输入缓冲区，设置client_biggest_input_buf参数，超过一定值告警</p><p>输出缓冲区：obl，oll，omem。与输入缓冲区不一样，输出区可以通过参数设置。输出区根据客户端的不同分为3种：普通客户端，发布订阅客户端，slave客户端（子客户端）。包含：固定缓冲区（16KB，用于返回比较小的执行结果0，动态缓冲区（返回比较大的结果）</p><p>客户端的存活状态：age：连接时间    idle：最近一次空闲时间</p><p>通过设置参数来控制客户端： config set maxclients（最大客户端连接数，默认10000）</p><p>config set timeout（客户端空闲时间超过这个值，就会被关闭，默认是0，即不关闭）</p><p>（一般开发的时候用默认的就行，实际发布和运维的时候，idle是必须大于0的）</p><p>flag：参数：表示客户端的类型。</p><p>N：普通客户端。M：master。S：slave。O：正在执行monitor命令。x：正在执行事务</p><p>b：正在等待阻塞事件     u：客户端未被阻塞        d：一个被watch的键已被修改，无法exec事务</p><p>c：回复完整的输出后，关闭连接        A：尽可能快地关闭连接</p><p>其他诸如：client setName/getName , kill port, pause timeout(毫秒），不再赘述</p><p>monitor：可以监控其他客户端的命令调用（在哪个时间，调用了哪个命令）。但在并发量过大的时候，monitor客户端的输出缓冲会暴涨，可能会瞬间占用大量内存。</p><p>tcp-keepalive:检测TCP连接活性的周期，默认是0.防止大量的死连接占用系统资源。</p><p>tcp-backlog：是一个队列，用于接受的TCP连接。此参数就是队列的大小，默认511，一般不修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;chapter1.&lt;/p&gt;
&lt;p&gt;Redis没有表和Schema（Schema就是数据库对象的集合，这个集合包含了各种对象如：表、视图、存储过程、索引等&lt;/p&gt;
&lt;p&gt;Redis用 key-value存储数据，所有的key必须是string类型&lt;/p&gt;
&lt;p&gt;Redis的命令不区分大小写，但存储的数据区分（包括key-value）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://hongscar.cn/categories/Redis/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>Swing笔记</title>
    <link href="https://hongscar.cn/Swing%E7%AC%94%E8%AE%B0.html"/>
    <id>https://hongscar.cn/Swing%E7%AC%94%E8%AE%B0.html</id>
    <published>2020-02-17T03:12:48.000Z</published>
    <updated>2020-02-17T06:19:18.755Z</updated>
    
    <content type="html"><![CDATA[<p>JFrame：基础窗口<br>JLabel：纯文本<br>JButton：按钮<br>JTextField：输入文本框</p><p>Swing有内置的专用线程来接受UI事件并更新屏幕（如果从其他线程着手对屏幕的操作，可能产生冲突和死锁）</p><a id="more"></a>例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SwingUtilities.invokeLater(<span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO the operation about the screen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>(不再直接操作JLabel，而是提交一个Runnable，当事件队列获取这通任务时，执行这个Runnable，不会做其他事情。前提是所有代码都如此提交，包括main。将包含初始化组件的任务在内部都设置为在SwingUtilities.invokeLater内调用)</p><p>JFrame默认使用BorderLayout</p><p>JTextArea： 多行文本输入 （常用方法append，可以rollback）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JTextArea t = <span class="keyword">new</span> JTextArea(<span class="number">20</span>, <span class="number">40</span>);</span><br><span class="line">t.setLineWrap(<span class="keyword">true</span>);    <span class="comment">//设置自动换行，默认为不换行</span></span><br><span class="line">t.setWrapStyleWord(<span class="keyword">true</span>);    <span class="comment">//断行不断字（不会把一个词分在两行中显示）</span></span><br><span class="line">JFrame jFrame = <span class="keyword">new</span> JFrame();</span><br><span class="line">jFrame.add(<span class="keyword">new</span> JScrollPane(t));    <span class="comment">//JScrollPane,给组件增加滚动条</span></span><br></pre></td></tr></table></figure><p>Container：面板，用于添加组件，布局等。JFrame实际不能直接设布局和添加组件，但JDK简化了写法，使得给JFrame的操作默认传给Container。<br>setLayout：设置布局<br>JFrame extends Frame<br>Frame extends Window<br>Window extends Container<br>( super.setLayout(…);)<br>布局管理器自适应窗口大小，如果窗口大小尺寸改变，组件的大小，形状和位置都会做出相应的改变</p><p>布局：<br>①BorderLayout：四个边框区域和一个中间区域<br>使用面板重载的add方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jFrame.add(BorderLayout.NORTH, <span class="keyword">new</span> JButton());</span><br></pre></td></tr></table></figure><p>除CENTER，加入的组件都是沿一个方向压缩到最小尺寸，同时在另一个方向上拉伸到最大尺寸。而CENTER是两个方向同时拉伸，以覆盖中间区域。</p><p>②FlowLayout：流布局。组件自左到右流动到窗体，占满空间后换行。组件为合适大小（刚好充满标签的大小）</p><p>③GridLayout：表格布局。创建一个放置组件的表格，依次放入。组件大小：自适应窗体。<br>例子：new GridLayout(7, 3); //默认为(n, 1);</p><p>④绝对定位：setLayout(null); 把容器的布局管理器设置为空，然后使用setBounds( )方法来定位组件<br>（比较简单粗暴，但是在不同大小的屏幕中显示效果会不一样）</p><p>各种按钮：<br>new BasicArrowButton(BasicArrowButton.NORTH);<br>JToggleButton, JCheckBox复选框， JRadioButton单选<br>ButtonGroup 按钮组：将多个AbstractButton对象添加进去，然后只有一个可以选中（排他）<br>例子：将两个JRadioButton加到ButtonGroup实现单选<br>（PS：对于JButton无效，因为只有一个状态，加以监听）</p><p>ImageIcon对象：获取文件地址以及文件名，即可用作程序中的图标<br>组件：setRolloverEnabled(true); //是否可以翻转，组件图标是否能改变<br>setRolloverIcon(icon); //设置松开时的图标<br>setPressedIcon(icon);<br>setToolTipText(“…”); //悬浮时，组件的提示语<br>setBorder(Border border); //设置一个边框</p><p>JTextField获取数据： jtf.getText(); setEditable(); //默认为true</p><p>组合框JComboBox 多选一，如果可自写，setEditable(true); getSelectedIndex(0 ~ n-1), 如果自定义，返回-1 getSelectedItem()</p><p>列表框JList<br>与JComboBox的区别：总是占据一定屏幕，可以多选（ctrl）<br>getSelectedValues();返回被选中的items，返回一个字符串数组。<br>JList本身没有对滚动条提供直接支持，需用通过JScrollPane</p><p>页签面板：JTabbedPane<br>类似文件夹的页签，里面可容纳多个组件（页面） 使用例子：浏览器上方选择不同页面的面板</p><p>消息框：<br>JOptionPane.showMessageDialog(); //消息对话框<br>JOptionPane.showConfirmDialog(); //确认对话框<br>返回值为int： JOptionPane.YES_OPTION &lt;=&gt; 0 , JOptionPane.NO_OPTION &lt;=&gt; 1 ,<br>JOptionPane.CANCEL_OPTION &lt;=&gt; 2 , JOptionPane.CLOSED_OPTION &lt;=&gt; -1</p><p>caidan :JMenuBar 能拥有菜单的组件，包括JApplet，JFrame，JDialog及它们的子类。 setMenuBar()方法</p><p>JPopupMenu 弹出式菜单 编写自定义对话框： extends JDialog</p><p>JDialog 默认布局： BorderLayout<br>setVisiable(true); 必须显式调用才可以使得Dialog显示出来 dispose(); 关闭JDialog，释放资源</p><p>文本对话框：JFileChooser 可用于选择，打开文件，保存文件等功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JFileChooser jfc = <span class="keyword">new</span> JFileChooser();</span><br><span class="line">jfc.setFileSelectionMode(JFileChooser.FILES_ONLY);  <span class="comment">//只选文件</span></span><br><span class="line"><span class="comment">//其他参数 DIRECTORIES_ONLY ， FILES_AND_DIRECTORIES</span></span><br><span class="line"><span class="keyword">int</span> value = jfc.showOpenDialog(<span class="keyword">null</span>);    <span class="comment">//打开一个文件选择对话框</span></span><br><span class="line"><span class="keyword">int</span> value1 = jfc.showSaveDialog(<span class="keyword">null</span>);    <span class="comment">//弹出保存文件选择框</span></span><br><span class="line"><span class="comment">//返回值： APPROVE_OPTION 为正常，其他都是有错误的情况</span></span><br></pre></td></tr></table></figure><p>getSelectedFile(), getCurrentDirectory() 用于查询操作的返回结果</p><p>Container的validate(); 使容器再次布置其子组件（刷新容器的作用）</p><p>任何能接受文本的组件都可以接受HTML文本（Swing组件上的HTML)<br>(必须使文本以<html>标记开始，然后就可以开始使用HTML标记)</p><p>Jslider 滑块 ProgressMonitor 进度条</p><p>选择外观：①可插拔外观（跨平台，默认） ②只适应当前系统的外观<br>选择②：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;    <span class="comment">//写在main()开头</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JFrame：基础窗口&lt;br&gt;JLabel：纯文本&lt;br&gt;JButton：按钮&lt;br&gt;JTextField：输入文本框&lt;/p&gt;
&lt;p&gt;Swing有内置的专用线程来接受UI事件并更新屏幕（如果从其他线程着手对屏幕的操作，可能产生冲突和死锁）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://hongscar.cn/categories/Java/"/>
    
    
      <category term="deprecated" scheme="https://hongscar.cn/tags/deprecated/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记1</title>
    <link href="https://hongscar.cn/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.html"/>
    <id>https://hongscar.cn/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.html</id>
    <published>2020-02-17T03:12:38.000Z</published>
    <updated>2020-02-17T06:18:56.256Z</updated>
    
    <content type="html"><![CDATA[<p>Python是完全面向对象的语言，函数，模块，数字，字符串都是对象。</p><p>Python的值不用定义类型，直接赋值即可使用。（因为任何数据都是对象，包括数字。所以变量赋值就是把对象关联起来。每一次变量重新赋值，并没有改变对象的值，只是新创建了一个新对象，并用变量指向它。）</p><p> 布尔值为True，False。为False的情况：</p><p>数字0（包括0.0），空字符串，None（None是Python里的一个特殊值，表示空值），</p><p>空集合,包括( ) , [ ] , { }    其他值都认为是True</p><p>变量名不能以 双下划线开头（这类标识符具有特殊意义，如： _<em>init_</em>( ) 代表类的构造函数）</p><p>同时只能由数字，字母，下划线组成。其他符号都不行。</p><a id="more"></a><p>算术运算符：</p><p>‘la ‘  *  3 =  ‘la la la ‘</p><p>10 / 3 = 3.3333(普通的除）        10 // 3 = 3(取整，跟java的一样）</p><p>3**2 = 3^2 = 9</p><p>关系运算符，对于字符串，从左到右比较字符。</p><p>‘z’ &gt; ‘a’ &gt; ‘Z’ &gt; ‘A’</p><p>逻辑运算符：not ， and， or</p><p>在字符串前面加u，表示Unicode编码。    u’asdczx’</p><p>id( )：输出变量的地址。</p><p>当x = y,二者就指向了同一个地址，此时  x is y  返回True。 x is not y 返回False</p><p>print可以有占位符。</p><p>例子：</p><p>“X’s address is : %d”    此时%d就是普通的字符串，但如同在后面增加value</p><p>“X’s address is : %d” %(id(x))        那么%d就会被  id(x) 所替换。</p><p>类型转换：</p><p>字符串转数字： int(x), long(x), float(x)    都有第二个可选参数，表进制。</p><p>eval(“..”)    计算字符串里的表达式。例子：eval(‘4+2’) 输出6</p><p>数字转字符串：str(x)</p><p>repr(obj)    将对象转换为可打印的字符串</p><p>chr(整数）将一个整数转换为ASCII字符。    ord（字符） 将一个ASCII字符进行转换为整数</p><p>hex（）整数转16进制        oct（） 转8进制</p><p>访问字符串某下标： [ ]</p><p>“asdefg”[3] = ‘e’    index从0开始。</p><p>截取子字段：[a : b]     获取index从a开始，到b-1的字串。</p><p>如果用 a - b，会将a - b计算出结果，然后再获取。如果是负数，则从后面算起。-1是最后一个。</p><p>范围是： [-length ~ length - 1]    a[-length]  ==  a[0]        [-1]  ==  a[length - 1]</p><p>in ， not in    某字符/字符串是否存在于该字符串中</p><p>r”asdzxc\nsdew” 使得\n这种转义符失效，成为普通字符串。R同理。这个例子要在print里生效。</p><p>-—</p><p>Python对于缩进是有限制的，错误的缩进会报错。</p><p>（CMD中写Python，tab第一次是4个空格，后面是8个空格，容易出错。）</p><p>例如if语句：</p><p>if a &gt; 10:    </p><p>print(“xxx”);        //如果不缩进，会报错</p><p>如果if中有多个语句，这些语句都要有相同的缩进。在cmd中，也要缩进，以一个空行结束if体。</p><p>elif    ：    相当于else if</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">15</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">20</span>:</span><br><span class="line">    print(<span class="string">"zz"</span>)</span><br><span class="line"><span class="keyword">elif</span> a &gt; <span class="number">15</span>:</span><br><span class="line">    print(<span class="string">"xx"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"cc"</span>)</span><br></pre></td></tr></table></figure><p>while语句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    sum += i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">print(i)</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p>for语句：   for i in range(start, end):    &lt;==&gt; for (int i = start; i &lt; end; i++) s</p><p>​        循环体</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">sum1 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">sum1 += i</span><br><span class="line">print(i)<span class="comment"># 100</span></span><br><span class="line">print(sum1)<span class="comment"># 5050</span></span><br></pre></td></tr></table></figure><p>(这里前面i定义与否都可以，但不定义的话，print(i)里会有warning，但还是可以运行的。</p><p>try-except语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    i = <span class="number">10</span></span><br><span class="line">    print(<span class="number">30</span> / (i - <span class="number">10</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">print(<span class="string">"Finished execute!"</span>)</span><br></pre></td></tr></table></figure><p>raise 可以显式抛出异常（相当于throw）</p><p>——–数据结构</p><p>1.列表List    （跟数组差不多，index从0开始）</p><p>定义一个list：    a = [ ]</p><p>len( ) 输出长度    append添加到最后        index(i, element)    插入到index为i处</p><p>a1.extends(a2)    将a2的元素全部添加到a1中</p><p>效果等同于：  a1 = a1 + a2</p><p>PS:使用加号运算符，会导致a1的内存地址改变。（即a1指向了新的内存地址）</p><p>a1 = a2;      #二者都是list</p><p>当a2改变的时候，a1也会跟着改变。（二者指向同一个list）</p><p>（但如果a2的改变是改变了内存地址，如上面的加号运算符，那么a1还是指向a2原本的内存地址，而a2指向了新的内存地址。此时a1 is a2 返回False）例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">d = [<span class="number">2000</span>, <span class="number">3000</span>]</span><br><span class="line">c = b</span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))<span class="comment"># if c == b True 2266036261960</span></span><br><span class="line">b.append(<span class="number">1000</span>)</span><br><span class="line">print(c)<span class="comment"># [1, 2, 88, 99, 1000]</span></span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))<span class="comment"># if c == b True 22660360261960</span></span><br><span class="line"></span><br><span class="line">b.extend(a)</span><br><span class="line">print(c)<span class="comment"># [1, 2, 88, 99, 1000, 1, 3, 5, 7]</span></span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))<span class="comment"># if c == b True 22660360261960</span></span><br><span class="line"></span><br><span class="line">b = b + d</span><br><span class="line">print(c)<span class="comment"># [1, 2, 88, 99, 1000, 1, 3, 5, 7]</span></span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))<span class="comment"># if c == b True 2266065942728</span></span><br><span class="line">print(b)<span class="comment"># [1, 2, 88, 99, 1000, 1, 3, 5, 7, 2000, 3000]</span></span><br></pre></td></tr></table></figure><p>list也可以用str( )转换成字符串。否则print的时候与字符串连接会报错。需要：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"some strings here: "</span> + str(aList))</span><br></pre></td></tr></table></figure><p>删除元素，length也会改变。（感觉也就C,JAVA的数组还是不可变长度了）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> listName[index]</span><br></pre></td></tr></table></figure><p>相当于String的indexOf，找到第一个element 的index。如果不存在，抛出异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.index(element)</span><br></pre></td></tr></table></figure><p>遍历数组，for语句即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">" "</span>)<span class="comment"># 1 3 3 3 5 7 3</span></span><br></pre></td></tr></table></figure><p>不换行print，第二个参数为 end=… 其中… 为每一次输出后面加到末尾的字符串，这里是一个空格。</p><p>同时for语句的range函数，如果省略掉一个参数，那么就是从0开始。</p><p>可以用for语句的同时，使用enumerate( )函数进行对 index跟value同时遍历，例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'csd'</span>, <span class="string">'we'</span>, <span class="string">'zca'</span>, <span class="string">'ert'</span>, <span class="string">'hnx'</span>]</span><br><span class="line"><span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    print(<span class="string">"第%d个元素是: %s"</span> % (i, val), end=<span class="string">"。。"</span>)</span><br><span class="line"><span class="comment"># 第0个元素是: a。。第1个元素是: we。。……</span></span><br></pre></td></tr></table></figure><p>（这个占位符的%后面要加空格，不然又有warning）</p><p>sort( ) ： 对list进行排序        a.sort( ) 才是正确的。   sort(a) 没有效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'z'</span>, <span class="string">'A'</span>, <span class="string">'Z'</span>, <span class="string">'B'</span>]</span><br><span class="line">a.sort()</span><br><span class="line"><span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    print(val, end=<span class="string">"。。"</span>)<span class="comment">#A。。B。。Z。。a。。z。。</span></span><br></pre></td></tr></table></figure><p>(z &gt; a &gt; Z &gt; A)</p><p>reverse( )： list倒转。如果希望倒序，应该先sort，再reverse</p><p>range(start, end)    （range函数实际上会生成一个list）</p><p>从start到end递增（到end的时候就结束循环），start 默认值为0</p><p>2.元组 tuple</p><p>与list很相似，</p><p>区别在于：一经定义，内容就不能改变（所以没有插入，删除等功能）。而且可以同时存储不同类似的数据，用圆括号，而不是中括号括起来。</p><p>各种方法都与list一致：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(a[<span class="number">0</span>])<span class="comment"># 1</span></span><br><span class="line">print(a[<span class="number">3</span>])<span class="comment"># 4</span></span><br><span class="line">print(len(a))<span class="comment"># 4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">", "</span>)<span class="comment"># 1, 2, 3, 4</span></span><br><span class="line">print()</span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    print(<span class="string">"a[%d] is : %s"</span> % (index, value), end=<span class="string">", "</span>)<span class="comment"># a[0] is : 1, a[1] is 2, a[2] is 3, a[3] is 4,</span></span><br></pre></td></tr></table></figure><p>由于内容不能改变，所以没有sort函数，也没有reverse。可以先将tuple转换为list，然后再对list排序，再将结果赋值给tuple。</p><p>转换：</p><p>列表对象 = list(元组对象)</p><p>元组对象 = tuple(列表对象)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">31</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">14</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">","</span>)<span class="comment"># 31, 12, 23, 14,</span></span><br><span class="line">print()</span><br><span class="line">b = list(a)</span><br><span class="line">b.sort()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)):</span><br><span class="line">    print(b[i], end=<span class="string">", "</span>)<span class="comment"># 12, 14, 23, 31,</span></span><br><span class="line">print()</span><br><span class="line">a = tuple(b)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">", "</span>)<span class="comment"># 12, 14, 23, 31,</span></span><br></pre></td></tr></table></figure><p>3.字典    directory</p><p>用{ }，就是键值对。    { key1: val1, key2: val2, … , keyn: valn}</p><p>len( ) 长度。    </p><p>a[keyx] = valx    添加</p><p>a1.update(a2)        合并两个字典，结果放入a1.（此处不可以用a1 = a1 + a2,会报错）</p><p>删除键： pop</p><p>判断是否存在： in</p><p>遍历keys，values：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">'name'</span>: <span class="string">'小明'</span>, <span class="string">'sex'</span>: <span class="string">'男'</span>&#125;</span><br><span class="line">d2 = &#123;<span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'score'</span>: <span class="string">'80'</span>&#125;</span><br><span class="line">d1.update(d2)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d1.keys():</span><br><span class="line">    print(key, end=<span class="string">", "</span>)<span class="comment"># name, sex, age, score</span></span><br><span class="line">print()</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d1.values():</span><br><span class="line">    print(value, end=<span class="string">", "</span>)<span class="comment"># 小明, 男, 18, 80,</span></span><br></pre></td></tr></table></figure><p>或者 ：   for (k, v) in dict.items( ):        # items( )，获取key-value结果集    (代码略)</p><p>清空字段：  a.clear( )</p><p>字典也可以嵌套，跟多维list一样。</p><p>{‘name’ : {‘first’: ‘Kevin’, ‘last’: ‘Seth’}, ‘age’: 40}</p><p>访问嵌套字典：字典[键] [键]        print(d[‘name’] [‘first’])</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">'name'</span>: &#123;<span class="string">'first'</span>: <span class="string">'Kevin'</span>, <span class="string">'last'</span>: <span class="string">'Seth'</span>&#125;, <span class="string">'age'</span>: <span class="number">24</span>&#125;</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d1.values():</span><br><span class="line">    print(value)<span class="comment"># &#123;'first': 'Kevin', 'last': 'Seth'&#125;\n24</span></span><br><span class="line">print(d1[<span class="string">'name'</span>][<span class="string">'first'</span>])<span class="comment"># Kevin</span></span><br></pre></td></tr></table></figure><p>4.集合    set</p><p>集合由一组无序排列的元素组成，同时集合里没有重复的元素。</p><p>分为可变集合（set） 和不可变集合（frozenset）</p><p>（可变集合 创建后，可以添加元素，修改元素，删除元素）</p><p>创建集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = set(<span class="string">'python'</span>)</span><br><span class="line">print(type(s))<span class="comment"># &lt;class 'set'&gt;</span></span><br><span class="line">print(s)<span class="comment"># &#123;'o', 't', 'h', 'n', 'p', 'y'&#125; (无序,每一次都不相同)</span></span><br><span class="line"></span><br><span class="line">s1 = set(<span class="string">'apple'</span>)</span><br><span class="line">print(s)<span class="comment"># &#123;'a', 'l', 'p', 'e'&#125;</span></span><br></pre></td></tr></table></figure><p>len( ) ：获取集合的长度</p><p>for e in s    遍历。</p><p>add 添加。添加后的元素也在随机位置</p><p>s1.update(s2) 添加集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">41</span>, <span class="number">22</span>, <span class="number">13</span>, <span class="number">54</span>, <span class="number">19</span>, <span class="number">38</span>, <span class="number">77</span>, <span class="number">5</span>, <span class="number">6</span>])<span class="comment"># 也可以直接&#123;41, 22, 13, ……&#125;</span></span><br><span class="line">print(len(s))</span><br><span class="line">s.update([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">print(s)<span class="comment"># &#123;4, 5, 38, 6, 41, 13, 77, 19, 54, 22&#125;</span></span><br></pre></td></tr></table></figure><p>remove(value)    删除指定的集合元素</p><p>clear( )    清空</p><p>in：判断某个value是否存在于集合中    存在返回True。否则False</p><p>A &lt; B , 如果A是B的真子集，返回True。</p><p>A &lt;= B, A是B的子集。</p><p>A &gt; B, A是B的真超集        A &gt;= B    A是B的超集</p><p>|   : 并集，    s1  |  s2   ==   s1 ∪ s2</p><p>也可以用这个union方法：    s = s1.union(s2)</p><p>&amp;  : 交集        s1  &amp;  s2  ==  s1  ∩  s2</p><p>也可以用这个intersection方法：    s = s1.intersection(s2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s = s1.intersection(s2)</span><br><span class="line">ss = s1 &amp; s2</span><br><span class="line">print(s)<span class="comment"># &#123;3&#125;</span></span><br><span class="line">print(ss)<span class="comment"># &#123;3&#125;</span></span><br></pre></td></tr></table></figure><p>^    :差分集        即    （s1 ∪ s2） - (s1 ∩ s2)</p><p>也可以用这个symmetric_difference方法：    s = s1.symmetric_dirrerence(s2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s = s1 ^ s2</span><br><span class="line">ss = s1.symmetric_difference(s2)</span><br><span class="line">print(s)<span class="comment"># &#123;1, 2, 4&#125;</span></span><br><span class="line">print(ss)<span class="comment"># &#123;1, 2, 4&#125;</span></span><br></pre></td></tr></table></figure><p>按位运算：  &amp;与    |或    ^异或</p><p>-————————-</p><p>函数：</p><p>在函数里定义的变量是局部变量，作用域就是在函数体内。如果全局变量和局部变量同名，那么在函数体内只能访问局部变量。如果在定义局部变量之前调用了同名的“全局变量”，会报错。因为函数体内只能访问局部变量，会显示：UnboundLocalError: local variable ‘a’ referenced before assignment</p><p>Python的传值是按值传递的（但传的值都是对象，数字也是对象，这点跟java不一样）</p><p>（经过测试：传数值，字符串都不会随着函数而改变，但list，directory会发生改变！）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(list)</span>:</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(len(list)):</span><br><span class="line">        <span class="keyword">if</span> x != len(list) - <span class="number">1</span>:</span><br><span class="line">            print(list[x], end= <span class="string">' + '</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(list[x], end=<span class="string">' '</span>)</span><br><span class="line">        total += list[x]</span><br><span class="line">    print(<span class="string">"="</span>, total)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">list = [<span class="number">15</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">65</span>]</span><br><span class="line">sum(list)<span class="comment"># 15 + 25 + 35 + 65 = 140</span></span><br><span class="line"><span class="comment"># 只是普通的函数演示,并不是演示list/directory会改变</span></span><br></pre></td></tr></table></figure><p>函数定义后面的参数可以指定默认值，（有默认值的参数只能出现在没默认值的参数的后面）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(message, times = <span class="number">1</span>)</span>:</span></span><br><span class="line">    print(message * times)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">say(<span class="string">'hello'</span>)<span class="comment"># hello</span></span><br><span class="line">say(<span class="string">'Python'</span>, <span class="number">3</span>)<span class="comment"># PythonPythonPython</span></span><br></pre></td></tr></table></figure><p>如果没有指定默认值，那么调用say(‘hello’)的时候参数个数就不对，会报错。当参数个数不一致的时候（或多或少），都会报错（不要跟JS混淆）</p><p>可变长参数（跟java不一样），这里是指参数可以是元组，或者是字典。</p><p>在形参前面加<em>，表示为 可变长参数。    <em>是元组，</em></em>是字典</p><p>例子：def f(*t):    此时调用可以是：f(1),f(1,2), f(5,756,234,23), f({‘a’: ‘111’, ‘b’: ‘324534’})</p><p>def f(**t):        此时调用可以是： f(a=1), f(a=1, b=2, c=3), f(a=1, b=12, c=543, d=765)</p><p>函数可以指定返回值，return。在函数体里用就行，定义上不用写什么。</p><p>Python预定义函数：</p><p>abs, pow(x, y), ound(x [, n]) 四舍五入，保留n位小数。 divmod(a,b) 返回 a / b , a % b</p><p>(这个四舍五入，-2.5的结果是-2，2.5的结果是2）</p><p>PS：Python2中，2.5的结果是3.0。但在python3中，2.5会返回2，2.5000000001才会返回3</p><p>字符串处理函数： lower, upper , swapcase(大写转小写，小写转大写）</p><p>capitalize 首字母大写。    title 首字母大写，其余为小写</p><p>title是每一个单词的首字母大写，例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'hello woRLd'</span>.title()</span><br><span class="line">print(s)<span class="comment"># Hello World</span></span><br><span class="line">s = <span class="string">'hello woRLd'</span>.capitalize()</span><br><span class="line">print(s)<span class="comment"># Hello world</span></span><br></pre></td></tr></table></figure><p>ljust，rjust， center        左对齐，右对齐，居中对齐，第一个参数为width表示字符串总长度，第二个参数可选，当长度不足时填充，默认是空格填充。</p><p>zfill， 用0填充到width长，右对齐。</p><p>搜索和替换：</p><p>str.find(substr)    查看字符串str中出现子串substr的第一个字母的位置，找不到则返回-1</p><p>index    与find函数相同，但找不到的时候会报错</p><p>rfind    从右侧开始find    （注意index的结果还是顺序来算的）</p><p>rindex            </p><p>count    计算子串的出现次数</p><p>（以上5个方法还有两个可选参数，start，end，表示搜索范围从start到end - 1）</p><p>str.replace(oldstr, newstr [,count])    替换。count为替换次数。</p><p>strip，lstrip，rstrip，把前后，前，后的[chars]字符去掉。默认为空白符。</p><p>expandtabs    把tab字符替换成空格，每个空格替换成[tabsize]个空格，默认是8个</p><p>分割和组合：</p><p>split（跟java一样），    splitlines 按照行分隔符划分    join把字符串序列用特定字符连接起来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="string">'214, '</span><span class="number">233</span><span class="string">', '</span><span class="number">532</span><span class="string">']</span></span><br><span class="line"><span class="string">str = '</span><span class="comment">##'</span></span><br><span class="line">s = str.join(list)</span><br><span class="line">print(s)<span class="comment"># 214##233##532 </span></span><br><span class="line"><span class="comment"># 这里会有一个warning：shadows build_in names 'xx', 因为list, str这种变量名起得不好，容易引起歧义，应该取得更能表达意思的名字 （但这里只是简单的演示代码,str跟list其实就能表示清楚了。。)</span></span><br></pre></td></tr></table></figure><p>startwith，endswith，isalnum（是否全是字母或数字），isalpha 字母  isdigit</p><p>islower   isupper</p><p>help(obj)  输出这个对象的帮助信息（可能是命令，可能是list等等的对象）</p><p>（传入一个list，就能看到List列表对象的源码）</p><p>type(obj)    显示一个对象的数据类型</p><p>字符串会返回：    &lt;class ‘str’&gt;</p><p>数值会返回：        &lt;class ‘int’&gt;    &lt;class ‘float’&gt;</p><p>列表会返回：        &lt;class ‘list’&gt;</p><p>-——————————-</p><p>类</p><p>1.变量，构造函数，析构函数，调用等等：</p><p>PS： <strong>xxx</strong> 表示系统定义的名字    __xx:表示是类的私有变量名(类外不能直接访问)</p><p>直接在构造器里调用  self.str11 = ‘111’    也算是定义了一个成员变量str11（即使函数外部没有定义str11这个变量。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span><span class="comment"># constructor</span></span><br><span class="line">        self.__str = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(self)</span>:</span><span class="comment"># normal function</span></span><br><span class="line">        print(self.__str)</span><br><span class="line">    __str = <span class="string">'MyString'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span><span class="comment"># destructor</span></span><br><span class="line">        print(<span class="string">"bye~"</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">p = Person(<span class="string">'Hong'</span>)</span><br><span class="line">p.sayHello()<span class="comment"># Hong</span></span><br><span class="line"><span class="keyword">del</span> p<span class="comment"># bye~</span></span><br><span class="line">p1 = Person(<span class="string">'Kai'</span>)</span><br><span class="line">p1.sayHello()<span class="comment"># Kai</span></span><br><span class="line"><span class="comment"># bye~(at the end of the program, p1 will release)</span></span><br><span class="line"><span class="comment"># if no 'del p' exists ahead, it will print 'bye~' twice here!</span></span><br></pre></td></tr></table></figure><p>2.静态变量，静态方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span>:</span></span><br><span class="line">    str = <span class="string">"this is the static"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.str = <span class="string">'MyString111'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.str)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">staticMethod</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(cls.str + <span class="string">' , '</span> + str(cls))</span><br><span class="line">        print(<span class="string">'this is a static method'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = MyString()</span><br><span class="line">s.output()                  <span class="comment"># MyString111   the value of instance</span></span><br><span class="line">print(MyString.str)         <span class="comment"># MyString      the value of class, static variable</span></span><br><span class="line">s.str = <span class="string">'Hong'</span></span><br><span class="line">MyString.str = <span class="string">'qqq'</span></span><br><span class="line">s.output()                  <span class="comment"># Hong</span></span><br><span class="line">print(MyString.str)         <span class="comment"># qqq           the value of class, static variable</span></span><br><span class="line">MyString.staticMethod()     <span class="comment"># this is a static method</span></span><br><span class="line">s.staticMethod()            <span class="comment"># this is a static method</span></span><br></pre></td></tr></table></figure><p>定义静态方法需要在方法前加：@staticmethod    （而且参数列表里不能有self）    </p><p>而定义静态变量不需要任何东西，每一个变量都同时是实例变量和静态变量。只要是通过类名访问的就是静态变量（看上面的例子，str通过instance访问时，就是实例变量，通过类名访问时则是静态）</p><p>类方法：@classmethod，第一个参数是cls（表示当前的类）</p><p>（其实类方法跟静态方法区别不大，静态方法可以直接用类名表示当前类。但一般的区分是这样的：静态方法存放与类无关的逻辑代码，如单纯的表达式计算。而类方法存放与类属性相关的逻辑代码）</p><p>isinstance(对象名， 类名或类型名）</p><p>例子： isinstance(str, MyString)        isinstance(1, int)</p><p>继承：class B (A)   B继承A，同时构造器里需要显式调用一次父类构造器</p><p>子类会继承父类的属性跟方法（私有除外）但如果提供了访问私有函数的公共接口，那么子类通过继承了这个public方法，也是可以间接访问父类私有函数的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, propertyA)</span>:</span></span><br><span class="line">        self.propertyA = propertyA</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__functionA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(str(self.propertyA) + <span class="string">' ... in class A'</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__functionA()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, propertyA, propertyB)</span>:</span></span><br><span class="line">        A.__init__(self, propertyA)<span class="comment"># call the father constructor</span></span><br><span class="line">        self.propertyB = propertyB</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionB</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(str(self.propertyB) + <span class="string">' ... in class B'</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">a1 = A(<span class="number">10</span>)</span><br><span class="line">a1.functionAA()<span class="comment"># 10 ... in class A     access the private f by a public f</span></span><br><span class="line">b1 = B(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">b1.functionAA()<span class="comment"># 5 ... in class Athe same as class A</span></span><br><span class="line">b1.functionB()<span class="comment"># 10 ... in class B</span></span><br><span class="line">print(b1.propertyA)<span class="comment"># 5</span></span><br><span class="line">print(b1.propertyB)<span class="comment"># 10</span></span><br><span class="line"><span class="comment"># a1.__functionA()# both a and b can't access the private atribute directly</span></span><br></pre></td></tr></table></figure><p>如果子类不调用父类的构造器，那么在父类构造器执行的语句就不会生效。比如，父类有属性a = 1，构造器里有赋值语句 a = 5.如果调用了父类构造器，那么子类继承的a属性值为5，如果没有调用，子类继承的属性值为1.如果父类的属性a仅仅定义在构造器里，那么调用父类构造器之后，子类成功继承属性a。如果没有调用父类构造器，则没有继承属性a，会报错（但其他构造器之外的成员都可继承）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        self.a = a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'method in class A'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, propertyA, propertyB)</span>:</span></span><br><span class="line">        A.__init__(self, propertyA)             <span class="comment"># call the father constructor</span></span><br><span class="line">        self.propertyB = propertyB</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'the method in class B'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b1 = B(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">b1.functionAA()          <span class="comment"># the method in class B</span></span><br><span class="line">b1.function1()</span><br><span class="line"><span class="comment"># print(b1.a)error, B object has no attribute 'a'</span></span><br></pre></td></tr></table></figure><p>同时，子类和父类有同名函数，此时是多态，会调用子类的函数，而非父类。（类型是子类）</p><p>抽象类和抽象方法：</p><p>Python通过类库abc实现抽象类，所以需要先import</p><p>from  abc  import  ABCMeta,  abstractmethod</p><p>在抽象类的第一行写下：   _<em>metaclass_</em>  =  ABCMeta</p><p>在抽象方法前增加：    @abstractmethod</p><p>抽象方法的定义：    def  abs_method_name (self): pass</p><p>PS：亲测，不需要前面三个步骤，想定义抽象方法直接在函数体 改为 pass 即可！</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myabs</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># __metaclass__ = ABCMeta</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abcmethod</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normalmethod</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"method in myabs"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myimp1</span><span class="params">(myabs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abcmethod</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="number">1123</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sub_abs_method</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># print(234)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = myimp1()</span><br><span class="line">a1.func1()              <span class="comment"># 111</span></span><br><span class="line">a1.abcmethod()          <span class="comment"># doesn't call,but no error</span></span><br><span class="line">a1.sub_abs_method()     <span class="comment">#234</span></span><br><span class="line"></span><br><span class="line">a2 = myabs()            <span class="comment"># abstract class still can make an instance</span></span><br><span class="line">a2.normalmethod()       <span class="comment"># call the non-abstract function(method in myabs)</span></span><br><span class="line">a2.abcmethod()          <span class="comment"># doesn't call,but no error</span></span><br></pre></td></tr></table></figure><p>值得注意的是，抽象类是可以实例化的，也可以调用非抽象方法跟抽象方法。而且子类也会继承这个抽象方法。但调用没有实现的抽象方法（pass），不会产生任何结果。</p><p>而且抽象类可以实例化，跟普通的没有区别。想定义抽象方法直接定义为pass即可</p><p>（我觉得抽象方法的主要用途是定义一个公共的方法，但未提供实现。子类可以选择实现并且使用，可以不实现，这时候甚至还能调用这个方法，但没有结果。比直接报错要好）</p><p>至于抽象类，似乎目前没有用，可能后面配合 模块 可以实现抽象类禁止实例化？    //TODO</p><p>多态：在不同的子类，同名方法可以有不同的实现。（如果子类没有实现该方法，就调用父类方法）</p><p>对象复制：</p><p>直接a2 = a1，之后二者指向同一个对象。除非指向其他对象，否则仅仅改变属性，内存地址并不会发生变化。而且a1的属性值改变之后，a2也跟着改变（二者始终指向同一个对象）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    property = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(id(a))            <span class="comment"># 3035407383560</span></span><br><span class="line">a.property = <span class="number">234</span></span><br><span class="line">print(a.property)       <span class="comment"># 234</span></span><br><span class="line">print(id(a))            <span class="comment"># 3035407383560 address don't change</span></span><br><span class="line">a2 = a</span><br><span class="line">print(a2.property)      <span class="comment"># 234</span></span><br><span class="line">print(id(a2))           <span class="comment"># 3035407383560</span></span><br><span class="line">a.property = <span class="number">567</span></span><br><span class="line">print(a.property)       <span class="comment"># 567</span></span><br><span class="line">print(a2.property)      <span class="comment"># 567   a2 change its value too</span></span><br><span class="line">print(id(a2))           <span class="comment"># 3035407383560</span></span><br><span class="line">print(id(a))            <span class="comment"># 3035407383560</span></span><br></pre></td></tr></table></figure><p>当函数的参数是对象是自定义的类对象时，由于传入的参数并没有声明类型，所以这个时候应该先对参数进行类型判断。    if isinstance(str, MyString):   …</p><p>-——————————</p><p>模块module    相当于java里的jar包，有封装好的函数，变量可以使用。</p><p>import xxx    调用：xxx.f        xxx.val</p><p>常用模块：</p><p>1.sys</p><p>可以获取系统的信息，还可以获取运行时的命令行参数，用作输入等等，例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用命令:  python test.py 3, 4, 9, 1 (如果逗号后面没有空格,好像会把整个当作list)</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.platform)<span class="comment"># win32</span></span><br><span class="line">print(<span class="string">"一共有%d个参数"</span> % len(sys.argv))<span class="comment"># 5个, 包括 test.py</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(sys.argv)):</span><br><span class="line">    sum += int(sys.argv[i])</span><br><span class="line">print(sum)<span class="comment"># 17</span></span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure><p>2.platform</p><p>可以获取操作系统的详细信息和与Python有关的信息</p><p>3.math</p><p>与数学有关的。</p><p>常量：e，pi</p><p>常用方法：</p><p>fabs：取绝对值</p><p>floor：返回小于等于x的最大整数</p><p>log（x，a）：返回loga(x)    如果不指定a，默认是e</p><p>log10</p><p>pow（x，y） ：    x^y</p><p>sqrt    :    根号x</p><p>trunc：    返回x的整数部分</p><p>4.random</p><p>生成随机数</p><p>random( )    :生成一个0到1的随机浮点数  0 &lt;= n &lt; 1.0</p><p>uniform(a, b)    :生成a~b范围内的随机浮点数 [a, b]  或者 [b, a] （看哪个比较大）</p><p>randint（a，b）：生成a~b之间的随机整数（a不能比b大）    [a, b]</p><p>randrange (a, b, c): </p><p>生成 [a, b)范围里的随机数，每次递增的间隔为c。即获取a, a+c, a+2c, a+3c ……（不包括b）</p><p>choice（sequence） ： 从sequence里随机获取一个元素。sequence可以是list，tuple，string</p><p>shuffle    打乱list</p><p>sample（sequence， k） ：    从sequence中随机获取长度为k的片段。原有sequence不会被修改</p><p>5.Decimal</p><p>导入： from decimal import Decimal  （用于浮点数计算，精度更高）</p><p>6.fractions</p><p>用于表现和处理分数。</p><p>x = fractions.Fractions(1, 3)</p><p>print(x)            #   1/3</p><p>对x计算之后，还会进行自动约分。如1/6 * 4会变成 2/3</p><p>\7. time模块    （常用）</p><p>struct_time数组，表示时间    或者时间戳（1970.1.1到现在的总毫秒数）</p><p>year，month，day，hours，minutes，seconds，weekday（星期一为0），yday一年一共几天</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">print(time.time())                          <span class="comment"># 1567835487.381137</span></span><br><span class="line">print(time.localtime(time.time()))</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2019, tm_mon=9, tm_mday=7, tm_hour=13, tm_min=51, tm_sec=56,</span></span><br><span class="line"><span class="comment"># tm_wday=5(星期六）, tm_yday=250（今年的第250天）, tm_isdst=0)</span></span><br><span class="line">print(time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>))   <span class="comment"># 2019-09-07 13:57:13</span></span><br><span class="line">print(time.ctime())                         <span class="comment"># Sat Sep  7 13:57:39 2019</span></span><br></pre></td></tr></table></figure><p>自定义模块：一个.py文件就是一个模块，外部可以通过import导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> myPackage.m1.myMath</span><br><span class="line"></span><br><span class="line">a = myPackage.m1.myMath.sum(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">print(a)<span class="comment"># 7</span></span><br></pre></td></tr></table></figure><p>-—————</p><p>函数式编程（感觉跟面向过程差不多，只是功能都封装到函数里）</p><p>lambda表达式， 可用作匿名函数</p><p>返回函数名   =   lambda  参数列表  ：  返回值表达式</p><p>还可以将lambda表达式作为数组里的value：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum1 = <span class="keyword">lambda</span> x, y, z: x + y + z<span class="comment"># 输入参数是x, y, z,返回值是三个的和</span></span><br><span class="line">print(sum1(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>))<span class="comment"># 9</span></span><br><span class="line">Arr = [(<span class="keyword">lambda</span> x: x**<span class="number">2</span>), (<span class="keyword">lambda</span> x: x**<span class="number">3</span>), (<span class="keyword">lambda</span> x: x**<span class="number">4</span>)]</span><br><span class="line">print(Arr[<span class="number">0</span>](<span class="number">5</span>), Arr[<span class="number">1</span>](<span class="number">4</span>), Arr[<span class="number">2</span>](<span class="number">5</span>))<span class="comment"># 25, 64, 625</span></span><br></pre></td></tr></table></figure><p>(但PEP8标准觉得def比lambda要好。准确的是，lambda一般用于匿名函数，如果要把lambda赋值给一个变量作函数变量，那还是用def比较好）</p><p>map函数</p><p>result_sequence = map(function，sequence1 [，sequence2 …])</p><p>(function里有n个参数，那么就需要sequenceN）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">    print(e, end=<span class="string">", "</span>)      <span class="comment"># (0, 4), (1, 16), (2, 36), (3, 64), (4, 100),</span></span><br><span class="line">print()</span><br><span class="line">arr = map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>])</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">    print(e, end=<span class="string">", "</span>)      <span class="comment"># (0, 101), (1, 203), (2, 305), (3, 407), (4, 509),</span></span><br></pre></td></tr></table></figure><p>filter函数</p><p>filter（function，sequence）</p><p>对sequence里的每一个元素调用function，结果为true的返回。最终的结果序列成为filter的返回值</p><p>reduce函数</p><p>reduce（function，sequence）</p><p>function必须有2个参数。然后sequence里的前两个参数调用function，返回结果和第三个参数继续调用function，直到最后一个。</p><p>zip函数        压缩，解压(下面例子不能同时for，迭代器对象只能单向迭代一次，到了结尾之后，第二次迭代就像是迭代了一个空的list)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">zipped = zip(a, b)</span><br><span class="line"><span class="comment"># for element in zipped:</span></span><br><span class="line"><span class="comment">#     print(element, end=", ")        # (1, 4), (2, 5), (3, 6),</span></span><br><span class="line"></span><br><span class="line">unzipped = zip(*zipped)</span><br><span class="line"><span class="keyword">for</span> element1 <span class="keyword">in</span> unzipped:</span><br><span class="line">    print(element1, end=<span class="string">", "</span>)         <span class="comment"># (1, 2, 3), (4, 5, 6),</span></span><br></pre></td></tr></table></figure><p>闭包：即函数的嵌套。</p><p>在fun1里定义另一个fun2，然后fun1里的返回语句是return fun2，这时候就去调用fun2.</p><p>递归，一样的道理。</p><p>迭代器。</p><p>1.iter( )   可以获取一个sequence的迭代器。    next（Iterator）获取下一个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">12</span>, <span class="number">345</span>, <span class="number">234</span>, <span class="number">65</span>, <span class="number">78</span>, <span class="number">54</span>]</span><br><span class="line">it = iter(list)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = next(it)</span><br><span class="line">        print(s, end=<span class="string">", "</span>)          <span class="comment"># 12, 345, 234, 65, 78, 54,</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>（原生迭代器竟然没有hasNext方法！辣鸡，建议自己实现一个Iterator）</p><p>2.enumerate（）   将列表或者元组生成一个有序号的序列（index，value）</p><p>生成器：</p><p>当存在迭代器的时候，比如for in，实际上每一次都会调用一次next（）函数，表示生成下一个对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addList</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> alist:</span><br><span class="line">        <span class="keyword">yield</span> i + <span class="number">1</span></span><br><span class="line">alist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> addList(alist):</span><br><span class="line">    print(x, end=<span class="string">', '</span>)      <span class="comment"># 2, 3, 4, 5,</span></span><br><span class="line">print()</span><br><span class="line">print(alist)                <span class="comment"># [1, 2, 3, 4]  alist的值并没有变化！</span></span><br><span class="line"></span><br><span class="line">x = addList(alist)</span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 2</span></span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 3</span></span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 4</span></span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><p>用生成器 yield。<a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856" target="_blank" rel="noopener">https://blog.csdn.net/mieleizhi0522/article/details/82142856</a></p><p>yield相当于return，但下一次再进入到这个方法体的时候，会从yield这个语句后面开始执行。显式用next（generator）来调用相应的generator（有yield的方法），在for in的时候，实际上是每一次都隐式调用了next方法的。</p><p>同时如果要传值进行next，那么就用generator.send(value),这样就不会出现yield那一句的值丢失（因为return了之后，从下一个语句开始执行，当前语句在下一次是失效的。如a = yield 4，相当于return了4，但下次是从a的赋值才是进行，但右边的值实际上已经丢失，此时传值才可以让a有值，否则是None值。）</p><p>那么，生成器和普通的递归有什么区别？</p><p>首先，代码可以更加的简洁，看例子：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\83e1a372729240e29c855c809401023c\clipboard.png)</p><p>或者这个例子：<a href="https://blog.csdn.net/weixin_40581980/article/details/80986026" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40581980/article/details/80986026</a></p><p>（用了生成器语法，直接用1行代码替代了一整个class的功能）</p><p>同时，迭代器其实是隐式调用next，而每一步（+1）都会生成元素，开辟空间，添加元素到list</p><p>比如我们要获取10000000里的所有素数。如果用迭代器，那么就是 for i in range（2，100000000）</p><p>，这样会生成一个很大的list。虽然结果不会有那么多，但中间隐式调用next还是会生成一个临时是长度为10000000的list，极度消耗内存空间。（每一步都要调用next）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primes</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span></span><br><span class="line">        self.max = max</span><br><span class="line">        self.number = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.number += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.number &gt;= self.max:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">elif</span> check_prime(self.number):</span><br><span class="line">            <span class="keyword">return</span> self.number</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__next__()</span><br></pre></td></tr></table></figure><p>如果使用生成器呢，此时首先无须迭代，那么也就无须用class来实现，用函数即可。然后在循环里，是先进行check，然后check通过之后，才开始yield（生成），并且下一次next的时候，可以从这一步继续执行下去，生成下一个素数。即无须像迭代器一样，首先需要逐步生成所有的数，然后再check。（相当于比如1到1亿里面，有1000万个素数，那么迭代需要生成一个1亿长度的list，然后再查找，找到1000万个素数，再输出。而用生成器，则是找到一个素数，再添加元素到list里，最后的list长度就只有1000万，远小于1亿!）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Primes</span><span class="params">(max)</span>:</span></span><br><span class="line">    number = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> number &lt; max:</span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> check_prime(number):</span><br><span class="line">            <span class="keyword">yield</span> number</span><br><span class="line">            </span><br><span class="line">  </span><br><span class="line">primes = Primes1(<span class="number">100000000000</span>)</span><br></pre></td></tr></table></figure><p>Python的可移植性：先编译成字节码，然后将其转发到虚拟机(Python虚拟机)中运行（跟java一样）</p><p>生成的字节码文件：.pyc文件</p><p>Python的编译器总是在运行时出现，因为程序执行之前不需要预编译和链接等等的操作，使得开发周期大大缩短。（具备了更多的动态语言特性，可以在一个Python程序中执行另一个Python程序，即可以动态地修改代码，无须拥有或者编译整个系统的代码）</p><p>Python的实现，即编译器，PVM的实现方式：CPython，Jython，IronPython</p><p>执行优化工具：Psyco实时编译器（对PVM的增强工具）</p><p>print语句，在Python2不需要括号，在Python3需要（被视为一个函数调用）</p><p>模块：一个.py文件实际上就是一个模块</p><p>UNIX输入输出重定向（Python支持UNIX输入输出重定向）</p><p>例子：python xxx.py  &gt; saveit.txt    输出会输出到saveit.txt中，而非控制台</p><p>导入模块。</p><p>import a.b    &lt;==&gt;    from a import b</p><p>也可以用一个变量来赋值：import a.b.c.d    q = a.b.c.d</p><p>导入的时候，被导入的模块文件会从头执行一次（包括def，class的定义，还是简单的print，都会执行）同时由于导入消耗较大，因此运行两次import（即使在中途模块文件被修改了），也不会执行第二次import，这时候要使用reload（在Python2是内置，Python3里并没有）</p><p>exec( open(‘xxx.py’).read( ))</p><p>对于exec，代码都相当于粘贴到当前模块文件中，因此同名变量会产生冲突。    </p><p>而import跟from并不会。例子：</p><p>（我们在myMath.py里定义了一个ak变量，值为100）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ak = <span class="number">50</span></span><br><span class="line">exec(open(<span class="string">'myModule/myMath.py'</span>).read())</span><br><span class="line">print(ak)<span class="comment"># 100</span></span><br></pre></td></tr></table></figure><p>（对于import和from，当我们要访问它的变量，我们需要使用myModule.myMath.ak, myMath.ak等）</p><p>Python是动态类型的（自动地跟踪类型，而不是要求声明代码），</p><p>但Python也是强类型语言（只能对一个对象进行适合该类型的有效的操作）</p><p>字符串截取（跟数组一样操作）：</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'python'</span></span><br><span class="line">print(s[<span class="number">2</span>])</span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">3</span>])<span class="comment"># [start, end - 1] 'yt'</span></span><br><span class="line">print(s[<span class="number">1</span>:])<span class="comment"># [start, -1]'ython'</span></span><br><span class="line">print(s[:])<span class="comment"># equals with s</span></span><br><span class="line">print(s[:<span class="number">-1</span>])<span class="comment"># 'pytho'[0, end - 1], that's [0, -2]</span></span><br><span class="line">print(s[:<span class="number">3</span>])<span class="comment"># 'pyt'[0, 2]</span></span><br></pre></td></tr></table></figure><p>字符串是不可变的，不能对单独一个字符进行改变等，只能重新赋值（指向另一个字符串对象！）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'python'</span></span><br><span class="line"><span class="comment"># s[0] = 'J'error</span></span><br><span class="line">print(s)</span><br><span class="line">s = <span class="string">'J'</span> + s[<span class="number">1</span>:]</span><br><span class="line">print(s)<span class="comment"># Jython</span></span><br></pre></td></tr></table></figure><p>实际上还有第三个参数，a[ i : j : k ]        k默认是1，表示每隔k个字符索引一次。</p><p>所以如果是’abcdefg’[::2]  ==  ‘aceg’</p><p>如果K为-1，表示反转字符串。    “hello”[::-1]    ==    “olleh”</p><p>如果是 [a : b : -1]    会将[b + 1, a]的字符串反转输出（b最小为0，因此不能获取第一个字符，只能通过index为0获取第一个字符）</p><p>slice( ) 切片函数。</p><p>dir(obj)    返回一个list，即该obj包含的所有方法（包括继承而来的各种方法，默认方法）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> textwrap</span><br><span class="line">s = <span class="string">'str'</span></span><br><span class="line">res = str(dir(s))</span><br><span class="line">print(textwrap.fill(res, width=<span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\516fb192a01f4a4384d78e6724706a55\clipboard.png)</p><p>（textwrap是一个Python标准库的模块，可以用于格式化输出，这里使得每行输出长度最大为100）</p><p>help(obj)    返回obj的类定义。    help(obj.func)    返回obj该方法的定义，帮助信息</p><p>（因为Python一切皆对象，当然函数也是一个对象）    </p><p>关于len( )，转义符也属于长度1</p><p>len(‘A\nB\tC’)    ==    5</p><p>关于字符串匹配。</p><p>导入re模块，用match( reg, str)方法匹配，返回匹配的结果串，并且可以根据括号进行分组</p><p>PS：使用group可以获取分组内容，而且括号仅限小括号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">regexp = <span class="string">'Hello[ \t]*(.*)world'</span></span><br><span class="line">string = <span class="string">'Hello        Python world'</span></span><br><span class="line">match = re.match(regexp, string)</span><br><span class="line">print(match.group(<span class="number">1</span>))<span class="comment"># 'Python ' 表示括号里的内容</span></span><br><span class="line"></span><br><span class="line">string = <span class="string">'/usr/home/lumberjack'</span></span><br><span class="line">regexp = <span class="string">'/(.*)/(.*)/(.*)'</span></span><br><span class="line">match = re.match(regexp, string)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    print(match.group(i))</span><br><span class="line"><span class="comment"># group(0)为整个string,group(n)为第n个括号的内容</span></span><br></pre></td></tr></table></figure><p>这些字符串操作都是一个真正的序列操作，所以很多对于list等等都是有效的。</p><p>比如list也可以用-1下标表示最后一个元素！</p><p>list的赋值不能超出边界。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># L[10] = 100并不会把length提到10, 而是直接报错, 只能用append等</span></span><br></pre></td></tr></table></figure><p>Python的核心数据类型，都支持任意的嵌套。（同时list允许不同类型的元素）例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, [<span class="string">'fsd'</span>, <span class="number">4</span>], <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list))</span><br><span class="line">print(list[i], end=<span class="string">", "</span>)<span class="comment"># 1, 2, ['fsd', 4], 5, </span></span><br><span class="line">print()</span><br><span class="line">print(list[<span class="number">2</span>][<span class="number">0</span>] + <span class="string">', '</span> + str(list[<span class="number">2</span>][<span class="number">1</span>]))<span class="comment"># fsd, 4</span></span><br></pre></td></tr></table></figure><p>列表解析表达式 list comprehension expression</p><p>语法:    [ result_expression   for   item   in   list   filter_expression]</p><p>（第一个的result_expression可以调用后面for item的item数组）</p><p>例子：[ [1, 2, 3], [4, 5, 6], [7, 8, 9]]    一个二维矩阵，现在要提取第二列，并且每个值加1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">col2 = [item[<span class="number">1</span>] + <span class="number">1</span> <span class="keyword">for</span> item <span class="keyword">in</span> list]</span><br><span class="line">print(col2)<span class="comment"># [3, 6, 9]</span></span><br><span class="line">col2Doules = [row[<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> list <span class="keyword">if</span> row[<span class="number">1</span>] %  <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">print(col2Doubles)<span class="comment"># 获取第二列的偶数元素, [2, 8]</span></span><br></pre></td></tr></table></figure><p>如果使用括号的解析语法，就变成了生成器generator：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">generator = (sum(row) <span class="keyword">for</span> row <span class="keyword">in</span> list1)</span><br><span class="line">print(next(generator))<span class="comment"># 6</span></span><br><span class="line">print(next(generator))<span class="comment"># 15</span></span><br><span class="line">print(next(generator))<span class="comment"># 24</span></span><br><span class="line">print(list(map(sum, list1)))<span class="comment"># [6, 15, 24]</span></span><br></pre></td></tr></table></figure><p>（直接用map函数，对列表的每一列进行sum操作，然后用list转换成列表）</p><p>ps：sum跟list都是标准模块里的函数，可以直接使用，平时不要覆盖掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mydir = &#123;<span class="string">'name'</span>: <span class="string">'hong'</span>, <span class="string">'jobs'</span>: [<span class="string">'student'</span>], <span class="string">'age'</span>: <span class="number">24</span>&#125;</span><br><span class="line">print(mydir)                <span class="comment"># &#123;'name': 'hong', 'jobs': ['student'], 'age': 24&#125;</span></span><br><span class="line">mydir[<span class="string">'sex'</span>] = <span class="string">'male'</span></span><br><span class="line">print(mydir)                <span class="comment"># &#123;'name': 'hong', 'jobs': ['student'], 'age': 24, 'sex': 'male'&#125;</span></span><br><span class="line">mydir[<span class="string">'jobs'</span>].append(<span class="string">'programmer'</span>)</span><br><span class="line">print(mydir)     <span class="comment"># &#123;'name': 'hong', 'jobs': ['student', 'programmer'], 'age': 24, 'sex': 'male'&#125;</span></span><br><span class="line">print(mydir[<span class="string">'jobs'</span>][<span class="number">-1</span>])    <span class="comment"># programmer</span></span><br></pre></td></tr></table></figure><p>Python也有GC机制，但我们也可以手动删除不再需要的对象（del），也可以赋值为0，引发GC</p><p>字典可以用in判断是否存在某个key，也可以get(key1, default_value)</p><p>如果存在key1，则返回，如果不存在，返回default_value</p><p>文件。    要调用open函数来生成file对象。</p><p>第一个参数是路径，第二个参数是权限。默认是’r’,只能是’r’或者’w’，不能是’rw’</p><p>同时还可以是’rb’，表示将读出来的数据改为二进制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'data.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">'Hello\n'</span>)</span><br><span class="line">f.write(<span class="string">'world\n'</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'data.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">text = f.read()</span><br><span class="line">print(text)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>判断类型，isinstance是最好的选择</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> type(list1) == type([]):</span><br><span class="line">    print(<span class="string">'yes'</span>)</span><br><span class="line"><span class="keyword">if</span> type(list1) == list:</span><br><span class="line">    print(<span class="string">'yep'</span>)</span><br><span class="line"><span class="keyword">if</span> isinstance(list1, list):</span><br><span class="line">    print(<span class="string">'yeah'</span>)</span><br></pre></td></tr></table></figure><p>Python操作符表达式：</p><p>yield  x                            生成器表达式</p><p>lambda  args  ：  expression            匿名函数</p><p>x  if  y  else  z                        y为真时，x。否则z</p><p>x  or  y，    x  and  y，  not  x</p><p>x  in  y，  x  not  in  y        （iterables，sets）</p><p>x  is  y，  x  is  not  y</p><p>&lt; , &gt; ,== , !=  |,  &amp; ,   ^（异或）,    &lt;&lt;左移    &gt;&gt;右移    /除，    //除，取整数结果</p><p>s[i: j: k]    数组切片，从[i, j)中，每隔k个数输出一个列表</p><p>……</p><p>当两个类型不一样的数字进行运算时，结果为更复杂的那个类型。</p><p>如：40 + 3.14 = 43.14    3.14 + （2+3j） = 5.14+3j</p><p>x &lt; y &gt; z，    x &gt; y &gt; z， x  &gt;  y  &lt; z 这种是可行的</p><p>math.floor( )    返回不大于x 的最大整数。所以x为2.5时，结果为2.为-2.5时候，结果为-3</p><p>//整除，实际上就是对获得的结果，再进行floor。</p><p>所以  5 // 2 == 2    5 // -2  == -3</p><p>如果真的只想要整数部分，应该用trunc</p><p>python的整数没有范围，支持无穷的大小</p><p>进制计数：</p><p>0o开头：八进制    （第一个是0，第二个是小写的o）</p><p>0x开头：十六进制</p><p>0b开头：二进制</p><p>oct(x)      十进制转八进制</p><p>hex(x)    十进制转十六进制</p><p>bin(x)    十进制转二进制</p><p>或者是  int( num, x)        第二个参数可选，表示进制，默认是10</p><p>eval函数，可以将字符串作为python代码执行，然后运行结果就是返回结果。一般的作用是将字符串对象转换成更具体的对象（比如数字，list，set，directory等等）。但由于eval实际上会将里面的字符串作为程序的一个小片段进行编译运行，所以可以做一些其他的工作。比如甚至可以偷偷地拿一个字符串，将电脑上的某个文件删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">eval(<span class="string">"os.remove('data.txt')"</span>)</span><br></pre></td></tr></table></figure><p>位运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">11</span> | <span class="number">0b1100</span>)      <span class="comment"># 0b1111 == 15  (11 == ob1011, 1011 | 1100 == 1111)</span></span><br><span class="line">print(<span class="number">11</span> | <span class="number">1100</span>)        <span class="comment"># 0b10001001100 | 00000001011 == 1100 + 3 == 1103</span></span><br><span class="line">print(bin(<span class="number">1100</span>))        <span class="comment"># 0b10001001100</span></span><br><span class="line">print(<span class="number">0b11</span> ^ <span class="number">0b1010</span>)        <span class="comment"># 1001 == 9</span></span><br></pre></td></tr></table></figure><p>buildins（Python的内建模块，预定义的功能函数）</p><p>max，min，sum都在此中。</p><p>decimal模块设置全局精度：</p><p>decimal.getcontext( ).prec = 4</p><p>获得运行环境</p><p>decimal.Decimal(1) </p><p>print(decimal.Decimal(1) / decimal.Decimal(<strong>‘7’</strong>))</p><p><em># 0.1428571428571428571428571429    (默认精度)</em></p><p>关于布尔值（bool）</p><p>原本只是一个数字，</p><p>如果要用==来判断，那么只有True == 1才会返回True。0 == False才会返回False</p><p>如果用if来判断，那么只有特定情况下是返回False。</p><p>返回False的情况：</p><p>数字0（包括0.0，0.00000等）</p><p>空字符串（仅限’’, “”）(前面是一对单引号，后面是一对双引号）</p><p>其他诸如：” “(一个空格),   ‘0’,  “‘’”(双引号里面再加一对单引号)等等，都是返回True的。</p><p>空值：None</p><p>空集合： [ ] , (  ),   {  }</p><p>(此外，由于python里的True跟False其实就是1跟0，所以甚至能跟数字进行运算。比如：</p><p>True + 3 + 5J  == 4 + 5J</p><p>False  + 7.4  ==  7.4        True  +  5.5  ==  6.5</p><p>(不过一般意义不大，omit it！）</p><p>多个字符串用空格分隔开赋值，相当于加号运算符。例子：</p><p>s = “Meaning “ ‘of’ ‘ the life’</p><p>s            # Meaning of the life</p><p>如果中间是用 逗号 分隔开，那么会生成元组。</p><p>s = “Meaning “ , ‘of’ “ the life’</p><p>s            # (‘Meaning ‘, ‘of the life’)</p><p>关于转义：</p><p>在cmd中直接输出，会变成自动带有转义效果的字符串。比如换行会变成\n，\会变成\</p><p>然后，如果赋值的时候，反斜杠后面跟的并不是转义的字符，那么反斜杠会直接写入，例子：</p><p>x = “C:\py\code”</p><p>print(x)    # C:\py\code    因为并没有\p,\c，但建议在使用反斜杠而非转义时，还是直接转义</p><p>即：    x = “C:\py\code”    结果会是一样的</p><p>同时，无论如何，print(x)，里面的反斜杠会是\，而直接x时候（在cmd），会是\</p><p>在字符串前面加一个r，表示不转义。例子：</p><p>c = r’c:\py\code’</p><p>print(c)        # c:\py\code</p><p>三重引号（无论单引号，双引号都可以），可以用于编写多行文本数据。</p><p>即’’’ asdzxc…………（包括各种换行）’’’    这时候里面所有行加起来成为一个字符串。</p><p>（cmd中换行会变成\n）</p><p>而多行文本中的引号都会直接输出，无须转义。（直到遇见三重引号结束的时候）</p><p>同时，可以利用三重引号来作为多行注释（对性能影响不大，一般应该还是用于调试阶段）</p><p>转换。int( ), str( ) , repr( )</p><p>repr函数能将一个对象转换成其字符串形式。</p><p>ord将字符转换成ASCII码，chr则将ASCII码转换成字符。</p><p>格式化字符串的两种方法：</p><p>1.用%d，%s等占位符</p><p>“That is %d %s bird!”% (1, ‘dead’)</p><p>2.使用占位数组</p><p>‘That is {0} {1} bird!’.format(1, ‘dead’)</p><p>显然，format紧接着的就是一个数组，从{0}开始慢慢对应替换。format方法是新的格式化方法。</p><p>一般除非要进行特殊的格式化，否则直接用%s就行了，因为每种类型的对象都可以转换为字符串。</p><p>PS：格式化的结果是一个新的字符串对象，而不是对原本的字符串进行的修改。</p><p>其他格式化代码    P194</p><p>字符串方法：P186，此处略</p><p>Python一共有3个主要类型（以及操作）：</p><p>1.数字（整数，浮点数，二进制，分数等）：</p><p>支持加法，乘法等等。</p><p>2.序列（字符串，列表，元组）：</p><p>支持索引，分片，合并等等。</p><p>3.映射（字典）：</p><p>支持通过键的索引等。</p><p>（集合是自成一体的一个分类，不在此中）</p><p>每种类型的操作都是相通的，比如：</p><p>对于字符串，乘法运算符* 的作用是创建一个字符串的N份拷贝。</p><p>s = ‘abc’</p><p>s = s * 3            # PS： s * 3  &lt;==&gt;  3 * s</p><p>s        # ‘abcabcabc’</p><p>那么对于其他的序列sequence来说，<em>的运算也是相同的。比如对于list，之前没对list用过</em>，实际上效果也是一样的：</p><p>x = [1, 2, 3] * 3</p><p>x            # [1, 2, 3, 1, 2, 3, 1, 2, 3]</p><p>可变类型：数字，字符串，元组，不可变集合。</p><p>可变类型：列表，字典，可变集合。</p><p>-———</p><p>list的append与extend：</p><p>append是添加一个元素，extend是添加一个iterable的元素（list，tuple等等,并且迭代展开来。</p><p>例子：</p><p>[1, 2, 3].append([4, 5, 6])        ==&gt;    [1, 2, 3, [4, 5, 6]]</p><p>[1, 2, 3].extend([4, 5, 6])        ==&gt;     [1, 2, 3, 4, 5, 6]</p><p>分片赋值：</p><p>L = [1, 2, 3, 4, 5, 6, 7, 8]</p><p>L[2: 4] = [100, 200, 300, 400, 500]</p><p>使得L的[2, 3]替换成右边的。结果：[1, 2, 100, 200, 300, 400, 500, 3, 4, 5, 6, 7, 8]</p><p>字典的key不一定要是字符串，整数也行。只要是不可变对象就行。</p><p>获取不存在的key的值时会报错，然后程序就会结束，避免程序结束：</p><p>1.if key1 in dir: … else: …            通过if判断是否存在该key</p><p>2.try: …… except KeyError: ……        如果出错就执行except里的语句，然后继续执行。</p><p>3.dir.get(key1, 0)                    get方法，获取key1的值，获取不到就返回第二个参数</p><p>创建字典的方法：</p><p>dir = {‘name’ : ‘xxx’ , ‘age’ : 45}</p><p>D = { }</p><p>D[‘name’] = ‘xxx’</p><p>D[‘age’] = 45</p><p>dir = dict(name = ‘mel’, age = 45)        # key必须都是字符串才行</p><p>dir = dict( [(‘name’, ‘mel’), (‘age’, 45)])    # 给dict传入一个list对象的时候比较适用</p><p>嵌套对象用&gt; , &lt;比较大小时，会一直递归，从左到右比较，走到最深的层次，逐步比较差值。</p><p>关于乘法运算符，是返回一个新的对象（重复n次连接起来的），这时即使是重复一个对象，也不会因为原对象引用改变而改变新的对象。但在嵌套可变序列（对象）时，情况会不一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">x = L * <span class="number">4</span></span><br><span class="line">y = [L] * <span class="number">4</span></span><br><span class="line">y2 = [L[:]] * <span class="number">4</span></span><br><span class="line">print(x)            <span class="comment"># [4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]</span></span><br><span class="line">print(y)            <span class="comment"># [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]</span></span><br><span class="line">print(y2)           <span class="comment"># [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]</span></span><br><span class="line">L[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">print(x)            <span class="comment"># [4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]</span></span><br><span class="line">print(y)            <span class="comment"># [[4, 0, 6], [4, 0, 6], [4, 0, 6], [4, 0, 6]]</span></span><br><span class="line">print(y2)           <span class="comment"># [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]</span></span><br></pre></td></tr></table></figure><p>对于x = L * 4，是生成了一个新的list，不存在共享引用，因此L改变时，x并不会改变。</p><p>但是对于y = [L] * 4,相当于[ … ] * 4生成了一个新的list，而每个[ ]里面又引用了一个外部的list（共享引用），此时L改变时，y也会跟着改变。</p><p>解决方法就是拷贝，y2 = [L[:]] * 4,这样就不存在共享引用。</p><p>当复合对象包含指向自身的引用，称为循环对象，而这个自身的引用会打印成[…]，避免无限循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; [&#39;hong&#39;]</span><br><span class="line">x.append(x)</span><br><span class="line">print(x[0])         # hong</span><br><span class="line">print(x[1])         # [&#39;hong&#39;, [...]]</span><br><span class="line">print(x[1][0])      # hong</span><br><span class="line">print(x[1][1])      # [&#39;hong&#39;, [...]]</span><br></pre></td></tr></table></figure><p>对于sequence：假如 L = [0, 1, 2, 3, 4]    len = 5</p><p>1.索引值超过边界时，会发生error        （如L[5]）</p><p>2.但分片运算超出边界时，会把超出的数字限制回最大值。</p><p>如L[2: 100]    会自动改为L[2: 5]    不会报错</p><p>3.但左边界大于右边界时，会返回空sequence。</p><p>如：L[3: 1]     ==&gt;  [ ]</p><p>（以翻转的方式提取序列是行不通的（ 较低边界值比较高边界值更大， 例如，</p><p>L[3:1] ）。你会得到空分片（ [] ），因为Python会缩放分片限制值，以确定较低边</p><p>界永远比较高边界小或相等（例如， L[3:1] 会缩放成 L[3:3] ，空的插入点是在偏</p><p>移值3处））</p><p>但对这部分赋值是可行的，并且是以左边界处进行插入。</p><p>如： L[3: 1] = [‘10’, ‘20’, ‘30’, ‘40’, ‘50’]     但不等于L[3] = [‘10’, ‘20’, ‘30’, ‘40’, ‘50’]</p><p>结果会是： [0, 1, 2, 10, 20, 30, 40, 50, 3, 4]    (与有边界的数字无关）</p><p>如果是L[3]=。。。    则是直接更新list，更新list[3]的值了，而且L[3]的值会变成一个[。。 ] list</p><p>L[3] = [‘10’, ‘20’, ‘30’, ‘40’, ‘50’]        ==&gt;    L == [0, 1, 2, [‘10’, ‘20’, ‘30’, ‘40’, ‘50’], 4]</p><p>(如果分片赋值的时候，也超出边界，那么仍然按照第二条来执行：</p><p>L[10000:200]    = […]    这样就相当于append（超出时是append）</p><p>（这种反向（左边界不小于右边界）分片赋值在插入元素时是一个可行的选择）</p><p>4.L[2] = [ ]     那么L[2]的值就变成了[ ],即 L == [0, 1, [ ] , 3, 4]</p><p>但如果是分片赋值，L[2: 4] = [ ] ,则这里面的值会删除，最后：L == [0, 1, 4]</p><p>赋值空列表给一个分片，则会删除该分片</p><p>(但如果是第三条的情况下赋值[ ],则不会生效。如L[3: 1] = [ ] ，并不会删除L[3]，不会执行任何操作。</p><p>而只有当左边界小于右边界（即正常情况），才会删除）</p><p>if state:</p><p>state2</p><p>try:</p><p>statement1</p><p>except:</p><p>statement2</p><p>else:</p><p>statement3</p><p>finally:</p><p>statement4</p><p>else可以与if连用，也可以与try-except连用。上述语句else是与try连用，就近原则。</p><p>try-except-else-finally的意思是：</p><p>如果出现了错误，那么就执行except里的语句，如果没有错误，就执行else里的语句。finally一定执行</p><p>关于作用域，global和nonlocal：</p><p>（global用于在函数里访问全局同名变量，如果没global，按照LEGB原则，全局变量会被局部变量名覆盖，因而访问不到全局变量。）</p><p>（而nonlocal用于在嵌套函数里访问外部函数的同名变量，如果没global，按照LEGB，也是会先访问当前层次的局部变量，访问不到外部函数的同名变量）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">y, z = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x1 = <span class="number">123</span></span><br><span class="line">    x = y + z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x1</span><br><span class="line">        x1 = <span class="number">1234</span></span><br><span class="line">    f2()</span><br><span class="line">    print(x1)   <span class="comment"># 1234  f2通过nonlocal把f1的x1给修改了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line">print(x)    <span class="comment"># 3 f1通过global把全局的x给修改了</span></span><br><span class="line">x = <span class="number">100</span></span><br><span class="line">print(x)    <span class="comment"># 100</span></span><br></pre></td></tr></table></figure><p>Python的嵌套函数类似于JS的闭包，也可以保存已经结束了的外部函数的变量。如下面，就相当于可以视为一个工厂函数：（同时还能根据类型而做出不同的选择）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maker</span><span class="params">(N)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> X * N</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = maker(<span class="number">3</span>)</span><br><span class="line">print(f(<span class="string">'a'</span>))<span class="comment"># aaa</span></span><br><span class="line">print(f(<span class="number">5</span>))<span class="comment"># 15</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python是完全面向对象的语言，函数，模块，数字，字符串都是对象。&lt;/p&gt;
&lt;p&gt;Python的值不用定义类型，直接赋值即可使用。（因为任何数据都是对象，包括数字。所以变量赋值就是把对象关联起来。每一次变量重新赋值，并没有改变对象的值，只是新创建了一个新对象，并用变量指向它。）&lt;/p&gt;
&lt;p&gt; 布尔值为True，False。为False的情况：&lt;/p&gt;
&lt;p&gt;数字0（包括0.0），空字符串，None（None是Python里的一个特殊值，表示空值），&lt;/p&gt;
&lt;p&gt;空集合,包括( ) , [ ] , { }    其他值都认为是True&lt;/p&gt;
&lt;p&gt;变量名不能以 双下划线开头（这类标识符具有特殊意义，如： _&lt;em&gt;init_&lt;/em&gt;( ) 代表类的构造函数）&lt;/p&gt;
&lt;p&gt;同时只能由数字，字母，下划线组成。其他符号都不行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://hongscar.cn/categories/Python/"/>
    
    
      <category term="note" scheme="https://hongscar.cn/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://hongscar.cn/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>https://hongscar.cn/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</id>
    <published>2020-02-17T03:12:21.000Z</published>
    <updated>2020-02-17T06:18:40.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        此文用于记录一些常用的Linux命令。主要记录每一个命令的作用，参数的作用。</p><h4 id="①ls-英语全文：list。列出目录下的文件。-语法：-ls-选项-文件名或目录名"><a href="#①ls-英语全文：list。列出目录下的文件。-语法：-ls-选项-文件名或目录名" class="headerlink" title="①ls  英语全文：list。列出目录下的文件。  语法： ls [选项] [文件名或目录名]"></a>①ls  英语全文：list。列出目录下的文件。  语法： ls [选项] [文件名或目录名]</h4><p>-a：显示所有文件    –color=when(颜色输出。默认为always。 never：从不  auto：自动)<br>-d：显示目录信息，而非文件<br>-h：文件大小显示为k，M,G<br>-i：显示iNode<br>#####-l：长格式显示（ <strong>ll &lt;==&gt; ls -l</strong>）</p><a id="more"></a><hr><h4 id="②cd。英语全文：change-directory。更新目录-（Shell内置命令）"><a href="#②cd。英语全文：change-directory。更新目录-（Shell内置命令）" class="headerlink" title="②cd。英语全文：change directory。更新目录  （Shell内置命令）"></a>②cd。英语全文：change directory。更新目录  （Shell内置命令）</h4><p>Linux命令：Shell内置命令（无执行文件所在路径）/外部文件（有可执行文件）  Linux绝大部分是外部命令<br>-P:如果切换的是软链接目录，则进入原始的物理目录，而非软链接目录<br>-L:如果切换的是软链接目录，直接进入软链接目录</p><hr><h4 id="③mkdir-英语全文：make-directories。创建一个空目录"><a href="#③mkdir-英语全文：make-directories。创建一个空目录" class="headerlink" title="③mkdir 英语全文：make directories。创建一个空目录"></a>③mkdir 英语全文：make directories。创建一个空目录</h4><p>-p：递归创建一连串的新目录。  例子：mkdir -p a/b/c</p><hr><h5 id="④rmdir-英语全文：remove-empty-directories。-删除一个空的目录（只能删目录），如果目录有内容-如其他空目录-，就会报错。"><a href="#④rmdir-英语全文：remove-empty-directories。-删除一个空的目录（只能删目录），如果目录有内容-如其他空目录-，就会报错。" class="headerlink" title="④rmdir 英语全文：remove empty directories。 删除一个空的目录（只能删目录），如果目录有内容(如其他空目录)，就会报错。"></a>④rmdir 英语全文：remove empty directories。 删除一个空的目录（只能删目录），如果目录有内容(如其他空目录)，就会报错。</h5><p>（这个命令不常用，后续一般用rm命令） -p：递归删除</p><hr><h5 id="⑤touch-英语全文：change-file-timestamps。-触摸，如果文件不存在，创建一个空文件。如果已存在，修改文件的时间戳。"><a href="#⑤touch-英语全文：change-file-timestamps。-触摸，如果文件不存在，创建一个空文件。如果已存在，修改文件的时间戳。" class="headerlink" title="⑤touch 英语全文：change file timestamps。 触摸，如果文件不存在，创建一个空文件。如果已存在，修改文件的时间戳。"></a>⑤touch 英语全文：change file timestamps。 触摸，如果文件不存在，创建一个空文件。如果已存在，修改文件的时间戳。</h5><p>访问时间：Access  数据修改时间：Modify  状态修改时间：Change<br>-a：只修改文件的访问时间<br>-m：只修改文件的数据修改时间<br>-c：<del>只修改状态修改时间</del> 如果文件不存在，不创建新文件。（没有只修改状态修改时间的功能！）<br>-d：把文件时间修改为指定的时间，而非当前时间<br>（注意，不要把touch用作新建文件的命令）</p><hr><h5 id="⑥stat-英语全文：display-file-or-file-system-status。显示文件或文件系统的详细信息"><a href="#⑥stat-英语全文：display-file-or-file-system-status。显示文件或文件系统的详细信息" class="headerlink" title="⑥stat 英语全文：display file or file system status。显示文件或文件系统的详细信息"></a>⑥stat 英语全文：display file or file system status。显示文件或文件系统的详细信息</h5><p>stat [选项] 文件名或目录名（必须要指定第二个参数）<br>-f:查看文件所在的文件系统信息，而不是查看文件的信息<br>改变三种时间的命令：<br>cat：改变Access Time<br>echo：写入数据，改变Modify Time， Change Time<br>chown： 改变文件所有者。 改变Change Time<br>touch：三种都改（不使用选项时）</p><hr><h5 id="⑦cat-英语全文：concatenate-files-and-print-on-the-standard-output。连接文件并打印输出到标准输出"><a href="#⑦cat-英语全文：concatenate-files-and-print-on-the-standard-output。连接文件并打印输出到标准输出" class="headerlink" title="⑦cat 英语全文：concatenate files and print on the standard output。连接文件并打印输出到标准输出"></a>⑦cat 英语全文：concatenate files and print on the standard output。连接文件并打印输出到标准输出</h5><p>-A：列出所有隐藏符号(all)<br>-E:列出每行结尾的回车符$ (end)<br>-n:显示行号<br>-T:显示出Tab键 ^|<br>-v:列出所有特殊字符         （即-A &lt;==&gt; -vET）<br>(不论文件内容有多少，都会一次性显示，如果文件太大，上面部分不会显示完全。cat不适合查看太大的文件，有其他命令)</p><hr><h5 id="⑧：more-英语全文：file-perusal-filter-for-crt-view-in。分屏显示文件内容"><a href="#⑧：more-英语全文：file-perusal-filter-for-crt-view-in。分屏显示文件内容" class="headerlink" title="⑧：more 英语全文：file perusal filter for crt view in。分屏显示文件内容"></a>⑧：more 英语全文：file perusal filter for crt view in。分屏显示文件内容</h5><p>常用快捷键：  空格：向下翻页。  b：向上翻页。  回车键：向下滚动一行<br>/字符串： 搜索指定的字符串。  q：退出<br>?:对于这种持续性命令（more，top等），显示各种可执行操作（即help）</p><hr><h5 id="⑨：head-英语全文：output-the-first-part-of-files。显示文件开头的几行"><a href="#⑨：head-英语全文：output-the-first-part-of-files。显示文件开头的几行" class="headerlink" title="⑨：head 英语全文：output the first part of files。显示文件开头的几行"></a>⑨：head 英语全文：output the first part of files。显示文件开头的几行</h5><p>-n 行数：显示前[行数]几行（n与行数之间，有无空格均可） 行数默认为10<br>-v：显示文件名（被head操作的文件）<br>注意： -行数 &lt;==&gt; -n 行数。即： head -n 20 .bash_history &lt;==&gt; head -20 .bash_history</p><hr><h5 id="⑩：tail-英语全文：output-the-last-part-of-files。显示文件结尾内容"><a href="#⑩：tail-英语全文：output-the-last-part-of-files。显示文件结尾内容" class="headerlink" title="⑩：tail 英语全文：output the last part of files。显示文件结尾内容"></a>⑩：tail 英语全文：output the last part of files。显示文件结尾内容</h5><p>-n 行数：显示最后[行数]几行。同样默认为10，与head用法一致<br>-f：监听文件新增内容。使用时，光标会一直存在，当其他终端向该文件追加一些数据时，该命令会监视出来。</p><hr><h5 id="11：-ln-英语全文：make-links-between-file。在文件之间建立链接。-ln-选项-源文件-目标文件"><a href="#11：-ln-英语全文：make-links-between-file。在文件之间建立链接。-ln-选项-源文件-目标文件" class="headerlink" title="11： ln 英语全文：make links between file。在文件之间建立链接。 ln[选项] 源文件 目标文件"></a>11： ln 英语全文：make links between file。在文件之间建立链接。 ln[选项] 源文件 目标文件</h5><p>-s:建议软链接（默认是硬链接）<br>-f：如果目标文件已存在，删除目标文件后再建立链接文件<br>如果：目标文件没有文件名（即是一个目录），那么新建的文件名跟源文件名一致。<br>ln /root/a /tmp/ &lt;==&gt; ln /root/a /tmp/a   此时/root/a与/tmp/a是硬链接<br>（注意：硬链接没有其他要求，但如果建立软链接，那么源文件必须写绝对路径，不能是相对路径）<br>硬链接：两个文件的iNode相同，其一修改，另一个都会修改。但其中之一删除，iNode文件仍然能访问<br>      （不能跨文件系统(分区），因为不同分区的iNode值重新计算，而且不能链接目录) （不常用）<br>软链接：创建一个新的目标文件，iNode不同，指向源文件（相当于快捷方式）<br>ll查看软链接文件时，权限开头的l表示：软链接。 文件名 -&gt; 指向源文件<br>（软链接可以链接目录，而且可以跨分区）<br>软链接的block写的不是真正的数据，而仅仅是源文件的文件名及iNode号。删除掉软链接，源文件不受影响。删除掉源文件，软连接会失效。但如果改变软链接，那么源文件也会被修改。</p><hr><h5 id="12：rm-英语全文：remove-files-or-directories。删除文件-目录"><a href="#12：rm-英语全文：remove-files-or-directories。删除文件-目录" class="headerlink" title="12：rm 英语全文：remove files or directories。删除文件/目录"></a>12：rm 英语全文：remove files or directories。删除文件/目录</h5><p>-f：强制删除(force)<br>-i：交互删除（删前会询问，默认就是-i）<br>-r：递归删除，可以删除目录（加了-r才可以删目录）（逐层，直到最底层，逐层删除，逐个询问）<br>rm -rf：递归删除，不询问，强制。<br>（传说中的： rm -rf / ,删除所有，强制执行！）</p><hr><h5 id="13：cp-英语全文：copyfiles-and-directories。复制文件和目录。-cp-选项-源文件-目的文件"><a href="#13：cp-英语全文：copyfiles-and-directories。复制文件和目录。-cp-选项-源文件-目的文件" class="headerlink" title="13：cp 英语全文：copyfiles and directories。复制文件和目录。  cp[选项] 源文件 目的文件"></a>13：cp 英语全文：copyfiles and directories。复制文件和目录。  cp[选项] 源文件 目的文件</h5><p>-d：如果源文件是软链接，那么目的文件也为软链接（如果不指定，复制的会是源文件）。对硬链接无效<br>-p：保留源文件的属性（所有者，所属组，权限，时间）<br>-r：递归复制，用于目录<br>-a：相当于 -dpr<br>-i：询问，如果目标文件已经存在，询问是否覆盖<br>-l：将目标文件建立为源文件的硬链接，而不是复制源文件<br>-s：……建立为软链接<br>（复制文件时，如果目标’是一个目录，即没有指定文件名，则不改名复制，否则会改名）<br>（执行cp命令后，目标文件的时间会更改为命令的执行时间，而非源文件的时间。用-p或者-a可以解决）</p><hr><h5 id="14：-mv-英语全文：-move-rename-files-移动文件或者改名。-mv-选-源-目’"><a href="#14：-mv-英语全文：-move-rename-files-移动文件或者改名。-mv-选-源-目’" class="headerlink" title="14： mv 英语全文： move(rename) files 移动文件或者改名。  mv[选] 源 目’"></a>14： mv 英语全文： move(rename) files 移动文件或者改名。  mv[选] 源 目’</h5><p>-f:强制覆盖，如果已存在，直接覆盖<br>-i：交互。……。询问（默认为-i,即mv &lt;==&gt; mv -i）<br>-n:如果已存在，不覆盖<br>-v：显示移动过程<br>（如果要覆盖的是一个非空目录，则无法覆盖。即便是-f也不可以）<br>改名操作：如果源’和目’在同一路径，则为改名操作。 mv mytmp1 mytmp2</p><hr><h5 id="15：man-英语全文：format-and-display-the-online-manual-pages。帮助手册-man-选项-命令"><a href="#15：man-英语全文：format-and-display-the-online-manual-pages。帮助手册-man-选项-命令" class="headerlink" title="15：man 英语全文：format and display the online manual pages。帮助手册   man [选项] 命令"></a>15：man 英语全文：format and display the online manual pages。帮助手册   man [选项] 命令</h5><p>-f：查看命令拥有哪个级别的帮助<br>-k：查看和命令相关的所有帮助<br>快捷键：上，下，pageUp，pageDown  g：第一页  G：最后一页   q：quit<br>/str:所有str   ?str:向上搜索str   n：搜下一个str<br>N：如果是/str 切换成 ?str ,如果是?str,切换成 /str<br>例子：man -f passwd 有 passwd(1), passwd(5)<br>      那么：man 1 passwd =&gt; passwd(1)<br>其他：whatis &lt;==&gt; man -f<br>apropos  &lt;==&gt; man -k<br>想知道命令在哪：whereis   想知道当前用户是谁： whoami</p><hr><h5 id="16：info-同样是帮助，但是是一份完整详细的电子书"><a href="#16：info-同样是帮助，但是是一份完整详细的电子书" class="headerlink" title="16：info  同样是帮助，但是是一份完整详细的电子书"></a>16：info  同样是帮助，但是是一份完整详细的电子书</h5><hr><h5 id="17：help-只用户获取Shell内置命令的帮助，不常用"><a href="#17：help-只用户获取Shell内置命令的帮助，不常用" class="headerlink" title="17：help  只用户获取Shell内置命令的帮助，不常用"></a>17：help  只用户获取Shell内置命令的帮助，不常用</h5><p>如：ls是外部命令。 help ls，会报错。<br>但绝大多数命令可用 –help获取帮助。  例子： ls –help（输出man的简化版）</p><hr><h5 id="18：whereis-只能搜索命令，不能索索普通文件"><a href="#18：whereis-只能搜索命令，不能索索普通文件" class="headerlink" title="18：whereis  只能搜索命令，不能索索普通文件"></a>18：whereis  只能搜索命令，不能索索普通文件</h5><p>-b：只查找二进制命令<br>-m：只查找帮助文档（命令的帮助文档）</p><hr><h5 id="19：which-英语全文：shows-the-full-path-of-shell-commands。列出命令所在路径，如果该命令有别名，则同时显示出别名命令"><a href="#19：which-英语全文：shows-the-full-path-of-shell-commands。列出命令所在路径，如果该命令有别名，则同时显示出别名命令" class="headerlink" title="19：which 英语全文：shows the full path of shell commands。列出命令所在路径，如果该命令有别名，则同时显示出别名命令"></a>19：which 英语全文：shows the full path of shell commands。列出命令所在路径，如果该命令有别名，则同时显示出别名命令</h5><p>如： which mv =&gt; alias mv = ‘mv -i’ /usr/bin/mv<br>which ll =&gt; alias ll = ‘ls -l –color=auto’ /usr/bin/ls</p><hr><h5 id="20-locate-英语全文-find-files-by-name。按照文件名搜索文件"><a href="#20-locate-英语全文-find-files-by-name。按照文件名搜索文件" class="headerlink" title="20: locate 英语全文: find files by name。按照文件名搜索文件"></a>20: locate 英语全文: find files by name。按照文件名搜索文件</h5><p>只能根据文件名搜索，但是因为locate并不是搜索硬盘空间，而是先建立locate数据库，然后在数据库中搜索，因此：搜索速度快，耗费的系统资源非常小。<br>-i:忽略大小写（ignore）<br>例子：locate mkdir 会搜索出包含mkdir字符串的文件名，当然也包括mkdir命令<br>ps：locate数据库并不会实时更新，而是等用户退出登录或者重启系统时才会更新（因此新创建的文件无法立刻locate查到）<br>locate数据库位置： ll /var/lib/mlocate/mlocate.db (二进制文件)<br>命令： updatedb ： 可以即时更新一次locate数据库（这样可以locate到新文件。命令执行需要一定时间，要等待）<br>同时，部分文件类型或目录，并不会放到locate数据库中，如：<br>光盘，网盘，临时目录等（要么不在Linux系统中，是外来存储的网络存储的，要么是系统的缓存和临时文件，如/tmp下的文件，此时updatedb也没用）</p><hr><h5 id="21：-find-英语全文：search-for-files-in-a-directory-hierarchy。在目录中查找文件。"><a href="#21：-find-英语全文：search-for-files-in-a-directory-hierarchy。在目录中查找文件。" class="headerlink" title="21： find 英语全文：search for files in a directory hierarchy。在目录中查找文件。"></a>21： find 英语全文：search for files in a directory hierarchy。在目录中查找文件。</h5><p>不仅可按照文件名搜索，还可按照权限，大小，时间，iNode号等来搜索文件<br>（find是在硬盘中进行搜索的，如果指定的搜索范围过大，就会消耗较大的系统资源）<br>语法： find 搜索路径 [选] 搜索内容     （如果路径设定为 /, 那么执行起来就会很慢）<br>如果无选项，则将路径下的所有文件都输出。<br>-name：按照文件名搜索<br>-iname：按文件名，切不区分大小写<br>-inum：按照iNode号搜索<br>（如果是按照文件名。必须是完全匹配才会列出，如： find /root -name a123  此时只会列出名为a123的文件。如果是locate，会列出a123，还可能列出a12345，vca123等）<br>-size[+-] 大小:按文件大小搜索。 +-表示是比[大小]的数字还要大，还是小<br>例：find . -size +25k  当前目录下，大于25k的文件<br>（-size与后续的+或-，要有空格，而 +/-与大小之间无空格，k必须是小写(kb）)<br>千字节(kb)必须用小写k，兆字节(MB)必须用大写M，GB用大写G。<br>如果不写单位，默认单位并不是字节b，而是512byte，即半个kb。<br>如果单位要指定为字节，要用小写c。双字节要用小写w<br>-atime [+-] 时间：根据Access Time。。。  -mtime：…… -ctime：……<br>例子：find . -mtime -5 : 5天内修改的文件。   5：前5~6，这一天内修改的  +5：6天前修改的<br>同时还有amin，mmin，cmin，单位是分钟（time单位是天）<br>按权限： -perm 数字， -perm -数字， -perm +数字<br>按所有者和所属组： -uid 用户id， -gid 用户组id， -user 用户名， -gid 组名， -nouser（没有所有者）<br>例子：find . -user root 所有者是root的文件<br>按文件类型：-type d 查目录  -type f 查普通文件  -type l 查软链接</p><p>逻辑运算符：-a 与 ， -o 或 ， -not 非<br>例子：find . -size +2k -a -type f   (大于2kb且是普通文件)<br>      find . -name cangls -o -name bols (文件名是cangls或bols)<br>      find . -name a55 -o -size +3k(文件名为a55或者size大于3kb)<br>      find . -not -name cangls(文件名不为cangls)</p><p>find 路径 [选项] 内容 -exec 命令2 {} ;<br>指将find获取的结果放入{}中，再由命令2执行。<br>例：find . -size +2k -exec ls -l {} ;<br>获取size大于2kb的文件，并进行ls -l命令<br>PS：命令2与’{‘必须有空格,’}’和’&#39;之间也必须有空格。<br>而且此处不能-exec ll，推测不能用alias。<br>-ok选项：与-exec基本一致，不过操作前询问一次y/n</p><hr><h5 id="22-zip-英语全文-package-and-compress-files-压缩文件或目录"><a href="#22-zip-英语全文-package-and-compress-files-压缩文件或目录" class="headerlink" title="22: zip 英语全文:package and compress files.压缩文件或目录"></a>22: zip 英语全文:package and compress files.压缩文件或目录</h5><p>语法： zip [选项] 压缩包名 源文件或目录<br>-r： 压缩目录<br>可以同时压缩多个文件，用空格分开即可。<br>如果已经有同名压缩包，会进行覆盖。如果资源名也是相同，会updating，否则是adding。（压缩包会放在当前路径下）</p><hr><h5 id="23：unzip-英语全文：list-test-and-extract-compressed-files-in-a-ZIP-archive-列举，测试和提取压缩文件中的文件。"><a href="#23：unzip-英语全文：list-test-and-extract-compressed-files-in-a-ZIP-archive-列举，测试和提取压缩文件中的文件。" class="headerlink" title="23：unzip 英语全文：list,test and extract compressed files in a ZIP archive.列举，测试和提取压缩文件中的文件。"></a>23：unzip 英语全文：list,test and extract compressed files in a ZIP archive.列举，测试和提取压缩文件中的文件。</h5><p>-d: 指定解压位置<br>例子： unzip -d /root/mytmp3 mytest.zip</p><hr><h5 id="24-gzip-英语全文-compress-or-expand-files-压缩或解压文件-目录"><a href="#24-gzip-英语全文-compress-or-expand-files-压缩或解压文件-目录" class="headerlink" title="24: gzip 英语全文:compress or expand files.压缩或解压文件/目录"></a>24: gzip 英语全文:compress or expand files.压缩或解压文件/目录</h5><p>语法：gzip file1 压缩file1，生成file1.gz（源文件会消失）<br>-c: 将压缩数据输出到标准输出中，保留源文件（可用 &gt; 将输出重定向到一个文件中，这样既可以压缩，又不让源文件消失）<br>例子：gzip -c a123 &gt; a123.gz<br>-r:压缩目录（递归地将目录下的文件分别压缩成xxx.gz）<br>-d:解压（将压缩文件恢复原样）<br>-v:显示压缩文件信息（压缩比）<br>-数字：指定压缩等级，-1等级最低，压缩比最差，-9最高。默认为-6<br>PS：解压时，gzip -d abc &lt;=&gt; gzip -d abc.gz(即前者abc会自动寻找abc.gz文件)<br>文件太小时，压缩等级不同，压缩比也可能相同。</p><hr><h5 id="25：gunzip-解压。-gunzip-lt-gt-gzip-d"><a href="#25：gunzip-解压。-gunzip-lt-gt-gzip-d" class="headerlink" title="25：gunzip 解压。 gunzip &lt;=&gt; gzip -d"></a>25：gunzip 解压。 gunzip &lt;=&gt; gzip -d</h5><p>gunzip a123操作的同样是a123.gz，即 gunzip a123 &lt;=&gt; gunzip a123.gz<br>解压目录： gunzip -r（将目录下的压缩文件解压，但不会解压打包）<br>如果压缩文件是纯文本，用zcat可以在不解压的情况下查看文本内容</p><hr><h5 id="26：-bzip2-bz2格式文件的压缩命令（-bz2格式的算法理论上更好，及压缩比更好，但-gz更快）"><a href="#26：-bzip2-bz2格式文件的压缩命令（-bz2格式的算法理论上更好，及压缩比更好，但-gz更快）" class="headerlink" title="26： bzip2 .bz2格式文件的压缩命令（.bz2格式的算法理论上更好，及压缩比更好，但.gz更快）"></a>26： bzip2 .bz2格式文件的压缩命令（.bz2格式的算法理论上更好，及压缩比更好，但.gz更快）</h5><p>-d:解压<br>-k:压缩时保留源文件<br>-v:显示压缩信息 -数组：压缩等级<br>（gzip不支持打包目录，-r也只是分别压缩目录下的每个文件，而bzip根本不支持压缩目录，也没有-r选项）</p><hr><h5 id="27-bunzip2-等同bzip2-d-解压"><a href="#27-bunzip2-等同bzip2-d-解压" class="headerlink" title="27: bunzip2  等同bzip2 -d 解压"></a>27: bunzip2  等同bzip2 -d 解压</h5><p>-k：保留压缩文件<br>值得注意的是，一定要写明.bz2后缀，即 bunzip a ≠ bunzip a.bz2 , bzip -d同理。<br>如果是纯文本，用bzcat可以在不解压时查看文本内容。</p><hr><h5 id="28：tar-打包-解打包命令-语法：-tar-选项-f-压缩包名-源文件或目录"><a href="#28：tar-打包-解打包命令-语法：-tar-选项-f-压缩包名-源文件或目录" class="headerlink" title="28：tar 打包/解打包命令   语法： tar[选项][-f 压缩包名] 源文件或目录"></a>28：tar 打包/解打包命令   语法： tar[选项][-f 压缩包名] 源文件或目录</h5><p>-c：打包<br>-f：指定压缩包的文件名（写清后缀）<br>-v：显示打包过程<br>例子： tar -cvf test.tar /root/mytmp2<br>-x: 解压打包<br>-t：测试，即不解压，只是看包中有哪些文件<br>-C：指定解压位置。<br>解压与打包的区别： -xvf 与 -cvf       测试： -tvf<br>可以先tar，再gzip或bzip2，获得 .tar.gz 或者 .tar.bz2的格式<br>也可以一步到位： -z：压缩或者解压.tar.gz格式     -j：压缩或者解压.tar.bz2格式<br>例子： tar -zxvf a.tar.gz 解压<br>       tar -jcvf b.tar.bz2 /tmp/   压缩，压缩包的文件名为 b.tar.bz2<br>常用： -zcvf , -jcvf , -zxvf , -jxvf</p><hr><h5 id="29-sync-英语全文-flush-file-system-buffers-刷新文件系统缓冲区"><a href="#29-sync-英语全文-flush-file-system-buffers-刷新文件系统缓冲区" class="headerlink" title="29: sync 英语全文:flush file system buffers. 刷新文件系统缓冲区"></a>29: sync 英语全文:flush file system buffers. 刷新文件系统缓冲区</h5><p>作用：将内存中的数据强制向硬盘中保存，避免宕机导致数据丢失（该命令在常规关机时会自动执行） 直接执行，无须任何选项</p><hr><h5 id="30：-shutdown-英语全文：bring-the-sytem-down-关机和重启-执行权限：超级用户"><a href="#30：-shutdown-英语全文：bring-the-sytem-down-关机和重启-执行权限：超级用户" class="headerlink" title="30： shutdown 英语全文：bring the sytem down 关机和重启   执行权限：超级用户"></a>30： shutdown 英语全文：bring the sytem down 关机和重启   执行权限：超级用户</h5><p>格式： shutdown [选项] 时间 [警告信息]<br>-c：取消已经执行的shutdown命令 shutdown -c<br>-h： 关机   -r：重启<br>shutdown -h now    #现在立刻关机<br>shutdown -h 05:30   （当天的5：30关机，如果时间已过，就是第二天的5：30）<br>shutdown -h 05:30 &amp; (命令会一直占用前端)<br>其他关机重启命令： reboot重启， halt 或者 poweroff ， init 0 关机 ，  init 6 重启 （还是建议用shutdown）</p><hr><h5 id="31：setup-系统配置工具，配置IP，网卡，防火墙等（Red-Hat专有命令）"><a href="#31：setup-系统配置工具，配置IP，网卡，防火墙等（Red-Hat专有命令）" class="headerlink" title="31：setup  系统配置工具，配置IP，网卡，防火墙等（Red Hat专有命令）"></a>31：setup  系统配置工具，配置IP，网卡，防火墙等（Red Hat专有命令）</h5><hr><h5 id="32：ifconfig-查看IP地址信息（也可配置网络接口）-（windows是ipconfig）"><a href="#32：ifconfig-查看IP地址信息（也可配置网络接口）-（windows是ipconfig）" class="headerlink" title="32：ifconfig 查看IP地址信息（也可配置网络接口） （windows是ipconfig）"></a>32：ifconfig 查看IP地址信息（也可配置网络接口） （windows是ipconfig）</h5><p>inet addr：IP地址            netmask：子网掩码<br>broadcast：广播地址/MAC地址/局域网，以太网，物理地址</p><hr><h5 id="33：-ping-向网络主机发送ICMP请求，测试网络中主机的通信情况-ping-选-IP地址"><a href="#33：-ping-向网络主机发送ICMP请求，测试网络中主机的通信情况-ping-选-IP地址" class="headerlink" title="33： ping 向网络主机发送ICMP请求，测试网络中主机的通信情况         ping [选]IP地址"></a>33： ping 向网络主机发送ICMP请求，测试网络中主机的通信情况         ping [选]IP地址</h5><p>-b：后面加入广播地址，对整个网段进行探测<br>-c 次数：指定ping的次数（中间有无空格均可。如果不指定，会一直ping）<br>-s 字节：指定探测包的大小</p><hr><h5 id="34：netstat-网络状态查看命令，可以看到本机开放的端口，也可看有哪些客户端连接"><a href="#34：netstat-网络状态查看命令，可以看到本机开放的端口，也可看有哪些客户端连接" class="headerlink" title="34：netstat 网络状态查看命令，可以看到本机开放的端口，也可看有哪些客户端连接"></a>34：netstat 网络状态查看命令，可以看到本机开放的端口，也可看有哪些客户端连接</h5><hr><h5 id="35：write-英语全文：send-a-message-to-another-user-向其他用户发送信息"><a href="#35：write-英语全文：send-a-message-to-another-user-向其他用户发送信息" class="headerlink" title="35：write 英语全文：send a message to another user 向其他用户发送信息"></a>35：write 英语全文：send a message to another user 向其他用户发送信息</h5><hr><h5 id="36-mail-英语全文：send-and-receive-Internet-mail-发送和接受电子邮件"><a href="#36-mail-英语全文：send-and-receive-Internet-mail-发送和接受电子邮件" class="headerlink" title="36: mail 英语全文：send and receive Internet mail. 发送和接受电子邮件"></a>36: mail 英语全文：send and receive Internet mail. 发送和接受电子邮件</h5><p>ctrl + c 和 ctrl + z的区别：<br>c是强制中断程序的执行，此时进程就会终止。<br>而z是讲任务终止（暂停），但进程并没有结束，只是被挂起。用户可用fg/bg继续前台或后台的任务</p><hr><hr><p>其他常用命令：（选项参数略）<br><strong>①top</strong>  查看系统的整体运行情况（相当于任务管理器）</p><p>*<em>②df *</em> 显示磁盘空间使用情况</p><p>*<em>③du *</em> 对文件和目录磁盘使用空间的情况</p><p><strong>④date</strong> 当前日期和时间<br>例子：将当前时间写入文件：  date &gt; cangls   如果是 echo date &gt; cangls ,写入cangls文件的会是字符串“date”<br>(&gt; , &lt; 用作输出重定向，echo为显示命令，显示后重定向，就是写操作)</p><p><strong>⑤ps</strong> 列出当前系统的进程状态  ps -ef   第一个数字是 PID，进程ID。 第二个数字是PPID，父进程的ID</p><p><strong>⑥kill</strong>  删除，终止程序。  （kill -数字）<br>kill -1： 终端断线<br>kill -2：中断（同ctrl + c）<br>kill -9: 强制终止<br>……<br>（只有9才可无条件终止进程，其他信号，进程有权利忽略。。）</p><p><strong>⑦grep</strong> 文本搜索，用正则表达式搜索，匹配文本<br>-i：忽略大小写  -n：所在行数<br>管道符： |   将两个命令分隔开，前一个的stdout（输出）作为下一个的stdin（输入）<br>例子： ps -ef | grep ping 查找包含ping的进程</p><p><strong>⑧awk sed grep</strong> 文本处理。</p><p><strong>⑨free</strong> 显示系统内存使用情况，包括物理内存，交换区内存（SWAP），内核缓冲区内存。</p><p><strong>⑩clear</strong>  清屏  vim：进行vim文本编辑器</p><p>11： <strong>rpm</strong>  安装RPM包。  rpm -ivh 包全名  -i：install  -v：显示详细信息verbose  -h：打印，显示安装进度hash<br>-e：卸载。   rpm -e 包名</p><p>12：启动服务等： <strong>service</strong> 服务名 start | stop | restart | status<br>                <strong>systemctl</strong> start | stop | restart | status 服务名</p><p>13：<strong>yum命令</strong>  下载相应的rpm包并安装，解决了依赖关系<br>yum list: 列出可安装，已安装的包<br>yum search: 从yum镜像源服务器上查找与关键字相关的所有软件包<br>yum info： 查询执行软件包的详细信息（大小，版本，证书，描述等）<br>yum install：安装  -y：自动回答yes<br>（用yum卸载软件包时，会把依赖包也同时卸载，包括系统允许的必备文件，此时的结果就是，系统崩溃。所以一般不要用yum卸载软件包）</p><p>gcc编译器， make：完成对源码包的自动编译    make install：将编译文件进行安装</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;​        此文用于记录一些常用的Linux命令。主要记录每一个命令的作用，参数的作用。&lt;/p&gt;
&lt;h4 id=&quot;①ls-英语全文：list。列出目录下的文件。-语法：-ls-选项-文件名或目录名&quot;&gt;&lt;a href=&quot;#①ls-英语全文：list。列出目录下的文件。-语法：-ls-选项-文件名或目录名&quot; class=&quot;headerlink&quot; title=&quot;①ls  英语全文：list。列出目录下的文件。  语法： ls [选项] [文件名或目录名]&quot;&gt;&lt;/a&gt;①ls  英语全文：list。列出目录下的文件。  语法： ls [选项] [文件名或目录名]&lt;/h4&gt;&lt;p&gt;-a：显示所有文件    –color=when(颜色输出。默认为always。 never：从不  auto：自动)&lt;br&gt;-d：显示目录信息，而非文件&lt;br&gt;-h：文件大小显示为k，M,G&lt;br&gt;-i：显示iNode&lt;br&gt;#####-l：长格式显示（ &lt;strong&gt;ll &amp;lt;==&amp;gt; ls -l&lt;/strong&gt;）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://hongscar.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://hongscar.cn/tags/Linux/"/>
    
  </entry>
  
</feed>
