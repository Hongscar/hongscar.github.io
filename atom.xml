<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hong&#39;s Blog</title>
  
  <subtitle>Like life,like coding</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hongscar.cn/"/>
  <updated>2020-02-17T04:00:53.254Z</updated>
  <id>https://hongscar.cn/</id>
  
  <author>
    <name>Hong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap源码阅读</title>
    <link href="https://hongscar.cn/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html"/>
    <id>https://hongscar.cn/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html</id>
    <published>2020-02-17T03:51:39.000Z</published>
    <updated>2020-02-17T04:00:53.254Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言："><a href="#一-前言：" class="headerlink" title="一. 前言："></a>一. 前言：</h3><p>​        在准备面试的过程中，发现HashMap源码是很常见的考点，于是进行了仔细的学习。以前都说读源码是快速提高Java水平的好途径，在阅读了HashMap的部分重要源码之后真的是深有体会，于是写下此篇文章做记录。具体内容包括，HashMap的构造方法，put，get方法，以及put&amp;get所需要的hash方法，还有扩容时所需要的resize方法。我们将对这几个方法的源码进行阅读，理解它的逻辑，以及一些巧妙的设计。</p><a id="more"></a><h3 id="二-HashMap原理："><a href="#二-HashMap原理：" class="headerlink" title="二. HashMap原理："></a>二. HashMap原理：</h3><p>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。<br><strong>常用的方法有</strong>：<br>构造方法，可以定义initialCapacity初始容量，factor负载因子。threshold = initialCapacity * factor<br>put，get，二者需要用到hash方法，也就是散列函数。<br>resize：放数组容量不足时，元素个数大于threshold时，就要扩容。<br>HashMap使用数组链表来存储数据（数组的每一项都是一个链表），JDK1.8开始，当链表的长度到达一定程度，就会把该链表转换成红黑树。</p><hr><h3 id="三-①-构造方法："><a href="#三-①-构造方法：" class="headerlink" title="三. ① 构造方法："></a>三. ① 构造方法：</h3><p>构造方法一共有4个：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_1.png" target="_blank" rel="noopener" title="HashMap构造方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_1.png" alt="HashMap构造方法" title="HashMap构造方法"></a><br>显然，第一个就是没有参数，此时会设置默认的负载因子factor。<br>对于第二个，实际上就是将float参数设置为默认的负载因子default_factor。<br>对于第四个，是传入一个Map对象进行初始化。我们重点看第三个构造方法：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_2.png" target="_blank" rel="noopener" title="第三个构造方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_2.png" alt="第三个构造方法" title="第三个构造方法"></a><br>前面的都是判断一下边界值，就省略了。<br>HashMap有几个关键的成员属性：<br><em>initialCapacity</em>：初始容量大小（数组大小，但后面会改变）<br><em>factor</em>：负载因子<br><em>threshold</em>：initialCapacity * factor（到达这个值的时候，哈希数组会扩容）<br>（初始化之后，后续用size表示哈希数组里的元素个数，当size超过threshold之后，扩容）<br>然后我们发现一行关键的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br></pre></td></tr></table></figure><p>点进入看<em>tableSizeFor</em>的函数逻辑：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_3.png" target="_blank" rel="noopener" title="tableSizeFor"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_3.png" alt="tableSizeFor" title="tableSizeFor"></a><br>可以看到这个方法的目的：<strong>returns a power of two size for the given target capacity</strong></p><p>也就是说，<strong>哈希数组的长度，永远是2的幂次方</strong>，至于为什么，请看后面的<strong>question1</strong>.<br>关于这个算法的逻辑，用下图可以说明：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_4.png" target="_blank" rel="noopener" title="tableSizeFor算法的逻辑"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_4.png" alt="tableSizeFor算法的逻辑" title="tableSizeFor算法的逻辑"></a><br>连续的n |= n &gt;&gt;&gt; 1, 2, 4, 8, 16，通过这样，最多可以让连续32位为1.不管capacity是多少，比如它是1011，减去1之后是1010，第一个不为0的位是第4位，那么这个算法会返回10000.<br>（这里的关键是<strong>或运算</strong>，因为第一位是1，1和任何数字进行或运算都为1，因此，n&gt;&gt;&gt;1，会使得n的前2位变为2，然后再执行n&gt;&gt;&gt;2，就是前4位，再执行n&gt;&gt;&gt;4，就是前8位。）如果数字没有那么高位，那么高位全是0，并且n&gt;&gt;&gt;x全部都为0，因而或运算为0，高位没有任何影响，看下图例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_5.png" target="_blank" rel="noopener" title="高位运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_5.png" alt="高位运算" title="高位运算"></a><br>这个算法，巧妙地通过了位运算，返回了一个不小于capacity 的最小2的幂次方。至于为什么要-1，是防止capacity已经是2的幂次方的情况，比如是10000，如果不减1，那么返回的将会是100000.减去1，使得初始的capacity改为1111（1111和1001，1101等都是一样的）。<br>以上的情况都是在capacity不为0的情况考虑的，而当capacity为0的时候，无论经过几次运算，都为0，那么最后的capacity将为1（最后有一个n+1的操作），所以也是符合预期结果的。<br>这样，我们就得到了一个2的幂次方的capacity，即哈希数组的长度（所以比如，当我们传入的capacity为12，最终生成的数组长度会是16.）<br>结果：<br> // 如果没有指定initialCapacity, 则不会给threshold赋值, 该值被初始化为0<br> // 如果指定了initialCapacity, 该值被初始化成不小于initialCapacity的最小的2的次幂</p><hr><h3 id="四-②put方法："><a href="#四-②put方法：" class="headerlink" title="四. ②put方法："></a>四. ②put方法：</h3><p>可以看到，put方法其实还有两个参数，但put方法并没有重载方法，所以如果我们需要改变后两个参数，应该使用putVal方法自己修改，但一般不需要，在下文看putVal的方法里我们就知道着两个参数是什么作用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**接下来关键是看putVal的方法实现：（逐行分析，中文注释）</p><p>**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">//创建一些后面需要的变量，略</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"><span class="comment">//如果哈希数组为空，即还没初始化，先resize一次，resize后面再看，这里只需要知道</span></span><br><span class="line"><span class="comment">//会创建一个默认长度的哈希数组即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//如果哈希数组该index没有元素，即没有发生碰撞，直接插入一个newNode即可。</span></span><br><span class="line"><span class="comment">//这里的(n - 1) &amp; hash的原理，查看后面的question2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//说明已经有元素，发生了碰撞，然后我们就沿着链表/红黑树去插入Node</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">//我们首先会查看第一个元素（在第一个元素时就能确定它是链表还是数组）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"><span class="comment">//这里的p是上文的p = tab[i = (n - 1) &amp; hash]，即第一个元素，如果第一个元素跟待插入</span></span><br><span class="line"><span class="comment">//的元素是相同的，即key相同（hash肯定是已经相同的了），然后我们只需要更改p的值</span></span><br><span class="line"><span class="comment">//即可。这里的逻辑是，把p赋值给新创建的Node e，然后跳出整个循环之后，再判断e</span></span><br><span class="line"><span class="comment">//是否位null，如果e为null，那么直接进行value的替换即可，否则，往后看。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="comment">//判断该index项是链表还是红黑树，如果是红黑树再进入putTreeVal，此处略</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//说明是链表，并且第一个元素也不相等，所以我们就遍历链表，然后插入到链表的最</span></span><br><span class="line"><span class="comment">//后，并且，如果链表长度过长，还会引起链表树化的操作。如果是整个数组的长度过</span></span><br><span class="line"><span class="comment">//大，那么还要对数组进行resize。（PS：这里的元素相等是指key，链表里的key都是互</span></span><br><span class="line"><span class="comment">//不相等的，只是它们发生hash冲突导致都放在数组的同一个index上。所以如果在中间</span></span><br><span class="line"><span class="comment">//发现了相同的key，那么就跟前面一样，其实也是e = p的逻辑，然后在后续直接覆盖</span></span><br><span class="line"><span class="comment">//value即可。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//p.next为null，那么直接将p.next新建一个newNode即可。即已经到达链表的最后。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line"><span class="comment">//这是指链表长度大于等于TREEIFY_THRESHOLD的时候，进行树化。默认是8.注意这</span></span><br><span class="line"><span class="comment">//里为什么是&gt;= THREIFY_THRESHOLD，看起来是7个就可以树化，但实际上还是8个</span></span><br><span class="line"><span class="comment">//的。具体的看后面的question4.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="comment">//如果遇到了相等的key，那么就是覆盖value。注意此时并未到链表的最后，所以这里的</span></span><br><span class="line"><span class="comment">//e不等于null。而上面的(e = p.next) == null，上面逻辑的e会是null。这个e后面马上用到</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line"><span class="comment">//这里的p = e实际上就是 p = p.next，因为并没有执行for循环里的两个if，如果执行了其</span></span><br><span class="line"><span class="comment">//中一个，都会直接break跳出循环。（个人觉得这个p = e放在for判定语句里可读性更好</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="comment">//这就是前面一直说的e，如果存在相同的key，那么e就不是null，此时直接覆盖value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">//这就是第三个参数，表示已有相同的key时是否更新。onlyIfAbsent默认是false，所以这</span></span><br><span class="line"><span class="comment">//里的if是一定会触发，即一定会覆盖value。如果手动将onlyIfAbsent改为true，那么就是</span></span><br><span class="line"><span class="comment">//只有当oldValue为null的时候，才能改变key的value，否则都不会改变。</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line"><span class="comment">//这个在HashMap是空方法，在LinkedHashMap的时候才会被重写并使用。</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="comment">//覆盖了value（或者不覆盖），就把oldValue返回，方法结束。因此插入一个相同key的</span></span><br><span class="line"><span class="comment">//元素，实际上是更新该key的value，方法的逻辑在这里已经完成，不会改变HashMap的</span></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//最外层的if-else循环结束</span></span><br><span class="line">    ++modCount;</span><br><span class="line"><span class="comment">//到达了这里，说明不存在相同的key，所以插入了一个新的key，改变modCount以及</span></span><br><span class="line"><span class="comment">//哈希数组的元素个数size</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line"><span class="comment">//如果改变了之后，哈希数组的元素个数大于threshold，此时发生碰撞的概率较大，因此</span></span><br><span class="line"><span class="comment">//进行resize，即对哈希数组进行扩容，后面会讲到。</span></span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">//同样是LinkedHashMap的东西，此处为空方法。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要是这么几个步骤：</strong><br>如果当前table为空，先进行初始化<br>查找插入的键值对是否存在，存在的话，先进行赋值，后续将更新旧的键值对<br>不存在，插入链表尾部，如果链表长度大于一个阈值，进行链表转化树的操作<br>如果size大于一个阈值，进行扩容<br>PS：threshold在初始化的时候，值为2的幂次方（在tableForSize那里可以看到），但threshold应该是capacity * factor，当size大于threshold的时候才执行resize。那么会不会因此而导致初始化的时候threshold并不受factor的影响？<br>（比如我们初始化的时候，capacity传参是10，factor是0.75，在tableForSize里，我们知道threshold会被赋值为不小于10的2的幂次方，即16.然后根据put的逻辑，应当是++size &gt; threshold的时候才扩容，那么初始化的threshold是16，而不是预期的值16 * 0.75 = 12？）<br>实际上并不是的，上面的threshold实际上就不应该是哈希数组的长度（所以JDK源码在构造方法里，把2的幂次方赋值给threshold确实有迷惑的意思）。在put方法的第一个步骤，即“如果当前table为空，先进行初始化”。那么我们再看一下这一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure><p>当table为空，那么要先resize，即数组是在这里才进行建立的。在resize里面，是把threshold赋值给了另一个叫newCap的变量（看变量名可知，显然就是新的哈希数组的长度），然后threshold又会被改变为newCap * factor。所以threshold虽然确实是2的幂次方，但确实并不是代表哈希数组的长度，仍然是作为扩容的判断点（<strong>虽然是个无聊的问题，但感觉是JDK源码的变量具有迷惑性！</strong>）至于resize的源码，继续看。</p><hr><h3 id="五-③get"><a href="#五-③get" class="headerlink" title="五. ③get"></a>五. ③get</h3><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_6.png" target="_blank" rel="noopener" title="get方法的源码"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_6.png" alt="get方法的源码" title="get方法的源码"></a><br>get方法显然简单很多。首先判断是否存在该key，如果不存在，返回null。<br>getNode的逻辑体也是比较简单，先查找第一个元素，看key值是否相等。至于为什么需要“always check first node”，显然，因为<strong>JDK1.8可能是链表，可能是红黑树，需要进行判断</strong>。<br>如果当第一个first就是相等的，那么就直接返回。如果不在，判断是否是红黑树，如果是，使用另一套逻辑，如果不是，就是简单的链表遍历，对比，e = e.next，应该很好理解，此处略。</p><hr><h3 id="六-④hash"><a href="#六-④hash" class="headerlink" title="六. ④hash"></a>六. ④hash</h3><p>首先给出<strong>HashMap计算哈希码的整体步骤</strong>：<br><em>1.获取key的hashCode</em><br><em>2.对hashCode进行处理（hash方法），主要是高16位不变，而低16位与高16位进行异或操作</em><br><em>3.对capacity进行取模（使用了 hash &amp; (n - 1)进行优化）</em><br>在put和get方法中，可以看到都需要对key进行hash运算：</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_7.png" target="_blank" rel="noopener" title="put方法的hash运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_7.png" alt="put方法的hash运算" title="put方法的hash运算"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_8.png" target="_blank" rel="noopener" title="get方法的hash运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_8.png" alt="get方法的hash运算" title="get方法的hash运算"></a></p><p>因为<strong>hashcode就是为了HashMap而生的</strong>，在学习重写equals时为何要重写hashCode的时候我们就已经知道了。那么HashMap里到底如何重写hashCode方法呢，如下：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_9.png" target="_blank" rel="noopener" title="HashMap中的hashCode方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_9.png" alt="HashMap中的hashCode方法" title="HashMap中的hashCode方法"></a><br>嗯。。。很简单的异或运算，结合了key和value的hashCode，没什么特别的。结合value同样是减少碰撞。这个就是步骤1.</p><p>那么接下来看一下步骤2，HashMap自定义的hash方法：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_10.png" target="_blank" rel="noopener" title="HashMap中自定义的hash方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_10.png" alt="HashMap中自定义的hash方法" title="HashMap中自定义的hash方法"></a><br>从逻辑上看，就是hash本身与hash右移16位的结果进行异或。<br>h &gt;&gt;&gt; 16的结果：高16位全部变成0，原本高16位的处于低16位。<br>h ^ ( h &gt;&gt;&gt; 16)的结果：<br>1.高16位不变。<strong>因为0与任何数进行异或，返回的都是那个数本身</strong>。0 ^ 1 = 1, 0 ^ 0 = 0<br>2.低16位于原本的高16位进行异或。<br>步骤3对capacity取模，很好理解，不能超出哈希数组的范围。第二步的意义何在？看<strong>question3</strong>.</p><hr><h3 id="七-⑤resize"><a href="#七-⑤resize" class="headerlink" title="七. ⑤resize"></a>七. ⑤resize</h3><p>在put的过程中，当size超出了threshold，那么就需要进行resize扩容。逻辑比较复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//oldCap表明，table里原本已经存在key-value</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">//如果oldCap都已经扩容到最大了，那么就直接将threshold设为最大值，只好任你碰撞</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line"><span class="comment">//没有超出最大值，那么就安心扩容为原来的 2倍。值得注意的是newCap跟newThr都扩</span></span><br><span class="line"><span class="comment">//容为 2倍，仔细看 if 语句的判定。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line"><span class="comment">//这个就是我们前面所说的，当初始化的时候，会将threshold仅仅作为一个变量赋值给</span></span><br><span class="line"><span class="comment">//newCap，然后后面又把newCap*factor赋值给threshold</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line"><span class="comment">//这里就是调用new HashMap( )的情况，一个构造参数也没有的时候，直接赋默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//当上面第一个if里面没有执行里面的两个子if语句时，newThr仍然没有变化，即为0.需要在这里再对threshold进行修改。</span></span><br><span class="line"><span class="comment">//（比如上面的： else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span></span><br><span class="line"><span class="comment">//                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)，此时newCap可能超出了MAX，那么</span></span><br><span class="line"><span class="comment">//newThr就仍然为0.又或者是 else if (oldThr &gt; 0)  newCap = oldThr;中，即初始化带int参数的时</span></span><br><span class="line"><span class="comment">//候，这里仍然没有对threshold进行赋值。）</span></span><br><span class="line"> <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"><span class="comment">//这段代码就是普通地判断threshold是否会超出MAX而已</span></span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"><span class="comment">//我们已经将新数组的各种参数（capacity，threshold等）都设置好了，接下来需要将原</span></span><br><span class="line"><span class="comment">//本的数组元素放入到新的哈希数组中。显然，因为这个操作，使得resize方法是一个极</span></span><br><span class="line"><span class="comment">//其耗费时间的方法，所以在大概知道元素个数的时候，不应该使用默认值16，而是显式</span></span><br><span class="line"><span class="comment">//定义HashMap的初始容量，减少resize次数，可以显著地提高效率</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//这里table中存放的只是Node的引用, 将oldTab[j]=null只是清除旧表的引用, 但是真正的</span></span><br><span class="line"><span class="comment">//node节点还在, 只是现在由e指向它。所以这里主要是提醒JVM，这里可以被GC清理了</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 如果该存储桶里面没有元素, 就直接将它放到新表的目标位置</span></span><br><span class="line">    </span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果是树，则根据红黑树的逻辑拆分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line"><span class="comment">// 不是红黑树，那么就是链表。因此我们需要把该链表放入新的哈希数组的位置。</span></span><br><span class="line"><span class="comment">//主要是获取整条链表（即使只有 1个元素，结构仍然是链表）。</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//设置了两个链表，原因是根据不同情况，插入到不同的链表，最后再根据结果赋值</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;<span class="comment">//第n位为0</span></span><br><span class="line"><span class="comment">// 我们知道hash &amp; (n - 1)就是原本的位置，那么hash &amp; n是什么？原本的哈希值为n - 1</span></span><br><span class="line"><span class="comment">//位，当它扩容之后，它的哈希值位n - 1或者n位，即第n位要么是0，要么是1，而</span></span><br><span class="line"><span class="comment">//hash &amp; n就是能获取第n位的值，在后面我们会解释为什么</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;<span class="comment">//第n位为1</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);<span class="comment">//此处do-while刚好使得循环至少执行1次</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;<span class="comment">//根据0还是1决定赋值哪个</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于resize的最后那一部分：<br>在JDK1.7之前，都是直接再计算一次hash，然后放入新的哈希数组位置（index,bucket）。<br>但在JDK1.8中，代码得到了改进，看一下官方注释：<br><strong><em>Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</em></strong><br>大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。（n - 1位哈希码，变成n - 1位或 n位）<br>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_11.png" target="_blank" rel="noopener" title="resize时hash位置的变化"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_11.png" alt="resize时hash位置的变化" title="resize时hash位置的变化"></a><br>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_12.png" target="_blank" rel="noopener" title="resize后index的变化"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_12.png" alt="resize后index的变化" title="resize后index的变化"></a><br>因此，<strong>我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</strong>可以看看下图为16扩充为32的resize示意图：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_13.png" target="_blank" rel="noopener" title="resize整个示意图"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_13.png" alt="resize整个示意图" title="resize整个示意图"></a><br>那么，<strong>为什么 hash &amp; n就是可以获得第n位的值呢？</strong><br>首先我们必须知道，n是一个2的幂次方数，它的二进制i形式是00……1000……<br>易知，0 &amp; x = 0，1 &amp; x = x，而我们就是想要hash值的第n位的x值。<br>因此，hash &amp; n，刚好就是取到了新的hash值的第n位的x值。<br>故得出结论:    （最后的if，else判断）<br>如果 (e.hash &amp; oldCap) == 0 则该节点在新表的下标位置与旧表一致都为 j<br>如果 (e.hash &amp; oldCap) == 1 则该节点在新表的下标位置 j + oldCap</p><hr><hr><h3 id="八-中间遗留出来的questions："><a href="#八-中间遗留出来的questions：" class="headerlink" title="八. 中间遗留出来的questions："></a>八. 中间遗留出来的questions：</h3><p><strong>question1：哈希数组的长度为什么需要是2的幂次方？</strong><br>ans：因为在映射的时候，需要执行(n - 1) &amp; hash，当n不为2的幂次方的时候，n的个位为1，(n - 1)的个位则为0，又因为0 &amp; x = 0，因此使得最后一位必定是0，即浪费了1个位的空间，碰撞的几率也会增大。而如果n是2的幂次方，那么(n - 1)的个位必定是1，1 &amp; x = x，即根据hash的个位来决定，而不是一定返回0，因此能降低碰撞几率，充分利用每一个位。</p><hr><p><strong>question2： （n - 1 ) &amp; hash的原理？</strong><br>ans：因为n是2的幂次方，因而(n - 1)的值位000……1111（若干个1.(n - 1) &amp; hash，即返回hash的低<br>⌈log2(n - 1)⌉ （2为底）位的值，即hash &amp; n。如下图：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_14.png" target="_blank" rel="noopener" title="hash &amp; (n - 1)"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_14.png" alt="hash &amp; (n - 1)" title="hash &amp; (n - 1)"></a><br>使用(n - 1) &amp; hash而不使用hash % n的好处：<br>位运算是计算机最快的运算，因此效率更高。同样因为n是2的幂次方，因而该算法也不会出现超出取模范围的错误。</p><hr><p><strong>question3：为什么要将低16位与高16位进行异或操作？</strong><br>ans：先看一下源码的代码注释：<br><strong><em>Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don’t benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</em></strong><br>设计者认为<strong>(n - 1) &amp; hash很容易发生碰撞</strong>，因为如果不对hash进行其他处理，那么hash起作用的仅仅是⌈log2(n - 1)⌉，比如当n为16的时候，hashCode起作用的仅仅是低4bit的有效位，那么当然容易碰撞了。因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是<strong>把高16bit和低16bit异或了一下</strong>。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。（即通过h ^ (h &gt;&gt;&gt; 16)，<strong>间接让高16位也参与计算，从而让键值对分布均匀，降低hash碰撞</strong>）</p><p>如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞<strong><em>(we use trees to handle large sets of collisions in bins)</em></strong>，在JEP-180中，描述了这个问题：<br><strong><em>Improve the performance of java.util.HashMap under high hash-collision conditions by using balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class.</em></strong><br>之前已经提过，在获取HashMap的元素时，基本分两步：<br>首先根据hashCode()做hash，然后确定bucket的index；<br>如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。<br>在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是<strong>O(1)+O(n)</strong>。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。<br>因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了<strong>O(1)+O(logn)</strong>了，这样在n很大的时候，能够比较理想的解决这个问题。</p><hr><p><strong>question4：为什么判定条件是”binCount &gt;= TREEIFY_THRESHOLD - 1”，但树化的条件仍然是bitCount &gt;= TREEIFY_THRESHOLD - 1?</strong><br>ans：这里：binCount &gt;= TREEIFY_THRESHOLD - 1，看起来是大于等于7就会树化，但其实并不是的。因为在刚执行完p.next = newNode(…);此时binCount仍然还没有执行完++。所以仍然是链表中元素的个数大于等于TREEIFY_THRESHOLD（默认是8），才会树化。<br>举例：当元素个数为1的时候，即只有p，此时binCount为0，然后执行p.next = newNode(…)。if判断失效，然后才执行binCount++（即添加完p.next之后，里面已经有k个元素了，但if判断的时候的binCount值为k - 1，只有到下一轮循环才改成k。<br>当链表一共有6个元素的时候，此时binCount为6（已经是下一轮循环），执行p.next = newNode,一共有7个元素。if判断（6 &lt; = 7)，所以不会树化，循环结束，binCount为7.然后下一轮循环，添加元素，为8，此时 7 &lt;= 7，为真，树化。<br>PS：Hash冲突是指不同对象的hashCode通过hash算法后得出了相同定位的下标，这时候采用链地址法，会将此元素插入至此位置链表的最后一位，形成单链表。当存在位置的链表长度 大于等于 8 并且当前数组容量超过64时，HashMap会将链表 转变为 红黑树，这里要说明一点，往往后者的条件会被大多数人忽略，当桶数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长。这个时候应该优先扩容，而不是立马树化。毕竟高碰撞率是因为桶数组容量较小引起的，这个是主因。容量小时，优先扩容可以避免一些列的不必要的树化过程。</p><hr><h3 id="九-其他一些常见问题："><a href="#九-其他一些常见问题：" class="headerlink" title="九. 其他一些常见问题："></a>九. 其他一些常见问题：</h3><p><strong>1. 什么时候会使用HashMap？他有什么特点？</strong><br>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p><p><strong>2. 你知道HashMap的工作原理吗？</strong><br>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。HashMap是非线程安全的，在多线程的操作下会存在异常情况，可以使用HashTable或者ConcurrentHashMap进行代替</p><p><strong>3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</strong><br>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p><p><strong>4. 你知道hash的实现吗？为什么要这样实现？</strong><br>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p><p><strong>5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong><br>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p><p><strong>6. JDK1.8之前，HashMap在并发的情况下会出现问题，比如同时put的时候甚至会引起死循环，导致CPU使用率100%，为什么？</strong><br>因为JDK1.8之前的resize方法是需要rehash的，导致在旧链表迁移到新链表的时候，如果在新链表的数组索引相同，会导致链表元素倒置，在JDK1.8中不需要rehash，直接根据新增的1bit是0还是1，决定是在原本位置还是增加capacity的位置，不会倒置。<br>而JDK1.8之前的transfer，以JDK1.7为例，当两个线程同时resize的时候，由于链表倒置，有可能出现循环链表的情况，导致无限循环，耗尽CPU算力。具体看这里：<a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a><br>HashMap是非线程安全的，在多线程的操作下会存在异常情况，比如类似于数据库的更新丢失（两个线程同时put，可能会导致其中一个put失效）。可以使用Hashtable或者ConcurrentHashMap进行代替。（Hashtable的效率太低，不推荐使用）<br>PS：回到本题的主干：存放数据时发现正在扩容会怎么样。<br>对于JDK1.7，应该就是同时resize，导致死循环。对于JDK1.8，则不会出现死循环。（1.7是头插法，导致会倒置，形成循环链表。而<strong>1.8增加了tail指针，使用尾插法</strong>，时间复杂度仍然是O(1)，但不会倒置，因而不会出现死循环。）。1.8中hashmap的确不会因为多线程put导致死循环，但是依然有其他的弊端，比如数据丢失等等。因此多线程情况下还是建议使用concurrenthashmap。</p><p>参考网站：<br><a href="https://segmentfault.com/a/1190000015812438" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015812438</a><br><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a><br><a href="https://juejin.im/post/5a7719456fb9a0633e51ae14" target="_blank" rel="noopener">https://juejin.im/post/5a7719456fb9a0633e51ae14</a><br><a href="https://juejin.im/post/5c7f69dff265da2dea054fdc" target="_blank" rel="noopener">https://juejin.im/post/5c7f69dff265da2dea054fdc</a><br><a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="noopener">https://blog.csdn.net/fan2012huan/article/details/51097331</a><br><a href="https://blog.csdn.net/zhuqiuhui/article/details/51849692" target="_blank" rel="noopener">https://blog.csdn.net/zhuqiuhui/article/details/51849692</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言：&quot;&gt;&lt;a href=&quot;#一-前言：&quot; class=&quot;headerlink&quot; title=&quot;一. 前言：&quot;&gt;&lt;/a&gt;一. 前言：&lt;/h3&gt;&lt;p&gt;​        在准备面试的过程中，发现HashMap源码是很常见的考点，于是进行了仔细的学习。以前都说读源码是快速提高Java水平的好途径，在阅读了HashMap的部分重要源码之后真的是深有体会，于是写下此篇文章做记录。具体内容包括，HashMap的构造方法，put，get方法，以及put&amp;amp;get所需要的hash方法，还有扩容时所需要的resize方法。我们将对这几个方法的源码进行阅读，理解它的逻辑，以及一些巧妙的设计。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://hongscar.cn/categories/Java/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁的判断</title>
    <link href="https://hongscar.cn/MySQL%E9%94%81%E7%9A%84%E5%88%A4%E6%96%AD.html"/>
    <id>https://hongscar.cn/MySQL%E9%94%81%E7%9A%84%E5%88%A4%E6%96%AD.html</id>
    <published>2020-02-17T03:50:57.000Z</published>
    <updated>2020-02-17T03:56:12.797Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>本文的最终解决的问题：<strong>如何判断一条SQL语句用到了哪些锁？</strong><br>（特别地，这里考虑的是<em>MySQL</em>数据库的锁机制）</p><p>首先，我们需要先对<em>MySQL</em>的事务机制，锁机制，索引机制都总结一遍。</p><a id="more"></a><hr><h3 id="二-事务隔离级别："><a href="#二-事务隔离级别：" class="headerlink" title="二. 事务隔离级别："></a>二. 事务隔离级别：</h3><p><strong>RU：Read UnCommitted<br>RC：Read Committed<br>RR：Repeatable Read （default）<br>Serializable</strong></p><p>总结：<br>RU可以读取未提交的数据，因此存在脏读的问题。<br>RC只能读取已经提交的数据，因而解决了脏读的问题，但存在不可重复读的问题<br>RR保证了可以重复读的问题。<br>RR与Serializable都解决了大部分的问题，因此默认就是RR。（当然，在需求高性能的情况下，会使用RC）</p><p>查看MySQL的隔离级别：<br>select @<a href="https://github.com/tx_isolation" target="_blank" rel="noopener">@tx_isolation</a> // 查看当前会话的事务隔离级别<br>select @<a href="https://github.com/global" target="_blank" rel="noopener">@global</a>.tx_isolation //查看系统全局的隔离级别<br>设置隔离级别：<br><em>set session/global transaction isolation level xx;</em><br>(xx can be <strong>read uncommitted, read committed, repeatable read, serializable</strong>)</p><hr><h3 id="三-锁机制："><a href="#三-锁机制：" class="headerlink" title="三. 锁机制："></a>三. 锁机制：</h3><p>MySQL锁的类型：（有多种分法）<br>①根据锁的兼容情况，可以分为4种：<br><strong><em>Shared locks，Exclusive locks</em></strong>（共享锁，排他锁，即S锁，X锁，在其他数据库也有这两种）<br><strong><em>Intention Locks</em></strong>：意向锁，分为共享意向锁IS，共享排他锁IX锁。（作用后续说，<strong>针对MySQL的行锁而出现</strong>）</p><p>②根据锁的锁定范围，可以分为三种：<br><strong><em>表锁 Table Locks，行锁 Record Locks，页锁 Page Locks</em></strong><br>（在MyISAM中为Table Locks，而在<strong>InnoDB中只有Record Locks</strong>。Page Locks存在于BerkeleyDB）<br>表锁和行锁的区别：<br><strong>表锁的开销较小，不会产生死锁，锁定范围大，但并发度最低<br>行锁的开销较大，可能产生死锁，锁定范围较小，并发度更高</strong><br>页锁此处不解释（我也不会）</p><p>③InnoDB下的Lock Type：<br>由于目前重点使用的MySQL引擎一般是InnoDB，因此对InnoDB进行更细致的了解。<br><strong>InnoDB的行级锁（InnoDB不存在表级锁，只是在特定情况下看起来像是表级锁的形式而已）：</strong><br><em>1.Record Locks：A record lock is a lock on an index record.</em> 即锁定一个index的record。<br><em>2.Gap Locks：A gap lock is a lock on a gap between index records, or a lock on the gap before the first or after the last index record.</em> 即锁定record之间的的间隙。<br>（Gap Locks存在于RR与Serializable，不存在于RC。RU一般不会用，不考虑，而且也没有）<br><em>3.Next-Key Locks:A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.(3 = 1 + 2)</em><br><del>PS：此处有一个小test，事务隔离级别是与系统全局的设置有关的（即使两个Session transaction isolation level都设置为RC，但如果Global transaction isolation level设置为RR，那么就按照RR的情况来执行，即此时存在Gap Locks。所以不清楚Session level有何作用）</del></p><hr><p>不同情况的加锁情况：<br>要考虑这个问题，先整理一些基础知识：</p><p><strong><em>①首先要了解锁之间的兼容性（S锁，X锁，IS锁，IX锁）：</em></strong></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_1.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_1.png" alt="MySQL中InnoDB引擎中锁的兼容性"></a><br>PS：这是<strong>仅限于Table-level的compatibility</strong>，网上传的很多都忽略了这个。</p><p><strong>关于意向锁：主要是用于解决行锁和表锁的冲突。</strong>试想一下，当事务A锁住了表中的一行（假设为S锁)，而事务B需要申请整个表的X锁。那么事务B需要做的事情：<br>1.判断表是否被其他表锁锁住（无论X,S），这个很简单.<br>2.判断表中的每一行是否被行锁锁住（无论X,S，因为X与二者均不兼容）。<br><strong>如果只有X,S锁，那么我们需要逐行检查，如果有1个亿的data，那么就需要查询1亿行。</strong><br>如果添加了意向锁呢？意向锁的作用方式：<br>当一个事务需要获取一个<strong>行锁</strong>的X锁，先获取一个IX锁。<br>当一个事务需要获取一个<strong>行锁</strong>的S锁，先获取一个IS锁。<br>（记住，<strong>上面的表格是仅限表锁的情况</strong>，如果需要获取表锁的X/S锁，那么不需要获取IX,IS锁。另外，<strong>IX,IS锁是数据库后台自动获取的，无须我们显式调用</strong>）<br>这个时候，当另一个事务，要申请X锁，第一步依然是判断是否被其他表锁锁住。<br>第二步就改成了，判断该表是否存在IX,IS锁。（如果存在IX，IS锁，说明该表存在X，S锁，不管是哪一行）<strong>仅仅通过判断是否存在意向锁，就省去了遍历所有行的操作。</strong><br>（PS：如果另一个事务要申请的是S锁，同样如此，只是不需要判断IS锁，而是判断IX锁）<br>记住：<strong>意向锁与表级的X锁不兼容，但与行级的X锁是兼容的</strong><br>（不然你先获取了IX锁，如何继续获取X锁呢？）</p><hr><p><strong><em>②数据库的并发控制协议</em></strong></p><p><em>MVVC：Multi-Version- Concurrency Control。</em>即基于多版本的并发控制协议。<br>它最大的好处：读操作不加锁，读写不冲突，可以极大地增强并发性。<br><em>Lock-Based Concurrency Control。</em>即基于锁的并发控制。<br>（如果我们每一种操作都需要获取lock，由lock来完全实现并发控制，那么并发性会相当地差。其实也就是相当于Serializable，完全串行化执行。所以<strong>现阶段，大部分的数据库都不会是完全的基于lock去实现并发控制，而是实现了MVVC模式</strong>）</p><p>在MVVC并发控制中，读操作可以分为两种；<strong>snapshot read</strong>(快照读）,<strong>current read</strong>(当前读）<br>所谓snapshot，就是系统在某一个时刻的印象，所以此时读取到的不一定是最新的数据，可能是某个历史版本的数据，那么这时候就不需要加锁。（因为本来就不一定是最新的数据，那么两次snapshot read不一致也是很正常的，所以怎么能算是脏读幻读呢（滑稽）！）<br>current read就不一样了，它就是要读取系统最新的数据，所以此时需要对读操作进行加锁，然后再基于Lock-Based去进行并发控制。</p><p><strong>在MySQL InnoDB中，snapshot read又称简单的select</strong>，一般形式为：<br>select <em>from table where ？; # 存在例外，后面分析<br>current read：<br>select</em> from table where ? lock in share mode || for update || for share(8.0之后的版本)<br>(如果直接显式要lock了，那么都lock了，当然就是要current read，而不是读取snapshot了）<br>insert，update，delete（这些操作当然不能读snapshot，不然你update一个已经被delete掉的数据吗)<br>(从底层源码来说，update，delete都包含一个current read，而insert，需要检查unique key冲突）</p><hr><p><strong><em>③聚簇索引（cluster index）：</em></strong></p><p>这是由MySQL<strong>自动生成</strong>的一个index（无法人为控制），它一般是直接把主键设置为cluster index，所以又称主键index。<br>（如果表没有创建主键？那么按照以下规则来创建cluster index：（一般还是要显式给表一个PK）<br>1.会用一个唯一的非空的index列，作为cluster index<br>2.如果没有这样的index，那么InnoDB会隐式生成一个主键来作为cluster index<br>其他人为定义的索引，称为辅助索引（secondary index），也可以称为非聚簇索引。<br>关于这两个index的具体区别，查找时的路径有何不同，可以参考这篇文章：<br><a href="https://www.cnblogs.com/rjzheng/p/9915754.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9915754.html</a><br>关键点：每创建一个index，那么就会生成一个B+树，因此index不能乱加，会导致index的时候需要同时维护多个index，导致效率低下）</p><p>PS：这里有一个关键点，就是<strong>cluster index是无论如何都会存在的。</strong>（不管你有没有创建其他index，每个表都会存在一个cluster index）<br>根据网上很多的文章，都提及到一个内容：InnoDB只有在使用index的时候才是使用行锁，否则会变成表锁。<strong>这句话是错误的</strong>。因为即使我们没有创建index，在select的时候也没有使用index列，那么一样会使用一个隐式创建的cluster index去寻找数据，所以<strong>InnoDB只存在行锁，不存在表锁。</strong><br>官方文档：<br><strong><em>Record Locks<br>A record lock is a lock on an index record. For example, SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE; prevents any other transaction from inserting, updating, or deleting rows where the value of t.c1 is 10.<br>Record locks always lock index records, even if a table is defined with no indexes. For such cases, InnoDB creates a hidden clustered index and uses this index for record locking. See Section 15.6.2.1, “Clustered and Secondary Indexes”.</em></strong><br>可是很多人表示自己亲自测试过，发现确实是整个表都锁住了呀，难道不是表锁吗？这主要是因为对底层了解不足，只开了两个session发现无法同时select就感觉是整个表都锁起来，是不正确的。这时候最正确的做法是：查看MySQL的状态表，查看当前存在的锁，然后<strong>直接查看锁的类型</strong>。毕竟网上说的都不权威，但MySQL它自己创建的表是最权威的！<br>我们这里创建两个session，发现存在lock，waiting的情况，这时候在另一个无须waiting的session执行： <strong>use information_schema;</strong> 进入到MySQL自带的information_schema数据库中<br>然后执行： <strong>select* from innodb_locks;</strong> 即可找到当前存在的locks。<br>（也可以使用 <strong>show engine innodb status;</strong>查看，不过可读性较差，需要仔细观察）<br>下面给出两个命令的结果：（第一个是select* from innodb_locks;)</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_2.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_2.png" alt="select* from innodb_locks的显示结果"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_3.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_3.png" alt="show engine innodb status的显示结果"></a></p><hr><p>PS：<strong>MySQL8.0与之前的版本不一致（5.7及以前）</strong>。如下：（如果不是使用8.0可以跳过）<br>MySQL5.7及之前，可以通过information_schema.innodb_locks查看事务的锁情况，但，只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。<br>MySQL8.0删除了information_schema.innodb_locks，添加了performance_schema.data_locks，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁，也就是说即使事务并未被阻塞，依然可以看到事务所持有的锁（不过，正如文中最后一段所说，performance_schema.data_locks并不总是能看到全部的锁）。表名的变化其实还反映了8.0的performance_schema.data_locks更为通用了，即使你使用InnoDB之外的存储引擎，你依然可以从performance_schema.data_locks看到事务的锁情况。<br>那么为何RECORD LOCKS会表现出类似于表锁的形式？这是因为InnoDB在没有使用index的时候，会使用cluster index（所以依然是行锁）此时会生成record locks和gap locks，并且是把每一个record，每一个gap都锁住，表现形式就像是整个表都被锁住的情况（但仍然是行锁）。<br>有的人可能觉得，这不是在挑文字游戏？并不，因为只有在特定情况下，才会出现这种情况，当我们修改一些其他参数，或者使用不同的index，都会出现不同的情况，到那时候就不再是整个表都锁住了。这个在最后的时候会详细说明，现在只需要知道，<strong>InnoDB，绝对不存在Table locks。</strong></p><hr><hr><h3 id="四-不同情况的加锁处理分析"><a href="#四-不同情况的加锁处理分析" class="headerlink" title="四. 不同情况的加锁处理分析"></a>四. 不同情况的加锁处理分析</h3><p>有了这些准备，我们开始讨论不同情况的加锁处理分析（加不加锁，加哪种锁）</p><p>此处参考了大佬的文章：<a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">http://hedengcheng.com/?p=771</a><br><strong>情况①：简单的snapshot read: select* from table where id = 1;</strong><br>这时候<strong>一般不加锁</strong>。但上文也说了，存在例外，那就是当事务隔离级别为Serializable的情况下，由于每一个操作都完全串行化，因而也不存在snapshot了，该操作会升级为current read，因而需要加锁。（同时，Serializable的情况下，MySQL的并发控制协议会从MVVC降级为Lock-Based。一般除非系统冲突非常严重，否则不采用Serializable）</p><p>有了第一个情况，可以发现<strong>加锁的情况是要考虑其他因素的，不能仅仅是给一个SQL语句就问获得了什么锁，还要考虑很多种情况</strong>。一般而言，需要考虑以下几种情况：（假设搜寻的字段为id）<br><strong>1.id是否为主键？<br>2.当前系统的隔离级别是什么？<br>3.id如果不为主键，那么它是否存在index？<br>4.如果id存在secondary index，那么这个index是否是unique index？<br>5.两个SQL的执行计划是什么，索引扫描？全表扫描？</strong>（这里我是参照大佬的文章来写的，但个人认为第五点其实跟前面的重叠了。如果id为主键，那么就是采用了cluster index，即全表扫描。如果id不存在index，同样是采用cluster index。如果id存在index，无论是否是unique，都为索引扫描。）</p><p>现在给定一个表：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_4.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_4.png" alt="测试所用的表结构"></a><br>对于上面的几种情况，不一定每一种都排列组合一遍，把关键的点get到即可。<br>下面通过<strong>8种情况</strong>来考虑：</p><hr><p><strong>①~④：RC级别<br>⑤~⑧：RR级别</strong></p><hr><h4 id="①搜寻字段是主键-PK）"><a href="#①搜寻字段是主键-PK）" class="headerlink" title="①搜寻字段是主键(PK）"></a>①搜寻字段是主键(PK）</h4><p><code>delete from testN where id = 10;</code><br>此时其他事务无法访问id = 10这一行记录<br>情况最简单，直接在主键上id = 10的记录上加上X锁即可（在id字段上锁）。</p><hr><h4 id="②字段不是主键，但存在一个unique-index。"><a href="#②字段不是主键，但存在一个unique-index。" class="headerlink" title="②字段不是主键，但存在一个unique index。"></a>②字段不是主键，但存在一个unique index。</h4><p><code>delete from testN where name = &#39;abc&#39;;</code><br>同样无法访问name = ‘abc’这一行记录，但同时在id和name1字段上锁。<br>这种情况下，由于存在index，所以会在index上查询，这时候会给unique index加上X锁。同时当select的时候，如果没有指定secondary index的字段（*号也不行），那么还会到cluster index里去顺序查找。具体看图：（在上面最开始讲到cluster index里的文章就有具体说明）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_5.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_5.png" alt="聚簇索引"></a><br>所以这个时候，除了给secondary unique index进行加锁，还会对cluster index进行加锁。<br>所以此处是给id，name1字段都加上了锁。（当然，被加锁的record依然是那一条，因为unique）</p><p>为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：<code>update t1 set id = 100 where name = ‘d’;</code>此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。</p><hr><h4 id="③字段不是主键，而且字段存在一个index，但并不是unique-index"><a href="#③字段不是主键，而且字段存在一个index，但并不是unique-index" class="headerlink" title="③字段不是主键，而且字段存在一个index，但并不是unique index"></a>③字段不是主键，而且字段存在一个index，但并不是unique index</h4><p><code>delete from testN where number = 12;</code><br>这种情况其实跟第②种情况是类似的，只是可能锁住多个record（因为不是unique index）<br>同样也是对number（index列）进行了加锁，然后还会对cluster index列加锁。<br>PS：看起来②和③可以归并在一起，但在RR的时候可以看到很大的不同。</p><hr><h4 id="④字段不是主键，而且不存在index。"><a href="#④字段不是主键，而且不存在index。" class="headerlink" title="④字段不是主键，而且不存在index。"></a>④字段不是主键，而且不存在index。</h4><p>此时会使用cluster index进行扫描，即全表扫描。而且会把所有的record都锁住。因为该条件无法通过索引快速过滤（暂且把cluster index视为很特殊的index吧，不然你都不需要自己创建index了），这时候在存储引擎层面就会将所有的记录加锁后返回，然后由MySQL Server层进行过滤。这是由于MySQL的实现所决定的。（在实际的实现中，进行了一些优化，在过滤条件中，如果发现不满足条件，那么在中途就会把不满足条件的记录释放锁。这样避免了把所有record都锁住导致的低并发，但也违背了二阶段锁的约束。这样最终持有锁的，会是满足条件的记录。但那大概是在事务提交执行的过程中，所以本地编写事务但不commit，依然会表现为全部记录加锁）</p><hr><h4 id="⑤搜寻字段是主键-PK）"><a href="#⑤搜寻字段是主键-PK）" class="headerlink" title="⑤搜寻字段是主键(PK）"></a>⑤搜寻字段是主键(PK）</h4><p>跟①没有区别</p><hr><h4 id="⑥字段不是主键，但存在一个unique-index。"><a href="#⑥字段不是主键，但存在一个unique-index。" class="headerlink" title="⑥字段不是主键，但存在一个unique index。"></a>⑥字段不是主键，但存在一个unique index。</h4><p>跟②没有区别</p><hr><h4 id="⑦字段不是主键，而且字段存在一个index，但并不是unique-index"><a href="#⑦字段不是主键，而且字段存在一个index，但并不是unique-index" class="headerlink" title="⑦字段不是主键，而且字段存在一个index，但并不是unique index"></a>⑦字段不是主键，而且字段存在一个index，但并不是unique index</h4><p>有区别了，为什么？RR相对于RC，解决的问题是幻读，不可重复读。为何⑤跟⑥的加锁却没有任何改变？幻读，不可重复读是指当前事务，连续执行两次current read，返回了不同的数据。而⑤和⑥都是unique index，能够保持唯一性，不用担心值会发生改变（改变值需要X锁，与S锁不兼容）。<br>那么在⑦的时候，字段存在了index，但该index并不是unique index，这时候问题就出现了，如果还是按照③的做法，那么就可能出现幻读跟不可重复读的情况。<br>举一个例子，按照我们上面给的table的来示例：（假设采用③的只对record进行加锁的模式）<br>字段名为： id， name1，number1， age (PK为id）<br>执行的current read的语句为：<br>select <em>from testN where number1 = 18 for update;(number1是非unique index列)<br>那么假如当我们在另一个session执行：insert into testN values(xx,xx,18,xx); commit;<br>这时候该session中的 transaction是可以成功提交的，因为并没有gap lock，而只是把原本符合条件的 record给锁住了，而不是把所有number1=18的都锁住。<br>这时候再次执行 select</em> from testN where number1 = 18 for update;就会出现幻读。</p><p>因此，<strong>此时会锁住符合记录与相邻记录的间隔。这个就称为间隔锁：gap locks</strong><br>假如：字段的取值是：12，32，18，18，20，24，30.选择的条件是 id = 18<br>那么除了锁住两个18的记录，还会锁住12与18，18与20之间的间隔（有序性）<br>所以此时锁住的范围：record locks： 18， 18<br>gap locks： [12, 18) ∪ [18, 20)所以整体锁住的范围就是： <strong>[12, 20)</strong></p><hr><h4 id="⑧字段不是主键，而且不存在index。"><a href="#⑧字段不是主键，而且不存在index。" class="headerlink" title="⑧字段不是主键，而且不存在index。"></a>⑧字段不是主键，而且不存在index。</h4><p>⑧跟⑦不一样的地方是，⑦会把符合条件的record的与前后record的间隔都给锁住，而⑧由于是全表搜索（无index，只有cluster index），因此⑧首先是把所有的records都锁住，然后再把所有records的间隔都锁住（包括±∞）。假如age列（非index列）一共有20，22，30等三个值，那么由行锁record locks和间隔锁gap locks锁住的范围为：<br><strong>(-∞, 20) ∪ [20, 22) ∪ [22, 30) ∪ [30, +∞）（因为表现为整个表都锁住了，所以容易误以为是表锁）</strong><br>（虽说误以为是表锁是错误的理解，但确实要<strong>尽量避免</strong>这种情况，因为这种情况需要加很多锁。当该非index列有n个records的时候，需要加n个record locks，(n+1)个gap locks，一共需要（2n+1)个锁，开销是极其大的。所以尽量通过index来查询，避免加入过多的锁，影响性能。</p><hr><h3 id="附：测试"><a href="#附：测试" class="headerlink" title="附：测试"></a>附：测试</h3><p>数据以上面的testN的数据为例，事务自动提交设置为否：set autocommit = 0（除了在阐述③如何引起幻读的情况下，需要commit，其余都无须commit，只需要显示到被锁住即可。并且这一步会放到最后执行，前面的每一项测试，在测试完毕之后，都执行rollback，避免事务对数据的更改）<br>初始数据：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_6.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_6.png" alt="初始数据"></a><br>确保环境：（1~4在RC，5~8在RR。虽说应该是global才生效，但直接把session跟global都设置一遍) （两个终端都设置）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_7.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_7.png" alt="初始环境(1~4RC,5~8RR)"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_8.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_8.png" alt="初始环境(1~4RC,5~8RR)"></a></p><hr><h4 id="情况①："><a href="#情况①：" class="headerlink" title="情况①："></a>情况①：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_9.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_9.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_10.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_10.png" alt="B终端"></a><br><strong><em>结论：①确实只锁住了id为10的那条记录，其他所有都没有锁。\</em></strong></p><hr><h4 id="情况②："><a href="#情况②：" class="headerlink" title="情况②："></a>情况②：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_11.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_11.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_12.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_12.png" alt="B终端"></a><br><strong><em>结论：②确实也是只把name1=’abc’该列锁住了。没有其他任何的锁。\</em></strong></p><hr><h4 id="情况③："><a href="#情况③：" class="headerlink" title="情况③："></a>情况③：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_13.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_13.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_14.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_14.png" alt="B终端"></a><br><strong>结论：③，number1为20有两个记录，这两个确实都被锁住了。而且其他都没有锁住，没有gap locks</strong></p><hr><h4 id="情况④："><a href="#情况④：" class="headerlink" title="情况④："></a>情况④：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_15.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_15.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_16.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_16.png" alt="B终端"></a><br><strong>结论：④理论上是锁住所有record，但在判定不符合之后就把锁释放了（即那个违背了二阶段锁的优化操作），所以最后只把age为22的锁住了。</strong></p><hr><p>RC环境转RR环境：<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_17.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_17.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_18.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_18.png" alt="B终端"></a></p><hr><h4 id="情况⑤："><a href="#情况⑤：" class="headerlink" title="情况⑤："></a>情况⑤：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_19.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_19.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_20.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_20.png" alt="B终端"></a><br><strong>结论：⑤与①相同，没有任何变化。</strong></p><hr><h4 id="情况⑥："><a href="#情况⑥：" class="headerlink" title="情况⑥："></a>情况⑥：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_21.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_21.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_22.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_22.png" alt="B终端"></a><br><strong>结论：Ⅵ与②相同，没有任何变化。</strong></p><hr><h4 id="情况⑦："><a href="#情况⑦：" class="headerlink" title="情况⑦："></a>情况⑦：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_23.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_23.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_24.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_24.png" alt="B终端"></a><br><strong>锁住18，与预期相同。</strong>18相邻的元素为12，20，因而把 [12, 18)∪ [18, 20)给锁住了。（锁的范围是左闭右开，因而12无法insert，但20是可以insert的）</p><p><strong>下面再测试锁住20的情况。</strong><br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_25.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_25.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_26.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_26.png" alt="B终端"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_27.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_27.png" alt="B终端"></a><br><strong>锁住20，同样跟预期相同，会把[18, 20) ∪ 20 ∪ [20, 40)都锁住</strong></p><p><strong>假设选择的值是最小/最大，是否也像no index的情况下，锁住±∞？</strong><br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_31.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_31.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_32.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_32.png" alt="B终端"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_33.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_33.png" alt="B终端"></a><br>答案是会的。所以也跟预期一样。</p><p><strong>结论：⑦与③不同，在RR的情况下会使用gap locks，锁住间隔。</strong></p><hr><h4 id="情况⑧："><a href="#情况⑧：" class="headerlink" title="情况⑧："></a>情况⑧：</h4><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_28.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_28.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_29.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_29.png" alt="B终端"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_30.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_30.png" alt="B终端"></a><br>表就像完全锁住一样，因为record locks &amp; gap locks 把整个表都锁住了。<br><strong>结论：⑧在RR的情况下，会把所有的record都锁住，也会把所有的gap锁住。</strong></p><hr><p>最后，测试RC环境下，③可能会导致<strong>幻读</strong>的情况：（RR已经确定不会出现幻读）<br>环境参数：（RR改回RC）<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_34.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_34.png" alt="A终端"></a></p><p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_35.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_35.png" alt="B终端"></a></p><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_36.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_36.png" alt="A终端"></a></p><p>中间，在另一个终端B执行：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_37.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_37.png" alt="B终端"></a><br>可见session1的lock并没有锁住session2创建number1为18的值。只要unique行没有duplicate，那么就可以insert，insert更多例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_38.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_38.png" alt="B终端"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_39.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_39.png" alt="A终端"></a></p><p>PS：<strong>以上讨论的是什么时候加锁</strong>。至于加什么锁，应该很好判断。如果是select lock in share mode，那就是加S锁，select for update，就是加X锁。</p><hr><hr><p><strong><em>当范围比较的时候，又有所不同！当范围比较的时候，又有所不同！</em></strong></p><p>(上面考虑的都是等值筛选的情况） 以下就不考虑等值的情况<br>使用数据：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_40.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_40.png" alt="使用数据"></a></p><hr><h4 id="①使用PK的情况（cluster-index）"><a href="#①使用PK的情况（cluster-index）" class="headerlink" title="①使用PK的情况（cluster index）"></a>①使用PK的情况（cluster index）</h4><p>SQL句子： （用4个句子来解释）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select* from testf where pid &gt; 30 for update;</span><br><span class="line">select* from testf where pid &gt; 33 for update;</span><br><span class="line">select* from testf where pid &gt; 50 for update;</span><br><span class="line">select* from testf where pid &lt; 30 for update;</span><br></pre></td></tr></table></figure><p><strong>对于RC：</strong><br>句子1：首先符合条件的记录为pid = 33， pid = 47.对这两个records加上X锁。<br>句子2：首先符合条件的记录为pid = 47，对着一个record加上X锁。<br>句子3：没有符合条件的记录。<br>句子4：两个符合，加锁。<br>此时执行select：句子1可以获取pid = 11，12，的记录，句子2可以获得11，12，33，句子3全部可以<br>此时执行insert：除了相同的pid（duplicate），没有任何限制。(但insert相同的pid时，还是会起冲突哦。先是waiting获得lock，然后获得了之后才发现，duplicate，insert失败。即添加被record lock锁住的记录，仍然要waiting，而其他就无须获取锁的就直接duplicate。下同）<br><strong>对于RR：（增加gap locks）</strong><br>句子仍然对符合的records加上X锁，之后，开始增加gap locks：<br>句子1：<br>gap locks：对于 pid &gt; 30，因而需要找一个左边界，找一个左边最接近30的record，在这里即为22.因此，gap locks的范围： [22, 33) ∪ [33, 47) ∪ [47, ＋∞)<br>对于insert，不能insert record locks &amp; gap locks范围里的pid。合理。<br>对于select，也还是跟RC情况一样。因为被record locks锁住的在RC就不能访问，而被gap locks锁住的范围无法insert，因而select也肯定是empty set。那么，就不会出现幻读。<br>句子2：<br>与句子1的唯一区别是，33刚好就在表里，那么左边界到底是22还是33？<br>好的，答案是33，因为判定条件≠33啊。剩下的也就一样了，gap locks：[33, 47)∪[47, +∞)<br>句子3：<br>这个有点特别的是，没有record。但其实是一样的，找边界，因而这里这里的边界显然就是47，gap locks： [47, +∞)<br>句子4：<br>值得注意的是，左边界是无穷，右边界显然是33.但这里的右边界竟然是闭合的！<br>所以此处gap locks：(-∞, 33],因而只能insert 34之后的pid。所以select的时候就只能select 47了，33是不可以的。insert也不能包括33.</p><hr><h4 id="②不使用PK，使用unique-index"><a href="#②不使用PK，使用unique-index" class="headerlink" title="②不使用PK，使用unique index"></a>②不使用PK，使用unique index</h4><p>修改了一下表的结构跟数据：num具备一个unique index<br>测试了一下，<strong>发现跟PK一模一样。懒得说。（内部实现实际上有区别的，如果说要什么区别的话，那就是上面刚开始说的①和②的区别啊！②会先给unique index加锁再给cluster index加锁。</strong><br>(其实就是cluster index那一篇拓展文章)</p><hr><h4 id="③不使用PK，使用non-unique-index-从这里开始很特别。"><a href="#③不使用PK，使用non-unique-index-从这里开始很特别。" class="headerlink" title="③不使用PK，使用non-unique index 从这里开始很特别。"></a>③不使用PK，使用non-unique index 从这里开始很特别。</h4><p>直接讨论RR：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select* from testf where num &gt; 200 for update;</span><br><span class="line">select* from testf where num &gt; 150 for update;</span><br><span class="line">select* from testf where num &gt; 400 for update;</span><br><span class="line">select* from testf where num &lt; 250 for update;</span><br></pre></td></tr></table></figure><p>对于句子1：<br>终端A：<br><a href="hhttps://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_41.png"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_41.png" alt="A终端"></a></p><p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_42.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_42.png" alt="B终端"></a><br>显然，select还是只把符合的记录给锁住了，即只锁住了300，100跟200均可select。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_43.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_43.png" alt="B终端"></a><br>对于insert，依然是找到相应的边界值（这里显然是200），于是锁住了[200, +∞)，因而可以insert 199</p><p>对于句子2：（<strong>看起来应该会跟句子1一样，但结果……</strong>）<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_44.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_44.png" alt="A终端"></a></p><p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_45.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_45.png" alt="B终端"></a><br><strong>select竟然全部记录都获取不到了，除了不存在的空记录</strong>。那么insert呢？<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_46.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_46.png" alt="insert情况"></a></p><p>既然已经是所有record都上锁了（record locks），那么理应把record之间的间隔也上锁（RR），结果insert确实如此，全部都无法insert。<br>（而句子1跟句子2的区别，仅仅只有150跟200，200存在于里面，而150不在。<strong>推测：索引为B+树类型，所以当存在相同的元素时，就可以直接根据B+树的有序性进行合理上锁，即对符合条件的记录上锁</strong>。那么如果不存在相同的元素，即不存在150，而且又不是unique index，仅仅是使用了一个non-unique index并且被动地去cluster index中查找，这时候就会把所有记录上锁，因为cluster index是一个特殊的index，具体的细节我也不懂，得去看源码。但现在只需要知道，<strong>cluster index无法标记到相同的元素，就无法进行定位了，然后就直接把所有record都锁了，当然在RR下还有gap locks</strong>）</p><p>对于句子3：<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_47.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_47.png" alt="A终端"></a></p><p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_48.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_48.png" alt="B终端"></a><br>可见，由于里面没有符合条件的记录，所以select没有被阻塞。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_49.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_49.png" alt="B终端"></a></p><p>可是，insert却是会被阻塞的。而且阻塞范围就是寻找边界。这里上锁的区域是[300, ＋∞)<br>（虽然400不存在于表中，但由于没有符合的记录，就没有把record给上锁了，所以也仅仅是添加了gap locks。但gap locks包含300，却只能search不能insert。看来只能看源码才能切实看懂了！先记住罢！）</p><p>对于句子4：<br>跟句子2是一样的，select全部锁住了，毫无意外的话，insert应该也会被全范围的gap locks给锁住。（// TODO = =！）<br>确实如此，就不贴图了。</p><p>本来不想测试RC的，但RR的结果有点出人意料，所以现在再把RC也测试一遍：<br>句子1：<strong>select还是一样，符合条件的锁住。insert没有任何阻塞</strong>（因为不存在gap locks）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_50.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_50.png" alt="B终端"></a><br>句子2：跟RR的不一样，并不会全部锁住，而且也不会把记录都锁住。<br>select依然是符合条件的才锁住。而insert依然是没有任何阻塞（没有gap locks）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_51.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_51.png" alt="B终端"></a><br>句子3：还是一样。select该锁的锁，insert无阻塞。<br>句子4：一样。pass<br>（RC的insert无阻塞是毫不意外的，首先RC不存在gap locks，至于已经存在的record则会因为PK/cluster index而产生冲突，并不是因为gap Locks）</p><hr><h4 id="情况④：不使用PK，也不使用index"><a href="#情况④：不使用PK，也不使用index" class="headerlink" title="情况④：不使用PK，也不使用index"></a>情况④：不使用PK，也不使用index</h4><p>RC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select* from testf where num &gt; 200 for update;</span><br><span class="line">select* from testf where num &gt; 150 for update;</span><br><span class="line">select* from testf where num &gt; 400 for update;</span><br><span class="line">select* from testf where num &lt; 250 for update;</span><br></pre></td></tr></table></figure><p>句子1：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_52.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_52.png" alt="B终端"></a><br>select全部锁住了，而且不仅仅是记录，包括gap。而RC是不存在gap locks的。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_53.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_53.png" alt="B终端"></a><br>而insert却是依旧跟预期一样，毫无阻塞（因为RC没有gap locks）</p><p>句子2：select也是一样全部阻塞。而insert也是毫无阻塞</p><p>句子3：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_54.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_54.png" alt="B终端"></a><br>select毫无阻塞，因为没有找到记录。insert也是毫无阻塞。</p><p>句子4：还是那样，select完全阻塞，insert没有阻塞。</p><p>RR：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select* from testf where num &gt; 200 for update;</span><br><span class="line">select* from testf where num &gt; 150 for update;</span><br><span class="line">select* from testf where num &gt; 400 for update;</span><br><span class="line">select* from testf where num &lt; 250 for update;</span><br></pre></td></tr></table></figure><p>句子1：<br>select依然全部被阻塞（RC都阻塞， RR岂有不阻之理？）<br>insert也是全部阻塞，因为RR多了gap locks，自然也就全部范围都锁住了。<br>句子2跟句子4显然结果也会是一样的。<br>那么再看句子3，竟然也是全部阻塞。</p><p>上面都是详细的推导环节，虽然还有所疑惑，但至少结果是没有错的，先总结了吧（关于insert并发这个，以后再说吧。这个应该满足了select/delete/update与insert之间的所有关系了，只差并发insert这一环节） PS : insert还有一个insert意向锁</p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>分两大类情况：等值筛选（id = x），范围筛选（id &gt; x)<br>以下操作只考虑select跟insert（delete跟update约等于select。）</p><p>先看<strong>等值筛选</strong>：</p><p><strong><em>① RC / RR + PK</em></strong></p><p>锁住该条记录的。select，insert均不能使用相同的字段值（insert是因为同名，select是因为锁）</p><p><strong><em>② RC / RR + Unique Index</em></strong></p><p>跟①一样，只是底层实现有所不同（先对Unique Index的记录加锁，再对cluster index的记录加锁）</p><p><strong><em>③ RC + Non-unique Index</em></strong></p><p>锁住所有符合条件的记录（因为不是unique，可能选出多条记录）</p><p><strong><em>④ RC + No index(无索引）</em></strong></p><p>锁住所有的记录（MySQL优化后，对判断不满足条件的记录，进行释放锁操作。违背了2PL协议）</p><p><strong><em>⑤ RR + Non-unique Index</em></strong></p><p>锁住符合条件的记录，并且新增gap locks。会锁住记录与其相邻记录的中间间隔（按照有序排列）<br>gap locks一般按照 左闭右开的原则。</p><p><strong><em>⑥ RR + No index</em></strong></p><p>锁住所有的记录，具备gap locks。因为所有记录都锁住，所以从-∞到＋∞其实都被锁住了。<br>n条记录时，n个Record Locks， n + 1 个gap locks，一共 2n+1 个锁。</p><p><strong>范围筛选</strong>：（PS：如果两个select都是S锁，那当然是可以同时存在的，S锁之间兼容）</p><p><strong><em>① RC + PK / Unique Index / Non-Unique Index</em></strong></p><p>(RC条件下，只要使用Index，无论是Unique Index还是Non-Unique）<br>锁住符合的记录，可以select没有锁的记录，insert无限制。</p><p><strong><em>② RR + PK / Unique Index</em></strong></p><p>锁住符合的所有记录，还有gap locks。同样是可以select没有锁的记录，insert无限制。</p><p><strong><em>③ RR + Non-unique Index</em></strong></p><p><strong>Ⅰ. 当表中存在比较的值（即id &gt; x, table存在 id = x的记录）</strong></p><p>同①</p><p><strong>Ⅱ. 当表中不存在比较的值（id &gt; x, table不存在id = x的记录）</strong></p><p>select全部阻塞（除了不存在的记录），insert全部阻塞（record已经阻塞，加上gap必然的结果)</p><p><strong>Ⅲ. 当select返回的是empty set （例子：where id &gt; 100，而table中不存在id大于100的记录）</strong></p><p>同① （其实跟 Ⅰ 也是等价的，只是符合的记录为empty set）</p><p><strong><em>④ RC + No Index</em></strong></p><p><strong>Ⅰ. select返回的值非空</strong></p><p>select完全阻塞（包括不存在的记录也无法select），insert无阻塞（RC不存在gap）</p><p><strong>Ⅱ. select返回的是empty set</strong></p><p>select跟insert都没有阻塞</p><p><strong><em>⑤ RR + No index</em></strong></p><p>select跟insert必定全部阻塞。</p><p>PS：在RR的情况下，对于并非全锁的情况，Gap Locks的边界值考量方法都是一样的（都是找左右相邻最近的，即使你是empty set，那么就找table中最大/最小的那个当边界，都是一样的，此处略）<br>并且，此处主要考虑的是RC跟RR级别下的情况。<strong>对RU跟Serializable并无太多讨论</strong>。而且只考虑了select与insert，select与select之间的冲突（据说select跟delete，update都是一个形式，那么就略了），还剩下的是Insert与Insert之间的冲突，即并发插入，TODO吧。</p><p>PPPS：写完之后再整理，想到了大佬文章里的第五点，<strong>SQL语句的执行计划是什么？是索引扫描还是全表扫描？</strong>我当时认为这点可以忽略，因为我认为cluster index必定存在，所以即使是全表扫描也是等同于索引扫描，只是扫描cluster index的时候存在一点特殊（就是上文提到的那点）现在看来，cluster index虽然是index，但确实是特殊的index，当我们需要使用全表扫描，<strong>即使是使用了cluster index，也是不能完全等同于索引扫描的</strong>。想想最后在范围搜索那里，出现的意外情况无法理解的，应该就是这一点了吧。（因为当时的注意力主要在考虑InnoDB是否存在表锁，然后最后的主要论据就是必定存在cluster index，所以必定有索引，表现出表锁的特征其实是行锁加间隔锁的作用等等……实际上，这一点倒是没有错，但cluster index是特殊的index也不可忽视！）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;本文的最终解决的问题：&lt;strong&gt;如何判断一条SQL语句用到了哪些锁？&lt;/strong&gt;&lt;br&gt;（特别地，这里考虑的是&lt;em&gt;MySQL&lt;/em&gt;数据库的锁机制）&lt;/p&gt;
&lt;p&gt;首先，我们需要先对&lt;em&gt;MySQL&lt;/em&gt;的事务机制，锁机制，索引机制都总结一遍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://hongscar.cn/categories/MySQL/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>JVM知识整理</title>
    <link href="https://hongscar.cn/JVM%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html"/>
    <id>https://hongscar.cn/JVM%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html</id>
    <published>2020-02-17T03:48:09.000Z</published>
    <updated>2020-02-17T06:18:09.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-类的生命周期：加载→连接→初始化→使用→销毁"><a href="#一-类的生命周期：加载→连接→初始化→使用→销毁" class="headerlink" title="一. 类的生命周期：加载→连接→初始化→使用→销毁"></a>一. 类的生命周期：加载→连接→初始化→使用→销毁</h3><h5 id="连接-包括："><a href="#连接-包括：" class="headerlink" title="连接 包括："></a>连接 包括：</h5><p>①验证（确保被加载的类的正确性）<br>②准备（为静态变量分配内存，并将其初始化为默认值（指0，false，null等），同时将static final值转换为具体的常量<br>③初始化：为静态变量执行赋值语句（static，非final），执行静态块<br>PS：初始化只有在对类主动使用时才会执行，包括以下：<br>①new<br>②访问静态域的时候<br>③反射（如Class.forName)<br>④初始化某个类时，其父类也会初始化<br>⑤运行main方法时，该类加载</p><a id="more"></a><hr><h5 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器:"></a>类加载器:</h5><p><em>①Bootstarp ClassLoader</em>（启动类加载器，由C++实现的类，无法获取实例）<br>负责加载JDK下/lib的类库（如java.*等关键类，是最底层的Class Loader)</p><p><em>②Extension ClassLoader</em>（拓展类加载器<br>负责加载JDK下 /lib/ext目录，即额外的类库</p><p><em>③Application ClassLoader</em>（应用程序类加载器负责加载用户类路径的类，即ClassPath</p><p><em>④其他自定义的类加载器    User Class Loader</em><br>PS：这里的加载器并不是通过继承组成的关系，而是组合。    ②③④都继承自java.lang.ClassLoader</p><hr><h4 id="question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）"><a href="#question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）" class="headerlink" title="question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）"></a>question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）</h4><p>ans：双亲委派模型：当一个Class loader收到了加载类的请求，它不会立刻加载，而是先交给父类加载器加载，但父类加载器找不到那个类，才传递回给子类加载器。即优先在Bootstarp中加载，然后是Extension，然后就才是Application。<br>这样做的好处：<br>①只有1个classloader加载了类，防止内存中会出现同样的字节码<br>②增强了安全性，避免用户自己定义了java预定义的类并成功覆盖。比如用户自定义了一个java.lang.Object的类，这时候它会优先从Bootstrap中加载，而Bootstrap中加载的是java预定义的Object类，而不是用户自定义的Object类，这样就避免了用户的Object类覆盖。如果是先从Application Class loader中加载，那么就是先加载用户自定义的Object类，而Java预定义的Object类被覆盖掉。</p><hr><hr><h3 id="二-JVM的内存结构："><a href="#二-JVM的内存结构：" class="headerlink" title="二. JVM的内存结构："></a>二. JVM的内存结构：</h3><p><strong>JDK1.6： Heap + PermGen（Method Area）永久区，方法区 + Stack + Program Counter Register</strong><br>同时：<strong>①Stack = JVM Stack + Native Method Stack</strong><br>Stack用于描述Java方法执行的内存模型，每个方法执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表，操作栈，动态链接，方法出口，基本类型和对象的引用等等。每一个方法从被调用直至执行完成的过程，就对应一个栈帧在JVM Stack中从入栈到出栈的过程。<br>（Native同理，只是作用与本地方法）<br>PS：如果线程请求的栈深度大于JVM所允许的深度，抛出StackOverflowError。<br>如果JVM Stack可以动态拓展，拓展时无法申请到足够的内存，抛出OutOfMemoryError</p><hr><p><strong>②Heap = Young Generation年轻代 + Old Generation 老年代</strong><br><strong>Young = Eden + From Survivor  + To Survivor</strong><br>通过各种参数可以控制各区域的内存大小，进而达到JVM调优效果<br>-Xms， -Xmx：设置Heap的最小，最大空间的大小<br>-XX:NewSize， -XX:MaxNewSize： 设置年轻代最小，最大空间的大小<br>-XX:PermSize, -XX:MaxPermSize： 设置永久区最小， 最大空间的大小<br>-Xss：设置每个JVM Stack的大小<br>（PS：Perm是永久区，要设置老年代只能通过 Heap - Young来间接控制）<br>PS：在Heap区中，有可能抛出OutOfMemoryError</p><hr><p><strong>③Program Counter Register</strong><br>较小的内存空间，是当前字节码的行号指示器（用于分支，跳转等待）<br>如果执行的是Java方法，记录正在执行的JVM字节码的指令地址。<br>如果是Native方法，那么为空（Undefined）<br>（此区域是JVM唯一无OutOfMemoryError的区域，因为一般不会在这里抛异常）</p><p><strong>④PermGen（Method Area）方法区，永久区</strong><br>用于存储已经被JVM加载的类信息，常量，静态变量，JNI编译后的代码·<br>（会抛出OutOfMemoryError）<br>PS：Heap 和Method Area在线程间是会共享资源的，而Stack和Counter是线程私有的。</p><hr><p><strong><em>JDK各版本的区别： (1.6 ~ 1.8)</em></strong><br>JDK1.6中，各种常量池是放在方法区中的<br>JDK1.7中，常量池放在Heap中，此时：Heap = Young + Old + 各种常量池<br>（PS：关于常量池，这里还有一个TODO，即intern那中问题，看《JVM入门到放弃》）<br>JDK1.8:常量池依然在Heap中，但永久区/方法区被移除，改为使用metaSpace（元空间）</p><hr><hr><h4 id="question2：移除永久区PermGen的原因"><a href="#question2：移除永久区PermGen的原因" class="headerlink" title="question2：移除永久区PermGen的原因"></a>question2：移除永久区PermGen的原因</h4><p>①永久区一直只存在于HotSpot JVM，而JRockit VM没有永久区，为了融合两个JVM而做出的调整，无须继续配置永久区<br>②永久区内存经常不够用，或者发生内存泄漏，抛出OutOfMemoryError：PermGen<br>③永久区会为GC带来不必要的复杂度，并且回收效率偏低</p><hr><h4 id="question3：元空间metaSpace和永久区的区别？"><a href="#question3：元空间metaSpace和永久区的区别？" class="headerlink" title="question3：元空间metaSpace和永久区的区别？"></a>question3：元空间metaSpace和永久区的区别？</h4><p>元空间并不在VM中，而是使用本地内存，默认情况下，仅受本地内存的限制。（可以通过配置参数来控制meta Space，默认情况下，最大空间没有限制，即内存的上限）。配置参数：<br>-XX：MetaspaceSize， -XX：MaxMetaspaceSize    初始空间大小，最大空间大小<br>-XX：MinMetaspaceFreeRadio， -XX：MaxMetaspaceFreeRadio：<br>在GC之后，最小/最大的Metaspace剩余空间容量的百分比</p><hr><h4 id="question4：常量池为什么要移动到Heap"><a href="#question4：常量池为什么要移动到Heap" class="headerlink" title="question4：常量池为什么要移动到Heap"></a>question4：常量池为什么要移动到Heap</h4><p>因为方法区的回收比较困难，会导致过多严重的bug，所以从1.7开始就把常量池移动到Heap，为后续移除PermGen做出准备（在JDK1.8已把PermGen移除）</p><hr><h3 id="三-GC算法："><a href="#三-GC算法：" class="headerlink" title="三. GC算法："></a>三. GC算法：</h3><p><strong>①标记-清除 Mark-Sweep</strong><br>缺点：效率不高，且会产生大量的内存碎片<br><strong>②复制算法 Copying</strong><br>缺点：会使内存缩小一半，不能直接用在Old，因为持续复制长生存期的对象会导致效率降低<br><strong>③标记-压缩 Mark-Compact</strong> （在①的基础上，清除完之后还对碎片进行压缩）<br><strong>④分代收集Generational Collection</strong> 即年轻代用 复制算法，老年代用标记清除/压缩</p><hr><p><strong>垃圾回收器</strong>：<br>①Serial，串行收集器。最古老，最稳定，效率高。但会产生较长的停顿<br>②ParNew，即Serial的多线程版本<br>③Parallel，于ParNew类似，但更关注系统的吞吐量<br>④CMS（Concurrent Mark Sweep）<br>重视服务的响应速度，希望系统停顿时间最短，但会产生大量的空间碎片，降低吞吐量。<br>⑤G1（Garbage-First）<br>满足了GC停顿时间要求，同时又具备高吞吐量的特征<br>（收集器之间可以组合使用，如Young使用A，Old使用B）</p><p>MinorGC：对年轻代进行GC。特点：频繁，回收速度快<br>MajorGC：对老年代进行GC。<br>FullGC：全堆范围的GC</p><hr><h4 id="question5：什么情况下会出现内存溢出-泄漏？"><a href="#question5：什么情况下会出现内存溢出-泄漏？" class="headerlink" title="question5：什么情况下会出现内存溢出/泄漏？"></a>question5：什么情况下会出现内存溢出/泄漏？</h4><p>虽说Java有GC，无须我们手动释放资源，但在运行时还是可能出现对象可达，但不会被使用的情况，这时候就会导致内存泄漏。例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/jvm_1.png" target="_blank" rel="noopener" title="Java内存泄漏例子"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/jvm_1.png" alt="Java内存泄漏例子" title="Java内存泄漏例子"></a><br>内存溢出的可能原因：<br>①内存泄漏导致Stack内存不断增大，引发OutOfMemory（Stack处）<br>②大量jar，class文件加载，装载类的空间不足，溢出 （Class Loader处）<br>③操作大量对象，导致Heap空间不足，溢出（Heap处）<br>④nio直接操作内存，内存过大导致溢出（内存处）<br>（同理应该MetaSpace溢出也是一样的）<br>解决方法：查看是否有内存泄漏，设置参数增大空间，代码是否存在死循环生成过多对象</p><hr><h4 id="question6：JVM从Young到Old的晋升条件是什么"><a href="#question6：JVM从Young到Old的晋升条件是什么" class="headerlink" title="question6：JVM从Young到Old的晋升条件是什么"></a>question6：JVM从Young到Old的晋升条件是什么</h4><p>①对象在Eden出生，经过一个MinorGC还存活，就被Survivor容纳，在From和to中复制交换。如果经过[MaxTenuringThreshold]（默认是15）次交换还存活，进入Old<br>②如果对象大小等于Eden的二分之一，直接分到Old。如果Old也分配不下，做一次MajorGC<br>（如果小于Eden的二分之一，但没有足够的空间，进行MinorGC）<br>③MajorGC之后，如果Survivor仍然放不下，则放到Old<br>④动态年龄判断。如果大于等于某年龄的对象超过survivor空间的一半，则这些对象全部都直接进入Old（无须达到MaxTenuringThreshold)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-类的生命周期：加载→连接→初始化→使用→销毁&quot;&gt;&lt;a href=&quot;#一-类的生命周期：加载→连接→初始化→使用→销毁&quot; class=&quot;headerlink&quot; title=&quot;一. 类的生命周期：加载→连接→初始化→使用→销毁&quot;&gt;&lt;/a&gt;一. 类的生命周期：加载→连接→初始化→使用→销毁&lt;/h3&gt;&lt;h5 id=&quot;连接-包括：&quot;&gt;&lt;a href=&quot;#连接-包括：&quot; class=&quot;headerlink&quot; title=&quot;连接 包括：&quot;&gt;&lt;/a&gt;连接 包括：&lt;/h5&gt;&lt;p&gt;①验证（确保被加载的类的正确性）&lt;br&gt;②准备（为静态变量分配内存，并将其初始化为默认值（指0，false，null等），同时将static final值转换为具体的常量&lt;br&gt;③初始化：为静态变量执行赋值语句（static，非final），执行静态块&lt;br&gt;PS：初始化只有在对类主动使用时才会执行，包括以下：&lt;br&gt;①new&lt;br&gt;②访问静态域的时候&lt;br&gt;③反射（如Class.forName)&lt;br&gt;④初始化某个类时，其父类也会初始化&lt;br&gt;⑤运行main方法时，该类加载&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://hongscar.cn/categories/Java/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>数据库三级封锁协议</title>
    <link href="https://hongscar.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.html"/>
    <id>https://hongscar.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.html</id>
    <published>2020-02-17T03:46:44.000Z</published>
    <updated>2020-02-17T04:01:35.523Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>数据库并发会导致各种问题（即多线程下导致的同步问题），需要用lock来解决。</p><p>一般会导致的问题：<strong><em>脏读，不可重复读，第一类更新丢失，第二类更新丢失</em></strong></p><p>为了解决这些问题，需要使用锁机制，数据库一般有三级封锁协议。本文阐述了这些问题具体是什么，锁机制如何解决这些问题。</p><a id="more"></a><h3 id="二-数据库并发导致的问题"><a href="#二-数据库并发导致的问题" class="headerlink" title="二. 数据库并发导致的问题"></a>二. 数据库并发导致的问题</h3><hr><p>①<strong><em>脏读</em></strong>（<em>dirty read</em>）：事务A update了data，事务B读取了update后的data，此时事务A rollback，导致B读取的是错误的数据，即dirty data</p><hr><p>②<strong><em>不可重复读</em></strong>（<em>unrepeatable read</em>）：B读取了data，A读取了data并且进行了update，此时B再次读取data，两次获取到的data并不一致。</p><hr><p>③<strong><em>第一类更新丢失</em></strong>：A读取了data①，B读取了data并且进行update，commit。A同时又对data进行update，而这个update是在①的基础上操作的，最终B的更新就会被丢失。</p><hr><p>④<strong><em>第二类更新丢失</em></strong>：B读取了data，A读取了data。B对data进行update，然后commit。接着A又对data进行update，commit。同样的，B的更新会被丢失。</p><hr><h3 id="三-数据库的锁机制"><a href="#三-数据库的锁机制" class="headerlink" title="三. 数据库的锁机制"></a>三. 数据库的锁机制</h3><p>数据库有两种锁，S锁和X锁：<br><strong>S锁（shared）：事务可读不可写。（其他事务可以同时添加S锁）</strong><br><strong>X锁（exclusive）：事务可读可写。（其他事务不可以同时添加任何锁）</strong><br>锁之间的兼容性，设定有两个锁a1，a2，用f(a1, a2)来表示两个锁的兼容性，如果f = 1，则表示兼容。如果f = 0，则不兼容。<br>f(s, s) = 1;其他诸如：f(x, x)= f(x, s)= f(s, x) = 0;<br><strong><em>即X锁不能与其他锁同时存在。而s锁与s锁之间可以同时存在。</em></strong></p><hr><p><strong>1.一级锁协议：</strong>事务T修改数据R之前，先加X锁，直到事务结束时释放（无论是正常结束commit还是非正常结束rollback）<br>作用：可防止 更新丢失问题。<br>不能防止： 脏读，不可重复读，幻读等。<br>PS：任何数据库都至少满足一级锁的协议，因为更新丢失是不能接受的错误，所以更新丢失一般只存在于理论讨论中，实际应用中基本不会出现这个问题。</p><hr><p><strong>2.二级锁协议：</strong>在一级锁的条件下，T在读取R之前先加S锁，读完后释放。<br>作用：可防止更新丢失，脏读。<br>不能防止： 不可重复读，幻读。</p><hr><p><strong>3.三级锁协议：</strong>在一级锁的条件下，T在读取R之前先加S锁，事务结束后释放。<br>作用：可防止 更新丢失，脏读，不可重复读，幻读。</p><hr><hr><h3 id="四-具体例子来说明锁的作用机制："><a href="#四-具体例子来说明锁的作用机制：" class="headerlink" title="四. 具体例子来说明锁的作用机制："></a>四. 具体例子来说明锁的作用机制：</h3><h5 id="①不使用锁导致的更新丢失问题："><a href="#①不使用锁导致的更新丢失问题：" class="headerlink" title="①不使用锁导致的更新丢失问题："></a>①不使用锁导致的更新丢失问题：</h5><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_1.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_1.jpg" alt=""></a></p><h5 id="②使用一级锁解决更新丢失问题："><a href="#②使用一级锁解决更新丢失问题：" class="headerlink" title="②使用一级锁解决更新丢失问题："></a>②使用一级锁解决更新丢失问题：</h5><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_2.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_2.jpg" alt=""></a><br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_3.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_3.jpg" alt=""></a></p><h5 id="③为什么一级锁不能解决脏读问题："><a href="#③为什么一级锁不能解决脏读问题：" class="headerlink" title="③为什么一级锁不能解决脏读问题："></a>③为什么一级锁不能解决脏读问题：</h5><p>脏读例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_4.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_4.jpg" alt=""></a><br>用一级锁的情况：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_5.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_5.jpg" alt=""></a></p><h5 id="④使用二级锁解决脏读问题："><a href="#④使用二级锁解决脏读问题：" class="headerlink" title="④使用二级锁解决脏读问题："></a>④使用二级锁解决脏读问题：</h5><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_6.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_6.jpg" alt=""></a></p><h5 id="⑤为什么二级锁不能解决不可重复读问题："><a href="#⑤为什么二级锁不能解决不可重复读问题：" class="headerlink" title="⑤为什么二级锁不能解决不可重复读问题："></a>⑤为什么二级锁不能解决不可重复读问题：</h5><p>不可重复读例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_7.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_7.jpg" alt=""></a><br>使用二级锁的情况：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_8.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_8.jpg" alt=""></a></p><h5 id="⑥三级锁解决不可重复读："><a href="#⑥三级锁解决不可重复读：" class="headerlink" title="⑥三级锁解决不可重复读："></a>⑥三级锁解决不可重复读：</h5><p>三级锁相当于，完全串行化。即一个事务开始了，其他事务都完全不能开始进行，无论是读还是写。因此就上述的例子，一定是A完全执行完毕，才轮到B执行。那么就必定不会出现不可重复读的问题。（三级锁的完全串行化，也就是，为了解决并行化带来的问题，直接不使用并行，改为串行执行。）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;数据库并发会导致各种问题（即多线程下导致的同步问题），需要用lock来解决。&lt;/p&gt;
&lt;p&gt;一般会导致的问题：&lt;strong&gt;&lt;em&gt;脏读，不可重复读，第一类更新丢失，第二类更新丢失&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了解决这些问题，需要使用锁机制，数据库一般有三级封锁协议。本文阐述了这些问题具体是什么，锁机制如何解决这些问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://hongscar.cn/categories/MySQL/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>Github的简要操作</title>
    <link href="https://hongscar.cn/Github%E7%9A%84%E7%AE%80%E8%A6%81%E6%93%8D%E4%BD%9C.html"/>
    <id>https://hongscar.cn/Github%E7%9A%84%E7%AE%80%E8%A6%81%E6%93%8D%E4%BD%9C.html</id>
    <published>2020-02-17T03:14:58.000Z</published>
    <updated>2020-02-17T06:17:42.730Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下IDEA项目提交到GitHub的整体操作:（主要是清晰每一步的作用，而不是死记硬背）<br><strong>step1:</strong><br>IDEA的GitHub<strong>连通配置</strong>。（这个就在setting-git那里，但一般配置一次就不再需要了，pass）<br><strong>step2：</strong><br>将本地的项目连接到GitHub。 <em>VCS — Import into Version</em> Control （会让你创建一个仓库）<br>然后再将项目切实地与该仓库连接。<em>VCS — Import into Version Control — Create Git Repository</em><br>（有一次没有Create，右键项目甚至没有git操作）</p><a id="more"></a><p><strong>step3：</strong><br>连接了之后，就是提交操作了，提交其实一共有3个步骤，不要胡乱pull跟push就什么都不会了。<br><strong>PS：只要IDEA的项目已经成功执行了步骤1和2，那么之后其实就不需要前面两个步骤了。</strong><br>①<strong>VCS — Git — add</strong><br>作用，把本地发生改变了的代码添加到branch中，其实就是先把你的代码都commit到本地的一个分支了，但这里还没有提交。<br>②<strong>VCS — Git — Commit File</strong><br>第一步的操作只是add到工作环境，还没添加到本地仓库，这里把所有add的文件commit到本地操作<br>③最后就是提交到远程仓库。这个最后一步才是pull跟push的地方。<br><strong><em>先pull，再push即可</em></strong>。<br>pull的作用其实就是先跟远程仓库的代码对比，因为可能别人已经commit过，与你的代码产生冲突，这时候你需要解决这些冲突再commit，不然你把别人的代码覆盖了怎么办？<br>push就是最后的提交代码了，一般pull成功的话push也就没有问题。</p><p>但是，在第一次创建的时候，可能会存在问题，好像是因为不在同一个项目里，无论是change分支，还是git pull —allow-unrelated-histories啊等等的，都不行。<br>其实第一次创建，又不可能conflict（唯一可能conflict的地方只有一个readme文件而已。。）<br>所以干脆直接强制push即可: <strong>git push -u origin master -f</strong> (-f 很显然，就是force）</p><p>其他常用操作：<br>查看远程仓库： git remote -v (remote就是远程的意思）<br>添加远程仓库： git remote add (nick_name) (repository-url)<br>删除仓库（注意是删除与仓库的连接而已)：git remote remove nick_name<br>（一般nick_name都叫origin了，不知为何，先这样记着）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下IDEA项目提交到GitHub的整体操作:（主要是清晰每一步的作用，而不是死记硬背）&lt;br&gt;&lt;strong&gt;step1:&lt;/strong&gt;&lt;br&gt;IDEA的GitHub&lt;strong&gt;连通配置&lt;/strong&gt;。（这个就在setting-git那里，但一般配置一次就不再需要了，pass）&lt;br&gt;&lt;strong&gt;step2：&lt;/strong&gt;&lt;br&gt;将本地的项目连接到GitHub。 &lt;em&gt;VCS — Import into Version&lt;/em&gt; Control （会让你创建一个仓库）&lt;br&gt;然后再将项目切实地与该仓库连接。&lt;em&gt;VCS — Import into Version Control — Create Git Repository&lt;/em&gt;&lt;br&gt;（有一次没有Create，右键项目甚至没有git操作）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Github" scheme="https://hongscar.cn/categories/Github/"/>
    
    
      <category term="Github" scheme="https://hongscar.cn/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>阅读Servlet的源码</title>
    <link href="https://hongscar.cn/%E9%98%85%E8%AF%BBServlet%E7%9A%84%E6%BA%90%E7%A0%81.html"/>
    <id>https://hongscar.cn/%E9%98%85%E8%AF%BBServlet%E7%9A%84%E6%BA%90%E7%A0%81.html</id>
    <published>2020-02-17T03:14:10.000Z</published>
    <updated>2020-02-17T04:02:09.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>在写SSM项目的过程中，遇到了一些小问题，不知道如何解决。其实对于框架的很多问题，很多时候都是因为框架的封装性，然后自身没有理解框架的内部逻辑而导致的。于是这次想花点时间好好读一下Servlet的源码，这样可以更好地理解JavaWeb底层，遇到问题也能更加地游刃有余。当然此次阅读源码只是比较浅显的，先看官方文档，然后在有目的性地读一部分源码来感受文档的内容。如果要认真看那肯定要看很久，目前还没这个时间。<br>    <strong>首先是Servlet API包含了两个软件包，javax.servlet和javax.servlet.http</strong>，为什么会有两个呢，因为早先设计该规范的人认为Servlet是一种服务模型，不一定要依赖于某种网络协议之上，于是就抽象出了一个javax.servlet，同时再提供一个基于HTTP协议上的接口拓展。但目前看来，似乎还没有发现有其他协议上实现的Servlet技术。</p><a id="more"></a><hr><h3 id="二-HTTPServlet抽象类"><a href="#二-HTTPServlet抽象类" class="headerlink" title="二. HTTPServlet抽象类"></a>二. HTTPServlet抽象类</h3><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/1.jpg" alt="img">)](<a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/1.jpg" target="_blank" rel="noopener">https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/1.jpg</a>)<br>官方解析：<br>    <em>Provides an abstract class to be subclassed to create an HTTP servlet suitable for a Web site.A subclass of HttpServlet must override at leat one method usually one of these: doGet,doPost,doPut,doDelete.</em><br>    提供一个抽象类，使得它的子类可以更方便地创建一个标准HTTP Servlet。子类必须至少实现以下方法的其中一个：<strong>doGet，doPost，doPut，doDelete</strong><br>    <strong>标准Servlet接口有一个service方法</strong>，即service的标准服务方法。但是service方法没必要override，因为HTTPServlet已经把service方法写好了，把标准的HTTP请求通过它们的HTTP request类型(即请求的doXXX)，分别转发到具体的处理方法中。比如类型是doGet，就转发到doGet方法中。<br>HttpServlet里的service方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    String method = req.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// servlet doesn't support if-modified-since, no reason</span></span><br><span class="line">        <span class="comment">// to go through further expensive logic</span></span><br><span class="line">        doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">        <span class="keyword">if</span> (ifModifiedSince &lt; (lastModified / <span class="number">1000</span> * <span class="number">1000</span>)) &#123;</span><br><span class="line">            <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                    <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                    <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">            maybeSetLastModified(resp, lastModified);</span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">        <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        可以看到是通过Java反射的机制，获取了HttpServletRequest的方法，返回了一个method的字符串，根据method来判定到底是属于哪一个doXXX，再分别调用doXXX方法。这里我钻了一下牛角尖，HttpServletRequest里有多个方法，getMethod方法的内部逻辑是如何返回的呢。HttpServletRequest只是一个接口，寻找了很久只找到了一个实现类HttpServletRequestWrapper，然而还是没有具体的getMethod实现。最后知道了这个HttpServletRequest是由J2EE的容器来实现的，比如Tomcat，webLogic。看来我们是不能得知getMethod的具体逻辑了，只需要知道它可以返回HTTP报文头的method是什么就行。<br>​        然后如果是METHOD_XXX方法，就调用doXXX方法。好几个方法都没有特别，直接调用。但HEAD方法和GET方法多了一个逻辑，用于验证文件是否已经被修改。HEAD和GET都是获取服务器上的资源，但HEAD不需要返回消息体，只请求返回报文头，空的消息体，也就是说，它可以用于检测资源是否有效，是否存在，网站是否有篡改等。当需要这类操作的时候，就不需要用GET了，用HEAD即可。如果本地有缓存文件，和要GET的文件是相同的，没有修改过的，那么此时就会返回状态码304，表示文件没有被修改。虽然返回304的时候已经做了一次数据库查询，但可以避免接下来更多的数据库查询。对于HEAD方法，只返回HTTP报文头，更是降低了带宽的消耗。<br>​    最终到达了doXXX的方法，以GET方法为例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String protocol = req.getProtocol();</span><br><span class="line">    String msg = lStrings.getString(<span class="string">"http.method_get_not_supported"</span>);</span><br><span class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">"1.1"</span>)) &#123;</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里有个特别的地方是，虽然doXXX方法有具体的实现，但它是无论如何都会返回错误的，即sendError。这是避免了具体子类直接调用HttpServlet的doXXX方法。因此子类必须重写至少1个doXXX方法，然后再通过HTTP的method判断要调用哪个doXXX方法，进而调用子类重写的doXXX方法。</p><hr><h3 id="三-Servlet-ServiceConfig接口"><a href="#三-Servlet-ServiceConfig接口" class="headerlink" title="三. Servlet, ServiceConfig接口"></a>三. Servlet, ServiceConfig接口</h3><p>​    一个Java Servlet具有生命周期，这个生命周期定义了一个Servlet如何被载入并被初始化，如何接受请求并对请求的响应，如何从服务中被清除等等。Servlet的生命周期被javax.servlet.Servlet这个接口所定义。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/5.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/5.jpg" alt="img"></a><br>​    所有的Java Servlet都会直接或间接地实现javax.servlet.Servlet接口，这样它才能在一个servlet引擎中运行。servlet引擎是web服务器按照Java Servlet API定制的拓展。Servlet引擎提供网络服务，能够理解MIME请求，并提供一个运行Servlet的容器。<br>​    只有实现了Servlet接口的才是Servlet，然后才包含Servlet的生命周期。当然，继承了HttpServlet，就是继承了GenericServlet，就是实现了Servlet接口。<br>​    ServletConfig就是用于获取Servlet的配置，比如初始化参数，参数名等等，还可以获取该Servlet的ServletContext对象。</p><hr><h3 id="四-ServletContext接口"><a href="#四-ServletContext接口" class="headerlink" title="四. ServletContext接口"></a>四. ServletContext接口</h3><p>​    Servlet上下文，服务器会为工程建立一个全局唯一的ServletContext对象，工程内部所有的Servlet都共享这个对象，可以用于读取全局配置参数，搜索资源文件等等。</p><hr><h3 id="五-ServletRequest接口等"><a href="#五-ServletRequest接口等" class="headerlink" title="五. ServletRequest接口等"></a>五. ServletRequest接口等</h3><p>ServletRequest接口，请求时产生的对象，ServletResponse接口，响应时产生的对象。<br>SingleThreadModel接口，使得Servlet成为单线程。（只接受1个请求）<br>GenericServlet类，实现了Servlet接口，使得编写Servlet更方便。<br>ServletInputStream，ServletOutputStream抽象类，继承InputStream，OutputStream<br>ServletException，UnavailableException类，没什么好说的。</p><hr><h3 id="六-Filter接口"><a href="#六-Filter接口" class="headerlink" title="六. Filter接口"></a>六. Filter接口</h3><p>​    用于对request，response等任务进行过滤，一般是用doFilter方法来过滤，可以通过FilterConfig的对象来获取Filter的初始化参数。包含了destroy，init，doFilter方法。<br>生命周期：当有Servlet的service方法要被执行时，被init，直到所有的service方法已经执行完毕doFilter，或者过了一定的时间之后，就会执行destroy方法。<br>​    对具体实现类的基本要求：<br>①要对request进行验证检查。<br>②对request和response可以选择自定义实现类去包装<br>③当有多个过滤方法的时候，需要用到过滤链FilterChain，并且在当前的Filter没执行完之前，当前的数据都不会被通过。执行完之后会继续执行chain里的下一个filter<br>④在过滤链调用下一个filter的时候，就要直接设置当前的response header（避免窜数据）<br>FilterChain的多个filter执行顺序在web.xml的filter-mapping里控制<br>FilterConfig，对Filter的初始化配置参数等等。</p><hr><h3 id="七-RequestDispatcher接口"><a href="#七-RequestDispatcher接口" class="headerlink" title="七. RequestDispatcher接口"></a>七. RequestDispatcher接口</h3><p>​    直译就是请求分发器。具备两个方法，forward和include。<br>定义了一个对象，从客户端接受请求之后，需要将请求发给服务器。有的时候需要传递给另一个资源去响应。比如用户请求资源A，A可以在接受请求后，在A上面做一些准备工作，再从A转发转发大都B，由B去响应例子。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/2.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/2.jpg" alt="img"></a><br>第一个request就是A的准备工作，第二个就是转发到B，由B去响应。</p><p>include不是转发，是包含某个资源，比如Servlet，JSP，HTML页面<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/3.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/3.jpg" alt="img"></a></p><hr><h3 id="八-HttpServletRequest，HttpServletResponse接口"><a href="#八-HttpServletRequest，HttpServletResponse接口" class="headerlink" title="八. HttpServletRequest，HttpServletResponse接口"></a>八. HttpServletRequest，HttpServletResponse接口</h3><p>继承ServletRequest，ServletResponse接口，用于处理一个HTTP格式的请求/响应<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/4.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/4.jpg" alt="img"></a><br>主要方法，setAttribute，getAttribute(继承得来的),getSession等等。Response同理。</p><hr><h3 id="九-HTTPSession接口"><a href="#九-HTTPSession接口" class="headerlink" title="九. HTTPSession接口"></a>九. HTTPSession接口</h3><p>创建一个HTTP会话。<br>方法主要是获取Session的参数(ID，creationTime，最长存在时间等等),以及setAttribute。。</p><p>HttpSessionBindingListener接口。HTTPSession监听器，添加到Session中，监听Session，此处是监听binding，绑定事件。<br>还有其他的Session的Listener，比如Attribute，Activation监听器。（也就是HttpSessionAttributeListener,HttpSessionActivationListener）</p><p>HttpSessionBindingEvent类，实现了HttpSessionBindingListener接口。只多了两个成员属性。<br>HttpUtils类，收集HTTP Servlet使用的静态的有效方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;在写SSM项目的过程中，遇到了一些小问题，不知道如何解决。其实对于框架的很多问题，很多时候都是因为框架的封装性，然后自身没有理解框架的内部逻辑而导致的。于是这次想花点时间好好读一下Servlet的源码，这样可以更好地理解JavaWeb底层，遇到问题也能更加地游刃有余。当然此次阅读源码只是比较浅显的，先看官方文档，然后在有目的性地读一部分源码来感受文档的内容。如果要认真看那肯定要看很久，目前还没这个时间。&lt;br&gt;    &lt;strong&gt;首先是Servlet API包含了两个软件包，javax.servlet和javax.servlet.http&lt;/strong&gt;，为什么会有两个呢，因为早先设计该规范的人认为Servlet是一种服务模型，不一定要依赖于某种网络协议之上，于是就抽象出了一个javax.servlet，同时再提供一个基于HTTP协议上的接口拓展。但目前看来，似乎还没有发现有其他协议上实现的Servlet技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Servlet" scheme="https://hongscar.cn/categories/Servlet/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>在vscode配置Java环境遇到的问题</title>
    <link href="https://hongscar.cn/%E5%9C%A8vscode%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://hongscar.cn/%E5%9C%A8vscode%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html</id>
    <published>2020-02-17T03:13:59.000Z</published>
    <updated>2020-02-17T06:20:12.587Z</updated>
    
    <content type="html"><![CDATA[<p>​        之前一直把vscode当作一个sublime的强化版，仅仅把它当作一个编辑器而已。虽然一直也清楚这是一个很好的IDE，但却没有好好利用，可能是因为之前一直觉得IntelliJ IDEA已经满足了我的需求罢。直到最近，IDEA真的是变本加厉，只要一输入（拿着键盘随便乱敲），那么CPU就会暴增。cpu暴增一般情况下倒没什么所谓，反正没有超100就行吧（刚打开的时候还真的会升到100），可是我这破电脑只要CPU稍微高一点，风扇就开始呜呜呜地，像一台发电机。明天等待工具到了真的要把它拆开来除一下灰尘，但无论如何，IDEA过于臃肿已经是显而易见的问题了，还是需要认真考虑一下如何使用vscode吧。说实话，真的没想到我这么快就会想跟IDEA说再见，还记得当时刚开始学C++，非要听信那个菜比老师，用vs2010，体验极差，而我竟然用了两年多。大二的时候开始学Java，一开始是使用Eclipse，感觉也是比vs2010提升了一个档次。后来接触到了IDEA，真的是感觉神仙一样的软件，各种智能补全。当然了，中途还因为学数媒的原因，下载了一个vs2013，那个的体验其实也很好的，反正真的应该大一的时候就直接用vs2013，而不是那脑残的vs2010。总而言之，技术永远是在进步的，需求也是在增加的，对于用户，程序员，都是一样的。</p><a id="more"></a>        其实还考虑过优化IDEA，但参照了一下网上的做法，无论是修改JVM参数，还是关闭所有代码检查，都无济于事。说实话，一开始也不抱什么希望，因为我是只要键入就会飙升，那真的不太行。<pre><code>然后开始搞vscode，突然想到了以前也尝试过，未遂。当时遇到的问题就是，它说我的JDK指向路径是空的，是version 0，可我指向的确切就是我一直使用的JDK8，我的IDEA都是在使用这个的。其实比较麻烦的是，我对vscode的各种参数，各种setting，包括快捷键，真的是几乎一无所知。当时仅仅也只是下载了几个plugins，当个普通的编辑器就完事了。最无奈的是，一直显示我没有配置JDK，或者准确地说应该是配置失败，但我直接使用一个Code Runner的插件时，直接使用alt+B就能成功运行了，可即便如此，还是不能直接点最上方的运行/ 调试，点了就报错。如果这个插件可以调试我可能就这样先暂时用着了，可是它似乎真的只能run，那只好继续处理。既然说是这个JDK有问题，那我便直接去下一个JDK吧，我下载了一个JDK12，修改了JAVA_HOME，重启电脑。结果发现java -version仍然是1.8。经过了许久的处理才发现，我以前在配置JDK的时候太过不求甚解了，导致遗留下来了很多错误。就是说，虽然这样做可以运行，但并不是正确的做法。比如JAVA_HOME其实就是用于存放JDK的一个路径，之后如果要放到ClassPath，或者Path等等的，都可以引用这个参数，%JAVA_HOME%，后面紧接着/bin，/lib等等的，差不多也就是可重用可维护了，以后如果要换JDK，直接改JAVA_HOME就行了。可我当时在ClassPath里使用了这个参数，在Path里却没有，说明当时根本就没有理解这个参数的作用。然后我把Path的绝对路径改成了JAVA_HOME，发现仍然不行。再仔细一看，原来这个根本就没有用上，因为上面还有3个不知道是什么的JavaPath，有什么AdoptOpenJDK，有Oracle commons files等等。在一台电脑上如果存在多个JavaPath，那么是最上方（win7应该就是最左方）的生效。所以我一直以为整台电脑都使用了的E盘的library下的JDK，原来根本就没有，我的环境变量竟然一直是OpenJDK，也就是说classpath跟path使用了两个不同的JDK罢了。把以前的蜜汁path都去掉之后，再把自己新增的%JAVA_HOME%/bin移动到了最上方，这下总算就成功了，java -version也成功改成了12。那么IDEA里一直用的1.8，会不会因此不能运行？答案是不会，因为IDEA根本就不需要环境变量的那个Path参数，那个是在cmd里，全局里生效的，相当于IDEA是在本地自己使用了另一个JDK。我一开始觉得JDK有点奇怪，使用java -verbose查看JDK路径，我还好奇为什么会是在C盘的一个OpenJDK里，原来是当时留下的各种错误啊。JDK总算配置好了，但vscode依然不能运行，显示不能找到主类。这会我又没有动脑子，直接去改参数瞎搞。其实这个问题我在看编程思想的第一章就应该碰到过了，因为vscode毕竟不是传统的IDEA，它本体就是一个编辑器，非常轻量级，只有40M，但它可以通过各种plugins来增强功能罢了。因此，可能就是vscode确实就是直接使用环境变量里的ClassPath跟Path，直接命令行运行程序的，而IDEA这种还有更多的改进。那么直接在cmd里编译运行java程序会有一个什么经典的问题呢，就是package。最开始学java 的时候都尝试过cmd里编译运行，结果有一天会发现，自己明明第一个程序在cmd里是可行的，但在eclipse或者IDEA把代码复制过去便是找不到主类的。唯一的区别便是package，package其实就是一个文件夹，对于javac，java命令，这个还没智能到直接跳入到相应的位置去执行正确的文件，所以当时我们的解决方案是这样的，直接删掉package语句，然后就可以运行了，但显然并不是长远之计，难道以后写的程序都不加package了吗？于是正经的方案是这样的，给命令增加一个-d参数，还有一个什么什么的，忘记了，然后就可以根据package语句进入相应的路径去执行正确的文件了。所以，在vscode里也是要对基本的命令进行修改，比如默认是java test，那么就改成 java -d …… test。所以最后是在settings里增加这段代码：</code></pre><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/vscode_1.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/vscode_1.png" alt="settings代码"></a><br>        进入相应的$dir，然后再进行javac跟java，那么就大功告成（看起来还是跟-d有所区别的）至于其他的注释，便是针对其他的语言，这里无须理会。最后把vscode进行reload，程序就成功运行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        之前一直把vscode当作一个sublime的强化版，仅仅把它当作一个编辑器而已。虽然一直也清楚这是一个很好的IDE，但却没有好好利用，可能是因为之前一直觉得IntelliJ IDEA已经满足了我的需求罢。直到最近，IDEA真的是变本加厉，只要一输入（拿着键盘随便乱敲），那么CPU就会暴增。cpu暴增一般情况下倒没什么所谓，反正没有超100就行吧（刚打开的时候还真的会升到100），可是我这破电脑只要CPU稍微高一点，风扇就开始呜呜呜地，像一台发电机。明天等待工具到了真的要把它拆开来除一下灰尘，但无论如何，IDEA过于臃肿已经是显而易见的问题了，还是需要认真考虑一下如何使用vscode吧。说实话，真的没想到我这么快就会想跟IDEA说再见，还记得当时刚开始学C++，非要听信那个菜比老师，用vs2010，体验极差，而我竟然用了两年多。大二的时候开始学Java，一开始是使用Eclipse，感觉也是比vs2010提升了一个档次。后来接触到了IDEA，真的是感觉神仙一样的软件，各种智能补全。当然了，中途还因为学数媒的原因，下载了一个vs2013，那个的体验其实也很好的，反正真的应该大一的时候就直接用vs2013，而不是那脑残的vs2010。总而言之，技术永远是在进步的，需求也是在增加的，对于用户，程序员，都是一样的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IDE" scheme="https://hongscar.cn/categories/IDE/"/>
    
    
      <category term="IDE" scheme="https://hongscar.cn/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>记一次服务器CPU100%的问题</title>
    <link href="https://hongscar.cn/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8CPU100%%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://hongscar.cn/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8CPU100%%E7%9A%84%E9%97%AE%E9%A2%98.html</id>
    <published>2020-02-17T03:13:34.000Z</published>
    <updated>2020-02-17T06:23:03.444Z</updated>
    
    <content type="html"><![CDATA[<p>PS：写在前面，这篇文章最后<strong>并没有解决</strong>服务器CPU100%的问题，仅仅是记录在尝试过程中学到的知识点。</p><p>​    今天原本打算使用redis连接项目，正好网站备案通过了，正打算先测试一下域名是否可用，结果反而整个项目都不可用了。想着应该又是tomcat那边的问题，先上服务器看了一下，感觉服务器的卡顿越来越厉害了，时不时就会卡住然后断开连接。想想腾讯云也不至于这么烂，于是查了一下原因。虽说最后没有解决，但当中的过程还是学习到了很多。目前先把出错的服务器保存了一个snapshot，然后对服务器进行重载。先把这个问题放下，以后再回去解决。（主要是我数据库没有进行备份，数据还在上面，而数据库也出问题了，完全无法connect，自然也无法备份了。但保存了snapshot，那么数据库文件还在里面，等到需要那部分数据的时候，就对snapshot进行载入，然后再修复错误去获取数据吧，现在先放下这个问题）</p><a id="more"></a>    首先就是先运行了一下top命令，意外地发现%id为0，即CPU idle space为0，也就是CPU使用率竟然是100？那肯定是出现问题了，而且这样的话断开连接也不足为奇了，那么CPU 100%到底是从什么时候开始的，先查看了一下腾讯云的监控记录：<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_1.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_1.png" alt="腾讯云的监控记录"></a></p><p>​    （吃惊）竟然一直是100的？我服务器上也没运行几个程序，也就一个tomcat（而且因为网站备案的原因，甚至直接stop了），还有mysql跟redis，但又没有事务读写，怎么会出现问题呢？于是我调了一下时间，调到5月初直到现在，看看是否一直都是100，还是在什么时候变成了100：</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_2.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_2.png" alt="更久之前的监控数据"></a></p><p>把鼠标指到确切的转折点，可以看到，是8月30号这天开始飙升的，而且之后就一直高居不下，那么8月30那天我在服务器上做了什么呢。翻了一下日记，我在8.30这天学习了Redis，也就是在服务器上装了Redis。虽说没什么道理，但确实如此，没有任何其他理由。等一下我还要在我刚刚重装的服务器上安装mysql跟redis，看一下还会不会出现100的问题。如果会，再重装，只安装redis。虽说后面会换另一台服务器去单独做MySQL跟redis服务器，但这个问题肯定还是要解决的。</p><hr><p>那么在解决的过程我使用了哪些命令，又遇到了哪些子问题，继续去处理的，现在列一个清单。</p><p>①首先去查询top的用法<br>top命令虽然是我实习的时候用得最熟练的命令，但时间过去太久了，我也记不清它的很多数值是什么意思。然后知道了%Cpu就是CPU的使用情况，其中：%us表示用户空间程序的CPU使用率，%sy表示系统（Kernel）的CPU使用率，%ni表示用户空间且通过nice调度过的程序的CPU使用率。<br><em>CPU time = user space time + system space time</em><br>至于nice调度，其实就是进程的优先级，大致先知晓即可。<br>%id：空间的CPU（我就是这里一直是0，也就是idle space为0，CPU使用率100）</p><p>②除了CPU，还有可能是内存的问题<br>    对着top使用回车（刷新），发现CPU idle space很奇怪，会变化，而且要么是0，要么是100，显然是出现了一个错误的进程，然后突然导致100，而且还是一直生成，短暂过后又结束。最坑的是，使用top并找不到一个高CPU使用率的进程，所以完全不理解为何是100？可能是top显示的只是用户进程，不显示系统进程？<br>    于是继续对磁盘进行查看，使用了df -h命令。图片没有存，但大概是，磁盘空间大小是50G，已经使用了41G。虽然安装软件的时候没有想太多，但毕竟只安装了几个软件，不至于这么大的空间，因而对这块还是存有疑惑。然后再查看了腾讯云的磁盘监控（对了，腾讯云的监控出错了，然后还得执行一段命令才能查看，但就是很简单地copy执行一次即可，就在腾讯云官方上的代码）。最后的磁盘监控结果是这样的：</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_3.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_3.png" alt="磁盘监控结果"></a></p><p>当时的磁盘读写一直很大，我就猜测是MySQL出现了错误，然后一直在编写错误日志？</p><p>③处理MySQL中的问题<br>    首先，我当时安装MySQL并没有直接安装服务service，这确实不是一个好的选择，tomcat也是如此。平时偶尔想对服务进行处理，使用systemctl，结果显示没有此service。然后还得去安装路径里自己调用shell脚本，然后还得找到这个安装路径，又是locate又是find，又是whereis的。<br>    然后想先看一下错误日志在哪，以往每次打开文件都是vim，实际上用head跟tail是一个很好的选择。不然突然一下子出现一大串文字的体验也是很差劲的。<br>    不过尝试了很多次，都无法彻底关闭mysql。这也就是安装法的最差劲的地方吧。找到了mysqld进程，都直接kill -9了，依然没有用处。如果是安装服务，直接systemctl stop即可。</p><p>④其他命令<br>因为top没有看到高CPU利用率的进程，于是还尝试了一些其他命令。<br>vmstat：查看系统负载<br>pidstat：查看进程使用磁盘的情况<br>pidstat -d 1：<br>netstat -na | grep 80 查找<em>80</em> 的端口（看是否开放，正在使用）</p><p>⑤finally<br>    其实没有解决问题，所以只能用最笨的方法，重装系统。虽然重装系统很快，一分钟就结束了，但还是很不好。首先必须得对服务器进行snapshot备份，毕竟数据库的数据也取不出来（感觉出错的原因主要就是MySQL跟redis的错）。然后数据至少存在了snapshot当中，等到需要那部分数据或者有空的时候，再new一个服务器去尝试解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：写在前面，这篇文章最后&lt;strong&gt;并没有解决&lt;/strong&gt;服务器CPU100%的问题，仅仅是记录在尝试过程中学到的知识点。&lt;/p&gt;
&lt;p&gt;​    今天原本打算使用redis连接项目，正好网站备案通过了，正打算先测试一下域名是否可用，结果反而整个项目都不可用了。想着应该又是tomcat那边的问题，先上服务器看了一下，感觉服务器的卡顿越来越厉害了，时不时就会卡住然后断开连接。想想腾讯云也不至于这么烂，于是查了一下原因。虽说最后没有解决，但当中的过程还是学习到了很多。目前先把出错的服务器保存了一个snapshot，然后对服务器进行重载。先把这个问题放下，以后再回去解决。（主要是我数据库没有进行备份，数据还在上面，而数据库也出问题了，完全无法connect，自然也无法备份了。但保存了snapshot，那么数据库文件还在里面，等到需要那部分数据的时候，就对snapshot进行载入，然后再修复错误去获取数据吧，现在先放下这个问题）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://hongscar.cn/categories/Linux/"/>
    
    
      <category term="Debug" scheme="https://hongscar.cn/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>关于链表的一些疑惑</title>
    <link href="https://hongscar.cn/%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E6%83%91.html"/>
    <id>https://hongscar.cn/%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E6%83%91.html</id>
    <published>2020-02-17T03:13:20.000Z</published>
    <updated>2020-02-17T06:19:44.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>​        链表想通的时候，感觉很简单，比数组还简单，只需要维护一个next指针，然后对指针进行操作即可。但有的时候也会遇到想不通的情况，这时候即便是非常简单的问题，都很难解决。所以这篇文章总结一下链表可能遇到的疑惑，下次遇到的时候查阅即可，无须每次都进行艰难的debug。</p><a id="more"></a><h5 id="当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？"><a href="#当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？" class="headerlink" title="当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？"></a>当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？</h5><p>出现这个疑惑是在一个非常简单的题目：<strong><em>反转一个链表</em></strong>。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" target="_blank" rel="noopener" title="反转链表"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" alt="反转链表" title="反转链表"></a><br>当时就觉得很奇怪，理应是非常简单的，却感觉不会做，画了很久的图，最后还用了4个指针才完成了，代码也是略显复杂。然后一看标准答案，果然跟预期的一样，十分简洁，但当时没有深究，于是后面总是要还的。因为一个地方不明白，后面肯定还会出现，这时候只会更加麻烦。<br>接下来看一下当时看不懂的标准答案：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" target="_blank" rel="noopener" title="答案"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_2.png" alt="答案" title="答案"></a></p><p>当时的疑惑很简单，curr.next指向了prev，但紧接着，prev就又发生了改变，那么curr.next不会改变吗？这看起来有点违反直觉，一开始觉得应该是二者指向了相同的地址，然后地址发生了改变，二者也就同时改变，但其实并不是这样的。这里最关键的就是引用的概念了。这里实际上是两个引用，curr.next跟prev，而curr.next = prev表示的是，curr.next指向了prev引用指向的对象。之后prev指向了其他的对象，并不会对curr.next造成影响。</p><hr><p>但是有的地方看起来是会发生改变，为什么？<br>首先要确定，到底改变的是对象，还是一个引用指向了其他的对象。<br>立刻想到的就是遍历，移除某个元素的例子：（移除所有val等于某个值的结点）</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" target="_blank" rel="noopener" title="链表移除某个元素的例子"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_3.png" alt="链表移除某个元素的例子" title="链表移除某个元素的例子"></a></p><p>这里对current操作，最后为什么head也会改变？<br>首先解答一个很简单的问题，为什么要有current，而不是直接在head上操作。因为我们在中间会将current后移（current = current.next)，这就导致了我们最后如果返回的是current，那么current已经移到了最后，即使前面的结果是正确的，也没有意义。<br>为什么要提这个问题？因为我一开始对于这个就想错了。我最开始对current引用的理解是，在current上操作，避免对head发生改变。但我们确实就是希望head发生改变啊，毕竟我们最后返回的就是改变后的head。所以我们确实就是通过current指向了head，然后改变current的中间结构，同时也成功地改变了head的中间结构，但我们要获取最终的链表，那么就需要获取头结点，所以才不对head进行操作。所以我们仅仅是保留了最初的头指针而已，如果上面的答案，是对head操作，最后返回的是current，作用也是一样的。<br>接下来就是问题的关键了，那么为什么会跟着改变？看起来current只是一个对象的引用罢了。这就是引用跟对象的区别了，这里的current确实是一个引用，但current.next却是一个实打实的存在于内存中的对象。所以，current.next = current.next.next，是直接在对象上发生改变，那么自然head.next(也就是现在的current.next）也会跟着改变了。而current = current.next，就是引用指向了其他的对象，也就是current引用指向了current.next。由于是引用指向了其他对象，那么显然也不会对head发生改变了。（所以关键就是确定到底是改变引用指向，还是改变对象）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;​        链表想通的时候，感觉很简单，比数组还简单，只需要维护一个next指针，然后对指针进行操作即可。但有的时候也会遇到想不通的情况，这时候即便是非常简单的问题，都很难解决。所以这篇文章总结一下链表可能遇到的疑惑，下次遇到的时候查阅即可，无须每次都进行艰难的debug。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Datastructure" scheme="https://hongscar.cn/categories/Datastructure/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>关于Mysql的optimize语句</title>
    <link href="https://hongscar.cn/%E5%85%B3%E4%BA%8EMysql%E7%9A%84optimize%E8%AF%AD%E5%8F%A5.html"/>
    <id>https://hongscar.cn/%E5%85%B3%E4%BA%8EMysql%E7%9A%84optimize%E8%AF%AD%E5%8F%A5.html</id>
    <published>2020-02-17T03:13:08.000Z</published>
    <updated>2020-02-17T06:19:29.178Z</updated>
    
    <content type="html"><![CDATA[<p>看到了一个optimize的语句，想尝试一下，但发现这个语句默认只在MyISAM引擎的表上执行，在InnoDB可能会出现错误，于是的确出现了错误：<br><em>Table does not support optimize, doing recreate + analyze instead</em></p><p>查找网上的解法，看到了这篇文章:<a href="https://blog.csdn.net/e421083458/article/details/39522513" target="_blank" rel="noopener">https://blog.csdn.net/e421083458/article/details/39522513</a><br>看样子是只需要在启动mysqld进程的时候，增加—skip-new参数即可。但下面还要一个shell脚本一键完成，因此想先尝试shell脚本。</p><a id="more"></a><p>可是发现在shell脚本里仍然不可执行，网上有说即使是用户root，可能也会因为一些错误而导致并非100%具备root的权限，因此尝试改了一下权限（权限在mysql.user表中），仍然不行。</p><p>无奈，只好使用第一种方法了。由于不是用systemctl启动的mysql，因此需要找到mysqld的启动进程我感觉以后装service还是直接装服务类型的程序，而不是用.sh文件启动的服务，那个太麻烦了（主要是我没有去刻意记住程序的位置，每一次都要locate，whereis去定位文件位置）。</p><p>然后发现关闭失败，即使找到process ID，kill -9，也无法关闭。然后我发现了一个很好的mysql管理命令：<code>mysqladmin -u root -p command</code><br>即使用root用户去运行mysql的某个“command”，启动命令之后先输入password，即可执行。<br>然后这里是关闭，所以是：mysqladmin -u root -p shutdown。没有显示异常。<br>再查找一下mysqld是否还存在：ps aux | grep mysqld，确实不存在了。<br>再在本地的navicat尝试连接数据库，连接失败。好了，数据库确实关闭了。</p><p>接下来我们启动mysqld，直接进行/xxx/xxx/mysqld 仍然显示错误，需要用root权限去启动，就跟直接调用shutdown时候出现的错误一样，那就简单了，直接继续用mysqladmin即可：<br><code>mysqladmin -u root -p /xxx/xxx/mysqld —daemin=xxx —skip-new</code><br>结果发现竟然不可以，推测是mysqladmin只能直接调用相关命令？其实增加参数肯定是可以的，但我不会啊！emm，那么换种思路，直接在调用mysqld脚本的时候增加user参数就好辣，于是：<br><code>/usr/sbin/mysqld —deamonize —pid-file=/xxx/xx/xx/xxx/mysqld.pid —skip-new —user=root</code><br>然后就启动成功了（其实刚刚shutdown的时候也直接加这么个参数就行了吧）</p><p>既然已经重新使用—skip-new参数去启动mysqld了，那么应该就能使用optimize命令了？</p><p>回到本地，用navicat继续调用optimize table <code>article</code>; 结果，竟然还是不行。错误信息：<br><em>[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column ‘information_schema.PROFILING.SEQ’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by”</em></p><p>然后发现原因是这个：<br><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/optinnodb_1.png" alt="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/optinnodb_1.png)"><br>即navicat的版本问题？！那么就直接在服务器上执行一遍吧。</p><p>然后再服务器上optimize table，果然没有任何错误。成功执行。（虽然只是个简单的命令，还是折腾了许久）<br>关于optimize的作用：当 您的库中删除了大量的数据后，您可能会发现数据文件尺寸并没有减小。这是因为删 除操作后在数据文件中留下碎片所致。Discuz! 在系统数设置界面提供了数据表优化的功能，可以去除删除操作后留下的数据文件碎片，减小文件尺寸，加快未来的读写操作。您只要在做完批量删除，或定期（如 每一两个月）进行一次数据表优化操作即可。</p><p>参考链接：<br><a href="https://www.cnblogs.com/Alight/p/3585646.html" target="_blank" rel="noopener">https://www.cnblogs.com/Alight/p/3585646.html</a><br><a href="https://blog.csdn.net/chuixue24/article/details/86624792" target="_blank" rel="noopener">https://blog.csdn.net/chuixue24/article/details/86624792</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到了一个optimize的语句，想尝试一下，但发现这个语句默认只在MyISAM引擎的表上执行，在InnoDB可能会出现错误，于是的确出现了错误：&lt;br&gt;&lt;em&gt;Table does not support optimize, doing recreate + analyze instead&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;查找网上的解法，看到了这篇文章:&lt;a href=&quot;https://blog.csdn.net/e421083458/article/details/39522513&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/e421083458/article/details/39522513&lt;/a&gt;&lt;br&gt;看样子是只需要在启动mysqld进程的时候，增加—skip-new参数即可。但下面还要一个shell脚本一键完成，因此想先尝试shell脚本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://hongscar.cn/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis笔记</title>
    <link href="https://hongscar.cn/Redis%E7%AC%94%E8%AE%B0.html"/>
    <id>https://hongscar.cn/Redis%E7%AC%94%E8%AE%B0.html</id>
    <published>2020-02-17T03:12:55.000Z</published>
    <updated>2020-02-17T03:28:21.548Z</updated>
    
    <content type="html"><![CDATA[<p>chapter1.</p><p>Redis没有表和Schema（Schema就是数据库对象的集合，这个集合包含了各种对象如：表、视图、存储过程、索引等</p><p>Redis用 key-value存储数据，所有的key必须是string类型</p><p>Redis的命令不区分大小写，但存储的数据区分（包括key-value）</p><a id="more"></a><p>chapter2.</p><p><strong>数据类型：（一个key只对应一种类型的value）</strong></p><p>1.string        </p><p>（关于双引号，应该默认是字符串，加引号保证空格的存在。单引号也可以）</p><p>SET    执行成功返回OK</p><p>（如果键值已经存在，那么覆盖先前的值。可以用EXIST命令来测试key的存在性。也可以用SETNX，即当key不存在时set。 set if not exist。如果设置成功，SETNX返回1.否则返回0）</p><p>命令选项：NX，XX（存在时候才set）</p><p>从Redis 2.6.12版本开始，SET命令的行为可以通过一系列参数来修改：</p><p>EX second：设置键的过期时间为second秒。SET key value EX second效果等同于 SETEX second value</p><p>PX millisecond： 设置键的过期时间为millisecond毫秒。SET key value PX m == PSETEX m value</p><p>NX：只有在键不存在时，才对键进行设置操作。SET key value NX == SETNX key value</p><p>XX：只有在键存在时，才对键进行设置操作。</p><p>选项例子：</p><p>redis 127.0.0.1:6379&gt; SET not-exists-key “value” <strong>NX</strong> OK      # 键不存在，设置成功</p><p>redis 127.0.0.1:6379&gt; SET exists-key “value” <strong>XX</strong></p><p># EX 和 PX 可以同时出现，但后面给出的选项会覆盖前面给出的选项 redis 127.0.0.1:6379&gt; SET key “value” <strong>EX 1000 PX 5000000</strong> OK</p><p>redis 127.0.0.1:6379&gt; SET key-with-expire-and-NX <strong>“hello” EX 10086 NX</strong> OK            //我猜是EX时hello。NX时10086</p><p>GET    不存在时返回    (nil)</p><p>STRLEN    计算字符串长度</p><p>APPEND    向一个字符串末尾追加字符串。如果该字符串不存在，先新建一个空字符串，再append</p><p>SETRANGE     参数： stringA， int， stringB</p><p>对stringA从偏移量int开始，直到结尾，用stringB替换（偏移量从0开始）</p><p>同理，如果stringA不存在，也是先new一个空字符串。如果int为0，那么就是new。</p><p>如果int不为0，前面的字符为 \x00     (好像是C++里的空字符）</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\7edf3f2832d645dca2c218773e8e0077$5pwjcaa(}cs.png)</p><p>\xhh表示十六进制，\x00 == 0x00， \x77 == 0x77。代码的作用应该就是看一下res地址对应的起始两个字节的值是否为0x00和0x77，对应于ascii字符的NULL和w。</p><p>OBJECT命令：可以查看value的内部编码形式    使用形式：OBJECT ENCODING stringA</p><p>（OBJECT还有其他功能，略）</p><p>string的三种编码形式：</p><p>①<strong>int</strong>。存储64位有符号整数表示的字符串</p><p>②<strong>embstr</strong>。长度小于等于44子节点字符串（使得在内存使用和性能方面更有效率）</p><p>③<strong>raw</strong>。长度大于44字节的字符串</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\801aa6d8307c4dea977870465435f2f2\clipboard.png)</p><p>2.列表 list    （就是stack，queue，array等等的）</p><p>LPUSH     key1     value1    value2</p><p>往 key1中添加 value1，value2值。返回添加元素之后key1的值。</p><p>如果key1已经存在，就是在后面继续添加，反之新建再insert</p><p>RPUSH    (将value添加到list的右端）</p><p>LINSERT         key1     BRFORE / AFTER        value1</p><p>添加到value1的前面/后面</p><p>只有当list存在才添加。 LPUSHX, RPUSHX</p><p>LRANGE        获取一定范围里的value</p><p>LRANCE     key1    int1        int2</p><p>即获取int1 ~ int2中的元素。index从0开始（跟数组一样）</p><p>（如果int2为 -1，表明读到结尾。所以 [0, -1] 就是输出所有value。</p><p>[2, -1]就是从第3个元素开始，输出到结尾）</p><p>获取某个index下的value：</p><p>LRANCE     key1    index1        index1     即可。</p><p>也可以： LINDEX       key1    index    </p><p>LPOP        RPOP        删除一个元素</p><p>list的index定义：从左到右： 0 ~ N - 1    从右到左：    -1 ~ -N</p><p>（所以0 ~ -1 表示整个列表）</p><p>​    </p><p>LTRIM    key1    int1        int2</p><p>删除key1中int1 ~ int2 之外的value</p><p>例子：LTRIM    key1    1    -1</p><p>即删除index为1到结尾以外的所有元素，即，只删除index为0的元素</p><p>LSET     key1    int        value</p><p>设置index为int的值，更改为value</p><p>LPOP和RPOP有对应的阻塞版本，即当list为空时，阻塞版本会将客户端阻塞。</p><p>BLPOP        BRPOP</p><p>同时还要设置超时时间，如果为0，表示永久等待。（在任务调度场景十分有用）</p><p>例子：</p><p>worker1&gt;        BRPOP     que1    0</p><p>worker2&gt;        BRPOP     que1    0</p><p>两个终端，阻塞执行。</p><p>此时对que1添加一个value1，worker1先执行，解除阻塞，把value1删除。</p><p>然后再对que1添加value2，value3，此时worker2解除阻塞，把value2删除。</p><p>最后que1里剩下了value3(先添加value2，立即删除，所以是剩下value3）</p><p>3.哈希 HASH 类型</p><p>相当于Map类型，即key里面还存储了其他的key-value，但存储实现方式是hashing。</p><p>（Redis本身其实就相当于一个hash。Redis的数据对象也可以再次使用hash，只要字段和值都是string类型。为了与Redis的key区分，hash里的“key-value”应该说成    “field-value”）</p><p>HMSET    key1    field1    value1    field2    value2    ……</p><p>设置多个hash字段，以及属性。（其实field-value集就是key1的value）</p><p>HMGET    key1    field1    field2    ……</p><p>获取多个hash的value</p><p>HGET    HSET    （获取/设置单个）</p><p>HEXISTS        是否存在某个字段</p><p>HGETALL    获取所有field和value    （阻塞，hash特别大时会导致Redis阻塞）</p><p>HDEL    删除field</p><p>可以用HSCAN替代HGETALL，此处略。</p><p>4.集合    SET类型</p><p>集合，SET，与Java一样，唯一，无序。（可用于去重）</p><p>SADD    添加</p><p>SISMEMBER    测试一个value是否在SET中</p><p>SREM    删除</p><p>SCARD    获取集合中成员的数量</p><p>SMEMBERS    列出所有value</p><p>同理，SMEMBERS会导致阻塞，可以改用SSCAN。略</p><p>集合间的操作：     SINTER        KEY        [KEY …]    交集</p><p>​    SUNION    KEY        [KEY …]        并集</p><p>​     SDIFF        差集</p><p>将集合运算的结果保存到K中：SINTERSTORE  K   KEY  [KEY…]</p><p>SUNIONSTORE    SDIFFSTORE</p><p>SET的编码，有两种方式：</p><p>intset    ：    对于value全是整数，且元素个数小于set-max-intset-entries时(默认为512）</p><p>（可以节省占用空间）</p><p>hashtable：    intset不适用时的默认编码</p><p>5.有序集合    SORTED SET类型</p><p>有序。    实现方式为：每个value还要拥有一个用于排序的权重。</p><p>ZADD    key1    weight1    value1    weight2    value2 ……    添加。</p><p>（与SET命令类似，可以使用NX,XX等选项）</p><p>ZREVRANGE        key1    int1        int2        [WITHSCORES]</p><p>获取排序。int1 ~ int2的value，0 ~ -1 即整个，和list一样。</p><p>WITHSCORES可选，表示 是否要列出 weight权重。</p><p>ZINCRBY    key1    int    value1</p><p>给value1的权重增加int</p><p>ZREVRANK    key1    value1</p><p>获取value1的排名（第一为 0）</p><p>ZSCORE        key1    value1</p><p>获取value1的权重</p><p>ZUNIONSTORE    合并两个SORTED SET。略</p><p>ZRANGEBYSCORE   key   MIN   MAX(从小到大），    ZREVRANGEBYSCORE</p><p>ZCOUNT KEY MIN MAX（指定范围内的成员个数）</p><p>集合之间的操作：ZINTERSTORE, ZUNIONSTORE    (没有ZDIFFSTORE, ZUNION）</p><p>6.HyperLogLog （HLL）类型</p><p>唯一计数类型。虽然可以用SET来计数，但需要考虑内存消耗和性能下降问题。</p><p>如果我们不需要获取SET的内容，只想获得不同value的个数，就可以考虑用HLL</p><p>PFADD    添加</p><p>PFCOUNT     统计数量</p><p>PFMERGE    添加多个</p><p>HLL对象的两种存储方式：</p><p>Sparse（稀疏）：对于长度小于hll-sparse-max-bytes（默认为3000）的HLL，采用此。</p><p>（存储效率更高，但可能会消耗更多的CPU资源）</p><p>Dense（稠密）：当Sparse不适用时。</p><p>7.Geo类型</p><p>存储地理位置相关的数据类型</p><p>GEOADD,    GEOPOS（获取），    GEODIST(比较距离）</p><p>等等。略</p><p>key的管理。</p><p>DBSIZE:    显示数据库的size，即数据库一共有多少个key</p><p>获取所有的key：</p><p>KEYS *</p><p>scan 0</p><p>KEYS的后面的参数是 正则表达式，scan后面的参数是cursor，游标，不懂。</p><p>删除key：</p><p>DEL        UNLINK        </p><p>(二者都可以同时删除多个，并且返回删除的key数量）</p><p>UNLINK主要用于执行大KEY的异步删除（即非阻塞？）当删除string以外的数据类型，当数量很大时，很可能导致服务器延迟，此时应该用UNLINK（UNLINK会在另一个线程，而不是主事件循环线程中执行删除操作，因此不会阻塞事件的处理。）</p><p>EXISTS    判断是否存在某个key</p><p>TYPE    获取key的（值）数据类型</p><p>RENAME        former_name        new_name    重命名</p><p>迁移键      （其实这些比较复杂少用的，到时要用到肯定还是上网查的，目前还没用到死记硬背真的没必要！倒是几种基本类型的常用操作确实值得记忆一下！）</p><p>①MOVE  KEY  DB    （redis内部可以有多个DB，用于内部迁移。但一般一个数据库即可！</p><p>②dump + restore</p><p>③migrate</p><p>（只需知道②是非原子性的，而③是原子性的即可！）</p><p>遍历键：keys ，或者scan（渐进式，游标。。）</p><p>关于多数据库，实际上是一个废弃的功能。并不能实现0号数据库是正式数据库，而1号数据库是测试数据库等等的想法。Redis已经在逐渐弱化这个功能，例如Redis的分布式实现Redis Cluster只允许使用0号数据库，留着只为了向下兼容。而且因为Redis是单线程的，所以使用的还是一个CPU，如果其中一个存在慢查询，那么依然会影响其他数据库（甚至会导致业务问题的定位非常困难）</p><p>PS:如果真的要使用多个数据库的功能，完全可以在一台机器上部署多个Redis实例，彼此之间使用端口号来进行区分（计算机一般有多个CPU，这样既保证了业务之间不会受到影响，又合理地使用了CPU资源）</p><p>清除所有数据：flushdb，flushall（后者是清除所有数据库） 慎用，会把所有数据都删掉，而且会阻塞。别乱用。！！！</p><p>chapter3.</p><p>数据特性：</p><p>1.位图 bitmap</p><p>(也称位数组或位向量），是由比特位bit组成的数组（其值只有0或者1）可用于记录每个用户是否属于某个表（使用过某个功能）等等。</p><p>（bitmap并不是一种新的数据类型，它实际的底层数据是字符串。）</p><p>-————————–</p><p>bitmap vs SET</p><p>显然，bitmap用于计数，而SET也可以，那么二者有什么区别呢？</p><p>对于bitmap：无论用户是否使用过某个功能，每个用户都需要占用bitmap中的1个比特（0/1）</p><p>对于SET：假设另起一个8字节的整型来存储用户ID（表示使用过某个功能），那么只有当用户使用过该功能，才需要存储该用户ID（一个ID 8字节）</p><p>假设有20亿个用户，某功能有80%的用户使用过。那么：</p><p>对于bitmap：需要在内存中分配20亿个bit，即大约250MB</p><p>对于SET：需要 20e x  80%  x  8   大约是12.8G</p><p>结论：当一个功能比较流行，更密集，即如果使用bitmap，1的概率更大的时候，用bitmap更好。反之，如果一个功能比较稀疏，使用人数较少，那么直接使用SET会更好（比如上述例子改为1%）</p><p>-—————————</p><p>SETBIT     key1    value1    1 / 0</p><p>对key1的value1设置相应的bit值，0或者1</p><p>GETBIT    key1    value1</p><p>查询value1对应的bit值，返回0或者1</p><p>BITCOUNT    key1</p><p>查询key1中所有的value，bit为1的个数。</p><p>BITOP    [OPERATOR]        result    key1    key2</p><p>BITOP用于进行位操作，包括：AND,OR,XOR,NOT（NOT只需要指定1个key，其他2个）</p><p>即对key1和key2进行位操作，然后将结果存储在result键中。</p><p>2.设置key的过期时间</p><p>除了使用DEL或者UNLINK删除key，还可以通过设置key的超时时间让Redis自动地删除key</p><p>EXPIRE        key1    int</p><p>将键key1的超时时间设置为int</p><p>TTL        key1</p><p>查看key1在过期前的剩余时间。</p><p>如果该key并没有过期时间，那么将返回-1.</p><p>如果该key已经过期，那么将返回-2</p><p>当key过期之后是否立刻删除？</p><p>并不，但当客户端试图访问过期key时，Redis会立即将其从内存中删除。（被动过期）</p><p>而对于那些已经过期但还没被访问的key，有一个基于概率的算法来进行主动删除。（略）</p><p>当发现有太多已经过期的key没有被删除时，可以通过执行SCAN命令来触发被动过期</p><p>如何清除一个key的过期时间？</p><p>1.PERSIST        使一个key成为持久的key</p><p>2.当key的value被替换或者删除。包括SET,GETSET, *STORE等等的命令会清除过期时间</p><p>（但修改list，set，hash的元素并不会清除过期时间，因为修改元素的操作并不会替换key所关联的值对象）</p><p>3.被另一个没有过期时间的key重命名</p><p>3.SORT命令</p><p>当我们需要获取一个Redis列表或者集合的已排序副本，或者以某种非权重的顺序对SORTED SET中的元素进行排序时候，就需要用到SORT命令</p><p>SORT key1        对    list    /    set/    sorted set 进行排序</p><p>（默认只能对数字排序，int/ double）</p><p>对于字符串，需要加ALPHA修饰符。</p><p>SORT key1    ALPHA</p><p>SORT    key1    ALPHA    LIMIT    int1        int2</p><p>排序之后，获取int1 ~ int2的元素。（index从0开始）</p><p>除了默认数字排序以及ALPHA，还可以通过其他key的权重来进行排序。</p><p>SORT     key1    BY    key2~x（用通配符表示多个）</p><p>（此处key2的value，hong123_104 &gt; hong123_455 &gt; hong123_333 &gt; 200 &gt; 365）</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\ab95885bd2bc4ec9bbadda92013433f6\clipboard.png)</p><p>用处：</p><p>比如A_userid是一个用户的记录。 count_userid是一个用户的使用次数。（每一个userid都有对应）</p><p>那么当我们需要对A_userid的value进行排序（里面的value并不是使用次数，比如，是消费总额），而我们是希望通过“使用次数”这个属性来排序，那么就用到了 BY 修饰符。</p><p>SORT     key1     BY        key2*    DESC/ASC(默认ASC）GET    xxx        STORE    key3</p><p>GET选项：表示要获取哪一个类型的值，比如是key2，key1里的*，而不一定是value</p><p>（GET可使用多次）</p><p>STORE选项：把GET得到的结果存储到key3</p><p>4.管道    pipeline</p><p>Redis客户端与服务端使用RESP协议进行通信，大致的通信过程如下：</p><p>1，客户端向服务端发送一个命令</p><p>2，服务器接受该命令并放入执行队列（Redis是单线程的执行模型）</p><p>3，命令执行</p><p>4，服务器将命令执行的结果返回到客户端</p><p>第2，3步耗费的时间取决于Redis服务器（一般较短），主要的时延还是1，4步的网络传输。</p><p>使用pipeline好处：客户端将多个命令打包在一起，并将它们一次性发送，而不再等待每个单独命令的执行结果。同时，pipeline是在服务器执行完所有的命令后再返回结果。</p><p>因此即使是执行多个命令，第1，4步也只发生一次，所以总的执行时间会大大减少。</p><p>使用方法：在Redis-cli中加入    –pipe选项</p><p>5.Redis事务        transaction</p><p>关键命令：</p><p>MULTI：用于组装一个命令，表示命令的开始部分。</p><p>EXEC：用于执行一个事务</p><p>DISCARD：取消事务</p><p>WATCH：用于监视key。当这些key在事务执行之前发生改变，那么事务将被取消。</p><p>Redis事务与关系数据库事务的区别：Redis事务没有回滚。</p><p>所以当所有正确的命令入队列之后，如果在执行过程发生错误，位于发生错误命令之后的其他命令将继续执行，而不会回滚。</p><p>6.发布订阅    PubSub</p><p>即终端分为了发布者和订阅者。订阅者可以订阅指定的频道（发布者），当发布者发送信息时，会一次性发送给所有的订阅者，同时发布者也可以单独给某位订阅者发送信息（类似公众号的模式）</p><p>命令：</p><p>SUBSCRIBE    订阅        (如果该频道从未被订阅过，那么会自动创建该频道）</p><p>UNSUBSCRIBE    取消订阅</p><p>PUBLISH        发布信息（一个发布者可以是多个频道的所有者，因此需要选择发布到哪个频道）</p><p>7，Lua脚本</p><p>略</p><p>chapter4.</p><p>Redis常用场景：</p><p>1.存储Session。</p><p>Session一般存储在外部存储系统，如果一个web服务器宕机，其他服务器仍然可以从外部存储中获取Session并继续服务。而与关系数据库相比，Redis的访问延迟非常低（存储在内存），所以用于存储Session非常合适。同时Redis的对key过期机制非常契合Session的有效期。</p><p>2.分析，排行，队列，最新的N个记录等等</p><p>这些功能使用SQL也可以做到，但SQL查询要比Redis查询慢得多。</p><p>3.缓存</p><p>因为Redis是基于内存的数据存储系统，所以在关系数据库前面增加Redis作为缓存，通常能够加速数据库的查询过程。</p><p>例如，在查询关系数据库之前，先在Redis中查找记录。如果找到就直接使用，如果找不到就从关系数据库中查找，并将记录放置到Redis中。在向关系数据库写入时，我们也将记录写入Redis。同时为了限制缓存的大小，可以设置过期时间，或者LRU等等的收回策略。</p><p>Redis的缺点：</p><p>因为Redis默认将全部数据都放在内存中，所以Redis的容量有限，不能作为单一的数据库来存储大量的数据（虽然有一些基于云的Redis提供了使用SSD作为数据存储后端的选项）。</p><p>其次，因为Redis事务并不完全符合关系数据库的ACID规范。如果要使用完全符合ACID规范的事务，就不能使用Redis。</p><p>其他命令：</p><p>FLUSHALL：删除所有的数据库的所有keys。</p><p>CONFIG SET XXX XX    设置conf配置文件，将XXX的属性值改成XX</p><p>同理还有 CONFIG GET XXX</p><p>INFO MEMORY    查看Redis的内存使用情况</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\2d1e6c0c369b432aa5976bc06ebecf77\clipboard.png)</p><p>普通Java程序使用Redis：使用Jedis即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring程序使用Redis：<a href="https://blog.csdn.net/Evankaka/article/details/50396325" target="_blank" rel="noopener">https://blog.csdn.net/Evankaka/article/details/50396325</a></p><p>依赖包，除了redis.clients，还需要：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>chapter5：</p><p>Redis复制，从一个Redis服务器，将data全部复制到另一个。略    INFO REPLICATION</p><p>chapter6：</p><p>由于Redis是在内存中存储数据的，所以当服务器重新启动时，所有的数据都将丢失。所以我们需要：像上一章一样复制复制备份到另一个服务器，或者持久化到disk。</p><p>持久化到磁盘的机制：RDB, AOF</p><p>RDB：可以看做是Redis在某一个时间点上的快点（snapshot），适合于备份和错误恢复</p><p>AOF：一个写入操作的日志，将在服务器启动时被重新放。</p><p>使用RDB的操作：</p><p>CONFIG SET SAVE “900 1”    （还是使用CONFIG SET修改配置文件）</p><p>永久启用RDB：cat conf/redis.conf | grep “^save”</p><p>RDB的结果会生成yige.rdb文件。二进制形式。略</p><p>由于RDB并不能提供非常强的一致性，虽然可以定期将数据保存到RDB，但在崩溃时，保存的时刻到崩溃时刻中间的数据将会丢失。</p><p>AOF是一种只记录Redis写入命令的追加式文件，因为每个写入命令都会被追加到文件中，所以AOF的数据一致性更高。</p><p>启用AOF持久化：CONFIG SET APPENDONLY YES</p><p>永久启动： cat conf/dis.conf | grep “^appendonly”</p><p>二者可以同时使用。</p><p>chapter7：高可用和集群Redis</p><p>当Redis的数据越来越大的时候，安全性会受到损害（宕机的时候恢复的时间越来越长）同时key越来越多，内存的使用率越来越大，内存的大小成为了性能的瓶颈。因此配置多个node（多个Redis服务器的集群），可以增加安全性和可用性。</p><p>略</p><p>chapter8：生产环境部署</p><p>即在Linux上部署Redis，成为真正的服务器，可不仅仅是一个测试demo。这个时候还需要配置各种参数，如客户端连接参数，数据库本身参数，key的管理，LRU，LFU等等的算法策略，还有日志。</p><p>略</p><p>chapter9：管理Redis</p><p>即Redis服务上线之后，对日常的Redis进行运维操作。</p><p>查看参数，备份，监控内存使用情况，监控客户端等等。</p><p>chapter10：Redis的故障诊断</p><p>chapter11：使用Redis模块拓展Redis    略略略</p><p>————————–Redis Dev &amp; Ops</p><p>chap2：</p><p>keys *， dbsize：</p><p>dbsize直接获取Redis内置的一个变量，时间复杂度为1</p><p>而keys会遍历所有键，所以时间复杂度是n（当Redis保存了大量键的时候，就不应该使用）</p><p>exists key，    del key，        </p><p>expire key seconds（设置过期时间</p><p>ttl key ：返回剩余过期时间。  大于等于0就是剩余值，-1是没设置过期时间，-2是键不存在</p><p>type key，  object encoding key   ： type是返回键的类型，object encoding是返回内部编码实现类型</p><p>（根据具体情况计算性能，底层选择不同的类型：</p><p>string字符串： raw，    int，        embstr</p><p>hash哈希：    hashtable，        ziplist</p><p>list列表：        linkedlist，        ziplist</p><p>set集合：    hashtable，        intset</p><p>zset有序集合（Sorted Set）：    skiplist，    ziplist</p><p>incr key：使key自增1.（如果不是整数，会报错。如果不存在这个key，创建一个，默认值为0，incr后就是变成1。 必须是整数，浮点数也会报错）</p><p>Redis使用了单线程 + IO Multiplexing（多路复用）模型来实现高性能的内存数据库服务</p><p>（所谓的IO Multiplexing，指由N个client要访问，然后IO根据哪个client ready了，就选择那个（就像是一个电路图：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\1e1c5c3688d74413b43baa95057179b0\clipboard.png)</p><p>IO Multiplexing主要是可以提高连接数。但始终还是单线程，因此如果其中一个命令的执行时间特别长，那么就会造成其他命令的阻塞。所以Redis是面向快速执行场景的数据库。</p><p>（内存的处理速度是磁盘IO的10万倍，所以Redis的效率是很快的，能达到每秒万级别）</p><p>（内存是100ns， Disk seek是10 000 000ns）</p><p>①字符串类型  string：</p><p>key都是字符串类型，字符串可以是字符串，数字，二进制（图片，音频，视频</p><p>（所以 set  1  123也是可行的。key为1，value为123）</p><p>set 选项： ex秒级过期时间， px 毫秒级， nx：键必须不存在，才可以设置成功。 xx：与nx相反</p><p>例子：setnx hello redis    (nx可以用作分布式锁的一种实现方案，因为只有一个可以set成功）</p><p>mset ： 批量设置值            例子： mset key1 value1 [key2 value2 ……]</p><p>get,  mget同理。</p><p>批量命令可以提升开发效率。如n次get，需要n次网络时间+n次命令时间。</p><p>而mget只需要1次网络时间+n次命令时间</p><p>（批量操作发送的命令数是有节制的，否则可能造成Redis阻塞或者网络阻塞）</p><p>del key [key ……]    del可以删除多个。 </p><p>incr,decr</p><p>incrby  key  increment(指定自增数值，可为负数）        decrby  key  decrement    （不能为浮点数</p><p>incrbyfloat  key  increment（每次增加的值为浮点数，同时key也能为浮点数，不然执行一次就没了）</p><p>append key  value    在尾部追加值</p><p>strlen  key        字符串长度</p><p>getset        设置，并且返回原来的值</p><p>setrange    key    offset    value    设定offset偏移值的那一位，字符由value替代（从0开始</p><p>例子： set redis  pest        setrange  redis  0  b    get  redis   ==》  best</p><p>getrange  key  start  end    (偏移量从0开始。 [start,  end]        （没有-1）</p><p>总结：del，mset，mget这三个的时间复杂度为O(n)，getrange为O(n),n是字符串的长度，如果字符串不是很长，可以视为O(1)。其他都是O(1)</p><p>字符串内部编码:  int,  embstr(小于等于39个字节的字符串） ， raw（大于39个字节）</p><p>②哈希 hashing</p><p>即value本身又是一个键值对。</p><p>设置值： hset  key   field  value    （同样还有hsetnx。相当于set和setnx的区别</p><p>获取值： hget  key   field      （一个key存储多个  field - value）</p><p>删除field： hdel  key  field1  [field2 ……]    返回成功删除field的个数</p><p>计算field的个数：   hlen  key</p><p>批量set/get  :  hmget  key  field [ field …]    hmget  key field  value [ field  value……]</p><p>hexists  key  field    判断是否存在</p><p>hkeys  key    获取所有的field（感觉叫hfields更恰当，但确实是hkeys</p><p>hvals    key</p><p>hgetall     key        获取所有的field-value</p><p>（当哈希元素比较多，hgetall可能会阻塞。如果只需要获取部分，可以使用hmget。如果一定要获取全部field-value，可以使用hscan，该命令会渐进式地遍历哈希类型。）</p><p>hincrby   key   field   increment    给key.field增加increment（可以为负数）    hincrbyfloat</p><p>hstrlen    key   field</p><p>总结：hdel，hmget，hmset是O(k)，k是field的个数。hgetall，hkeys， hvals是O(n)，n是field的总数</p><p>其他都为O(1)</p><p>哈希内部编码：ziplist（压缩列表）：当元素个数小于hash-mmmax-ziplist-entries(默认是512），同时所有值都小于hash-max-ziplist-value(默认是64字节），就使用ziplist（结构更紧凑，节省内存）</p><p>hashtable（哈希表）：当无法满足ziplist时，ziplist的读写效率会下降，而hashtable的读写为O(1)</p><p>ps：对于一个用户的各种信息属性，可以单独用不同的key，但这样用户信息性差，一般不会使用这种方案。比较好的方案是使用哈希类型，提高内聚性，控制在ziplist之内，有效减少内存空间的使用。（必须的时候使用hashtable也不是不行）</p><p>哈希类型是稀疏的，而关系数据库是完全结构化的，当在关系数据库增加新的列，所有行都要设置值（如果没有指定就设置为NULL）。但可以做复杂的关系查询，而Redis比较困难。</p><p>③列表 list</p><p>rpush，lpush（二者都可以插入多个）    linsert key before | after  pivot  value</p><p>lrange key  start  end 查找</p><p>……</p><p>懒了，其实各种类型的操作就略过吧，上面已经看过一次了，把上面的复习一遍就好。主要看它举的实例并理解。</p><p>chap3：各种功能topic</p><p>①慢查询</p><p>Redis有一个表专门记录命令执行较长的命令（只包含执行时间，不包含客户端等待时间）</p><p>参数：slowlog-log-slower-than    (超出该值则记录，单位是微秒。）</p><p>1 秒 = 1000 毫秒 = 1000 000微秒    （即默认是10毫秒）</p><p>slowlog-max-len ：慢查询日志的最大记录，如果超出上限，则最早insert的那条删除。</p><p>（slowlog-max-len设置大一点，不会耗费很多内存空间的）</p><p>设置命令：config xx int        持久化到配置文件：    config  rewrite</p><p>获取日志： slowlog  get  [n]    // n表示指定条数</p><p>slowlog len  ： 获取慢查询日志列表的当前长度</p><p>slowlog reset：重置（即clear</p><p>②redis shell</p><p>redis-cli的各种参数：</p><p>-h  ： host    -p： port        -a： auth        </p><p>-r 重复执行n次：  redis-cli -r 3 ping    </p><p>(即重复执行3次ping命令，ping命令会测试服务器的连通性，如果连通，返回PONG）</p><p>-i 表示每隔几秒执行一次命令（与-r连用，单位是秒）</p><p>例子：redis-cli -a xxx -r 10 -i 1 info | grep used_memory_human    每隔1秒输出内存的使用量</p><p>-x：将stdin读取，作为redis-cli的最后一个参数，例如；</p><p>echo “gogogo” | redis-cli -a xxx -x set hello    # 之后hello的值就被设置为”gogogo\n”</p><p>值得注意的是，echo输入，会存在一个换行符，进入redis-cli里再set才不会有换行符。</p><p>–scan和–pattern ：扫描指定模式的keys，相当于使用scan命令</p><p>–slave：将当前客户端模拟成一个子节点，然后获取当前Redis结点的更新操作。</p><p>（可以用于记录当前连接Redis结点的一些更新操作）</p><p>（在一个客户端中使用redis-cli –slave -a xxx，然后其他客户端的更新，当前都会有命令记录）</p><p>–rdb：请求Redis实例生成并发送RDB持久化文件，保存在本地。</p><p>–pipe：把批量的命令一次发送到一个管道中，一次执行</p><p>–bigkeys：使用scan命令获取占用内存比较大的键值。（这些键可能是系统的瓶颈）</p><p>–eval ： 执行指定的Lua脚本</p><p>–latency :测试到目标Redis的网络延迟   redis-cli  -h  {另一台机器的host IP}  –latency</p><p>–latency-history :上面的只有一条记录，而这个是每执行15秒就生成另一条记录（可以用作对比），同时也可以使用-i参数来控制间隔时间。</p><p>-latency-dist   使用统计图表的形式从控制台输出信息</p><p>info  ： redis-cli  info    输出redis的所有信息（很长，配合| grep使用）</p><p>redis-cli –stat：实时获取Redis的重要统计信息（比info少很多，但可以实时查看一些增量的数据）</p><p>–raw ， –no-raw    使得返回的结果是原始格式 / 不是原始格式</p><p>当存储中文时，保存在redis里的中文会被转义成16进制。此时无论是命令行时get还是进入redis-cli之后get，返回的结果都是二进制格式，如： \xe4\xbd\xa0\xe5\xa5\xbd</p><p>如果使用–raw，则返回原始格式，即中文： redis-cli –raw get hello (–raw必须在get前面）</p><p>PS:但是在进入redis-cli之后的get好像无法指定参数，所以不能返回raw，只能在命令行时指定–raw</p><p>③redis-server</p><p>redis-server是Redis的启动脚本。可选参数只有：–test-memory，用于检测当前的OS能否稳定地分配指定容量的内存给Redis（防止因为内存问题造成Redis崩溃）</p><p>（检测时间较长，但输出passed this test表示检测完毕。 单位是MB，所以1024就是1G）</p><p>一般只是用于调试跟测试，快速沾满机器内存做一些边界测试</p><p>④redis-benchmark</p><p>用于为Redis做基准性能测试</p><p>-c：表示客户端的并发数量（默认50）</p><p>-n：表示客户端的请求总量（默认是100000）</p><p>例子：redis-benchmark  -c  100  -n  20000，代表100个客户端同时请求Redis，一共执行20000次。</p><p>-q：只显示 requests per second信息。</p><p>-r：插入更多的键。如-r 10000，插入10000个随机的键（仅作测试使用）</p><p>-P：表示每个请求的pipeline的数据量（默认是1）</p><p>（我发现恰当指定pipeline的值，比默认是1要快。）</p><p>-k：表示客户端使用使用keepalive，1为使用，0为不使用，默认是1</p><p>-t 指定命令测试</p><p>–csv：按照csv格式输出，可以到处到excel等（注意是两条杠）</p><p>⑤Pipeline</p><p>Redis客户端的一条命令的4个过程：发送命令，命令排队，命令执行，返回结果。</p><p>（第一步跟第四步称为Round Trip Time，RTT，往返时间）</p><p>虽然有部分批量操作的命令，但大部分命令都没有批量命令，此时需要使用pipeline，一次过发送多个命令，减少RTT的次数（由于Redis的处理速度很快，只要Pipeline包含的命令数不是太多，就能有效提升效率）</p><p>（高级语言的客户端中基本都支持Pipeline。比如Jedis。）</p><p>提升的结论：</p><p>1.一般Pipleline的执行速度会比逐条执行要快（Redis的性能瓶颈是网络，即RTT）</p><p>2.客户端和服务端的网络时延越大（即RTT越大），那么Pipeline的提升效果越明显。</p><p>原生批量命令与Pipeline的区别：</p><p>1.原生批量命令是原子的，而Pipeline是非原子的。</p><p>2.原生批量是一个命令对应多个key，而Pipeline是支持多个命令的</p><p>3.原生批量是Redis服务端支持实现的，而Pipeline需要服务端和客户端的共同实现。</p><p>Ps：Pipeline一次组装的命令个数不能太多，否则会增加客户端的等待时间，以及网络阻塞，可以将一次包含大量命令的Pipeline拆分成多次较小的Pipeline来完成。</p><p>Pipeline虽然只能操作1个Redis实例，但即使在分布式Redis的场景中，也可以作为批量操作的重要优化手段。</p><p>⑥事务</p><p>Redis提供了简单的事务功能，但又跟关系数据库的事务不太一样。它无法保证很多方面的数据一致性，因为需要复杂事务的业务不应该放在Redis中实现。</p><p>multi：开启一个事务（事务里不可以嵌套事务</p><p>……中间执行的各种命令都会输出QUEUED，即存储在事务里，但还没开始执行。</p><p>exec：执行事务。        discard：取消事务</p><p>Redis的事务不提供回滚功能，如果执行出错，那么会出现问题：</p><p>1.当命令出现语法错误</p><p>此时Redis在执行每一条命令之前就已经发现了，因而这时候执行exec会显示错误。然后每一条语句都会失效。（因为根本就没有去执行，并不是回滚）</p><p>2.当命令出现运行时错误</p><p>有一些语句，不存在语法错误，但在运行时才会出现错误，这时Redis在检查语句的时候是不能发现的，只能在执行的时候才发现。比如对于SET跟SORTED SET，对一个SET使用SSET的ZADD操作，并不属于语法错误，但在运行时会出错。这时候事务不会回滚，因而在出错之前的语句，仍然已经执行成功，而且出错之后的语句也会执行！无论如何，这种问题只能靠程序员自己避免。</p><p>watch： 使得客户端监控1个或者多个键，有效期直到执行了unwatch或者exec。</p><p>当客户端A监控的这些keys，只要有其中一个被修改了(除非是在A的事务中进行修改的），那么该客户端A下的第一个事务不会执行。（返回nil）</p><p>小细节点：</p><p>1.如果是在当前客户端A的事务中修改了被监控的值，那么是可以成功执行的，因为要保证的是，在执行事务的时候，该值不会在事务在之外发生了变化。</p><p>2.如果是在当前客户端A的事务之外修改了被监控的值，那么也是不可以执行的。如果是在其他客户端B中修改，那么一定不能执行（即使是在B的事务环境中执行，也不行）</p><p>3.准确地说，并不是执行exec会取消，而是当事务（即multi）结束的时候，watch的键会取消。所以，如果执行了multi……discard，这时候其实watch已经失效了。后面如果继续使用multi，是可以执行事务的。所以单独地使用exec / discard(即在没有multi的前提下运行这两条命令），watch是仍然存在的。</p><p>⑦Lua</p><p>语法省略。</p><p>Redis使用Lua的方法：eval，evalsha</p><p>eval当作命令的时候：  eval  脚本内容  key个数  key列表  参数列表</p><p>例子：eval ‘return “hello “ .. KEYS[1] .. ARGV[1] ‘  1  redis  world</p><p>输出：”hello redisworld”</p><p>如果Lua脚本较长，可以使用–eval直接执行文件</p><p>evalsha：将Lua加载到Redis，得到该脚本的SHA1检验和，之后evalsha使用SHA1作为参数就可以直接执行对应的Lua脚本，避免每次都发送Lua脚本的开销，而且脚本也能常驻在服务端了。</p><p>script load：将脚本内容加载到Redis内存中：redis-cli script load “xxx”        返回SHA1值。</p><p>执行脚本： evalsha  脚本SHA1值  key个数  key列表  参数列表</p><p>Lua的redis.call可以实现对Redis的访问：</p><p>redis.call(“set”, “hello”, “world”)        redis.call(“get”, ”hello”)</p><p>pcall也可以调用Redis，但如果call执行失败，脚本会直接结束，而pcall会忽略错误继续执行（根据具体的情况进行函数的选择）</p><p>Lua对于Redis的好处：</p><p>1.Lua在Redis中的原子执行的，执行中途不会插入其他命令</p><p>2.Lua可以自定制命令，并且可以将这些命令常驻在Redis内存中，达到复用的效果</p><p>3.Lua可以将多条命令一次性打包，有效地减少网络开销。</p><p>举一个Lua的例子：</p><p>假设有user1,user2,user3,user4这几个键，分别对应一个数字。</p><p>如get user1 =》 123    ，user2 = 444 , user3 = 743 , user4 = 814</p><p>有一个列表，存储了这几个键：</p><p>lpush  hot  user1, user2, user3, user4</p><p>现在我们需要对列表内所有的键对应的值进行+1操作，并且保证是原子执行，返回操作的个数。</p><p>Lua脚本：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\a8de5b73eb2142e490223c07e13bee29\clipboard.png)</p><p>执行Lua脚本： redis-cli  -a  xxx  –eval  my.lua  hot（即执行my.lua脚本，第一个key参数是hot列表）</p><p>Redis管理Lua脚本：</p><p>script load：将Lua脚本加载到Redis</p><p>script exists sha1 [sha1 …]：判断sha1是否已经加载到内存</p><p>script flush：清除Redis内存以及加载的所有Lua脚本（此时需要重新load</p><p>script  kill：杀掉正在执行的Lua脚本（如果Lua比较耗时，或者存在死循环等问题，就可以考虑kill</p><p>ps：Redis提供了一个参数，是Lua脚本的超时时间，但仅仅是当Lua脚本超过该时间之后，向其他命令发出BUSY的信号，但并不会停止掉服务端和客户端的脚本执行。其他命令会收到“Busy Redis is busy running a script”的错误。</p><p>但是，如果Lua脚本正在执行写操作，那么script kill将不能生效，此时只能使用shutdown save停掉Redis服务。（如果是死循环的重复写操作，那么只能shutdown save了）</p><p>⑧bitmap，HyprtLogLog，订阅，GEO等等（上面的笔记有</p><p>chap4：客户端</p><p>Redis的CS模型：</p><p>Redis制定了RESP（Redis Serialization Protocol，Redis序列化协议），实现客户端与服务端的正常交互。这种协议简单高效，能被机器解析，同时也容易理解。</p><p>发送命令的格式：先指定参数个数（前面加一个*，然后每一个参数前面用$加数字，表示该参数的长度。）</p><p>例子：SET hello world</p><p>底层发送的命令格式：(下面的各种参数与\r\n之间是没有空格的，只是这里增加以下可读性</p><p>*3 \r\n $3 \r\n SET \r\n $5 \r\n hello \r\n $5 \r\n world \r\n</p><p>上面的每一部分解释：</p><p>首先，每一part都是单独的一行(\r\n就是换行了），然后*3表示有3个参数， $3表示第一个参数的长度3，第一个参数是SET。$5表示第二个参数长度5，第二个参数是hello.第三个的长度也是$5,值为world</p><p>返回结果的格式：</p><p>有5种：</p><p>1.状态回复： 在RESP中，第一个字节是 +</p><p>2.错误回复：在RESP中，第一个字节是 -</p><p>3.整数回复：在RESP中，第一个字节是  :</p><p>4.字符串回复：在RESP中，第一个字节是 $</p><p>5.多条字符串回复：在RESP中，第一个字节是  *</p><p>从redis-cli.c的源码的 cliFormatReplyTTY方法，可以看到一共有这几种执行结果：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\8cc4710fe2404a6582bb758a14fd3161\clipboard.png)</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\a3fbdf67f35f4db3a293a700bf15f534\clipboard.png)</p><p>一共有REDIS_REPLY_ERROR,  STATUS,  INTEGER,  STRING, NIL, ARRAY</p><p>Jedis的重要类，重要方法，重要功能等等：</p><p>1.基本连接： Jedis</p><p>但默认是直连，于是每一次都要新建/关闭TCP的开销，资源无法控制（无法限制Jedis对象的个数)，Jedis线程不安全。而使用连接池，可以事先初始化好Jedis连接，降低TCP的开销。而且借用和归还到连接池的操作都是在本地进行的，只有少量的并发同步开销。</p><p>2.Jedis连接池：JedisPool</p><p>一般还有它的配置类GenericObjectPoolConfig类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"poolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"1000"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（此处的JedisPoolConfig是GenericObjectPoolConfig的子类，只有一个默认构造方法，初始化一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolConfig</span> <span class="keyword">extends</span> <span class="title">GenericObjectPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JedisPoolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setTestWhileIdle(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.setMinEvictableIdleTimeMillis(<span class="number">60000L</span>);</span><br><span class="line">        <span class="keyword">this</span>.setTimeBetweenEvictionRunsMillis(<span class="number">30000L</span>);</span><br><span class="line">        <span class="keyword">this</span>.setNumTestsPerEvictionRun(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:书上列了一堆GenericObjectPoolConfig的属性，因为BaseObjectPoolConfig还有很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericObjectPoolConfig</span> <span class="keyword">extends</span> <span class="title">BaseObjectPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericObjectPoolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseObjectPoolConfig</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_LIFO = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_FAIRNESS = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_MAX_WAIT_MILLIS = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFALUT_MIN_EVICTABLE_IDLE_TIME_MILLIS = <span class="number">1800000L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NUM_TESTS_PER_EVICTION_RUN = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_TEST_ON_CREATE = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_TEST_ON_BORROW = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_TEST_ON_RETURN = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFALUT_TEST_WHILE_IDLE = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_BLOCK_WHEN_EXHAUSTED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_JMX_ENABLE = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_JMX_NAME_PREFIX = <span class="string">"pool"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_JMX_NAME_BASE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_EVICTION_POLICY_CLASS_NAME = <span class="string">"org.apache.commons.pool2.impl.DefaultEvictionPolicy"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lifo = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> fairness = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxWaitMillis = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> minEvictableIdleTimeMillis = <span class="number">1800000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> softMinEvictableIdleTimeMillis = <span class="number">1800000L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numTestsPerEvictionRun = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> String evictionPolicyClassName = <span class="string">"org.apache.commons.pool2.impl.DefaultEvictionPolicy"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnCreate = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnBorrow = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnReturn = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testWhileIdle = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeBetweenEvictionRunsMillis = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> blockWhenExhausted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> jmxEnabled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> String jmxNamePrefix = <span class="string">"pool"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.看一下当时在Spring下自己的项目的Redis完整配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"poolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"300"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"1000"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"poolConfig"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6379"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"xxx.xx.xx.xxx"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"xxxx"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"100000"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"database"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- org.springframework.data.redis.core.RedisTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisTemplate"</span> <span class="attr">class</span>=<span class="string">"com.hong.utils.redis.MyRedisTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashKeySerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"keySerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"valueSerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashValueSerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"methodCacheInterceptor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.support.SimpleCacheManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"caches"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.hong.utils.redis.RedisUtil"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"redisTemplate"</span> <span class="attr">ref</span>=<span class="string">"redisTemplate"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"common"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisUtil"</span> <span class="attr">class</span>=<span class="string">"com.hong.utils.redis.RedisUtil"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"redisTemplate"</span> <span class="attr">ref</span>=<span class="string">"redisTemplate"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- name属性的值,是用于等会的注解当中 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"common"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还是很好理解的，首先JedisPoolConfig是连接池的配置。</p><p>然后JedisConnectionFactory就是连接的配置（连接池要预先创建连接，那么自然需要一个Factory去创建连接，而至于hostName，password，timeout，port等等的，确实就应该写在factory里了，同时还传入了poolConfig配置，database就是默认是第一个数据库吧，也没什么好说的）</p><p>然后是RedisTemplate，这个也很显然，就跟JdbcTemplate，就是封装了原生的Redis API，然后提供了更易操作的方法接口罢了。我们看一下方法：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\3e927f8193dc487b9d462e096537527a\clipboard.png)</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\a5493d3d73cb441ca0a50ab95ad2323f\clipboard.png)</p><p>方法确实很多哈，这里也没必要截完了，反正都是封装好了的Redis原生API，不妨随意选择一个方法去查看？就选keys方法吧，返回所有的键，很简单的方法逻辑，这里重在理解方法的主要构成，没必要选择太复杂的方法逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keys</span><span class="params">(K pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(pattern);</span><br><span class="line">    Set&lt;<span class="keyword">byte</span>[]&gt; rawKeys = (Set)<span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;Set&lt;<span class="keyword">byte</span>[]&gt;&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Set&lt;<span class="keyword">byte</span>[]&gt; doInRedis(RedisConnection connection) &#123;</span><br><span class="line">            <span class="keyword">return</span> connection.keys(rawKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.keySerializer != <span class="keyword">null</span> ? SerializationUtils.deserialize(rawKeys, <span class="keyword">this</span>.keySerializer) : rawKeys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看不出什么，但感觉关键就是把具体的参数传到execute方法，然后再执行，再看几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Object&gt; <span class="title">execRaw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (List)<span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;List&lt;Object&gt;&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">List</span><span class="params">(Object)</span> <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> connection.exec();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">    <span class="keyword">this</span>.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> </span>&#123;</span><br><span class="line">            connection.del(<span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;rawKey&#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，都是把不同的参数传到了execute方法。所以说就是对execute方法进行重载咯！我们查一下，确实，一堆的execute重载方法：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\bf4ed38156ac4f6f811fff3169568859\clipboard.png)</p><p>那我们还是继续拿keys指向的那个execute来看一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(RedisCallback&lt;T&gt; action, <span class="keyword">boolean</span> exposeConnection, <span class="keyword">boolean</span> pipeline)</span> </span>&#123;</span><br><span class="line">Assert.isTrue(initialized, <span class="string">"template not initialized; call afterPropertiesSet() before using it"</span>);</span><br><span class="line">Assert.notNull(action, <span class="string">"Callback object must not be null"</span>);</span><br><span class="line"></span><br><span class="line">RedisConnectionFactory factory = getConnectionFactory();</span><br><span class="line">RedisConnection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (enableTransactionSupport) &#123;</span><br><span class="line"><span class="comment">// only bind resources in case of potential transaction synchronization</span></span><br><span class="line">conn = RedisConnectionUtils.bindConnection(factory, enableTransactionSupport);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">conn = RedisConnectionUtils.getConnection(factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> existingConnection = TransactionSynchronizationManager.hasResource(factory);</span><br><span class="line"></span><br><span class="line">RedisConnection connToUse = preProcessConnection(conn, existingConnection);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> pipelineStatus = connToUse.isPipelined();</span><br><span class="line"><span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">connToUse.openPipeline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RedisConnection connToExpose = (exposeConnection ? connToUse : createRedisConnectionProxy(connToUse));</span><br><span class="line">T result = action.doInRedis(connToExpose);</span><br><span class="line"></span><br><span class="line"><span class="comment">// close pipeline</span></span><br><span class="line"><span class="keyword">if</span> (pipeline &amp;&amp; !pipelineStatus) &#123;</span><br><span class="line">connToUse.closePipeline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> any other connection processing?</span></span><br><span class="line"><span class="keyword">return</span> postProcessResult(result, connToUse, existingConnection);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!enableTransactionSupport) &#123;</span><br><span class="line">RedisConnectionUtils.releaseConnection(conn, factory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面两行Assert，普通的断言语句。然后后面的几行就很显然了，先获取ConnectionFactory，然后再在try-catch块里获取connection。具体的怎么getConnectionFactory这种是涉及到比较复杂的很多类的跳转的，但本质上都只是设计模式的运用，此处可以不管。接下来的就是Redis的操作了，先判断一下事务同步管理器，连接预处理等等的，最后再放入pipeline执行（因为keys是一个批处理操作，原子性的）。最后再返回postProcessResult。话说再刷新了一下，这段代码更新了，这个var11确实没有存在的必要，直接return postPro…即可。但总体来说，确实也是获取到ConnectionFactory，然后生成连接，再操作。那么，RedisTemplate的作用确实也跟我们预期的一样。</p><p>除此之外，网上也有提到，Redis可以直接存储Java对象，那么就需要序列化跟反序列化。    在Spring中，是通过StringRedisSerializer跟JdkSerializationRedisSerializer实现的。那么，RedisTemplate下面传入的两个蜜汁property也是可以理解了。至于传入connectionFactory，那是当然的了，我们上面看源码也已经看到了，RedisTemplate是需要调用connectionFactory生成连接的）</p><p>接下来最后这两个，MethodCacheInterceptor跟RedisUtil。我第一次使用的时候，直接拿RedisUtil当作RedisTemplate使用了，只是简单的set，get，那确实是足够的（RedisUtil是我的自定义类，只有最简单的set，get，remove）。其实认真一点看类名，就知道它的作用了，MethodCacheInterceptor，Redis的作用是什么？就是Cache。那么Method，Interceptor？显然，就是对方法进行拦截，确定哪些属性要考虑缓存的问题。如果需要，那么就要用到RedisUtil（基本就是最简单的set，get，remove，所以使用一个迷你版的RedisUtil就可以满足RedisTemplate的功能了）</p><p>至于MethodCacheInterceptor，是自己写的方法，我们看一下这份网上cv的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodCacheInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = Logger.getLogger(MethodCacheInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; targetNamesList; <span class="comment">// 不加入缓存的service名称</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; methodNamesList; <span class="comment">// 不加入缓存的方法名称</span></span><br><span class="line">    <span class="keyword">private</span> Long defaultCacheExpireTime; <span class="comment">// 缓存默认的过期时间</span></span><br><span class="line">    <span class="keyword">private</span> Long xxxRecordManagerTime; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> Long xxxSetRecordManagerTime; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodCacheInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File f = <span class="keyword">new</span> File(<span class="string">"D:\\cacheConf.properties"</span>);</span><br><span class="line">            <span class="comment">//配置文件位置直接被写死，有需要自己修改下</span></span><br><span class="line">            InputStream in = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="comment">//InputStream in = getClass().getClassLoader().getResourceAsStream(</span></span><br><span class="line"><span class="comment">//"D:\\lunaJee-workspace\\msm\\msm_core\\src\\main\\java\\com\\mucfc\\msm\\common\\cacheConf.properties");</span></span><br><span class="line">            Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">            p.load(in);</span><br><span class="line">            <span class="comment">// 分割字符串</span></span><br><span class="line">            String[] targetNames = p.getProperty(<span class="string">"targetNames"</span>).split(<span class="string">","</span>);</span><br><span class="line">            String[] methodNames = p.getProperty(<span class="string">"methodNames"</span>).split(<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加载过期时间设置</span></span><br><span class="line">            defaultCacheExpireTime = Long.valueOf(p.getProperty(<span class="string">"defaultCacheExpireTime"</span>));</span><br><span class="line">            xxxRecordManagerTime = Long.valueOf(p.getProperty(<span class="string">"com.service.impl.xxxRecordManager"</span>));</span><br><span class="line">            xxxSetRecordManagerTime = Long.valueOf(p.getProperty(<span class="string">"com.service.impl.xxxSetRecordManager"</span>));</span><br><span class="line">            <span class="comment">// 创建list</span></span><br><span class="line">            targetNamesList = <span class="keyword">new</span> ArrayList&lt;String&gt;(targetNames.length);</span><br><span class="line">            methodNamesList = <span class="keyword">new</span> ArrayList&lt;String&gt;(methodNames.length);</span><br><span class="line">            Integer maxLen = targetNames.length &gt; methodNames.length ? targetNames.length</span><br><span class="line">                    : methodNames.length;</span><br><span class="line">            <span class="comment">// 将不需要缓存的类名和方法名添加到list中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; targetNames.length) &#123;</span><br><span class="line">                    targetNamesList.add(targetNames[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; methodNames.length) &#123;</span><br><span class="line">                    methodNamesList.add(methodNames[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object value = <span class="keyword">null</span>;</span><br><span class="line">        String targetName = invocation.getThis().getClass().getName();</span><br><span class="line">        String methodName = invocation.getMethod().getName();</span><br><span class="line">        <span class="keyword">if</span> (!isAddCache(targetName, methodName))       <span class="comment">// 不需要缓存的内容</span></span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();               <span class="comment">// 执行方法返回结果</span></span><br><span class="line">        Object[] arguments = invocation.getArguments();</span><br><span class="line">        String key = getCacheKey(targetName, methodName, arguments);</span><br><span class="line">        System.out.println(key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (redisUtil.exists(key))             <span class="comment">// 判断是否有缓存</span></span><br><span class="line">                <span class="keyword">return</span> redisUtil.get(key);</span><br><span class="line"></span><br><span class="line">            value = invocation.proceed();                       <span class="comment">// 写入缓存</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> String tkey = key;</span><br><span class="line">                <span class="keyword">final</span> Object tvalue = value;</span><br><span class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (tkey.startsWith(<span class="string">"com.service.impl.xxxRecordManager"</span>)) &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, xxxRecordManagerTime);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tkey.startsWith(<span class="string">"com.service.impl.xxxSetRecordManager"</span>)) &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, xxxSetRecordManagerTime);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            redisUtil.set(tkey, tvalue, defaultCacheExpireTime);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否加入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAddCache</span><span class="params">(String targetName, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (targetNamesList.contains(targetName)</span><br><span class="line">                || methodNamesList.contains(methodName)) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建缓存key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCacheKey</span><span class="params">(String targetName, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Object[] arguments)</span> </span>&#123;</span><br><span class="line">        StringBuffer sbu = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sbu.append(targetName).append(<span class="string">"_"</span>).append(methodName);</span><br><span class="line">        <span class="keyword">if</span> ((arguments != <span class="keyword">null</span>) &amp;&amp; (arguments.length != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                sbu.append(<span class="string">"_"</span>).append(arguments[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sbu.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRedisUtil</span><span class="params">(RedisUtil redisUtil)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisUtil = redisUtil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先第一个是构造方法，里面就是对Interceptor的配置，比如过期时间啊，要拦截哪部分的方法啊等等的。这段代码显然有点糙（毕竟上面的都是优雅的源码，这个虽然也是网上大佬写的，但还是有差距哈）。然后invoke方法，这个是最关键的方法。我们的这个类实现了MethodInterceptor接口，这个接口就是只有这么1个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implement this method to perform extra treatments before and</span></span><br><span class="line"><span class="comment">     * after the invocation. Polite implementations would certainly</span></span><br><span class="line"><span class="comment">     * like to invoke &#123;<span class="doctag">@link</span> Joinpoint#proceed()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation the method invocation joinpoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result of the call to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * Joinpoint#proceed()&#125;, might be intercepted by the</span></span><br><span class="line"><span class="comment">     * interceptor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable if the interceptors or the</span></span><br><span class="line"><span class="comment">     * target-object throws an exception.  */</span></span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注释也可以看得出来，用于对方法在before或者after进行加强（此处有点像AOP）。而对于invoke方法，前面首先是要读取配置辣，然后try-catch也是比较显然的，判断是否有缓存，如果有，直接return，如果没有，写入缓存（其实这里的interceptor的invoke方法写得不够好，应该要分情况去缓存的，这个大概只是一个demo，还要修改很多，但这里暂时不讨论）。后面的这个Thread我没看懂是为何，既然用到了RedisUtil，应该跟它demo的逻辑有关系，但跟整体的Cache关系不大，略。至于其他的方法，都是辅助这个invoke方法的，比如判断是否要写入缓存，是否存在键等等，关键还是invoke。</p><p>至此，对当时Spring整合Redis的全部配置文件，每一个导入的类作用是什么，为什么要有这些property，应该是能有比较清晰的认知了。</p><p>4.Jedis的一些重要方法</p><p>其实最关键的框架也就是上面的第3点了。这一部分还有的就是Pipeline，调用Lua脚本等等，也是直接调用就行（看着方法名，方法参数来就行，只要对Redis的原生操作足够熟悉）。</p><p>Pipeline就直接使用Pipeline类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pipeline</span> <span class="keyword">extends</span> <span class="title">MultiKeyPipelineBase</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pipeline.MultiResponseBuilder currentMulti;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Response&lt;T&gt; <span class="title">getResponse</span><span class="params">(Builder&lt;T&gt; builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.currentMulti != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">super</span>.getResponse(BuilderFactory.STRING);</span><br><span class="line">            Response&lt;T&gt; lr = <span class="keyword">new</span> Response(builder);</span><br><span class="line">            <span class="keyword">this</span>.currentMulti.addResponse(lr);</span><br><span class="line">            <span class="keyword">return</span> lr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getResponse(builder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClient</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Client <span class="title">getClient</span><span class="params">(<span class="keyword">byte</span>[] key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Client <span class="title">getClient</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isInMulti()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.discard();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.sync();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用Lua是在Jedis下的方法：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\60fbd8249e904bc3a36241008b228f76\clipboard.png)</p><p>看了一下，RedisTemplate搜eval竟然没有相关方法。然后再搜了一下script，就出来了：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\c46dfa03d3e647adb313655d32a4e859\clipboard.png)</p><p>显然，这个就是调用脚本的总方法了。原来没有eval是因为，RedisTemplate还有更大的野心，它要一个方法来执行所有的跟Redis兼容的脚本。。那么看来Jedis也有其他的调用脚本的方法，此处就不再赘述。</p><p>客户端管理的API</p><p>client list：列出与Redis服务端相连的所有客户端连接信息。下面的客户端的属性：</p><p>标识：id，addr，name，fd（socket的文件描述符，如果fd=-1，表示客户端不是外部客户端，而是Redis内部的伪装客户端）</p><p>输入缓冲区： qbuf， qbuf-free。缓冲区会动态调整，只是要求每个客户端缓冲区的大小不能超过1G。如果超过了，客户端将会被关闭。而且缓冲区不受maxmomory控制，假设一个Redis实例设置了maxmemory为4G，已经存储了2G，但是如果此时输入缓冲区使用了3G，加起来就超过了maxmemory的限制，可能会产生数据丢失，键值淘汰，OOM等情况。</p><p>导致输入缓冲区过大的主要原因：Redis的处理速度跟不上输入缓冲区的输入速度，并且每次进入输入缓冲区的命令包含了大量的bigkey，从而造成了输入缓冲区过大的情况。或者是Redis发生了阻塞，短期内不能处理命令，造成客户端输入的命令积压在了输入缓冲区。</p><p>监控输入缓冲区的方法：</p><p>1.client  list（收集qbuf和qbuf-free，找到可能出现问题的客户端）</p><p>2.info clients，找到最大的输入缓冲区，设置client_biggest_input_buf参数，超过一定值告警</p><p>输出缓冲区：obl，oll，omem。与输入缓冲区不一样，输出区可以通过参数设置。输出区根据客户端的不同分为3种：普通客户端，发布订阅客户端，slave客户端（子客户端）。包含：固定缓冲区（16KB，用于返回比较小的执行结果0，动态缓冲区（返回比较大的结果）</p><p>客户端的存活状态：age：连接时间    idle：最近一次空闲时间</p><p>通过设置参数来控制客户端： config set maxclients（最大客户端连接数，默认10000）</p><p>config set timeout（客户端空闲时间超过这个值，就会被关闭，默认是0，即不关闭）</p><p>（一般开发的时候用默认的就行，实际发布和运维的时候，idle是必须大于0的）</p><p>flag：参数：表示客户端的类型。</p><p>N：普通客户端。M：master。S：slave。O：正在执行monitor命令。x：正在执行事务</p><p>b：正在等待阻塞事件     u：客户端未被阻塞        d：一个被watch的键已被修改，无法exec事务</p><p>c：回复完整的输出后，关闭连接        A：尽可能快地关闭连接</p><p>其他诸如：client setName/getName , kill port, pause timeout(毫秒），不再赘述</p><p>monitor：可以监控其他客户端的命令调用（在哪个时间，调用了哪个命令）。但在并发量过大的时候，monitor客户端的输出缓冲会暴涨，可能会瞬间占用大量内存。</p><p>tcp-keepalive:检测TCP连接活性的周期，默认是0.防止大量的死连接占用系统资源。</p><p>tcp-backlog：是一个队列，用于接受的TCP连接。此参数就是队列的大小，默认511，一般不修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;chapter1.&lt;/p&gt;
&lt;p&gt;Redis没有表和Schema（Schema就是数据库对象的集合，这个集合包含了各种对象如：表、视图、存储过程、索引等&lt;/p&gt;
&lt;p&gt;Redis用 key-value存储数据，所有的key必须是string类型&lt;/p&gt;
&lt;p&gt;Redis的命令不区分大小写，但存储的数据区分（包括key-value）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://hongscar.cn/categories/Redis/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>Swing笔记</title>
    <link href="https://hongscar.cn/Swing%E7%AC%94%E8%AE%B0.html"/>
    <id>https://hongscar.cn/Swing%E7%AC%94%E8%AE%B0.html</id>
    <published>2020-02-17T03:12:48.000Z</published>
    <updated>2020-02-17T06:19:18.755Z</updated>
    
    <content type="html"><![CDATA[<p>JFrame：基础窗口<br>JLabel：纯文本<br>JButton：按钮<br>JTextField：输入文本框</p><p>Swing有内置的专用线程来接受UI事件并更新屏幕（如果从其他线程着手对屏幕的操作，可能产生冲突和死锁）</p><a id="more"></a>例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SwingUtilities.invokeLater(<span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO the operation about the screen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>(不再直接操作JLabel，而是提交一个Runnable，当事件队列获取这通任务时，执行这个Runnable，不会做其他事情。前提是所有代码都如此提交，包括main。将包含初始化组件的任务在内部都设置为在SwingUtilities.invokeLater内调用)</p><p>JFrame默认使用BorderLayout</p><p>JTextArea： 多行文本输入 （常用方法append，可以rollback）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JTextArea t = <span class="keyword">new</span> JTextArea(<span class="number">20</span>, <span class="number">40</span>);</span><br><span class="line">t.setLineWrap(<span class="keyword">true</span>);    <span class="comment">//设置自动换行，默认为不换行</span></span><br><span class="line">t.setWrapStyleWord(<span class="keyword">true</span>);    <span class="comment">//断行不断字（不会把一个词分在两行中显示）</span></span><br><span class="line">JFrame jFrame = <span class="keyword">new</span> JFrame();</span><br><span class="line">jFrame.add(<span class="keyword">new</span> JScrollPane(t));    <span class="comment">//JScrollPane,给组件增加滚动条</span></span><br></pre></td></tr></table></figure><p>Container：面板，用于添加组件，布局等。JFrame实际不能直接设布局和添加组件，但JDK简化了写法，使得给JFrame的操作默认传给Container。<br>setLayout：设置布局<br>JFrame extends Frame<br>Frame extends Window<br>Window extends Container<br>( super.setLayout(…);)<br>布局管理器自适应窗口大小，如果窗口大小尺寸改变，组件的大小，形状和位置都会做出相应的改变</p><p>布局：<br>①BorderLayout：四个边框区域和一个中间区域<br>使用面板重载的add方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jFrame.add(BorderLayout.NORTH, <span class="keyword">new</span> JButton());</span><br></pre></td></tr></table></figure><p>除CENTER，加入的组件都是沿一个方向压缩到最小尺寸，同时在另一个方向上拉伸到最大尺寸。而CENTER是两个方向同时拉伸，以覆盖中间区域。</p><p>②FlowLayout：流布局。组件自左到右流动到窗体，占满空间后换行。组件为合适大小（刚好充满标签的大小）</p><p>③GridLayout：表格布局。创建一个放置组件的表格，依次放入。组件大小：自适应窗体。<br>例子：new GridLayout(7, 3); //默认为(n, 1);</p><p>④绝对定位：setLayout(null); 把容器的布局管理器设置为空，然后使用setBounds( )方法来定位组件<br>（比较简单粗暴，但是在不同大小的屏幕中显示效果会不一样）</p><p>各种按钮：<br>new BasicArrowButton(BasicArrowButton.NORTH);<br>JToggleButton, JCheckBox复选框， JRadioButton单选<br>ButtonGroup 按钮组：将多个AbstractButton对象添加进去，然后只有一个可以选中（排他）<br>例子：将两个JRadioButton加到ButtonGroup实现单选<br>（PS：对于JButton无效，因为只有一个状态，加以监听）</p><p>ImageIcon对象：获取文件地址以及文件名，即可用作程序中的图标<br>组件：setRolloverEnabled(true); //是否可以翻转，组件图标是否能改变<br>setRolloverIcon(icon); //设置松开时的图标<br>setPressedIcon(icon);<br>setToolTipText(“…”); //悬浮时，组件的提示语<br>setBorder(Border border); //设置一个边框</p><p>JTextField获取数据： jtf.getText(); setEditable(); //默认为true</p><p>组合框JComboBox 多选一，如果可自写，setEditable(true); getSelectedIndex(0 ~ n-1), 如果自定义，返回-1 getSelectedItem()</p><p>列表框JList<br>与JComboBox的区别：总是占据一定屏幕，可以多选（ctrl）<br>getSelectedValues();返回被选中的items，返回一个字符串数组。<br>JList本身没有对滚动条提供直接支持，需用通过JScrollPane</p><p>页签面板：JTabbedPane<br>类似文件夹的页签，里面可容纳多个组件（页面） 使用例子：浏览器上方选择不同页面的面板</p><p>消息框：<br>JOptionPane.showMessageDialog(); //消息对话框<br>JOptionPane.showConfirmDialog(); //确认对话框<br>返回值为int： JOptionPane.YES_OPTION &lt;=&gt; 0 , JOptionPane.NO_OPTION &lt;=&gt; 1 ,<br>JOptionPane.CANCEL_OPTION &lt;=&gt; 2 , JOptionPane.CLOSED_OPTION &lt;=&gt; -1</p><p>caidan :JMenuBar 能拥有菜单的组件，包括JApplet，JFrame，JDialog及它们的子类。 setMenuBar()方法</p><p>JPopupMenu 弹出式菜单 编写自定义对话框： extends JDialog</p><p>JDialog 默认布局： BorderLayout<br>setVisiable(true); 必须显式调用才可以使得Dialog显示出来 dispose(); 关闭JDialog，释放资源</p><p>文本对话框：JFileChooser 可用于选择，打开文件，保存文件等功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JFileChooser jfc = <span class="keyword">new</span> JFileChooser();</span><br><span class="line">jfc.setFileSelectionMode(JFileChooser.FILES_ONLY);  <span class="comment">//只选文件</span></span><br><span class="line"><span class="comment">//其他参数 DIRECTORIES_ONLY ， FILES_AND_DIRECTORIES</span></span><br><span class="line"><span class="keyword">int</span> value = jfc.showOpenDialog(<span class="keyword">null</span>);    <span class="comment">//打开一个文件选择对话框</span></span><br><span class="line"><span class="keyword">int</span> value1 = jfc.showSaveDialog(<span class="keyword">null</span>);    <span class="comment">//弹出保存文件选择框</span></span><br><span class="line"><span class="comment">//返回值： APPROVE_OPTION 为正常，其他都是有错误的情况</span></span><br></pre></td></tr></table></figure><p>getSelectedFile(), getCurrentDirectory() 用于查询操作的返回结果</p><p>Container的validate(); 使容器再次布置其子组件（刷新容器的作用）</p><p>任何能接受文本的组件都可以接受HTML文本（Swing组件上的HTML)<br>(必须使文本以<html>标记开始，然后就可以开始使用HTML标记)</p><p>Jslider 滑块 ProgressMonitor 进度条</p><p>选择外观：①可插拔外观（跨平台，默认） ②只适应当前系统的外观<br>选择②：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;    <span class="comment">//写在main()开头</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JFrame：基础窗口&lt;br&gt;JLabel：纯文本&lt;br&gt;JButton：按钮&lt;br&gt;JTextField：输入文本框&lt;/p&gt;
&lt;p&gt;Swing有内置的专用线程来接受UI事件并更新屏幕（如果从其他线程着手对屏幕的操作，可能产生冲突和死锁）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://hongscar.cn/categories/Java/"/>
    
    
      <category term="deprecated" scheme="https://hongscar.cn/tags/deprecated/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记1</title>
    <link href="https://hongscar.cn/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.html"/>
    <id>https://hongscar.cn/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.html</id>
    <published>2020-02-17T03:12:38.000Z</published>
    <updated>2020-02-17T06:18:56.256Z</updated>
    
    <content type="html"><![CDATA[<p>Python是完全面向对象的语言，函数，模块，数字，字符串都是对象。</p><p>Python的值不用定义类型，直接赋值即可使用。（因为任何数据都是对象，包括数字。所以变量赋值就是把对象关联起来。每一次变量重新赋值，并没有改变对象的值，只是新创建了一个新对象，并用变量指向它。）</p><p> 布尔值为True，False。为False的情况：</p><p>数字0（包括0.0），空字符串，None（None是Python里的一个特殊值，表示空值），</p><p>空集合,包括( ) , [ ] , { }    其他值都认为是True</p><p>变量名不能以 双下划线开头（这类标识符具有特殊意义，如： _<em>init_</em>( ) 代表类的构造函数）</p><p>同时只能由数字，字母，下划线组成。其他符号都不行。</p><a id="more"></a><p>算术运算符：</p><p>‘la ‘  *  3 =  ‘la la la ‘</p><p>10 / 3 = 3.3333(普通的除）        10 // 3 = 3(取整，跟java的一样）</p><p>3**2 = 3^2 = 9</p><p>关系运算符，对于字符串，从左到右比较字符。</p><p>‘z’ &gt; ‘a’ &gt; ‘Z’ &gt; ‘A’</p><p>逻辑运算符：not ， and， or</p><p>在字符串前面加u，表示Unicode编码。    u’asdczx’</p><p>id( )：输出变量的地址。</p><p>当x = y,二者就指向了同一个地址，此时  x is y  返回True。 x is not y 返回False</p><p>print可以有占位符。</p><p>例子：</p><p>“X’s address is : %d”    此时%d就是普通的字符串，但如同在后面增加value</p><p>“X’s address is : %d” %(id(x))        那么%d就会被  id(x) 所替换。</p><p>类型转换：</p><p>字符串转数字： int(x), long(x), float(x)    都有第二个可选参数，表进制。</p><p>eval(“..”)    计算字符串里的表达式。例子：eval(‘4+2’) 输出6</p><p>数字转字符串：str(x)</p><p>repr(obj)    将对象转换为可打印的字符串</p><p>chr(整数）将一个整数转换为ASCII字符。    ord（字符） 将一个ASCII字符进行转换为整数</p><p>hex（）整数转16进制        oct（） 转8进制</p><p>访问字符串某下标： [ ]</p><p>“asdefg”[3] = ‘e’    index从0开始。</p><p>截取子字段：[a : b]     获取index从a开始，到b-1的字串。</p><p>如果用 a - b，会将a - b计算出结果，然后再获取。如果是负数，则从后面算起。-1是最后一个。</p><p>范围是： [-length ~ length - 1]    a[-length]  ==  a[0]        [-1]  ==  a[length - 1]</p><p>in ， not in    某字符/字符串是否存在于该字符串中</p><p>r”asdzxc\nsdew” 使得\n这种转义符失效，成为普通字符串。R同理。这个例子要在print里生效。</p><p>-—</p><p>Python对于缩进是有限制的，错误的缩进会报错。</p><p>（CMD中写Python，tab第一次是4个空格，后面是8个空格，容易出错。）</p><p>例如if语句：</p><p>if a &gt; 10:    </p><p>print(“xxx”);        //如果不缩进，会报错</p><p>如果if中有多个语句，这些语句都要有相同的缩进。在cmd中，也要缩进，以一个空行结束if体。</p><p>elif    ：    相当于else if</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">15</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">20</span>:</span><br><span class="line">    print(<span class="string">"zz"</span>)</span><br><span class="line"><span class="keyword">elif</span> a &gt; <span class="number">15</span>:</span><br><span class="line">    print(<span class="string">"xx"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"cc"</span>)</span><br></pre></td></tr></table></figure><p>while语句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span>:</span><br><span class="line">    sum += i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">print(i)</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p>for语句：   for i in range(start, end):    &lt;==&gt; for (int i = start; i &lt; end; i++) s</p><p>​        循环体</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">sum1 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">sum1 += i</span><br><span class="line">print(i)<span class="comment"># 100</span></span><br><span class="line">print(sum1)<span class="comment"># 5050</span></span><br></pre></td></tr></table></figure><p>(这里前面i定义与否都可以，但不定义的话，print(i)里会有warning，但还是可以运行的。</p><p>try-except语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    i = <span class="number">10</span></span><br><span class="line">    print(<span class="number">30</span> / (i - <span class="number">10</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">print(<span class="string">"Finished execute!"</span>)</span><br></pre></td></tr></table></figure><p>raise 可以显式抛出异常（相当于throw）</p><p>——–数据结构</p><p>1.列表List    （跟数组差不多，index从0开始）</p><p>定义一个list：    a = [ ]</p><p>len( ) 输出长度    append添加到最后        index(i, element)    插入到index为i处</p><p>a1.extends(a2)    将a2的元素全部添加到a1中</p><p>效果等同于：  a1 = a1 + a2</p><p>PS:使用加号运算符，会导致a1的内存地址改变。（即a1指向了新的内存地址）</p><p>a1 = a2;      #二者都是list</p><p>当a2改变的时候，a1也会跟着改变。（二者指向同一个list）</p><p>（但如果a2的改变是改变了内存地址，如上面的加号运算符，那么a1还是指向a2原本的内存地址，而a2指向了新的内存地址。此时a1 is a2 返回False）例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">d = [<span class="number">2000</span>, <span class="number">3000</span>]</span><br><span class="line">c = b</span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))<span class="comment"># if c == b True 2266036261960</span></span><br><span class="line">b.append(<span class="number">1000</span>)</span><br><span class="line">print(c)<span class="comment"># [1, 2, 88, 99, 1000]</span></span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))<span class="comment"># if c == b True 22660360261960</span></span><br><span class="line"></span><br><span class="line">b.extend(a)</span><br><span class="line">print(c)<span class="comment"># [1, 2, 88, 99, 1000, 1, 3, 5, 7]</span></span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))<span class="comment"># if c == b True 22660360261960</span></span><br><span class="line"></span><br><span class="line">b = b + d</span><br><span class="line">print(c)<span class="comment"># [1, 2, 88, 99, 1000, 1, 3, 5, 7]</span></span><br><span class="line">print(<span class="string">"if c == b "</span> + str(c <span class="keyword">is</span> b) + <span class="string">" "</span> + str(id(b)))<span class="comment"># if c == b True 2266065942728</span></span><br><span class="line">print(b)<span class="comment"># [1, 2, 88, 99, 1000, 1, 3, 5, 7, 2000, 3000]</span></span><br></pre></td></tr></table></figure><p>list也可以用str( )转换成字符串。否则print的时候与字符串连接会报错。需要：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"some strings here: "</span> + str(aList))</span><br></pre></td></tr></table></figure><p>删除元素，length也会改变。（感觉也就C,JAVA的数组还是不可变长度了）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> listName[index]</span><br></pre></td></tr></table></figure><p>相当于String的indexOf，找到第一个element 的index。如果不存在，抛出异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.index(element)</span><br></pre></td></tr></table></figure><p>遍历数组，for语句即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">" "</span>)<span class="comment"># 1 3 3 3 5 7 3</span></span><br></pre></td></tr></table></figure><p>不换行print，第二个参数为 end=… 其中… 为每一次输出后面加到末尾的字符串，这里是一个空格。</p><p>同时for语句的range函数，如果省略掉一个参数，那么就是从0开始。</p><p>可以用for语句的同时，使用enumerate( )函数进行对 index跟value同时遍历，例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'csd'</span>, <span class="string">'we'</span>, <span class="string">'zca'</span>, <span class="string">'ert'</span>, <span class="string">'hnx'</span>]</span><br><span class="line"><span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    print(<span class="string">"第%d个元素是: %s"</span> % (i, val), end=<span class="string">"。。"</span>)</span><br><span class="line"><span class="comment"># 第0个元素是: a。。第1个元素是: we。。……</span></span><br></pre></td></tr></table></figure><p>（这个占位符的%后面要加空格，不然又有warning）</p><p>sort( ) ： 对list进行排序        a.sort( ) 才是正确的。   sort(a) 没有效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'a'</span>, <span class="string">'z'</span>, <span class="string">'A'</span>, <span class="string">'Z'</span>, <span class="string">'B'</span>]</span><br><span class="line">a.sort()</span><br><span class="line"><span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    print(val, end=<span class="string">"。。"</span>)<span class="comment">#A。。B。。Z。。a。。z。。</span></span><br></pre></td></tr></table></figure><p>(z &gt; a &gt; Z &gt; A)</p><p>reverse( )： list倒转。如果希望倒序，应该先sort，再reverse</p><p>range(start, end)    （range函数实际上会生成一个list）</p><p>从start到end递增（到end的时候就结束循环），start 默认值为0</p><p>2.元组 tuple</p><p>与list很相似，</p><p>区别在于：一经定义，内容就不能改变（所以没有插入，删除等功能）。而且可以同时存储不同类似的数据，用圆括号，而不是中括号括起来。</p><p>各种方法都与list一致：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(a[<span class="number">0</span>])<span class="comment"># 1</span></span><br><span class="line">print(a[<span class="number">3</span>])<span class="comment"># 4</span></span><br><span class="line">print(len(a))<span class="comment"># 4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">", "</span>)<span class="comment"># 1, 2, 3, 4</span></span><br><span class="line">print()</span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    print(<span class="string">"a[%d] is : %s"</span> % (index, value), end=<span class="string">", "</span>)<span class="comment"># a[0] is : 1, a[1] is 2, a[2] is 3, a[3] is 4,</span></span><br></pre></td></tr></table></figure><p>由于内容不能改变，所以没有sort函数，也没有reverse。可以先将tuple转换为list，然后再对list排序，再将结果赋值给tuple。</p><p>转换：</p><p>列表对象 = list(元组对象)</p><p>元组对象 = tuple(列表对象)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">31</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">14</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">","</span>)<span class="comment"># 31, 12, 23, 14,</span></span><br><span class="line">print()</span><br><span class="line">b = list(a)</span><br><span class="line">b.sort()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(b)):</span><br><span class="line">    print(b[i], end=<span class="string">", "</span>)<span class="comment"># 12, 14, 23, 31,</span></span><br><span class="line">print()</span><br><span class="line">a = tuple(b)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i], end=<span class="string">", "</span>)<span class="comment"># 12, 14, 23, 31,</span></span><br></pre></td></tr></table></figure><p>3.字典    directory</p><p>用{ }，就是键值对。    { key1: val1, key2: val2, … , keyn: valn}</p><p>len( ) 长度。    </p><p>a[keyx] = valx    添加</p><p>a1.update(a2)        合并两个字典，结果放入a1.（此处不可以用a1 = a1 + a2,会报错）</p><p>删除键： pop</p><p>判断是否存在： in</p><p>遍历keys，values：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">'name'</span>: <span class="string">'小明'</span>, <span class="string">'sex'</span>: <span class="string">'男'</span>&#125;</span><br><span class="line">d2 = &#123;<span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'score'</span>: <span class="string">'80'</span>&#125;</span><br><span class="line">d1.update(d2)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d1.keys():</span><br><span class="line">    print(key, end=<span class="string">", "</span>)<span class="comment"># name, sex, age, score</span></span><br><span class="line">print()</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d1.values():</span><br><span class="line">    print(value, end=<span class="string">", "</span>)<span class="comment"># 小明, 男, 18, 80,</span></span><br></pre></td></tr></table></figure><p>或者 ：   for (k, v) in dict.items( ):        # items( )，获取key-value结果集    (代码略)</p><p>清空字段：  a.clear( )</p><p>字典也可以嵌套，跟多维list一样。</p><p>{‘name’ : {‘first’: ‘Kevin’, ‘last’: ‘Seth’}, ‘age’: 40}</p><p>访问嵌套字典：字典[键] [键]        print(d[‘name’] [‘first’])</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d1 = &#123;<span class="string">'name'</span>: &#123;<span class="string">'first'</span>: <span class="string">'Kevin'</span>, <span class="string">'last'</span>: <span class="string">'Seth'</span>&#125;, <span class="string">'age'</span>: <span class="number">24</span>&#125;</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d1.values():</span><br><span class="line">    print(value)<span class="comment"># &#123;'first': 'Kevin', 'last': 'Seth'&#125;\n24</span></span><br><span class="line">print(d1[<span class="string">'name'</span>][<span class="string">'first'</span>])<span class="comment"># Kevin</span></span><br></pre></td></tr></table></figure><p>4.集合    set</p><p>集合由一组无序排列的元素组成，同时集合里没有重复的元素。</p><p>分为可变集合（set） 和不可变集合（frozenset）</p><p>（可变集合 创建后，可以添加元素，修改元素，删除元素）</p><p>创建集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = set(<span class="string">'python'</span>)</span><br><span class="line">print(type(s))<span class="comment"># &lt;class 'set'&gt;</span></span><br><span class="line">print(s)<span class="comment"># &#123;'o', 't', 'h', 'n', 'p', 'y'&#125; (无序,每一次都不相同)</span></span><br><span class="line"></span><br><span class="line">s1 = set(<span class="string">'apple'</span>)</span><br><span class="line">print(s)<span class="comment"># &#123;'a', 'l', 'p', 'e'&#125;</span></span><br></pre></td></tr></table></figure><p>len( ) ：获取集合的长度</p><p>for e in s    遍历。</p><p>add 添加。添加后的元素也在随机位置</p><p>s1.update(s2) 添加集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">41</span>, <span class="number">22</span>, <span class="number">13</span>, <span class="number">54</span>, <span class="number">19</span>, <span class="number">38</span>, <span class="number">77</span>, <span class="number">5</span>, <span class="number">6</span>])<span class="comment"># 也可以直接&#123;41, 22, 13, ……&#125;</span></span><br><span class="line">print(len(s))</span><br><span class="line">s.update([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">print(s)<span class="comment"># &#123;4, 5, 38, 6, 41, 13, 77, 19, 54, 22&#125;</span></span><br></pre></td></tr></table></figure><p>remove(value)    删除指定的集合元素</p><p>clear( )    清空</p><p>in：判断某个value是否存在于集合中    存在返回True。否则False</p><p>A &lt; B , 如果A是B的真子集，返回True。</p><p>A &lt;= B, A是B的子集。</p><p>A &gt; B, A是B的真超集        A &gt;= B    A是B的超集</p><p>|   : 并集，    s1  |  s2   ==   s1 ∪ s2</p><p>也可以用这个union方法：    s = s1.union(s2)</p><p>&amp;  : 交集        s1  &amp;  s2  ==  s1  ∩  s2</p><p>也可以用这个intersection方法：    s = s1.intersection(s2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s = s1.intersection(s2)</span><br><span class="line">ss = s1 &amp; s2</span><br><span class="line">print(s)<span class="comment"># &#123;3&#125;</span></span><br><span class="line">print(ss)<span class="comment"># &#123;3&#125;</span></span><br></pre></td></tr></table></figure><p>^    :差分集        即    （s1 ∪ s2） - (s1 ∩ s2)</p><p>也可以用这个symmetric_difference方法：    s = s1.symmetric_dirrerence(s2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s = s1 ^ s2</span><br><span class="line">ss = s1.symmetric_difference(s2)</span><br><span class="line">print(s)<span class="comment"># &#123;1, 2, 4&#125;</span></span><br><span class="line">print(ss)<span class="comment"># &#123;1, 2, 4&#125;</span></span><br></pre></td></tr></table></figure><p>按位运算：  &amp;与    |或    ^异或</p><p>-————————-</p><p>函数：</p><p>在函数里定义的变量是局部变量，作用域就是在函数体内。如果全局变量和局部变量同名，那么在函数体内只能访问局部变量。如果在定义局部变量之前调用了同名的“全局变量”，会报错。因为函数体内只能访问局部变量，会显示：UnboundLocalError: local variable ‘a’ referenced before assignment</p><p>Python的传值是按值传递的（但传的值都是对象，数字也是对象，这点跟java不一样）</p><p>（经过测试：传数值，字符串都不会随着函数而改变，但list，directory会发生改变！）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(list)</span>:</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(len(list)):</span><br><span class="line">        <span class="keyword">if</span> x != len(list) - <span class="number">1</span>:</span><br><span class="line">            print(list[x], end= <span class="string">' + '</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(list[x], end=<span class="string">' '</span>)</span><br><span class="line">        total += list[x]</span><br><span class="line">    print(<span class="string">"="</span>, total)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">list = [<span class="number">15</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">65</span>]</span><br><span class="line">sum(list)<span class="comment"># 15 + 25 + 35 + 65 = 140</span></span><br><span class="line"><span class="comment"># 只是普通的函数演示,并不是演示list/directory会改变</span></span><br></pre></td></tr></table></figure><p>函数定义后面的参数可以指定默认值，（有默认值的参数只能出现在没默认值的参数的后面）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(message, times = <span class="number">1</span>)</span>:</span></span><br><span class="line">    print(message * times)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">say(<span class="string">'hello'</span>)<span class="comment"># hello</span></span><br><span class="line">say(<span class="string">'Python'</span>, <span class="number">3</span>)<span class="comment"># PythonPythonPython</span></span><br></pre></td></tr></table></figure><p>如果没有指定默认值，那么调用say(‘hello’)的时候参数个数就不对，会报错。当参数个数不一致的时候（或多或少），都会报错（不要跟JS混淆）</p><p>可变长参数（跟java不一样），这里是指参数可以是元组，或者是字典。</p><p>在形参前面加<em>，表示为 可变长参数。    <em>是元组，</em></em>是字典</p><p>例子：def f(*t):    此时调用可以是：f(1),f(1,2), f(5,756,234,23), f({‘a’: ‘111’, ‘b’: ‘324534’})</p><p>def f(**t):        此时调用可以是： f(a=1), f(a=1, b=2, c=3), f(a=1, b=12, c=543, d=765)</p><p>函数可以指定返回值，return。在函数体里用就行，定义上不用写什么。</p><p>Python预定义函数：</p><p>abs, pow(x, y), ound(x [, n]) 四舍五入，保留n位小数。 divmod(a,b) 返回 a / b , a % b</p><p>(这个四舍五入，-2.5的结果是-2，2.5的结果是2）</p><p>PS：Python2中，2.5的结果是3.0。但在python3中，2.5会返回2，2.5000000001才会返回3</p><p>字符串处理函数： lower, upper , swapcase(大写转小写，小写转大写）</p><p>capitalize 首字母大写。    title 首字母大写，其余为小写</p><p>title是每一个单词的首字母大写，例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'hello woRLd'</span>.title()</span><br><span class="line">print(s)<span class="comment"># Hello World</span></span><br><span class="line">s = <span class="string">'hello woRLd'</span>.capitalize()</span><br><span class="line">print(s)<span class="comment"># Hello world</span></span><br></pre></td></tr></table></figure><p>ljust，rjust， center        左对齐，右对齐，居中对齐，第一个参数为width表示字符串总长度，第二个参数可选，当长度不足时填充，默认是空格填充。</p><p>zfill， 用0填充到width长，右对齐。</p><p>搜索和替换：</p><p>str.find(substr)    查看字符串str中出现子串substr的第一个字母的位置，找不到则返回-1</p><p>index    与find函数相同，但找不到的时候会报错</p><p>rfind    从右侧开始find    （注意index的结果还是顺序来算的）</p><p>rindex            </p><p>count    计算子串的出现次数</p><p>（以上5个方法还有两个可选参数，start，end，表示搜索范围从start到end - 1）</p><p>str.replace(oldstr, newstr [,count])    替换。count为替换次数。</p><p>strip，lstrip，rstrip，把前后，前，后的[chars]字符去掉。默认为空白符。</p><p>expandtabs    把tab字符替换成空格，每个空格替换成[tabsize]个空格，默认是8个</p><p>分割和组合：</p><p>split（跟java一样），    splitlines 按照行分隔符划分    join把字符串序列用特定字符连接起来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="string">'214, '</span><span class="number">233</span><span class="string">', '</span><span class="number">532</span><span class="string">']</span></span><br><span class="line"><span class="string">str = '</span><span class="comment">##'</span></span><br><span class="line">s = str.join(list)</span><br><span class="line">print(s)<span class="comment"># 214##233##532 </span></span><br><span class="line"><span class="comment"># 这里会有一个warning：shadows build_in names 'xx', 因为list, str这种变量名起得不好，容易引起歧义，应该取得更能表达意思的名字 （但这里只是简单的演示代码,str跟list其实就能表示清楚了。。)</span></span><br></pre></td></tr></table></figure><p>startwith，endswith，isalnum（是否全是字母或数字），isalpha 字母  isdigit</p><p>islower   isupper</p><p>help(obj)  输出这个对象的帮助信息（可能是命令，可能是list等等的对象）</p><p>（传入一个list，就能看到List列表对象的源码）</p><p>type(obj)    显示一个对象的数据类型</p><p>字符串会返回：    &lt;class ‘str’&gt;</p><p>数值会返回：        &lt;class ‘int’&gt;    &lt;class ‘float’&gt;</p><p>列表会返回：        &lt;class ‘list’&gt;</p><p>-——————————-</p><p>类</p><p>1.变量，构造函数，析构函数，调用等等：</p><p>PS： <strong>xxx</strong> 表示系统定义的名字    __xx:表示是类的私有变量名(类外不能直接访问)</p><p>直接在构造器里调用  self.str11 = ‘111’    也算是定义了一个成员变量str11（即使函数外部没有定义str11这个变量。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span><span class="comment"># constructor</span></span><br><span class="line">        self.__str = name</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(self)</span>:</span><span class="comment"># normal function</span></span><br><span class="line">        print(self.__str)</span><br><span class="line">    __str = <span class="string">'MyString'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span><span class="comment"># destructor</span></span><br><span class="line">        print(<span class="string">"bye~"</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">p = Person(<span class="string">'Hong'</span>)</span><br><span class="line">p.sayHello()<span class="comment"># Hong</span></span><br><span class="line"><span class="keyword">del</span> p<span class="comment"># bye~</span></span><br><span class="line">p1 = Person(<span class="string">'Kai'</span>)</span><br><span class="line">p1.sayHello()<span class="comment"># Kai</span></span><br><span class="line"><span class="comment"># bye~(at the end of the program, p1 will release)</span></span><br><span class="line"><span class="comment"># if no 'del p' exists ahead, it will print 'bye~' twice here!</span></span><br></pre></td></tr></table></figure><p>2.静态变量，静态方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span>:</span></span><br><span class="line">    str = <span class="string">"this is the static"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.str = <span class="string">'MyString111'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.str)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">staticMethod</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(cls.str + <span class="string">' , '</span> + str(cls))</span><br><span class="line">        print(<span class="string">'this is a static method'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = MyString()</span><br><span class="line">s.output()                  <span class="comment"># MyString111   the value of instance</span></span><br><span class="line">print(MyString.str)         <span class="comment"># MyString      the value of class, static variable</span></span><br><span class="line">s.str = <span class="string">'Hong'</span></span><br><span class="line">MyString.str = <span class="string">'qqq'</span></span><br><span class="line">s.output()                  <span class="comment"># Hong</span></span><br><span class="line">print(MyString.str)         <span class="comment"># qqq           the value of class, static variable</span></span><br><span class="line">MyString.staticMethod()     <span class="comment"># this is a static method</span></span><br><span class="line">s.staticMethod()            <span class="comment"># this is a static method</span></span><br></pre></td></tr></table></figure><p>定义静态方法需要在方法前加：@staticmethod    （而且参数列表里不能有self）    </p><p>而定义静态变量不需要任何东西，每一个变量都同时是实例变量和静态变量。只要是通过类名访问的就是静态变量（看上面的例子，str通过instance访问时，就是实例变量，通过类名访问时则是静态）</p><p>类方法：@classmethod，第一个参数是cls（表示当前的类）</p><p>（其实类方法跟静态方法区别不大，静态方法可以直接用类名表示当前类。但一般的区分是这样的：静态方法存放与类无关的逻辑代码，如单纯的表达式计算。而类方法存放与类属性相关的逻辑代码）</p><p>isinstance(对象名， 类名或类型名）</p><p>例子： isinstance(str, MyString)        isinstance(1, int)</p><p>继承：class B (A)   B继承A，同时构造器里需要显式调用一次父类构造器</p><p>子类会继承父类的属性跟方法（私有除外）但如果提供了访问私有函数的公共接口，那么子类通过继承了这个public方法，也是可以间接访问父类私有函数的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, propertyA)</span>:</span></span><br><span class="line">        self.propertyA = propertyA</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__functionA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(str(self.propertyA) + <span class="string">' ... in class A'</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__functionA()</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, propertyA, propertyB)</span>:</span></span><br><span class="line">        A.__init__(self, propertyA)<span class="comment"># call the father constructor</span></span><br><span class="line">        self.propertyB = propertyB</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionB</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(str(self.propertyB) + <span class="string">' ... in class B'</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">a1 = A(<span class="number">10</span>)</span><br><span class="line">a1.functionAA()<span class="comment"># 10 ... in class A     access the private f by a public f</span></span><br><span class="line">b1 = B(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">b1.functionAA()<span class="comment"># 5 ... in class Athe same as class A</span></span><br><span class="line">b1.functionB()<span class="comment"># 10 ... in class B</span></span><br><span class="line">print(b1.propertyA)<span class="comment"># 5</span></span><br><span class="line">print(b1.propertyB)<span class="comment"># 10</span></span><br><span class="line"><span class="comment"># a1.__functionA()# both a and b can't access the private atribute directly</span></span><br></pre></td></tr></table></figure><p>如果子类不调用父类的构造器，那么在父类构造器执行的语句就不会生效。比如，父类有属性a = 1，构造器里有赋值语句 a = 5.如果调用了父类构造器，那么子类继承的a属性值为5，如果没有调用，子类继承的属性值为1.如果父类的属性a仅仅定义在构造器里，那么调用父类构造器之后，子类成功继承属性a。如果没有调用父类构造器，则没有继承属性a，会报错（但其他构造器之外的成员都可继承）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        self.a = a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'method in class A'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, propertyA, propertyB)</span>:</span></span><br><span class="line">        A.__init__(self, propertyA)             <span class="comment"># call the father constructor</span></span><br><span class="line">        self.propertyB = propertyB</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">functionAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'the method in class B'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b1 = B(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">b1.functionAA()          <span class="comment"># the method in class B</span></span><br><span class="line">b1.function1()</span><br><span class="line"><span class="comment"># print(b1.a)error, B object has no attribute 'a'</span></span><br></pre></td></tr></table></figure><p>同时，子类和父类有同名函数，此时是多态，会调用子类的函数，而非父类。（类型是子类）</p><p>抽象类和抽象方法：</p><p>Python通过类库abc实现抽象类，所以需要先import</p><p>from  abc  import  ABCMeta,  abstractmethod</p><p>在抽象类的第一行写下：   _<em>metaclass_</em>  =  ABCMeta</p><p>在抽象方法前增加：    @abstractmethod</p><p>抽象方法的定义：    def  abs_method_name (self): pass</p><p>PS：亲测，不需要前面三个步骤，想定义抽象方法直接在函数体 改为 pass 即可！</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myabs</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># __metaclass__ = ABCMeta</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abcmethod</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normalmethod</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"method in myabs"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myimp1</span><span class="params">(myabs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abcmethod</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="number">1123</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sub_abs_method</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># print(234)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = myimp1()</span><br><span class="line">a1.func1()              <span class="comment"># 111</span></span><br><span class="line">a1.abcmethod()          <span class="comment"># doesn't call,but no error</span></span><br><span class="line">a1.sub_abs_method()     <span class="comment">#234</span></span><br><span class="line"></span><br><span class="line">a2 = myabs()            <span class="comment"># abstract class still can make an instance</span></span><br><span class="line">a2.normalmethod()       <span class="comment"># call the non-abstract function(method in myabs)</span></span><br><span class="line">a2.abcmethod()          <span class="comment"># doesn't call,but no error</span></span><br></pre></td></tr></table></figure><p>值得注意的是，抽象类是可以实例化的，也可以调用非抽象方法跟抽象方法。而且子类也会继承这个抽象方法。但调用没有实现的抽象方法（pass），不会产生任何结果。</p><p>而且抽象类可以实例化，跟普通的没有区别。想定义抽象方法直接定义为pass即可</p><p>（我觉得抽象方法的主要用途是定义一个公共的方法，但未提供实现。子类可以选择实现并且使用，可以不实现，这时候甚至还能调用这个方法，但没有结果。比直接报错要好）</p><p>至于抽象类，似乎目前没有用，可能后面配合 模块 可以实现抽象类禁止实例化？    //TODO</p><p>多态：在不同的子类，同名方法可以有不同的实现。（如果子类没有实现该方法，就调用父类方法）</p><p>对象复制：</p><p>直接a2 = a1，之后二者指向同一个对象。除非指向其他对象，否则仅仅改变属性，内存地址并不会发生变化。而且a1的属性值改变之后，a2也跟着改变（二者始终指向同一个对象）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    property = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(id(a))            <span class="comment"># 3035407383560</span></span><br><span class="line">a.property = <span class="number">234</span></span><br><span class="line">print(a.property)       <span class="comment"># 234</span></span><br><span class="line">print(id(a))            <span class="comment"># 3035407383560 address don't change</span></span><br><span class="line">a2 = a</span><br><span class="line">print(a2.property)      <span class="comment"># 234</span></span><br><span class="line">print(id(a2))           <span class="comment"># 3035407383560</span></span><br><span class="line">a.property = <span class="number">567</span></span><br><span class="line">print(a.property)       <span class="comment"># 567</span></span><br><span class="line">print(a2.property)      <span class="comment"># 567   a2 change its value too</span></span><br><span class="line">print(id(a2))           <span class="comment"># 3035407383560</span></span><br><span class="line">print(id(a))            <span class="comment"># 3035407383560</span></span><br></pre></td></tr></table></figure><p>当函数的参数是对象是自定义的类对象时，由于传入的参数并没有声明类型，所以这个时候应该先对参数进行类型判断。    if isinstance(str, MyString):   …</p><p>-——————————</p><p>模块module    相当于java里的jar包，有封装好的函数，变量可以使用。</p><p>import xxx    调用：xxx.f        xxx.val</p><p>常用模块：</p><p>1.sys</p><p>可以获取系统的信息，还可以获取运行时的命令行参数，用作输入等等，例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用命令:  python test.py 3, 4, 9, 1 (如果逗号后面没有空格,好像会把整个当作list)</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.platform)<span class="comment"># win32</span></span><br><span class="line">print(<span class="string">"一共有%d个参数"</span> % len(sys.argv))<span class="comment"># 5个, 包括 test.py</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(sys.argv)):</span><br><span class="line">    sum += int(sys.argv[i])</span><br><span class="line">print(sum)<span class="comment"># 17</span></span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure><p>2.platform</p><p>可以获取操作系统的详细信息和与Python有关的信息</p><p>3.math</p><p>与数学有关的。</p><p>常量：e，pi</p><p>常用方法：</p><p>fabs：取绝对值</p><p>floor：返回小于等于x的最大整数</p><p>log（x，a）：返回loga(x)    如果不指定a，默认是e</p><p>log10</p><p>pow（x，y） ：    x^y</p><p>sqrt    :    根号x</p><p>trunc：    返回x的整数部分</p><p>4.random</p><p>生成随机数</p><p>random( )    :生成一个0到1的随机浮点数  0 &lt;= n &lt; 1.0</p><p>uniform(a, b)    :生成a~b范围内的随机浮点数 [a, b]  或者 [b, a] （看哪个比较大）</p><p>randint（a，b）：生成a~b之间的随机整数（a不能比b大）    [a, b]</p><p>randrange (a, b, c): </p><p>生成 [a, b)范围里的随机数，每次递增的间隔为c。即获取a, a+c, a+2c, a+3c ……（不包括b）</p><p>choice（sequence） ： 从sequence里随机获取一个元素。sequence可以是list，tuple，string</p><p>shuffle    打乱list</p><p>sample（sequence， k） ：    从sequence中随机获取长度为k的片段。原有sequence不会被修改</p><p>5.Decimal</p><p>导入： from decimal import Decimal  （用于浮点数计算，精度更高）</p><p>6.fractions</p><p>用于表现和处理分数。</p><p>x = fractions.Fractions(1, 3)</p><p>print(x)            #   1/3</p><p>对x计算之后，还会进行自动约分。如1/6 * 4会变成 2/3</p><p>\7. time模块    （常用）</p><p>struct_time数组，表示时间    或者时间戳（1970.1.1到现在的总毫秒数）</p><p>year，month，day，hours，minutes，seconds，weekday（星期一为0），yday一年一共几天</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">print(time.time())                          <span class="comment"># 1567835487.381137</span></span><br><span class="line">print(time.localtime(time.time()))</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2019, tm_mon=9, tm_mday=7, tm_hour=13, tm_min=51, tm_sec=56,</span></span><br><span class="line"><span class="comment"># tm_wday=5(星期六）, tm_yday=250（今年的第250天）, tm_isdst=0)</span></span><br><span class="line">print(time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>))   <span class="comment"># 2019-09-07 13:57:13</span></span><br><span class="line">print(time.ctime())                         <span class="comment"># Sat Sep  7 13:57:39 2019</span></span><br></pre></td></tr></table></figure><p>自定义模块：一个.py文件就是一个模块，外部可以通过import导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> myPackage.m1.myMath</span><br><span class="line"></span><br><span class="line">a = myPackage.m1.myMath.sum(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">print(a)<span class="comment"># 7</span></span><br></pre></td></tr></table></figure><p>-—————</p><p>函数式编程（感觉跟面向过程差不多，只是功能都封装到函数里）</p><p>lambda表达式， 可用作匿名函数</p><p>返回函数名   =   lambda  参数列表  ：  返回值表达式</p><p>还可以将lambda表达式作为数组里的value：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum1 = <span class="keyword">lambda</span> x, y, z: x + y + z<span class="comment"># 输入参数是x, y, z,返回值是三个的和</span></span><br><span class="line">print(sum1(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>))<span class="comment"># 9</span></span><br><span class="line">Arr = [(<span class="keyword">lambda</span> x: x**<span class="number">2</span>), (<span class="keyword">lambda</span> x: x**<span class="number">3</span>), (<span class="keyword">lambda</span> x: x**<span class="number">4</span>)]</span><br><span class="line">print(Arr[<span class="number">0</span>](<span class="number">5</span>), Arr[<span class="number">1</span>](<span class="number">4</span>), Arr[<span class="number">2</span>](<span class="number">5</span>))<span class="comment"># 25, 64, 625</span></span><br></pre></td></tr></table></figure><p>(但PEP8标准觉得def比lambda要好。准确的是，lambda一般用于匿名函数，如果要把lambda赋值给一个变量作函数变量，那还是用def比较好）</p><p>map函数</p><p>result_sequence = map(function，sequence1 [，sequence2 …])</p><p>(function里有n个参数，那么就需要sequenceN）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">    print(e, end=<span class="string">", "</span>)      <span class="comment"># (0, 4), (1, 16), (2, 36), (3, 64), (4, 100),</span></span><br><span class="line">print()</span><br><span class="line">arr = map(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>])</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">    print(e, end=<span class="string">", "</span>)      <span class="comment"># (0, 101), (1, 203), (2, 305), (3, 407), (4, 509),</span></span><br></pre></td></tr></table></figure><p>filter函数</p><p>filter（function，sequence）</p><p>对sequence里的每一个元素调用function，结果为true的返回。最终的结果序列成为filter的返回值</p><p>reduce函数</p><p>reduce（function，sequence）</p><p>function必须有2个参数。然后sequence里的前两个参数调用function，返回结果和第三个参数继续调用function，直到最后一个。</p><p>zip函数        压缩，解压(下面例子不能同时for，迭代器对象只能单向迭代一次，到了结尾之后，第二次迭代就像是迭代了一个空的list)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">zipped = zip(a, b)</span><br><span class="line"><span class="comment"># for element in zipped:</span></span><br><span class="line"><span class="comment">#     print(element, end=", ")        # (1, 4), (2, 5), (3, 6),</span></span><br><span class="line"></span><br><span class="line">unzipped = zip(*zipped)</span><br><span class="line"><span class="keyword">for</span> element1 <span class="keyword">in</span> unzipped:</span><br><span class="line">    print(element1, end=<span class="string">", "</span>)         <span class="comment"># (1, 2, 3), (4, 5, 6),</span></span><br></pre></td></tr></table></figure><p>闭包：即函数的嵌套。</p><p>在fun1里定义另一个fun2，然后fun1里的返回语句是return fun2，这时候就去调用fun2.</p><p>递归，一样的道理。</p><p>迭代器。</p><p>1.iter( )   可以获取一个sequence的迭代器。    next（Iterator）获取下一个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">12</span>, <span class="number">345</span>, <span class="number">234</span>, <span class="number">65</span>, <span class="number">78</span>, <span class="number">54</span>]</span><br><span class="line">it = iter(list)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = next(it)</span><br><span class="line">        print(s, end=<span class="string">", "</span>)          <span class="comment"># 12, 345, 234, 65, 78, 54,</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>（原生迭代器竟然没有hasNext方法！辣鸡，建议自己实现一个Iterator）</p><p>2.enumerate（）   将列表或者元组生成一个有序号的序列（index，value）</p><p>生成器：</p><p>当存在迭代器的时候，比如for in，实际上每一次都会调用一次next（）函数，表示生成下一个对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addList</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> alist:</span><br><span class="line">        <span class="keyword">yield</span> i + <span class="number">1</span></span><br><span class="line">alist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> addList(alist):</span><br><span class="line">    print(x, end=<span class="string">', '</span>)      <span class="comment"># 2, 3, 4, 5,</span></span><br><span class="line">print()</span><br><span class="line">print(alist)                <span class="comment"># [1, 2, 3, 4]  alist的值并没有变化！</span></span><br><span class="line"></span><br><span class="line">x = addList(alist)</span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 2</span></span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 3</span></span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 4</span></span><br><span class="line">a = next(x)</span><br><span class="line">print(a)        <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><p>用生成器 yield。<a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856" target="_blank" rel="noopener">https://blog.csdn.net/mieleizhi0522/article/details/82142856</a></p><p>yield相当于return，但下一次再进入到这个方法体的时候，会从yield这个语句后面开始执行。显式用next（generator）来调用相应的generator（有yield的方法），在for in的时候，实际上是每一次都隐式调用了next方法的。</p><p>同时如果要传值进行next，那么就用generator.send(value),这样就不会出现yield那一句的值丢失（因为return了之后，从下一个语句开始执行，当前语句在下一次是失效的。如a = yield 4，相当于return了4，但下次是从a的赋值才是进行，但右边的值实际上已经丢失，此时传值才可以让a有值，否则是None值。）</p><p>那么，生成器和普通的递归有什么区别？</p><p>首先，代码可以更加的简洁，看例子：</p><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\83e1a372729240e29c855c809401023c\clipboard.png)</p><p>或者这个例子：<a href="https://blog.csdn.net/weixin_40581980/article/details/80986026" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40581980/article/details/80986026</a></p><p>（用了生成器语法，直接用1行代码替代了一整个class的功能）</p><p>同时，迭代器其实是隐式调用next，而每一步（+1）都会生成元素，开辟空间，添加元素到list</p><p>比如我们要获取10000000里的所有素数。如果用迭代器，那么就是 for i in range（2，100000000）</p><p>，这样会生成一个很大的list。虽然结果不会有那么多，但中间隐式调用next还是会生成一个临时是长度为10000000的list，极度消耗内存空间。（每一步都要调用next）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primes</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max)</span>:</span></span><br><span class="line">        self.max = max</span><br><span class="line">        self.number = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.number += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.number &gt;= self.max:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">elif</span> check_prime(self.number):</span><br><span class="line">            <span class="keyword">return</span> self.number</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__next__()</span><br></pre></td></tr></table></figure><p>如果使用生成器呢，此时首先无须迭代，那么也就无须用class来实现，用函数即可。然后在循环里，是先进行check，然后check通过之后，才开始yield（生成），并且下一次next的时候，可以从这一步继续执行下去，生成下一个素数。即无须像迭代器一样，首先需要逐步生成所有的数，然后再check。（相当于比如1到1亿里面，有1000万个素数，那么迭代需要生成一个1亿长度的list，然后再查找，找到1000万个素数，再输出。而用生成器，则是找到一个素数，再添加元素到list里，最后的list长度就只有1000万，远小于1亿!）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Primes</span><span class="params">(max)</span>:</span></span><br><span class="line">    number = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> number &lt; max:</span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> check_prime(number):</span><br><span class="line">            <span class="keyword">yield</span> number</span><br><span class="line">            </span><br><span class="line">  </span><br><span class="line">primes = Primes1(<span class="number">100000000000</span>)</span><br></pre></td></tr></table></figure><p>Python的可移植性：先编译成字节码，然后将其转发到虚拟机(Python虚拟机)中运行（跟java一样）</p><p>生成的字节码文件：.pyc文件</p><p>Python的编译器总是在运行时出现，因为程序执行之前不需要预编译和链接等等的操作，使得开发周期大大缩短。（具备了更多的动态语言特性，可以在一个Python程序中执行另一个Python程序，即可以动态地修改代码，无须拥有或者编译整个系统的代码）</p><p>Python的实现，即编译器，PVM的实现方式：CPython，Jython，IronPython</p><p>执行优化工具：Psyco实时编译器（对PVM的增强工具）</p><p>print语句，在Python2不需要括号，在Python3需要（被视为一个函数调用）</p><p>模块：一个.py文件实际上就是一个模块</p><p>UNIX输入输出重定向（Python支持UNIX输入输出重定向）</p><p>例子：python xxx.py  &gt; saveit.txt    输出会输出到saveit.txt中，而非控制台</p><p>导入模块。</p><p>import a.b    &lt;==&gt;    from a import b</p><p>也可以用一个变量来赋值：import a.b.c.d    q = a.b.c.d</p><p>导入的时候，被导入的模块文件会从头执行一次（包括def，class的定义，还是简单的print，都会执行）同时由于导入消耗较大，因此运行两次import（即使在中途模块文件被修改了），也不会执行第二次import，这时候要使用reload（在Python2是内置，Python3里并没有）</p><p>exec( open(‘xxx.py’).read( ))</p><p>对于exec，代码都相当于粘贴到当前模块文件中，因此同名变量会产生冲突。    </p><p>而import跟from并不会。例子：</p><p>（我们在myMath.py里定义了一个ak变量，值为100）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ak = <span class="number">50</span></span><br><span class="line">exec(open(<span class="string">'myModule/myMath.py'</span>).read())</span><br><span class="line">print(ak)<span class="comment"># 100</span></span><br></pre></td></tr></table></figure><p>（对于import和from，当我们要访问它的变量，我们需要使用myModule.myMath.ak, myMath.ak等）</p><p>Python是动态类型的（自动地跟踪类型，而不是要求声明代码），</p><p>但Python也是强类型语言（只能对一个对象进行适合该类型的有效的操作）</p><p>字符串截取（跟数组一样操作）：</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'python'</span></span><br><span class="line">print(s[<span class="number">2</span>])</span><br><span class="line">print(s[<span class="number">1</span>:<span class="number">3</span>])<span class="comment"># [start, end - 1] 'yt'</span></span><br><span class="line">print(s[<span class="number">1</span>:])<span class="comment"># [start, -1]'ython'</span></span><br><span class="line">print(s[:])<span class="comment"># equals with s</span></span><br><span class="line">print(s[:<span class="number">-1</span>])<span class="comment"># 'pytho'[0, end - 1], that's [0, -2]</span></span><br><span class="line">print(s[:<span class="number">3</span>])<span class="comment"># 'pyt'[0, 2]</span></span><br></pre></td></tr></table></figure><p>字符串是不可变的，不能对单独一个字符进行改变等，只能重新赋值（指向另一个字符串对象！）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'python'</span></span><br><span class="line"><span class="comment"># s[0] = 'J'error</span></span><br><span class="line">print(s)</span><br><span class="line">s = <span class="string">'J'</span> + s[<span class="number">1</span>:]</span><br><span class="line">print(s)<span class="comment"># Jython</span></span><br></pre></td></tr></table></figure><p>实际上还有第三个参数，a[ i : j : k ]        k默认是1，表示每隔k个字符索引一次。</p><p>所以如果是’abcdefg’[::2]  ==  ‘aceg’</p><p>如果K为-1，表示反转字符串。    “hello”[::-1]    ==    “olleh”</p><p>如果是 [a : b : -1]    会将[b + 1, a]的字符串反转输出（b最小为0，因此不能获取第一个字符，只能通过index为0获取第一个字符）</p><p>slice( ) 切片函数。</p><p>dir(obj)    返回一个list，即该obj包含的所有方法（包括继承而来的各种方法，默认方法）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> textwrap</span><br><span class="line">s = <span class="string">'str'</span></span><br><span class="line">res = str(dir(s))</span><br><span class="line">print(textwrap.fill(res, width=<span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>![img](E:\daily program\YNote\qqF3F14E026172AA79052A8219DFDB8FD2\516fb192a01f4a4384d78e6724706a55\clipboard.png)</p><p>（textwrap是一个Python标准库的模块，可以用于格式化输出，这里使得每行输出长度最大为100）</p><p>help(obj)    返回obj的类定义。    help(obj.func)    返回obj该方法的定义，帮助信息</p><p>（因为Python一切皆对象，当然函数也是一个对象）    </p><p>关于len( )，转义符也属于长度1</p><p>len(‘A\nB\tC’)    ==    5</p><p>关于字符串匹配。</p><p>导入re模块，用match( reg, str)方法匹配，返回匹配的结果串，并且可以根据括号进行分组</p><p>PS：使用group可以获取分组内容，而且括号仅限小括号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">regexp = <span class="string">'Hello[ \t]*(.*)world'</span></span><br><span class="line">string = <span class="string">'Hello        Python world'</span></span><br><span class="line">match = re.match(regexp, string)</span><br><span class="line">print(match.group(<span class="number">1</span>))<span class="comment"># 'Python ' 表示括号里的内容</span></span><br><span class="line"></span><br><span class="line">string = <span class="string">'/usr/home/lumberjack'</span></span><br><span class="line">regexp = <span class="string">'/(.*)/(.*)/(.*)'</span></span><br><span class="line">match = re.match(regexp, string)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    print(match.group(i))</span><br><span class="line"><span class="comment"># group(0)为整个string,group(n)为第n个括号的内容</span></span><br></pre></td></tr></table></figure><p>这些字符串操作都是一个真正的序列操作，所以很多对于list等等都是有效的。</p><p>比如list也可以用-1下标表示最后一个元素！</p><p>list的赋值不能超出边界。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># L[10] = 100并不会把length提到10, 而是直接报错, 只能用append等</span></span><br></pre></td></tr></table></figure><p>Python的核心数据类型，都支持任意的嵌套。（同时list允许不同类型的元素）例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, [<span class="string">'fsd'</span>, <span class="number">4</span>], <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list))</span><br><span class="line">print(list[i], end=<span class="string">", "</span>)<span class="comment"># 1, 2, ['fsd', 4], 5, </span></span><br><span class="line">print()</span><br><span class="line">print(list[<span class="number">2</span>][<span class="number">0</span>] + <span class="string">', '</span> + str(list[<span class="number">2</span>][<span class="number">1</span>]))<span class="comment"># fsd, 4</span></span><br></pre></td></tr></table></figure><p>列表解析表达式 list comprehension expression</p><p>语法:    [ result_expression   for   item   in   list   filter_expression]</p><p>（第一个的result_expression可以调用后面for item的item数组）</p><p>例子：[ [1, 2, 3], [4, 5, 6], [7, 8, 9]]    一个二维矩阵，现在要提取第二列，并且每个值加1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">col2 = [item[<span class="number">1</span>] + <span class="number">1</span> <span class="keyword">for</span> item <span class="keyword">in</span> list]</span><br><span class="line">print(col2)<span class="comment"># [3, 6, 9]</span></span><br><span class="line">col2Doules = [row[<span class="number">1</span>] <span class="keyword">for</span> row <span class="keyword">in</span> list <span class="keyword">if</span> row[<span class="number">1</span>] %  <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">print(col2Doubles)<span class="comment"># 获取第二列的偶数元素, [2, 8]</span></span><br></pre></td></tr></table></figure><p>如果使用括号的解析语法，就变成了生成器generator：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">generator = (sum(row) <span class="keyword">for</span> row <span class="keyword">in</span> list1)</span><br><span class="line">print(next(generator))<span class="comment"># 6</span></span><br><span class="line">print(next(generator))<span class="comment"># 15</span></span><br><span class="line">print(next(generator))<span class="comment"># 24</span></span><br><span class="line">print(list(map(sum, list1)))<span class="comment"># [6, 15, 24]</span></span><br></pre></td></tr></table></figure><p>（直接用map函数，对列表的每一列进行sum操作，然后用list转换成列表）</p><p>ps：sum跟list都是标准模块里的函数，可以直接使用，平时不要覆盖掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mydir = &#123;<span class="string">'name'</span>: <span class="string">'hong'</span>, <span class="string">'jobs'</span>: [<span class="string">'student'</span>], <span class="string">'age'</span>: <span class="number">24</span>&#125;</span><br><span class="line">print(mydir)                <span class="comment"># &#123;'name': 'hong', 'jobs': ['student'], 'age': 24&#125;</span></span><br><span class="line">mydir[<span class="string">'sex'</span>] = <span class="string">'male'</span></span><br><span class="line">print(mydir)                <span class="comment"># &#123;'name': 'hong', 'jobs': ['student'], 'age': 24, 'sex': 'male'&#125;</span></span><br><span class="line">mydir[<span class="string">'jobs'</span>].append(<span class="string">'programmer'</span>)</span><br><span class="line">print(mydir)     <span class="comment"># &#123;'name': 'hong', 'jobs': ['student', 'programmer'], 'age': 24, 'sex': 'male'&#125;</span></span><br><span class="line">print(mydir[<span class="string">'jobs'</span>][<span class="number">-1</span>])    <span class="comment"># programmer</span></span><br></pre></td></tr></table></figure><p>Python也有GC机制，但我们也可以手动删除不再需要的对象（del），也可以赋值为0，引发GC</p><p>字典可以用in判断是否存在某个key，也可以get(key1, default_value)</p><p>如果存在key1，则返回，如果不存在，返回default_value</p><p>文件。    要调用open函数来生成file对象。</p><p>第一个参数是路径，第二个参数是权限。默认是’r’,只能是’r’或者’w’，不能是’rw’</p><p>同时还可以是’rb’，表示将读出来的数据改为二进制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'data.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">'Hello\n'</span>)</span><br><span class="line">f.write(<span class="string">'world\n'</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'data.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">text = f.read()</span><br><span class="line">print(text)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>判断类型，isinstance是最好的选择</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> type(list1) == type([]):</span><br><span class="line">    print(<span class="string">'yes'</span>)</span><br><span class="line"><span class="keyword">if</span> type(list1) == list:</span><br><span class="line">    print(<span class="string">'yep'</span>)</span><br><span class="line"><span class="keyword">if</span> isinstance(list1, list):</span><br><span class="line">    print(<span class="string">'yeah'</span>)</span><br></pre></td></tr></table></figure><p>Python操作符表达式：</p><p>yield  x                            生成器表达式</p><p>lambda  args  ：  expression            匿名函数</p><p>x  if  y  else  z                        y为真时，x。否则z</p><p>x  or  y，    x  and  y，  not  x</p><p>x  in  y，  x  not  in  y        （iterables，sets）</p><p>x  is  y，  x  is  not  y</p><p>&lt; , &gt; ,== , !=  |,  &amp; ,   ^（异或）,    &lt;&lt;左移    &gt;&gt;右移    /除，    //除，取整数结果</p><p>s[i: j: k]    数组切片，从[i, j)中，每隔k个数输出一个列表</p><p>……</p><p>当两个类型不一样的数字进行运算时，结果为更复杂的那个类型。</p><p>如：40 + 3.14 = 43.14    3.14 + （2+3j） = 5.14+3j</p><p>x &lt; y &gt; z，    x &gt; y &gt; z， x  &gt;  y  &lt; z 这种是可行的</p><p>math.floor( )    返回不大于x 的最大整数。所以x为2.5时，结果为2.为-2.5时候，结果为-3</p><p>//整除，实际上就是对获得的结果，再进行floor。</p><p>所以  5 // 2 == 2    5 // -2  == -3</p><p>如果真的只想要整数部分，应该用trunc</p><p>python的整数没有范围，支持无穷的大小</p><p>进制计数：</p><p>0o开头：八进制    （第一个是0，第二个是小写的o）</p><p>0x开头：十六进制</p><p>0b开头：二进制</p><p>oct(x)      十进制转八进制</p><p>hex(x)    十进制转十六进制</p><p>bin(x)    十进制转二进制</p><p>或者是  int( num, x)        第二个参数可选，表示进制，默认是10</p><p>eval函数，可以将字符串作为python代码执行，然后运行结果就是返回结果。一般的作用是将字符串对象转换成更具体的对象（比如数字，list，set，directory等等）。但由于eval实际上会将里面的字符串作为程序的一个小片段进行编译运行，所以可以做一些其他的工作。比如甚至可以偷偷地拿一个字符串，将电脑上的某个文件删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">eval(<span class="string">"os.remove('data.txt')"</span>)</span><br></pre></td></tr></table></figure><p>位运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">11</span> | <span class="number">0b1100</span>)      <span class="comment"># 0b1111 == 15  (11 == ob1011, 1011 | 1100 == 1111)</span></span><br><span class="line">print(<span class="number">11</span> | <span class="number">1100</span>)        <span class="comment"># 0b10001001100 | 00000001011 == 1100 + 3 == 1103</span></span><br><span class="line">print(bin(<span class="number">1100</span>))        <span class="comment"># 0b10001001100</span></span><br><span class="line">print(<span class="number">0b11</span> ^ <span class="number">0b1010</span>)        <span class="comment"># 1001 == 9</span></span><br></pre></td></tr></table></figure><p>buildins（Python的内建模块，预定义的功能函数）</p><p>max，min，sum都在此中。</p><p>decimal模块设置全局精度：</p><p>decimal.getcontext( ).prec = 4</p><p>获得运行环境</p><p>decimal.Decimal(1) </p><p>print(decimal.Decimal(1) / decimal.Decimal(<strong>‘7’</strong>))</p><p><em># 0.1428571428571428571428571429    (默认精度)</em></p><p>关于布尔值（bool）</p><p>原本只是一个数字，</p><p>如果要用==来判断，那么只有True == 1才会返回True。0 == False才会返回False</p><p>如果用if来判断，那么只有特定情况下是返回False。</p><p>返回False的情况：</p><p>数字0（包括0.0，0.00000等）</p><p>空字符串（仅限’’, “”）(前面是一对单引号，后面是一对双引号）</p><p>其他诸如：” “(一个空格),   ‘0’,  “‘’”(双引号里面再加一对单引号)等等，都是返回True的。</p><p>空值：None</p><p>空集合： [ ] , (  ),   {  }</p><p>(此外，由于python里的True跟False其实就是1跟0，所以甚至能跟数字进行运算。比如：</p><p>True + 3 + 5J  == 4 + 5J</p><p>False  + 7.4  ==  7.4        True  +  5.5  ==  6.5</p><p>(不过一般意义不大，omit it！）</p><p>多个字符串用空格分隔开赋值，相当于加号运算符。例子：</p><p>s = “Meaning “ ‘of’ ‘ the life’</p><p>s            # Meaning of the life</p><p>如果中间是用 逗号 分隔开，那么会生成元组。</p><p>s = “Meaning “ , ‘of’ “ the life’</p><p>s            # (‘Meaning ‘, ‘of the life’)</p><p>关于转义：</p><p>在cmd中直接输出，会变成自动带有转义效果的字符串。比如换行会变成\n，\会变成\</p><p>然后，如果赋值的时候，反斜杠后面跟的并不是转义的字符，那么反斜杠会直接写入，例子：</p><p>x = “C:\py\code”</p><p>print(x)    # C:\py\code    因为并没有\p,\c，但建议在使用反斜杠而非转义时，还是直接转义</p><p>即：    x = “C:\py\code”    结果会是一样的</p><p>同时，无论如何，print(x)，里面的反斜杠会是\，而直接x时候（在cmd），会是\</p><p>在字符串前面加一个r，表示不转义。例子：</p><p>c = r’c:\py\code’</p><p>print(c)        # c:\py\code</p><p>三重引号（无论单引号，双引号都可以），可以用于编写多行文本数据。</p><p>即’’’ asdzxc…………（包括各种换行）’’’    这时候里面所有行加起来成为一个字符串。</p><p>（cmd中换行会变成\n）</p><p>而多行文本中的引号都会直接输出，无须转义。（直到遇见三重引号结束的时候）</p><p>同时，可以利用三重引号来作为多行注释（对性能影响不大，一般应该还是用于调试阶段）</p><p>转换。int( ), str( ) , repr( )</p><p>repr函数能将一个对象转换成其字符串形式。</p><p>ord将字符转换成ASCII码，chr则将ASCII码转换成字符。</p><p>格式化字符串的两种方法：</p><p>1.用%d，%s等占位符</p><p>“That is %d %s bird!”% (1, ‘dead’)</p><p>2.使用占位数组</p><p>‘That is {0} {1} bird!’.format(1, ‘dead’)</p><p>显然，format紧接着的就是一个数组，从{0}开始慢慢对应替换。format方法是新的格式化方法。</p><p>一般除非要进行特殊的格式化，否则直接用%s就行了，因为每种类型的对象都可以转换为字符串。</p><p>PS：格式化的结果是一个新的字符串对象，而不是对原本的字符串进行的修改。</p><p>其他格式化代码    P194</p><p>字符串方法：P186，此处略</p><p>Python一共有3个主要类型（以及操作）：</p><p>1.数字（整数，浮点数，二进制，分数等）：</p><p>支持加法，乘法等等。</p><p>2.序列（字符串，列表，元组）：</p><p>支持索引，分片，合并等等。</p><p>3.映射（字典）：</p><p>支持通过键的索引等。</p><p>（集合是自成一体的一个分类，不在此中）</p><p>每种类型的操作都是相通的，比如：</p><p>对于字符串，乘法运算符* 的作用是创建一个字符串的N份拷贝。</p><p>s = ‘abc’</p><p>s = s * 3            # PS： s * 3  &lt;==&gt;  3 * s</p><p>s        # ‘abcabcabc’</p><p>那么对于其他的序列sequence来说，<em>的运算也是相同的。比如对于list，之前没对list用过</em>，实际上效果也是一样的：</p><p>x = [1, 2, 3] * 3</p><p>x            # [1, 2, 3, 1, 2, 3, 1, 2, 3]</p><p>可变类型：数字，字符串，元组，不可变集合。</p><p>可变类型：列表，字典，可变集合。</p><p>-———</p><p>list的append与extend：</p><p>append是添加一个元素，extend是添加一个iterable的元素（list，tuple等等,并且迭代展开来。</p><p>例子：</p><p>[1, 2, 3].append([4, 5, 6])        ==&gt;    [1, 2, 3, [4, 5, 6]]</p><p>[1, 2, 3].extend([4, 5, 6])        ==&gt;     [1, 2, 3, 4, 5, 6]</p><p>分片赋值：</p><p>L = [1, 2, 3, 4, 5, 6, 7, 8]</p><p>L[2: 4] = [100, 200, 300, 400, 500]</p><p>使得L的[2, 3]替换成右边的。结果：[1, 2, 100, 200, 300, 400, 500, 3, 4, 5, 6, 7, 8]</p><p>字典的key不一定要是字符串，整数也行。只要是不可变对象就行。</p><p>获取不存在的key的值时会报错，然后程序就会结束，避免程序结束：</p><p>1.if key1 in dir: … else: …            通过if判断是否存在该key</p><p>2.try: …… except KeyError: ……        如果出错就执行except里的语句，然后继续执行。</p><p>3.dir.get(key1, 0)                    get方法，获取key1的值，获取不到就返回第二个参数</p><p>创建字典的方法：</p><p>dir = {‘name’ : ‘xxx’ , ‘age’ : 45}</p><p>D = { }</p><p>D[‘name’] = ‘xxx’</p><p>D[‘age’] = 45</p><p>dir = dict(name = ‘mel’, age = 45)        # key必须都是字符串才行</p><p>dir = dict( [(‘name’, ‘mel’), (‘age’, 45)])    # 给dict传入一个list对象的时候比较适用</p><p>嵌套对象用&gt; , &lt;比较大小时，会一直递归，从左到右比较，走到最深的层次，逐步比较差值。</p><p>关于乘法运算符，是返回一个新的对象（重复n次连接起来的），这时即使是重复一个对象，也不会因为原对象引用改变而改变新的对象。但在嵌套可变序列（对象）时，情况会不一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">x = L * <span class="number">4</span></span><br><span class="line">y = [L] * <span class="number">4</span></span><br><span class="line">y2 = [L[:]] * <span class="number">4</span></span><br><span class="line">print(x)            <span class="comment"># [4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]</span></span><br><span class="line">print(y)            <span class="comment"># [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]</span></span><br><span class="line">print(y2)           <span class="comment"># [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]</span></span><br><span class="line">L[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">print(x)            <span class="comment"># [4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]</span></span><br><span class="line">print(y)            <span class="comment"># [[4, 0, 6], [4, 0, 6], [4, 0, 6], [4, 0, 6]]</span></span><br><span class="line">print(y2)           <span class="comment"># [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]</span></span><br></pre></td></tr></table></figure><p>对于x = L * 4，是生成了一个新的list，不存在共享引用，因此L改变时，x并不会改变。</p><p>但是对于y = [L] * 4,相当于[ … ] * 4生成了一个新的list，而每个[ ]里面又引用了一个外部的list（共享引用），此时L改变时，y也会跟着改变。</p><p>解决方法就是拷贝，y2 = [L[:]] * 4,这样就不存在共享引用。</p><p>当复合对象包含指向自身的引用，称为循环对象，而这个自身的引用会打印成[…]，避免无限循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; [&#39;hong&#39;]</span><br><span class="line">x.append(x)</span><br><span class="line">print(x[0])         # hong</span><br><span class="line">print(x[1])         # [&#39;hong&#39;, [...]]</span><br><span class="line">print(x[1][0])      # hong</span><br><span class="line">print(x[1][1])      # [&#39;hong&#39;, [...]]</span><br></pre></td></tr></table></figure><p>对于sequence：假如 L = [0, 1, 2, 3, 4]    len = 5</p><p>1.索引值超过边界时，会发生error        （如L[5]）</p><p>2.但分片运算超出边界时，会把超出的数字限制回最大值。</p><p>如L[2: 100]    会自动改为L[2: 5]    不会报错</p><p>3.但左边界大于右边界时，会返回空sequence。</p><p>如：L[3: 1]     ==&gt;  [ ]</p><p>（以翻转的方式提取序列是行不通的（ 较低边界值比较高边界值更大， 例如，</p><p>L[3:1] ）。你会得到空分片（ [] ），因为Python会缩放分片限制值，以确定较低边</p><p>界永远比较高边界小或相等（例如， L[3:1] 会缩放成 L[3:3] ，空的插入点是在偏</p><p>移值3处））</p><p>但对这部分赋值是可行的，并且是以左边界处进行插入。</p><p>如： L[3: 1] = [‘10’, ‘20’, ‘30’, ‘40’, ‘50’]     但不等于L[3] = [‘10’, ‘20’, ‘30’, ‘40’, ‘50’]</p><p>结果会是： [0, 1, 2, 10, 20, 30, 40, 50, 3, 4]    (与有边界的数字无关）</p><p>如果是L[3]=。。。    则是直接更新list，更新list[3]的值了，而且L[3]的值会变成一个[。。 ] list</p><p>L[3] = [‘10’, ‘20’, ‘30’, ‘40’, ‘50’]        ==&gt;    L == [0, 1, 2, [‘10’, ‘20’, ‘30’, ‘40’, ‘50’], 4]</p><p>(如果分片赋值的时候，也超出边界，那么仍然按照第二条来执行：</p><p>L[10000:200]    = […]    这样就相当于append（超出时是append）</p><p>（这种反向（左边界不小于右边界）分片赋值在插入元素时是一个可行的选择）</p><p>4.L[2] = [ ]     那么L[2]的值就变成了[ ],即 L == [0, 1, [ ] , 3, 4]</p><p>但如果是分片赋值，L[2: 4] = [ ] ,则这里面的值会删除，最后：L == [0, 1, 4]</p><p>赋值空列表给一个分片，则会删除该分片</p><p>(但如果是第三条的情况下赋值[ ],则不会生效。如L[3: 1] = [ ] ，并不会删除L[3]，不会执行任何操作。</p><p>而只有当左边界小于右边界（即正常情况），才会删除）</p><p>if state:</p><p>state2</p><p>try:</p><p>statement1</p><p>except:</p><p>statement2</p><p>else:</p><p>statement3</p><p>finally:</p><p>statement4</p><p>else可以与if连用，也可以与try-except连用。上述语句else是与try连用，就近原则。</p><p>try-except-else-finally的意思是：</p><p>如果出现了错误，那么就执行except里的语句，如果没有错误，就执行else里的语句。finally一定执行</p><p>关于作用域，global和nonlocal：</p><p>（global用于在函数里访问全局同名变量，如果没global，按照LEGB原则，全局变量会被局部变量名覆盖，因而访问不到全局变量。）</p><p>（而nonlocal用于在嵌套函数里访问外部函数的同名变量，如果没global，按照LEGB，也是会先访问当前层次的局部变量，访问不到外部函数的同名变量）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">y, z = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x1 = <span class="number">123</span></span><br><span class="line">    x = y + z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x1</span><br><span class="line">        x1 = <span class="number">1234</span></span><br><span class="line">    f2()</span><br><span class="line">    print(x1)   <span class="comment"># 1234  f2通过nonlocal把f1的x1给修改了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line">print(x)    <span class="comment"># 3 f1通过global把全局的x给修改了</span></span><br><span class="line">x = <span class="number">100</span></span><br><span class="line">print(x)    <span class="comment"># 100</span></span><br></pre></td></tr></table></figure><p>Python的嵌套函数类似于JS的闭包，也可以保存已经结束了的外部函数的变量。如下面，就相当于可以视为一个工厂函数：（同时还能根据类型而做出不同的选择）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maker</span><span class="params">(N)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> X * N</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = maker(<span class="number">3</span>)</span><br><span class="line">print(f(<span class="string">'a'</span>))<span class="comment"># aaa</span></span><br><span class="line">print(f(<span class="number">5</span>))<span class="comment"># 15</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python是完全面向对象的语言，函数，模块，数字，字符串都是对象。&lt;/p&gt;
&lt;p&gt;Python的值不用定义类型，直接赋值即可使用。（因为任何数据都是对象，包括数字。所以变量赋值就是把对象关联起来。每一次变量重新赋值，并没有改变对象的值，只是新创建了一个新对象，并用变量指向它。）&lt;/p&gt;
&lt;p&gt; 布尔值为True，False。为False的情况：&lt;/p&gt;
&lt;p&gt;数字0（包括0.0），空字符串，None（None是Python里的一个特殊值，表示空值），&lt;/p&gt;
&lt;p&gt;空集合,包括( ) , [ ] , { }    其他值都认为是True&lt;/p&gt;
&lt;p&gt;变量名不能以 双下划线开头（这类标识符具有特殊意义，如： _&lt;em&gt;init_&lt;/em&gt;( ) 代表类的构造函数）&lt;/p&gt;
&lt;p&gt;同时只能由数字，字母，下划线组成。其他符号都不行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://hongscar.cn/categories/Python/"/>
    
    
      <category term="note" scheme="https://hongscar.cn/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://hongscar.cn/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>https://hongscar.cn/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</id>
    <published>2020-02-17T03:12:21.000Z</published>
    <updated>2020-02-17T06:18:40.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        此文用于记录一些常用的Linux命令。主要记录每一个命令的作用，参数的作用。</p><h4 id="①ls-英语全文：list。列出目录下的文件。-语法：-ls-选项-文件名或目录名"><a href="#①ls-英语全文：list。列出目录下的文件。-语法：-ls-选项-文件名或目录名" class="headerlink" title="①ls  英语全文：list。列出目录下的文件。  语法： ls [选项] [文件名或目录名]"></a>①ls  英语全文：list。列出目录下的文件。  语法： ls [选项] [文件名或目录名]</h4><p>-a：显示所有文件    –color=when(颜色输出。默认为always。 never：从不  auto：自动)<br>-d：显示目录信息，而非文件<br>-h：文件大小显示为k，M,G<br>-i：显示iNode<br>#####-l：长格式显示（ <strong>ll &lt;==&gt; ls -l</strong>）</p><a id="more"></a><hr><h4 id="②cd。英语全文：change-directory。更新目录-（Shell内置命令）"><a href="#②cd。英语全文：change-directory。更新目录-（Shell内置命令）" class="headerlink" title="②cd。英语全文：change directory。更新目录  （Shell内置命令）"></a>②cd。英语全文：change directory。更新目录  （Shell内置命令）</h4><p>Linux命令：Shell内置命令（无执行文件所在路径）/外部文件（有可执行文件）  Linux绝大部分是外部命令<br>-P:如果切换的是软链接目录，则进入原始的物理目录，而非软链接目录<br>-L:如果切换的是软链接目录，直接进入软链接目录</p><hr><h4 id="③mkdir-英语全文：make-directories。创建一个空目录"><a href="#③mkdir-英语全文：make-directories。创建一个空目录" class="headerlink" title="③mkdir 英语全文：make directories。创建一个空目录"></a>③mkdir 英语全文：make directories。创建一个空目录</h4><p>-p：递归创建一连串的新目录。  例子：mkdir -p a/b/c</p><hr><h5 id="④rmdir-英语全文：remove-empty-directories。-删除一个空的目录（只能删目录），如果目录有内容-如其他空目录-，就会报错。"><a href="#④rmdir-英语全文：remove-empty-directories。-删除一个空的目录（只能删目录），如果目录有内容-如其他空目录-，就会报错。" class="headerlink" title="④rmdir 英语全文：remove empty directories。 删除一个空的目录（只能删目录），如果目录有内容(如其他空目录)，就会报错。"></a>④rmdir 英语全文：remove empty directories。 删除一个空的目录（只能删目录），如果目录有内容(如其他空目录)，就会报错。</h5><p>（这个命令不常用，后续一般用rm命令） -p：递归删除</p><hr><h5 id="⑤touch-英语全文：change-file-timestamps。-触摸，如果文件不存在，创建一个空文件。如果已存在，修改文件的时间戳。"><a href="#⑤touch-英语全文：change-file-timestamps。-触摸，如果文件不存在，创建一个空文件。如果已存在，修改文件的时间戳。" class="headerlink" title="⑤touch 英语全文：change file timestamps。 触摸，如果文件不存在，创建一个空文件。如果已存在，修改文件的时间戳。"></a>⑤touch 英语全文：change file timestamps。 触摸，如果文件不存在，创建一个空文件。如果已存在，修改文件的时间戳。</h5><p>访问时间：Access  数据修改时间：Modify  状态修改时间：Change<br>-a：只修改文件的访问时间<br>-m：只修改文件的数据修改时间<br>-c：<del>只修改状态修改时间</del> 如果文件不存在，不创建新文件。（没有只修改状态修改时间的功能！）<br>-d：把文件时间修改为指定的时间，而非当前时间<br>（注意，不要把touch用作新建文件的命令）</p><hr><h5 id="⑥stat-英语全文：display-file-or-file-system-status。显示文件或文件系统的详细信息"><a href="#⑥stat-英语全文：display-file-or-file-system-status。显示文件或文件系统的详细信息" class="headerlink" title="⑥stat 英语全文：display file or file system status。显示文件或文件系统的详细信息"></a>⑥stat 英语全文：display file or file system status。显示文件或文件系统的详细信息</h5><p>stat [选项] 文件名或目录名（必须要指定第二个参数）<br>-f:查看文件所在的文件系统信息，而不是查看文件的信息<br>改变三种时间的命令：<br>cat：改变Access Time<br>echo：写入数据，改变Modify Time， Change Time<br>chown： 改变文件所有者。 改变Change Time<br>touch：三种都改（不使用选项时）</p><hr><h5 id="⑦cat-英语全文：concatenate-files-and-print-on-the-standard-output。连接文件并打印输出到标准输出"><a href="#⑦cat-英语全文：concatenate-files-and-print-on-the-standard-output。连接文件并打印输出到标准输出" class="headerlink" title="⑦cat 英语全文：concatenate files and print on the standard output。连接文件并打印输出到标准输出"></a>⑦cat 英语全文：concatenate files and print on the standard output。连接文件并打印输出到标准输出</h5><p>-A：列出所有隐藏符号(all)<br>-E:列出每行结尾的回车符$ (end)<br>-n:显示行号<br>-T:显示出Tab键 ^|<br>-v:列出所有特殊字符         （即-A &lt;==&gt; -vET）<br>(不论文件内容有多少，都会一次性显示，如果文件太大，上面部分不会显示完全。cat不适合查看太大的文件，有其他命令)</p><hr><h5 id="⑧：more-英语全文：file-perusal-filter-for-crt-view-in。分屏显示文件内容"><a href="#⑧：more-英语全文：file-perusal-filter-for-crt-view-in。分屏显示文件内容" class="headerlink" title="⑧：more 英语全文：file perusal filter for crt view in。分屏显示文件内容"></a>⑧：more 英语全文：file perusal filter for crt view in。分屏显示文件内容</h5><p>常用快捷键：  空格：向下翻页。  b：向上翻页。  回车键：向下滚动一行<br>/字符串： 搜索指定的字符串。  q：退出<br>?:对于这种持续性命令（more，top等），显示各种可执行操作（即help）</p><hr><h5 id="⑨：head-英语全文：output-the-first-part-of-files。显示文件开头的几行"><a href="#⑨：head-英语全文：output-the-first-part-of-files。显示文件开头的几行" class="headerlink" title="⑨：head 英语全文：output the first part of files。显示文件开头的几行"></a>⑨：head 英语全文：output the first part of files。显示文件开头的几行</h5><p>-n 行数：显示前[行数]几行（n与行数之间，有无空格均可） 行数默认为10<br>-v：显示文件名（被head操作的文件）<br>注意： -行数 &lt;==&gt; -n 行数。即： head -n 20 .bash_history &lt;==&gt; head -20 .bash_history</p><hr><h5 id="⑩：tail-英语全文：output-the-last-part-of-files。显示文件结尾内容"><a href="#⑩：tail-英语全文：output-the-last-part-of-files。显示文件结尾内容" class="headerlink" title="⑩：tail 英语全文：output the last part of files。显示文件结尾内容"></a>⑩：tail 英语全文：output the last part of files。显示文件结尾内容</h5><p>-n 行数：显示最后[行数]几行。同样默认为10，与head用法一致<br>-f：监听文件新增内容。使用时，光标会一直存在，当其他终端向该文件追加一些数据时，该命令会监视出来。</p><hr><h5 id="11：-ln-英语全文：make-links-between-file。在文件之间建立链接。-ln-选项-源文件-目标文件"><a href="#11：-ln-英语全文：make-links-between-file。在文件之间建立链接。-ln-选项-源文件-目标文件" class="headerlink" title="11： ln 英语全文：make links between file。在文件之间建立链接。 ln[选项] 源文件 目标文件"></a>11： ln 英语全文：make links between file。在文件之间建立链接。 ln[选项] 源文件 目标文件</h5><p>-s:建议软链接（默认是硬链接）<br>-f：如果目标文件已存在，删除目标文件后再建立链接文件<br>如果：目标文件没有文件名（即是一个目录），那么新建的文件名跟源文件名一致。<br>ln /root/a /tmp/ &lt;==&gt; ln /root/a /tmp/a   此时/root/a与/tmp/a是硬链接<br>（注意：硬链接没有其他要求，但如果建立软链接，那么源文件必须写绝对路径，不能是相对路径）<br>硬链接：两个文件的iNode相同，其一修改，另一个都会修改。但其中之一删除，iNode文件仍然能访问<br>      （不能跨文件系统(分区），因为不同分区的iNode值重新计算，而且不能链接目录) （不常用）<br>软链接：创建一个新的目标文件，iNode不同，指向源文件（相当于快捷方式）<br>ll查看软链接文件时，权限开头的l表示：软链接。 文件名 -&gt; 指向源文件<br>（软链接可以链接目录，而且可以跨分区）<br>软链接的block写的不是真正的数据，而仅仅是源文件的文件名及iNode号。删除掉软链接，源文件不受影响。删除掉源文件，软连接会失效。但如果改变软链接，那么源文件也会被修改。</p><hr><h5 id="12：rm-英语全文：remove-files-or-directories。删除文件-目录"><a href="#12：rm-英语全文：remove-files-or-directories。删除文件-目录" class="headerlink" title="12：rm 英语全文：remove files or directories。删除文件/目录"></a>12：rm 英语全文：remove files or directories。删除文件/目录</h5><p>-f：强制删除(force)<br>-i：交互删除（删前会询问，默认就是-i）<br>-r：递归删除，可以删除目录（加了-r才可以删目录）（逐层，直到最底层，逐层删除，逐个询问）<br>rm -rf：递归删除，不询问，强制。<br>（传说中的： rm -rf / ,删除所有，强制执行！）</p><hr><h5 id="13：cp-英语全文：copyfiles-and-directories。复制文件和目录。-cp-选项-源文件-目的文件"><a href="#13：cp-英语全文：copyfiles-and-directories。复制文件和目录。-cp-选项-源文件-目的文件" class="headerlink" title="13：cp 英语全文：copyfiles and directories。复制文件和目录。  cp[选项] 源文件 目的文件"></a>13：cp 英语全文：copyfiles and directories。复制文件和目录。  cp[选项] 源文件 目的文件</h5><p>-d：如果源文件是软链接，那么目的文件也为软链接（如果不指定，复制的会是源文件）。对硬链接无效<br>-p：保留源文件的属性（所有者，所属组，权限，时间）<br>-r：递归复制，用于目录<br>-a：相当于 -dpr<br>-i：询问，如果目标文件已经存在，询问是否覆盖<br>-l：将目标文件建立为源文件的硬链接，而不是复制源文件<br>-s：……建立为软链接<br>（复制文件时，如果目标’是一个目录，即没有指定文件名，则不改名复制，否则会改名）<br>（执行cp命令后，目标文件的时间会更改为命令的执行时间，而非源文件的时间。用-p或者-a可以解决）</p><hr><h5 id="14：-mv-英语全文：-move-rename-files-移动文件或者改名。-mv-选-源-目’"><a href="#14：-mv-英语全文：-move-rename-files-移动文件或者改名。-mv-选-源-目’" class="headerlink" title="14： mv 英语全文： move(rename) files 移动文件或者改名。  mv[选] 源 目’"></a>14： mv 英语全文： move(rename) files 移动文件或者改名。  mv[选] 源 目’</h5><p>-f:强制覆盖，如果已存在，直接覆盖<br>-i：交互。……。询问（默认为-i,即mv &lt;==&gt; mv -i）<br>-n:如果已存在，不覆盖<br>-v：显示移动过程<br>（如果要覆盖的是一个非空目录，则无法覆盖。即便是-f也不可以）<br>改名操作：如果源’和目’在同一路径，则为改名操作。 mv mytmp1 mytmp2</p><hr><h5 id="15：man-英语全文：format-and-display-the-online-manual-pages。帮助手册-man-选项-命令"><a href="#15：man-英语全文：format-and-display-the-online-manual-pages。帮助手册-man-选项-命令" class="headerlink" title="15：man 英语全文：format and display the online manual pages。帮助手册   man [选项] 命令"></a>15：man 英语全文：format and display the online manual pages。帮助手册   man [选项] 命令</h5><p>-f：查看命令拥有哪个级别的帮助<br>-k：查看和命令相关的所有帮助<br>快捷键：上，下，pageUp，pageDown  g：第一页  G：最后一页   q：quit<br>/str:所有str   ?str:向上搜索str   n：搜下一个str<br>N：如果是/str 切换成 ?str ,如果是?str,切换成 /str<br>例子：man -f passwd 有 passwd(1), passwd(5)<br>      那么：man 1 passwd =&gt; passwd(1)<br>其他：whatis &lt;==&gt; man -f<br>apropos  &lt;==&gt; man -k<br>想知道命令在哪：whereis   想知道当前用户是谁： whoami</p><hr><h5 id="16：info-同样是帮助，但是是一份完整详细的电子书"><a href="#16：info-同样是帮助，但是是一份完整详细的电子书" class="headerlink" title="16：info  同样是帮助，但是是一份完整详细的电子书"></a>16：info  同样是帮助，但是是一份完整详细的电子书</h5><hr><h5 id="17：help-只用户获取Shell内置命令的帮助，不常用"><a href="#17：help-只用户获取Shell内置命令的帮助，不常用" class="headerlink" title="17：help  只用户获取Shell内置命令的帮助，不常用"></a>17：help  只用户获取Shell内置命令的帮助，不常用</h5><p>如：ls是外部命令。 help ls，会报错。<br>但绝大多数命令可用 –help获取帮助。  例子： ls –help（输出man的简化版）</p><hr><h5 id="18：whereis-只能搜索命令，不能索索普通文件"><a href="#18：whereis-只能搜索命令，不能索索普通文件" class="headerlink" title="18：whereis  只能搜索命令，不能索索普通文件"></a>18：whereis  只能搜索命令，不能索索普通文件</h5><p>-b：只查找二进制命令<br>-m：只查找帮助文档（命令的帮助文档）</p><hr><h5 id="19：which-英语全文：shows-the-full-path-of-shell-commands。列出命令所在路径，如果该命令有别名，则同时显示出别名命令"><a href="#19：which-英语全文：shows-the-full-path-of-shell-commands。列出命令所在路径，如果该命令有别名，则同时显示出别名命令" class="headerlink" title="19：which 英语全文：shows the full path of shell commands。列出命令所在路径，如果该命令有别名，则同时显示出别名命令"></a>19：which 英语全文：shows the full path of shell commands。列出命令所在路径，如果该命令有别名，则同时显示出别名命令</h5><p>如： which mv =&gt; alias mv = ‘mv -i’ /usr/bin/mv<br>which ll =&gt; alias ll = ‘ls -l –color=auto’ /usr/bin/ls</p><hr><h5 id="20-locate-英语全文-find-files-by-name。按照文件名搜索文件"><a href="#20-locate-英语全文-find-files-by-name。按照文件名搜索文件" class="headerlink" title="20: locate 英语全文: find files by name。按照文件名搜索文件"></a>20: locate 英语全文: find files by name。按照文件名搜索文件</h5><p>只能根据文件名搜索，但是因为locate并不是搜索硬盘空间，而是先建立locate数据库，然后在数据库中搜索，因此：搜索速度快，耗费的系统资源非常小。<br>-i:忽略大小写（ignore）<br>例子：locate mkdir 会搜索出包含mkdir字符串的文件名，当然也包括mkdir命令<br>ps：locate数据库并不会实时更新，而是等用户退出登录或者重启系统时才会更新（因此新创建的文件无法立刻locate查到）<br>locate数据库位置： ll /var/lib/mlocate/mlocate.db (二进制文件)<br>命令： updatedb ： 可以即时更新一次locate数据库（这样可以locate到新文件。命令执行需要一定时间，要等待）<br>同时，部分文件类型或目录，并不会放到locate数据库中，如：<br>光盘，网盘，临时目录等（要么不在Linux系统中，是外来存储的网络存储的，要么是系统的缓存和临时文件，如/tmp下的文件，此时updatedb也没用）</p><hr><h5 id="21：-find-英语全文：search-for-files-in-a-directory-hierarchy。在目录中查找文件。"><a href="#21：-find-英语全文：search-for-files-in-a-directory-hierarchy。在目录中查找文件。" class="headerlink" title="21： find 英语全文：search for files in a directory hierarchy。在目录中查找文件。"></a>21： find 英语全文：search for files in a directory hierarchy。在目录中查找文件。</h5><p>不仅可按照文件名搜索，还可按照权限，大小，时间，iNode号等来搜索文件<br>（find是在硬盘中进行搜索的，如果指定的搜索范围过大，就会消耗较大的系统资源）<br>语法： find 搜索路径 [选] 搜索内容     （如果路径设定为 /, 那么执行起来就会很慢）<br>如果无选项，则将路径下的所有文件都输出。<br>-name：按照文件名搜索<br>-iname：按文件名，切不区分大小写<br>-inum：按照iNode号搜索<br>（如果是按照文件名。必须是完全匹配才会列出，如： find /root -name a123  此时只会列出名为a123的文件。如果是locate，会列出a123，还可能列出a12345，vca123等）<br>-size[+-] 大小:按文件大小搜索。 +-表示是比[大小]的数字还要大，还是小<br>例：find . -size +25k  当前目录下，大于25k的文件<br>（-size与后续的+或-，要有空格，而 +/-与大小之间无空格，k必须是小写(kb）)<br>千字节(kb)必须用小写k，兆字节(MB)必须用大写M，GB用大写G。<br>如果不写单位，默认单位并不是字节b，而是512byte，即半个kb。<br>如果单位要指定为字节，要用小写c。双字节要用小写w<br>-atime [+-] 时间：根据Access Time。。。  -mtime：…… -ctime：……<br>例子：find . -mtime -5 : 5天内修改的文件。   5：前5~6，这一天内修改的  +5：6天前修改的<br>同时还有amin，mmin，cmin，单位是分钟（time单位是天）<br>按权限： -perm 数字， -perm -数字， -perm +数字<br>按所有者和所属组： -uid 用户id， -gid 用户组id， -user 用户名， -gid 组名， -nouser（没有所有者）<br>例子：find . -user root 所有者是root的文件<br>按文件类型：-type d 查目录  -type f 查普通文件  -type l 查软链接</p><p>逻辑运算符：-a 与 ， -o 或 ， -not 非<br>例子：find . -size +2k -a -type f   (大于2kb且是普通文件)<br>      find . -name cangls -o -name bols (文件名是cangls或bols)<br>      find . -name a55 -o -size +3k(文件名为a55或者size大于3kb)<br>      find . -not -name cangls(文件名不为cangls)</p><p>find 路径 [选项] 内容 -exec 命令2 {} ;<br>指将find获取的结果放入{}中，再由命令2执行。<br>例：find . -size +2k -exec ls -l {} ;<br>获取size大于2kb的文件，并进行ls -l命令<br>PS：命令2与’{‘必须有空格,’}’和’&#39;之间也必须有空格。<br>而且此处不能-exec ll，推测不能用alias。<br>-ok选项：与-exec基本一致，不过操作前询问一次y/n</p><hr><h5 id="22-zip-英语全文-package-and-compress-files-压缩文件或目录"><a href="#22-zip-英语全文-package-and-compress-files-压缩文件或目录" class="headerlink" title="22: zip 英语全文:package and compress files.压缩文件或目录"></a>22: zip 英语全文:package and compress files.压缩文件或目录</h5><p>语法： zip [选项] 压缩包名 源文件或目录<br>-r： 压缩目录<br>可以同时压缩多个文件，用空格分开即可。<br>如果已经有同名压缩包，会进行覆盖。如果资源名也是相同，会updating，否则是adding。（压缩包会放在当前路径下）</p><hr><h5 id="23：unzip-英语全文：list-test-and-extract-compressed-files-in-a-ZIP-archive-列举，测试和提取压缩文件中的文件。"><a href="#23：unzip-英语全文：list-test-and-extract-compressed-files-in-a-ZIP-archive-列举，测试和提取压缩文件中的文件。" class="headerlink" title="23：unzip 英语全文：list,test and extract compressed files in a ZIP archive.列举，测试和提取压缩文件中的文件。"></a>23：unzip 英语全文：list,test and extract compressed files in a ZIP archive.列举，测试和提取压缩文件中的文件。</h5><p>-d: 指定解压位置<br>例子： unzip -d /root/mytmp3 mytest.zip</p><hr><h5 id="24-gzip-英语全文-compress-or-expand-files-压缩或解压文件-目录"><a href="#24-gzip-英语全文-compress-or-expand-files-压缩或解压文件-目录" class="headerlink" title="24: gzip 英语全文:compress or expand files.压缩或解压文件/目录"></a>24: gzip 英语全文:compress or expand files.压缩或解压文件/目录</h5><p>语法：gzip file1 压缩file1，生成file1.gz（源文件会消失）<br>-c: 将压缩数据输出到标准输出中，保留源文件（可用 &gt; 将输出重定向到一个文件中，这样既可以压缩，又不让源文件消失）<br>例子：gzip -c a123 &gt; a123.gz<br>-r:压缩目录（递归地将目录下的文件分别压缩成xxx.gz）<br>-d:解压（将压缩文件恢复原样）<br>-v:显示压缩文件信息（压缩比）<br>-数字：指定压缩等级，-1等级最低，压缩比最差，-9最高。默认为-6<br>PS：解压时，gzip -d abc &lt;=&gt; gzip -d abc.gz(即前者abc会自动寻找abc.gz文件)<br>文件太小时，压缩等级不同，压缩比也可能相同。</p><hr><h5 id="25：gunzip-解压。-gunzip-lt-gt-gzip-d"><a href="#25：gunzip-解压。-gunzip-lt-gt-gzip-d" class="headerlink" title="25：gunzip 解压。 gunzip &lt;=&gt; gzip -d"></a>25：gunzip 解压。 gunzip &lt;=&gt; gzip -d</h5><p>gunzip a123操作的同样是a123.gz，即 gunzip a123 &lt;=&gt; gunzip a123.gz<br>解压目录： gunzip -r（将目录下的压缩文件解压，但不会解压打包）<br>如果压缩文件是纯文本，用zcat可以在不解压的情况下查看文本内容</p><hr><h5 id="26：-bzip2-bz2格式文件的压缩命令（-bz2格式的算法理论上更好，及压缩比更好，但-gz更快）"><a href="#26：-bzip2-bz2格式文件的压缩命令（-bz2格式的算法理论上更好，及压缩比更好，但-gz更快）" class="headerlink" title="26： bzip2 .bz2格式文件的压缩命令（.bz2格式的算法理论上更好，及压缩比更好，但.gz更快）"></a>26： bzip2 .bz2格式文件的压缩命令（.bz2格式的算法理论上更好，及压缩比更好，但.gz更快）</h5><p>-d:解压<br>-k:压缩时保留源文件<br>-v:显示压缩信息 -数组：压缩等级<br>（gzip不支持打包目录，-r也只是分别压缩目录下的每个文件，而bzip根本不支持压缩目录，也没有-r选项）</p><hr><h5 id="27-bunzip2-等同bzip2-d-解压"><a href="#27-bunzip2-等同bzip2-d-解压" class="headerlink" title="27: bunzip2  等同bzip2 -d 解压"></a>27: bunzip2  等同bzip2 -d 解压</h5><p>-k：保留压缩文件<br>值得注意的是，一定要写明.bz2后缀，即 bunzip a ≠ bunzip a.bz2 , bzip -d同理。<br>如果是纯文本，用bzcat可以在不解压时查看文本内容。</p><hr><h5 id="28：tar-打包-解打包命令-语法：-tar-选项-f-压缩包名-源文件或目录"><a href="#28：tar-打包-解打包命令-语法：-tar-选项-f-压缩包名-源文件或目录" class="headerlink" title="28：tar 打包/解打包命令   语法： tar[选项][-f 压缩包名] 源文件或目录"></a>28：tar 打包/解打包命令   语法： tar[选项][-f 压缩包名] 源文件或目录</h5><p>-c：打包<br>-f：指定压缩包的文件名（写清后缀）<br>-v：显示打包过程<br>例子： tar -cvf test.tar /root/mytmp2<br>-x: 解压打包<br>-t：测试，即不解压，只是看包中有哪些文件<br>-C：指定解压位置。<br>解压与打包的区别： -xvf 与 -cvf       测试： -tvf<br>可以先tar，再gzip或bzip2，获得 .tar.gz 或者 .tar.bz2的格式<br>也可以一步到位： -z：压缩或者解压.tar.gz格式     -j：压缩或者解压.tar.bz2格式<br>例子： tar -zxvf a.tar.gz 解压<br>       tar -jcvf b.tar.bz2 /tmp/   压缩，压缩包的文件名为 b.tar.bz2<br>常用： -zcvf , -jcvf , -zxvf , -jxvf</p><hr><h5 id="29-sync-英语全文-flush-file-system-buffers-刷新文件系统缓冲区"><a href="#29-sync-英语全文-flush-file-system-buffers-刷新文件系统缓冲区" class="headerlink" title="29: sync 英语全文:flush file system buffers. 刷新文件系统缓冲区"></a>29: sync 英语全文:flush file system buffers. 刷新文件系统缓冲区</h5><p>作用：将内存中的数据强制向硬盘中保存，避免宕机导致数据丢失（该命令在常规关机时会自动执行） 直接执行，无须任何选项</p><hr><h5 id="30：-shutdown-英语全文：bring-the-sytem-down-关机和重启-执行权限：超级用户"><a href="#30：-shutdown-英语全文：bring-the-sytem-down-关机和重启-执行权限：超级用户" class="headerlink" title="30： shutdown 英语全文：bring the sytem down 关机和重启   执行权限：超级用户"></a>30： shutdown 英语全文：bring the sytem down 关机和重启   执行权限：超级用户</h5><p>格式： shutdown [选项] 时间 [警告信息]<br>-c：取消已经执行的shutdown命令 shutdown -c<br>-h： 关机   -r：重启<br>shutdown -h now    #现在立刻关机<br>shutdown -h 05:30   （当天的5：30关机，如果时间已过，就是第二天的5：30）<br>shutdown -h 05:30 &amp; (命令会一直占用前端)<br>其他关机重启命令： reboot重启， halt 或者 poweroff ， init 0 关机 ，  init 6 重启 （还是建议用shutdown）</p><hr><h5 id="31：setup-系统配置工具，配置IP，网卡，防火墙等（Red-Hat专有命令）"><a href="#31：setup-系统配置工具，配置IP，网卡，防火墙等（Red-Hat专有命令）" class="headerlink" title="31：setup  系统配置工具，配置IP，网卡，防火墙等（Red Hat专有命令）"></a>31：setup  系统配置工具，配置IP，网卡，防火墙等（Red Hat专有命令）</h5><hr><h5 id="32：ifconfig-查看IP地址信息（也可配置网络接口）-（windows是ipconfig）"><a href="#32：ifconfig-查看IP地址信息（也可配置网络接口）-（windows是ipconfig）" class="headerlink" title="32：ifconfig 查看IP地址信息（也可配置网络接口） （windows是ipconfig）"></a>32：ifconfig 查看IP地址信息（也可配置网络接口） （windows是ipconfig）</h5><p>inet addr：IP地址            netmask：子网掩码<br>broadcast：广播地址/MAC地址/局域网，以太网，物理地址</p><hr><h5 id="33：-ping-向网络主机发送ICMP请求，测试网络中主机的通信情况-ping-选-IP地址"><a href="#33：-ping-向网络主机发送ICMP请求，测试网络中主机的通信情况-ping-选-IP地址" class="headerlink" title="33： ping 向网络主机发送ICMP请求，测试网络中主机的通信情况         ping [选]IP地址"></a>33： ping 向网络主机发送ICMP请求，测试网络中主机的通信情况         ping [选]IP地址</h5><p>-b：后面加入广播地址，对整个网段进行探测<br>-c 次数：指定ping的次数（中间有无空格均可。如果不指定，会一直ping）<br>-s 字节：指定探测包的大小</p><hr><h5 id="34：netstat-网络状态查看命令，可以看到本机开放的端口，也可看有哪些客户端连接"><a href="#34：netstat-网络状态查看命令，可以看到本机开放的端口，也可看有哪些客户端连接" class="headerlink" title="34：netstat 网络状态查看命令，可以看到本机开放的端口，也可看有哪些客户端连接"></a>34：netstat 网络状态查看命令，可以看到本机开放的端口，也可看有哪些客户端连接</h5><hr><h5 id="35：write-英语全文：send-a-message-to-another-user-向其他用户发送信息"><a href="#35：write-英语全文：send-a-message-to-another-user-向其他用户发送信息" class="headerlink" title="35：write 英语全文：send a message to another user 向其他用户发送信息"></a>35：write 英语全文：send a message to another user 向其他用户发送信息</h5><hr><h5 id="36-mail-英语全文：send-and-receive-Internet-mail-发送和接受电子邮件"><a href="#36-mail-英语全文：send-and-receive-Internet-mail-发送和接受电子邮件" class="headerlink" title="36: mail 英语全文：send and receive Internet mail. 发送和接受电子邮件"></a>36: mail 英语全文：send and receive Internet mail. 发送和接受电子邮件</h5><p>ctrl + c 和 ctrl + z的区别：<br>c是强制中断程序的执行，此时进程就会终止。<br>而z是讲任务终止（暂停），但进程并没有结束，只是被挂起。用户可用fg/bg继续前台或后台的任务</p><hr><hr><p>其他常用命令：（选项参数略）<br><strong>①top</strong>  查看系统的整体运行情况（相当于任务管理器）</p><p>*<em>②df *</em> 显示磁盘空间使用情况</p><p>*<em>③du *</em> 对文件和目录磁盘使用空间的情况</p><p><strong>④date</strong> 当前日期和时间<br>例子：将当前时间写入文件：  date &gt; cangls   如果是 echo date &gt; cangls ,写入cangls文件的会是字符串“date”<br>(&gt; , &lt; 用作输出重定向，echo为显示命令，显示后重定向，就是写操作)</p><p><strong>⑤ps</strong> 列出当前系统的进程状态  ps -ef   第一个数字是 PID，进程ID。 第二个数字是PPID，父进程的ID</p><p><strong>⑥kill</strong>  删除，终止程序。  （kill -数字）<br>kill -1： 终端断线<br>kill -2：中断（同ctrl + c）<br>kill -9: 强制终止<br>……<br>（只有9才可无条件终止进程，其他信号，进程有权利忽略。。）</p><p><strong>⑦grep</strong> 文本搜索，用正则表达式搜索，匹配文本<br>-i：忽略大小写  -n：所在行数<br>管道符： |   将两个命令分隔开，前一个的stdout（输出）作为下一个的stdin（输入）<br>例子： ps -ef | grep ping 查找包含ping的进程</p><p><strong>⑧awk sed grep</strong> 文本处理。</p><p><strong>⑨free</strong> 显示系统内存使用情况，包括物理内存，交换区内存（SWAP），内核缓冲区内存。</p><p><strong>⑩clear</strong>  清屏  vim：进行vim文本编辑器</p><p>11： <strong>rpm</strong>  安装RPM包。  rpm -ivh 包全名  -i：install  -v：显示详细信息verbose  -h：打印，显示安装进度hash<br>-e：卸载。   rpm -e 包名</p><p>12：启动服务等： <strong>service</strong> 服务名 start | stop | restart | status<br>                <strong>systemctl</strong> start | stop | restart | status 服务名</p><p>13：<strong>yum命令</strong>  下载相应的rpm包并安装，解决了依赖关系<br>yum list: 列出可安装，已安装的包<br>yum search: 从yum镜像源服务器上查找与关键字相关的所有软件包<br>yum info： 查询执行软件包的详细信息（大小，版本，证书，描述等）<br>yum install：安装  -y：自动回答yes<br>（用yum卸载软件包时，会把依赖包也同时卸载，包括系统允许的必备文件，此时的结果就是，系统崩溃。所以一般不要用yum卸载软件包）</p><p>gcc编译器， make：完成对源码包的自动编译    make install：将编译文件进行安装</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;​        此文用于记录一些常用的Linux命令。主要记录每一个命令的作用，参数的作用。&lt;/p&gt;
&lt;h4 id=&quot;①ls-英语全文：list。列出目录下的文件。-语法：-ls-选项-文件名或目录名&quot;&gt;&lt;a href=&quot;#①ls-英语全文：list。列出目录下的文件。-语法：-ls-选项-文件名或目录名&quot; class=&quot;headerlink&quot; title=&quot;①ls  英语全文：list。列出目录下的文件。  语法： ls [选项] [文件名或目录名]&quot;&gt;&lt;/a&gt;①ls  英语全文：list。列出目录下的文件。  语法： ls [选项] [文件名或目录名]&lt;/h4&gt;&lt;p&gt;-a：显示所有文件    –color=when(颜色输出。默认为always。 never：从不  auto：自动)&lt;br&gt;-d：显示目录信息，而非文件&lt;br&gt;-h：文件大小显示为k，M,G&lt;br&gt;-i：显示iNode&lt;br&gt;#####-l：长格式显示（ &lt;strong&gt;ll &amp;lt;==&amp;gt; ls -l&lt;/strong&gt;）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://hongscar.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://hongscar.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装Apache</title>
    <link href="https://hongscar.cn/Linux%E5%AE%89%E8%A3%85Apache.html"/>
    <id>https://hongscar.cn/Linux%E5%AE%89%E8%A3%85Apache.html</id>
    <published>2020-02-17T03:12:12.000Z</published>
    <updated>2020-02-17T06:18:26.240Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下第一次在Linux上安装Apache遇到的问题以及解决过程。</p><p>具体步骤可以参考此博文：<br><a href="https://blog.csdn.net/u010297957/article/details/50751656" target="_blank" rel="noopener">https://blog.csdn.net/u010297957/article/details/50751656</a></p><p>1.安装有两种方法，<strong>第一种是手动安装</strong>，</p><p>步骤：<br>①<strong><em>先下载相关的源码包</em></strong>，包括：Apache HTTP Server（这个就是我们要安装的Apache Server，但它还需要其他依赖包，所以仅有这个并不足够），APR（Apache Server的依赖包，然而这个APR本身又依赖APR-Util和PCRE），APR-Util，PCRE。一共4个源码包。此处用到了wget命令，wget url，下载相应的源码包。</p><a id="more"></a><hr><p>②<strong><em>解压源码包</em></strong>，获得源码文件，用到tar命令，至于选项是-zxvf还是-jxvf则看下载的文件类型是tar.gz，tar.bz2来决定。</p><hr><p>③<strong><em>要将这些软件解压到/usr/local/ 下</em></strong> (并不强求，但用户软件安装到这个目录是一个好选择)。先创建相应的目录存放文件，如mkdir /usr/local/httpd , mkdir /usr/local/apr , mkdir /usr…/pcre</p><hr><p>④<strong><em>分别对4个软件进行，配置，编译，安装。</em></strong>用到的命令： ./configure … (./指当前目录下的configure命令，要先进入相应的文件夹)，配置完成之后执行make命令，用于编译源码文件。最后执行make install，安装。（configure的时候要指定相应的依赖包文件）</p><hr><p>⑤<strong><em>此时Apache已安装完毕，进入bin目录执行./apachectl start ，即可启动Apache服务。</em></strong>至于Apache相应的配置，进入conf命令修改httpd.conf即可。（建议提前对httpd.conf进行备份，避免出错。 cp httpd.conf httpd.conf.bak）</p><hr><p>⑥<strong><em>在httpd.conf定义相应的监听端口等，然后外网即可通过IP地址访问服务器。</em></strong></p><hr><p><strong>当中遇到的问题：</strong></p><p>①一开始是根据那个Linux教程来安装的，它那里只要求用Apache HTTP Server的源码包，缺少相关的依赖包，因此要先把APR下载安装。</p><hr><p>②安装APR时又缺少依赖包，需要APR-Util。</p><hr><p>③下载APR-Util，安装时出错，显示缺少expat.h文件，即缺少expat库，此时需要安装expat开发库。yum install expat-devel。安装完成后再安装APR-Util即可。</p><hr><p>④再安装APR，成功。此时安装Apache HTTP Server要指定APR和APR-Util的路径，依然报错，显示缺少PCRE。跟前面的错误是相同性质的，不是大问题。</p><hr><p>⑤下载PCRE，安装，此时又出错，显示：configure: error: You need a C++ compiler for C++ support.因为我的机器默认只安装了gcc，还没有安装gcc-c++，因此要编译C++文件的时候就出错了。所以此时要安装C++环境。yum install -y gcc-c++ (安装gcc同理)。安装完gcc-c++之后，安装PCRE没有任何问题，都是make，make install。</p><hr><p>⑥最后安装Apache HTTP Server，把上面3个依赖包的路径都指定了，安装成功。</p><hr><p>⑦在bin中启动了Apache的httpd服务，配置完httpd.conf后，外网可以访问到Apache，有一个默认的index.html，显示it works！表示Apache配置完成。</p><hr><p>⑧此时想找到这个index.html来做一下简单的修改，但找不到相应的文件在哪。上网查到，httpd.conf文件中，有一个DocumentRoot的路径，表示默认的路径在哪。本文当前的路径是：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/Linux_01.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/Linux_01.jpg" alt="DocumentRoot路径"></a><br>进入htdocs文件夹后，可以看到只有一个index.html，看来默认项目的路径的确是这里。</p><hr><p>⑨修改index.html，出现中文乱码。一开始设定了GB2312编码，依然无效，然后改为UTF-8，乱码问题解决。推测是vim编辑器本身的编码就是用UTF-8，所以设置html为GB2312并无效果？毕竟在本地直接编写GB2312是没有乱码问题的(—TODO)。然后再新增一个my.html，外网依然能通过改路径访问。Apache的配置和连通性测试到此结束。</p><hr><p><strong>总结：</strong></p><p>1.第一种方法主要是，下载源码包以及相应的依赖包，然后分别进行解压，配置，编译，安装。最关键的是要指定依赖包，因此必须按照顺序，先安装没有其他依赖的包，即先PCRE，再APR,APR-Util，最后才是Apache。安装成功就是配置和启动Apache，配置是在httpd.conf中配置，启动是在bin目录下启动。</p><p>2.第二种方法，直接使用yum安装。yum就是自动化安装，它会自动帮你安装相应的依赖包，无须自己手动操作，即我们要安装httpd的时候，它也会自动把PCRE等也安装好了，无须像第一种方法一样，在安装httpd之前还要自己先安装PCRE等。网上的教程也都是说直接用yum list httpd，然后yum install httpd.x86_64就可以了。可是自己实际操作的时候，发现第一步yum list就没有找到相应的包，只有其他的版本，如Lighttpd(light httpd)轻量级的版本等等。也尝试过换镜像源（虽然觉得可能性不大，但还是尝试了一下），后来在镜像源的网站上是可以直接搜到httpd的，可是在Linux上却找不到。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/789.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/789.jpg" alt="阿里镜像源下搜索httpd"></a></p><p>继续尝试了一下，mysql，nginx等也是没有相应的包。按理说这些常用的，应该肯定存在包才对。最后查看yum命令的配置文件yum.conf，才发现它有一个exclude名单：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/777.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/777.jpg" alt="yum.conf的exclude名单"></a></p><p>可以看到都是最常用的几个服务，想了一下，肯定不是黑名单，那么作用应该是：避免平时误操作，在已经install了这些服务的情况下，又再次安装一次，把之前的数据给搞坏。所以解决方法并不是要修改这个conf，而是在yum的时候显式说明，使得exclude无效，即：<br><code>yum disableexcludes all install httpd</code><br>(当然，也可以修改yum.conf，安装完再改回去。。)</p><p>解决了这个问题之后，的确就直接安装成功。在后续的启动和配置服务的时候，也遇到了问题。不过猜想是和第一种方法安装的Apache起冲突了，也懒得如何共存了，直接用最暴力的方法解决：把第一种方法安装的Apache给卸载掉了，remake之后，第二种方法安装的Apache就能成功运动了~至此，两种方法安装Apache都成功。</p><p>最后的总结：yum安装的确方便很多，在安装之前先yum list找到相关的源码包，或者直接到镜像源的官网去查找，作用都是一样的。总的来说yum安装要方便简单一些，但手动安装可以自己定制修改源码等等，那个就是更高级的层面了，暂时不考虑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下第一次在Linux上安装Apache遇到的问题以及解决过程。&lt;/p&gt;
&lt;p&gt;具体步骤可以参考此博文：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/u010297957/article/details/50751656&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/u010297957/article/details/50751656&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.安装有两种方法，&lt;strong&gt;第一种是手动安装&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;步骤：&lt;br&gt;①&lt;strong&gt;&lt;em&gt;先下载相关的源码包&lt;/em&gt;&lt;/strong&gt;，包括：Apache HTTP Server（这个就是我们要安装的Apache Server，但它还需要其他依赖包，所以仅有这个并不足够），APR（Apache Server的依赖包，然而这个APR本身又依赖APR-Util和PCRE），APR-Util，PCRE。一共4个源码包。此处用到了wget命令，wget url，下载相应的源码包。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://hongscar.cn/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="https://hongscar.cn/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建记录</title>
    <link href="https://hongscar.cn/Hexo%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95.html"/>
    <id>https://hongscar.cn/Hexo%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95.html</id>
    <published>2020-02-17T03:11:38.000Z</published>
    <updated>2020-02-17T04:01:51.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        Hexo是一个很流行的博客框架。之前一直想构建一个博客，也花费过很多功夫。其实一开始是想着完全自己从零实现，不使用框架，主要是为了学习一遍web开发。很可惜，到了后面愈发感觉力不从心。不套用博客框架自己实现，确实自由度非常广，可是要用到的知识也非常的多。对于后端，我用的是SSM+Redis，前端用的是Bootstrap和jQuery。最后让我放弃的是前端原因，我感觉自己对前端仅限于读懂，或者写一些简单的界面，或者是在别人的界面上进行修改。在找前端模板的过程中，我就想着不如试试Hexo吧，反正学习目的已经达到了，于是记录一下Hexo搭建博客的过程遇到的问题。<strong><em>这里使用的hexo版本是：4.2.0</em></strong></p><a id="more"></a><h3 id="如何使用Hexo"><a href="#如何使用Hexo" class="headerlink" title="如何使用Hexo"></a>如何使用Hexo</h3><p>​        不同的博客框架有利有弊，如果是新手就直接选Hexo吧，不要去考虑Wordpress，Hugo等等的了，那些以后再慢慢接触，现在Hexo就足够用了！于是我参考了一个<strong><em><a href="http://fanzhenyu.cn/2016/11/30/Github%20Pages%20+%20Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">博客</a></em></strong>，大概的步骤都是完全按照它的，所以也无须再照搬一次了。</p><h3 id="构建Hexo的过程遇到的问题"><a href="#构建Hexo的过程遇到的问题" class="headerlink" title="构建Hexo的过程遇到的问题"></a>构建Hexo的过程遇到的问题</h3><p>​        只要是上网学过教程的朋友，或者是看书的朋友，都肯定会遇到一个问题：跟着书上/文章上的去做，却发现出错。导致的原因一般有，自己忽略了步骤，版本的变更。无论如何，这些才是学习中最大的困难，所以这篇文章就是记录我在构建Hexo博客的过程中所遇到的问题，以及如何解决。</p><h4 id="①-注册GitHub，使用GitHub-Page。本地安装Git，配置好环境变量，本地Git与Github连接。在Git-bash中安装node-js和hexo及其依赖文件。将本地hexo项目托管到GitHub"><a href="#①-注册GitHub，使用GitHub-Page。本地安装Git，配置好环境变量，本地Git与Github连接。在Git-bash中安装node-js和hexo及其依赖文件。将本地hexo项目托管到GitHub" class="headerlink" title="① 注册GitHub，使用GitHub Page。本地安装Git，配置好环境变量，本地Git与Github连接。在Git bash中安装node.js和hexo及其依赖文件。将本地hexo项目托管到GitHub"></a>① 注册GitHub，使用GitHub Page。本地安装Git，配置好环境变量，本地Git与Github连接。在Git bash中安装node.js和hexo及其依赖文件。将本地hexo项目托管到GitHub</h4><p>​        一般程序员都有GitHub，所以前面的步骤基本都可以忽略掉。直到安装hexo的时候，这时候原文有提到需要初始化hexo：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init hexo</span><br></pre></td></tr></table></figure><p>这里就出现了问题，显示：<em>bash: hexo command not found</em>。显然，没有找到hexo命令。对于此类错误，一般有两种可能。第一种可能的错误是没有安装hexo，于是再三确定了一下前面的安装代码是否出错，并没有，基本可以排除。第二种可能的错误是环境变量的设置问题。我们都知道只有把命令设置到环境变量里才可以直接在命令行里调用，或者就是安装的时候安装系统自动添加到了环境变量，只有这样才可以直接使用。于是我们到环境变量里添加hexo的安装路径：F:\XXX\node_modules\.bin    问题解决。</p><p>​    除此之外，如果yml配置文件出错（一般是格式错误，记住yml的冒号需要用英文格式，以及冒号后面要加空格即可），那么启动hexo会失败，导致无法访问主页。这时候就要具体地看一下启动的时候的报错信息去检查。</p><p>​    只要完成教程一，那么最简陋的hexo就搭建成功了，后续就是完善。</p><h4 id="②-全局配置文件的设置，主题配置文件的设置。设置图片，设置菜单，添加几个菜单页面，发布文章。"><a href="#②-全局配置文件的设置，主题配置文件的设置。设置图片，设置菜单，添加几个菜单页面，发布文章。" class="headerlink" title="② 全局配置文件的设置，主题配置文件的设置。设置图片，设置菜单，添加几个菜单页面，发布文章。"></a>② 全局配置文件的设置，主题配置文件的设置。设置图片，设置菜单，添加几个菜单页面，发布文章。</h4><p>​        配置文件处都没什么问题。图片那里值得一提的是，默认的图片路径是 hexo/source/下。而菜单页面看起来也是调用命令hexo new page xxx即可自动生成，在对应的路径下就能看到一个index.md（部署到GitHub的时候会变成index.html）。可是无法访问，一直报错，<strong>Cannot GET /about/%20/</strong>。这里的关键是%20，这是空格的意思！知道了这个，就很容易排查了，问题出在配置文件里。虽然它提供了默认代码，但它的||前后加了空格，导致出错。所以虽然这是默认代码，但我们还是老老实实把它的错误改了吧：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/||home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/||user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/||tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/||th</span></span><br><span class="line">  <span class="comment"># archives: /archives/ || archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment"># sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure><p>​        这时候一般是可以运行了的，如果还是不行，那么可能是因为你复制了上面教程作者的md文字？可能是由于版本的不同，教程作者的index.md的第一行是：”—“，如果你也跟着加了，那么就是画蛇添足了。我这里用的是Typora，只要在那条虚线下面开始写你的页面内容即可（上面的都是格式配置，一般不会直接显示出来）。于是，这里的问题也解决了。发布文章也是同理。</p><p>​        完成教程二，对于博客的关键功能：发布文章，分类查找等等，都已经可以实现，后续可以继续添加更多有趣的功能。</p><h4 id="③教程三"><a href="#③教程三" class="headerlink" title="③教程三"></a>③教程三</h4><p>​        教程三是教我们使用外部图床存储图片，添加了一个评论功能，以及文章浏览量，网站访问量，站内搜索等等。这里我个人只建议看浏览量和站内搜索。因为外部图床，其实新手暂时没必要，等到你觉得性能需要提高的时候才考虑，先把网站搭起来吧（其实直接用腾讯云COS就可以做图床了）。。至于评论功能，这个评论功能是过时的，不建议使用。</p><p>​        浏览量这里也存在问题，开启了之后只有图标，没有显示具体数据，这是因为hexo next主题中不蒜子脚本链接失效，这时候需要编辑：<strong>/themes/next/layout/_third-party/analytics/busuanzi-counter.swig</strong> 文件，将里面的链接：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js</span></span><br></pre></td></tr></table></figure><p>改成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js</span></span><br></pre></td></tr></table></figure><p>​        这时候就能看到统计的数据量了。</p><p>​        对于站内搜索功能，设置了全局配置文件，发现仍然没有搜索功能，这是因为我们还需要一个步骤，在主题配置文件里找到 <strong>local_search</strong>。显然，还需要把enable的false值：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="④-添加功能模块"><a href="#④-添加功能模块" class="headerlink" title="④ 添加功能模块"></a>④ 添加功能模块</h4><p>​        教程四的内容我直接跳过了，感觉意义不是很大，但评论功能还是比较有用的，于是直接研究评论功能。一开始按照教程来使用Gitment，无论怎么样都显示Error： Not Found。原因竟然是。。Gitment已经过时了，大概是作者也不维护了，服务器也过期了等等，所以大家跳车吧，转战<strong>Gittalk</strong>。这里的使用的教程是<strong><a href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank" rel="noopener">这个</a></strong>。</p><p>​        Gitalk中值得注意的问题是：</p><p>​            Ⅰ. <strong>comments.swig</strong>处添加一个elseif，这里要注意elseif添加的位置，要与前面的elseif同一级别，自己细心看一下就知道要添加在哪里了，不要添加在endif后面。。</p><p>​            Ⅱ. 最常见的错误，<strong>Error: Not Found</strong>。在Gitment就是因为这个而弃坑的，可是在Gitalk依然遇到了这个情况。这里的错误点在于：repo的位置出错。这里的repo值必须是： xxx.github.io，而不能写 <a href="https://github.com/Xxx/xxx.github.io" target="_blank" rel="noopener">https://github.com/Xxx/xxx.github.io</a></p><p>​            解决了这两个问题，只要把项目部署到GitHub上，就能成功运行了。至此，hexo搭建基本结束，重要的功能都涵盖了，后续还能进行更多的补充。</p><h4 id="⑤-一些其他可能会出现的错误"><a href="#⑤-一些其他可能会出现的错误" class="headerlink" title="⑤ 一些其他可能会出现的错误"></a>⑤ 一些其他可能会出现的错误</h4><p>​        即使是像本人的专业踩坑者，也不可能把所有的坑踩完（否则我应该去应聘测试！）。所以这里只能列举一些我本人遇到的错误，以及如何解决。</p><p>​        在关闭hexo server的时候，应该使用ctrl + c，不小心按成了ctrl + z，也就是挂起，导致后续再启动会显示端口占用。这属于Linux的基本命令问题。本来想通过ps，kill等等的命令去解决的，可是都不行。最后使用的是jobs命令。jobs命令可以查找job号（假设为num），这时候我们执行 <strong>stop %num</strong>  ，即可解决。</p><p>​        踩完坑在本地修改完，发现打开网址还是没有改变？这个问题很多web开发者应该都曾经遇到，其实最简单的原因就是缓存的原因，浏览器直接读取了缓存的东西，导致服务器新改的东西并没有生效，这时候只需要：<strong>ctrl + F5</strong>，浏览器刷新，可能你就会发现有所改变了，避免了多做无用功。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;​        Hexo是一个很流行的博客框架。之前一直想构建一个博客，也花费过很多功夫。其实一开始是想着完全自己从零实现，不使用框架，主要是为了学习一遍web开发。很可惜，到了后面愈发感觉力不从心。不套用博客框架自己实现，确实自由度非常广，可是要用到的知识也非常的多。对于后端，我用的是SSM+Redis，前端用的是Bootstrap和jQuery。最后让我放弃的是前端原因，我感觉自己对前端仅限于读懂，或者写一些简单的界面，或者是在别人的界面上进行修改。在找前端模板的过程中，我就想着不如试试Hexo吧，反正学习目的已经达到了，于是记录一下Hexo搭建博客的过程遇到的问题。&lt;strong&gt;&lt;em&gt;这里使用的hexo版本是：4.2.0&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://hongscar.cn/categories/hexo/"/>
    
    
      <category term="blog" scheme="https://hongscar.cn/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>centos环境配置记录</title>
    <link href="https://hongscar.cn/centos%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95.html"/>
    <id>https://hongscar.cn/centos%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95.html</id>
    <published>2020-02-17T03:11:19.000Z</published>
    <updated>2020-02-17T06:17:21.955Z</updated>
    
    <content type="html"><![CDATA[<p>（Tomcat + MySQL + Redis的配置，以及连通性测试）</p><p>写在前面:<br>其实大概半年前就已经配置好了Tomcat跟MySQL，项目也部署好了，能够正常的运行。但自从8月底的时候加上了redis，就开始出现了问题。从那时候开始，服务器的CPU一直停留在100，似乎是MySQL与Redis之间出现了冲突。但我当时装了好了Redis，大概只是简单学习了几天就搁置了，所以等到我意识到服务器出现问题的时候，已经是9月下旬的时候了。（中途域名拿去网站备案了，所以项目也是一直搁置的。但中途在研究MySQL的锁机制的时候，确实已经觉得服务器出现了问题，时不时会掉线）对于问题的排查，持续了一整天都没有解决，使用TOP命令，会发现CPU idle space是0，要么是0，要么是100，两个数字之间刷新，但下面的所有进程，就没有CPU超过5%的进程。除了top，诸如netstat，vmstat，df -h，uptime，等等的各种命令都尝试过了，还是没有找出问题。倒是发现在/var/crash中出现了高达25G的系统崩溃碎片，删除了也未果。甚至，一怒之下把这个基础的服务器升级了（1核2G，直接升级为4核8G），结果还是显示100。。说实话，我就那么一个项目，能够把这种升级后的配置也用到CPU100，唯一的可能也只是出现了deadlock了吧。但我排查了许久都失败了，服务器上的数据库也崩溃了无法访问，而且我对于数据库也没有备份的习惯（以后一定要对数据库进行定时备份）。导致只好先对这个出了问题的系统进行snapshot，等待以后需要那部分数据，或者有时间的时候，再回去排查问题吧，至少也要把那部分数据拿回来。<br>然后呢，就是直接把系统重装了，那么就需要重新配置一遍环境。其实因为之前配置这三个的时候都比较轻松，所以心里觉得应该很快能解决的。但没想到遇到了各种各样的问题，所以这次把整个成功的配置过程都写出来记录，包括中间出现了错误如何解决等等。</p><a id="more"></a><p>最后，在不同的系统之间，在不同的软件安装包之间，都存在差异，而这种差异可能会导致安装的时候也会面临不同的问题，所以仅供参考本文列出的服务器系统版本，以及安装包的版本。<br>本文的主要内容：安装Tomcat，MySQL，Redis的过程，本地连接访问Tomcat，MySQL，Redis的过程。Spring项目整合MySQL并发布的过程（Redis目前只做了连通性测试，还没有整个到项目中)<br>服务器系统版本：CentOS 7.6 64位</p><p><strong>step1：服务器安装Tomcat并在本地执行连通性测试</strong><br>这一步其实很简单，但我当中出现了一个比较stupid的错误，导致也卡了很久。总的步骤也很简单：到官网下载RPM包，解压，进入bin目录执行startup.sh即可启动Tomcat，然后在本地进行连通性测试（也就是打开xxx.xxx.xx.xx:8080看是否会出现初始页面而已）。<br>安装完了之后，我还想把tomcat放到Linux的系统服务中（也就是把tomcat的启动脚本拷贝一份放到/etc/init.d/中，然后进行一系列操作诸如chkconfig命令等等），但我尝试过了之后失败了，想想其实服务器也很少关闭，而且只要记住Tomcat的路径就好，我的是放在/usr/local/tomcat下，想处理的时候直接进去该目录执行相关的.sh脚本就好。于是这部分pass。<br>然后连通性分析，第一次的时候就失败了。然后网上都说开通端口，防火墙配置等等的就好，这部分也不难，很快就解决了，在本地也成功看到了Tomcat的初始页面。<br>接下来关键的点就来了，我把本地的war项目复制到了webapps文件夹下，然后关闭tomcat之后重新执行，发现连初始页面都看不到了。当时可能比较晚了，所以我也没想清楚，通过netstat，ps等命令发现tomcat的关闭，开启都存在问题，于是觉得可能还是端口的问题等等的。通过了一顿蜜汁操作之后还是无法访问。当时都怀疑人生了（为什么刚刚还能访问初始页面，突然就不行了？沃不服！）然后到了第二天再redo一次才顿悟，应该是war出现了问题，所以tomcat的开启跟关闭出现了错误，然后才导致了初始页面也无法访问的情况（因为之前的war一直是可以访问的，所以也没考虑这一点）。所以我把webapps下的war给删掉了，包括war解压后的文件夹，再restart一次tomcat，发现确实就可以访问初始页面了。所以：如果tomcat可以正常开启，但加入了错误的war之后，是会导致tomcat也出错的（我开始以为应该是其他项目会可用，只有该自定义war不可用才对，但事情并不是如此）。出错原因也很显然，服务器重装了，MySQL也没了，那么项目指向了MySQL就无法访问了，自然也就全部出错了。所以我得先把MySQL安装好，然后再在本地的项目连通数据库，到时候再进行打包，放置到webapps下，应该就可以成功运行了。</p><hr><p><strong>step2：服务器安装MySQL并且在本地执行连通性分析</strong><br>我是参照这一篇文章来执行的：<a href="https://blog.csdn.net/u013541411/article/details/89516575" target="_blank" rel="noopener">https://blog.csdn.net/u013541411/article/details/89516575</a><br>其实安装MySQL应该也是一个很简单的流程，但因为第一天的时候，被Tomcat的错误搞到不明所以，还以为是MySQL的问题，也进行了很多无用的排查。所以问题的定位也是非常的关键。<br>但还好这篇文章确实还是可行的，除了在安装server的时候其实还要安装一个其他的软件，但问题不大。错误信息CV一下，答案就出来了。<br>然后本地连通性，排查了好久都不行，最后才发现，是服务器的安全组没有开通3306端口号。第一天的时候很轻松就连通了，因为当时还没有设置安全组。之后安全组设置了开放3306端口号之后就成功了连通。然后对项目执行了连通性测试，也是可行的。再打包，放置到webapps，成功执行。</p><hr><p><strong>step3：服务器安装Redis并且在本地执行连通性分析</strong><br>参照文章：<a href="https://www.cnblogs.com/zuidongfeng/p/8032505.html" target="_blank" rel="noopener">https://www.cnblogs.com/zuidongfeng/p/8032505.html</a><br>这篇文章是确实可行的，唯一要注意的点是，它的当前目录并不是root，而且存在变化，要看清楚。比如第一条命令是在/usr/local下执行的，如果在root下执行，还得对tar指定解压路径。<br>关于安装到系统服务：第一次的时候我是在root下面tar的，导致有点乱。于是我删掉了重来，第二次在usr/local下开始执行，最后一步差点就成功了。在使用systemctl status redisd查看的时候，发现状态是active(exited)，这种其实有点贼，虽然算是启动成功，但其实跟失败没有区别，所以千万不要看到绿色就觉得是no problems。当然了，在status下面可以看到错误信息：<br><code>/var/run/redis_6379.pid exists, process is already running or crashed</code><br>这个的原因是，如果redis没有正确的关闭（比如直接rm -rf，kill -9等等），那么该文件还是会存在的，导致第二次执行的时候就会出错。这时候要做的也是很简单，先stop/kill等等，再删掉：<br><code>rm -rf /var/run/redis_6379.pid</code><br>然后再start，执行status查看，状态改成了active（running），看来是成功执行了，那么使用redis-cli测试一下，确实可行。<br>接下来对redis增加密码，也是出错了许久。其实添加密码都不难，但是在restart / stop, start的时候都出现了问题。无论是restart还是stop，命令都会卡住，只能ctrl + C。那么显然，就是Redis没有正确关闭了，于是就又会出现上面的问题，又要再rm一次。关键是再次成功启动，发现密码还是没有。仔细一想才明白，上面那篇文章，conf文件并不是redis文件夹下的conf，而是拷贝了一个副本，存到了/etc/redis中，名为6379.conf，所以我们需要改的是6379.conf的内容，也不是Redis文件夹下的redis.conf。改了之后，确实就成功添加了密码。而且还有一点很关键，添加了密码之后，Redis的关闭是存在问题的。比如之前没有密码，直接systemctl stop redisd即可，而有了密码就不能直接这样。这时候我们需要先进入redis-cli，auth（已经有了密码），然后执行：shutdown。在redis-cli里关闭Redis连接，然后quit回到命令行，最后再执行systemctl stop redisd。这时候我们就能成功地退出，然后start也可以成功执行，密码也成功添加了。（退出redisd服务前先进入redis-cli执行shutdown）<br>(或者直接： redis-cli shutdown)<br>最后是连通性分析，也是折腾了许久。首先是给安全组增加6379端口，还有各种防火墙配置，开放端口等等，发现都不行。最后是参考这篇文章的第二点：<a href="https://www.jianshu.com/p/2fa4622fc1d3" target="_blank" rel="noopener">https://www.jianshu.com/p/2fa4622fc1d3</a><br>在配置文件里，默认只能本地访问（127.0.0.1）,把该行注释掉，就成功连通了。</p><p>直到这里，三个服务都成功配置，并且能够连通。</p><hr><p><strong>step4: URL路径简化</strong><br>其实主要就是tomcat的配置文件罢了。之前一直偷懒，感觉能这样就这样，直到今天一定要改，才去花时间搞好了。所幸也不难，估计也就花了一个小时，但还是记录一下。<br>首先就是端口号，web一般默认都是80端口，直接把项目的端口号改为80，就不需要端口了。当然，应该是可以换端口号，然后设置其他默认端口号的，懒得深究。<br>接着就是省略项目名，其实对于docBase跟appBase我还是不太懂，目前来看，大概就是。appBase就是项目解压的路径，也就是tomcat就是从这里面寻找项目的。然后docBase就是我们想要的，增加了一个Context标签，附上docBase属性，就使得默认项目是webapps/xxx，而不是webapps<br>最后就是默认的主页，其实我也知道是welcome-list，可是有点奇怪的是，我在最上面写了我的目的网址，可他还是优先访问最下面的index.jsp。不是很懂这个优先级，最后直接索性把下面的全部注释掉，只留下我的mainPage.html。然后也成功了，最后，只需要输入自己的域名，就能直接进入我的网站主页。</p><hr><p>总结：最关键的还是要懂得原理。处理Redis问题的时候显然比前两者快，因为真的动脑子了。<br>一开始修改了redis.conf，发现redis-cli里根本没有改变密码，然后联想到启动redis的脚本（也就是拷贝到/etc/init.d/的redisd脚本），原本应该是要指定配置参数的，但并不需要，应该是直接写到了代码里。于是查看了一下脚本的代码，才意识到，代码里的conf并不是redis.conf，然后就修改了正确的conf文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（Tomcat + MySQL + Redis的配置，以及连通性测试）&lt;/p&gt;
&lt;p&gt;写在前面:&lt;br&gt;其实大概半年前就已经配置好了Tomcat跟MySQL，项目也部署好了，能够正常的运行。但自从8月底的时候加上了redis，就开始出现了问题。从那时候开始，服务器的CPU一直停留在100，似乎是MySQL与Redis之间出现了冲突。但我当时装了好了Redis，大概只是简单学习了几天就搁置了，所以等到我意识到服务器出现问题的时候，已经是9月下旬的时候了。（中途域名拿去网站备案了，所以项目也是一直搁置的。但中途在研究MySQL的锁机制的时候，确实已经觉得服务器出现了问题，时不时会掉线）对于问题的排查，持续了一整天都没有解决，使用TOP命令，会发现CPU idle space是0，要么是0，要么是100，两个数字之间刷新，但下面的所有进程，就没有CPU超过5%的进程。除了top，诸如netstat，vmstat，df -h，uptime，等等的各种命令都尝试过了，还是没有找出问题。倒是发现在/var/crash中出现了高达25G的系统崩溃碎片，删除了也未果。甚至，一怒之下把这个基础的服务器升级了（1核2G，直接升级为4核8G），结果还是显示100。。说实话，我就那么一个项目，能够把这种升级后的配置也用到CPU100，唯一的可能也只是出现了deadlock了吧。但我排查了许久都失败了，服务器上的数据库也崩溃了无法访问，而且我对于数据库也没有备份的习惯（以后一定要对数据库进行定时备份）。导致只好先对这个出了问题的系统进行snapshot，等待以后需要那部分数据，或者有时间的时候，再回去排查问题吧，至少也要把那部分数据拿回来。&lt;br&gt;然后呢，就是直接把系统重装了，那么就需要重新配置一遍环境。其实因为之前配置这三个的时候都比较轻松，所以心里觉得应该很快能解决的。但没想到遇到了各种各样的问题，所以这次把整个成功的配置过程都写出来记录，包括中间出现了错误如何解决等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://hongscar.cn/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="https://hongscar.cn/tags/CentOS/"/>
    
  </entry>
  
</feed>
