<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hong&#39;s Blog</title>
  
  <subtitle>Like life,like coding</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hongscar.cn/"/>
  <updated>2020-02-20T09:47:35.131Z</updated>
  <id>https://hongscar.cn/</id>
  
  <author>
    <name>Hong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode-双指针</title>
    <link href="https://hongscar.cn/LeetCode-%E5%8F%8C%E6%8C%87%E9%92%88.html"/>
    <id>https://hongscar.cn/LeetCode-%E5%8F%8C%E6%8C%87%E9%92%88.html</id>
    <published>2020-02-19T09:49:21.000Z</published>
    <updated>2020-02-20T09:47:35.131Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一.  前言"></a>一.  前言</h3><p>​        LeetCode的题目还是挺多的，但漫无目的地刷题其实意义不大，更多的还是需要在适量的题目之后，进行归纳总结，比如这篇文章就是对“双指针”相关的题目进行归纳总结。</p><p>​        参考：①<a href="https://github.com/CyC2018/CS-Notes/tree/master/notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/tree/master/notes</a></p><p>​                    ②<a href="https://leetcode-cn.com/circle/article/GMopsy/" target="_blank" rel="noopener">https://leetcode-cn.com/circle/article/GMopsy/</a></p><a id="more"></a><h3 id="二-什么是双指针？"><a href="#二-什么是双指针？" class="headerlink" title="二. 什么是双指针？"></a>二. 什么是双指针？</h3><p>​        在Java里并不像C++那样具备完全的“pointer”功能，但实际上把它当作index就差不多了。采用最简单的暴力法，通常都只有一个指针（想想那两层甚至是三层的for循环，实际上就只有一个指针指向一个确切的数据）。有的时候只要多增加一个变量（指针），那么就能很好的优化算法效率。</p><p>​        双指针通常有两种。①左右指针。通常用于数组，字符串的问题，比如二分查找，查找回文串，子序列等等。②快慢指针。通常用于链表的问题，使用快慢指针有时候可以巧妙地解决很多链表问题。</p><p>​        理论应该很好理解，尤其只要在leetcode上刷过一定数量题目的朋友都应该大致了解了。那么现在就拿几道实际的题目进行操作。</p><h3 id="三-LeetCode-167-有序数组的Two-Sum"><a href="#三-LeetCode-167-有序数组的Two-Sum" class="headerlink" title="三. LeetCode 167. 有序数组的Two Sum"></a>三. LeetCode 167. 有序数组的Two Sum</h3><p><strong><em>167. Two Sum II - Input array is sorted (Easy)</em></strong></p><p><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers&#x3D;&#123;2, 7, 11, 15&#125;, target&#x3D;9</span><br><span class="line">Output: index1&#x3D;1, index2&#x3D;2</span><br></pre></td></tr></table></figure><p><strong>题目描述</strong>：在有序数组中找出两个数，使它们的和为 target。</p><p><strong>分析</strong>: 这里需要注意的是，题目的一个条件是“有序数组”，一般这种<strong><em>有序的数组</em></strong>，都可以采用双指针来进行解决。</p><p>使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p><ul><li>如果两个指针指向元素的和 sum == target，那么得到要求的结果；</li><li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li><li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li></ul><p>数组中的元素最多遍历一次，时间复杂度为 <strong><em>O(N)</em></strong>。只使用了两个额外变量，空间复杂度为 <strong><em>O(1)</em></strong>。</p><p><strong>总结</strong>：这题没什么难度，即使直接暴力法也能解决，或者使用额外的哈希表作为存储空间都可以，双指针也不难想到。下面是双指针的示意图：</p><p><img src="https://camo.githubusercontent.com/98b3f53b56644b038cddd17fb1f6b4d5d1546989/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34333763623534632d353937302d346261392d623265662d3235343166376436633831652e676966" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span> (tmp == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmp &lt; target)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四-LeetCode-633-两数的平方和"><a href="#四-LeetCode-633-两数的平方和" class="headerlink" title="四. LeetCode 633. 两数的平方和"></a>四. LeetCode 633. 两数的平方和</h3><p><strong><em>633.Sum of Square Numbers (Easy)</em></strong></p><p><a href="https://leetcode.com/problems/sum-of-square-numbers/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: True</span><br><span class="line">Explanation: 1 * 1 + 2 * 2 &#x3D; 5</span><br></pre></td></tr></table></figure><p><strong>题目描述</strong>：判断一个非负整数是否为两个整数的平方和。</p><p><strong>分析</strong>：可以看成是在元素为 0~target 的有序数组中查找两个数，使得这两个数的平方和为 target，如果能找到，则返回 true，表示 target 是两个整数的平方和。</p><p>本题和 167. Two Sum II - Input array is sorted 类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。本题同样可以使用双指针得到两个数，使其平方和为 target。</p><p>本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 02 + x2 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。</p><p>因为最多只需要遍历一次 0~sqrt(target)，所以时间复杂度为 <strong><em>O(sqrt(target))</em></strong>。又因为只使用了两个额外的变量，因此空间复杂度为 <strong><em>O(1)</em></strong>。</p><p><strong>总结</strong>：像这种可行解是全体整数的时候（如果严谨一点应该是sqrt(Integer.MAX_VALUE))，暴力法显然会超时，哪怕你提前把上界限定为sqrt(n),可是在暴力法的时间复杂度为O(n^2)的情况下，需要的时间依然很长导致超时（n可能会很大）。这时候第一想法可能会是使用额外的空间，使用数据结构来存储，确实能比暴力法优化很多。如果是使用List，那么就需要用到contains方法，也就是O(n)，所以这时候的效率提升并不明显，仍然会超时。而如果使用Set，Set的contains方法使用的是哈希表，理论上是O(1)，所以时间复杂度为O(sqrt(target)) * O(1)。这时候可以AC，并不会超时，但是随着target比较大的时候，哈希表的时间不能完全忽略，所以效率还是比双指针低。</p><p>哈希表方法：    77ms</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> temp = (<span class="keyword">int</span>)Math.floor(Math.sqrt(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= temp; i++) </span><br><span class="line">            set.add(i * i);</span><br><span class="line">        Iterator it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(c - (<span class="keyword">int</span>)it.next()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针方法：    2ms</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = (<span class="keyword">int</span>)Math.sqrt(c);</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = left * left + right * right;</span><br><span class="line">            <span class="keyword">if</span> (tmp == c)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tmp &lt; c)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五-LeetCode-345-反转字符串中的元音字母"><a href="#五-LeetCode-345-反转字符串中的元音字母" class="headerlink" title="五.  LeetCode 345. 反转字符串中的元音字母"></a>五.  LeetCode 345. 反转字符串中的元音字母</h3><p><strong><em>345.Reverse Vowels of a String (Easy)</em></strong></p><p><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given s &#x3D; &quot;leetcode&quot;, return &quot;leotcede&quot;.</span><br></pre></td></tr></table></figure><p><strong>题目描述</strong>：把字符串里的所有元音字符倒转，即第一个元音字符与最后一个倒转，第二个与倒数第二个倒转。元音字母包括大小写，所以不能只考虑小写。</p><p><strong>分析</strong>: 使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。</p><p>为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。</p><ul><li>时间复杂度为 <strong><em>O(N)</em></strong>：只需要遍历所有元素一次</li><li>空间复杂度 <strong><em>O(1)</em></strong>：只需要使用两个额外变量</li></ul><p><strong>总结</strong>：最直观的方法，应该是直接创建一个List，把所有元音字符的indexs存储起来，然后逐个反转。经过测试，效率跟双指针方法差不多。但是这里要明白，双指针并非只能用于数组链表，对于字符串也是很有效的工具，因为字符串可以很容易地转换成字符数组。而且双指针还有一个优势是，消耗的空间较少。如果要存储indexs，需要一个额外的List，而双指针只需要两个简单的变量。（而这道题的HashSet，任何方法都要用到）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(</span><br><span class="line">            Arrays.asList(<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];<span class="comment">// 使用char数组存储临时数据</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(l))</span><br><span class="line">                result[left++] = l;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!set.contains(r))</span><br><span class="line">                result[right--] = r;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result[left++] = r;</span><br><span class="line">                result[right--] = l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六-LeetCode-680-回文字符串"><a href="#六-LeetCode-680-回文字符串" class="headerlink" title="六. LeetCode 680. 回文字符串"></a>六. LeetCode 680. 回文字符串</h3><p> <strong><em>680.Valid Palindrome II (Easy)</em></strong></p><p><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/valid-palindrome-ii/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abca&quot;</span><br><span class="line">Output: True</span><br><span class="line">Explanation: You could delete the character &#39;c&#39;.</span><br></pre></td></tr></table></figure><p><strong>题目描述</strong>：给定一个非空字符串 s，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p><p><strong>分析</strong>：所谓的回文字符串，是指具有左右对称特点的字符串，例如 “abcba” 就是一个回文字符串。</p><p>使用双指针可以很容易判断一个字符串是否是回文字符串：令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。</p><p>本题的关键是处理删除一个字符。在使用双指针遍历字符串时，如果出现两个指针指向的字符不相等的情况，我们就试着删除一个字符，再判断删除完之后的字符串是否是回文字符串。</p><p>在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。</p><p>在试着删除字符时，我们<strong><em>既可以删除左指针指向的字符，也可以删除右指针指向的字符</em></strong>。</p><p><strong>总结</strong>：接着上一题，双指针在字符串题型里很有效，而对于回文这个定义，双指针更是非常适合用于检测回文。因而这道理最应该直接想到的方法便是双指针法。除此之外，这种要考虑不止1种情况的情形（删左/删右），最好就直接新建一个helper方法，直接同时调用，将结果取或即可。如果直接用for循环，那么还得慢慢考虑如果改变left，right指针值的变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">            <span class="keyword">char</span> r= s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span> (l != r)</span><br><span class="line">                <span class="keyword">return</span> helper(s, left + <span class="number">1</span>, right) || helper(s, left, right - <span class="number">1</span>);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">char</span> l = s.charAt(left++);</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right--);</span><br><span class="line">            <span class="keyword">if</span> (l != r)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七-LeetCode-524-最长子序列"><a href="#七-LeetCode-524-最长子序列" class="headerlink" title="七. LeetCode 524. 最长子序列"></a>七. LeetCode 524. 最长子序列</h3><p><strong><em>524.Longest Word in Dictionary through Deleting (Medium)</em></strong></p><p><a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s &#x3D; &quot;abpcplea&quot;, d &#x3D; [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;apple&quot;</span><br></pre></td></tr></table></figure><p><strong>题目描述</strong>：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。</p><p><strong>分析</strong>：通过删除字符串 s 中的一个字符能得到字符串 t，可以认为 t 是 s 的子序列，我们可以使用双指针来判断一个字符串是否为另一个字符串的子序列。</p><p><strong>总结</strong>：除了回文串，字符串子序列的相关问题也很适合使用双指针解决。（不一定要左右指针，这里用的是同向指针，当两个指针指向的字符相同，则同时移动两个指针。如果不相同，则移动指向s的指针，这样可以检测t是否为s的子序列subsequence。时间复杂度为<strong><em>O(n)</em></strong>,空间复杂度为<strong><em>O(1)</em></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">        String longestWord = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str: d) &#123;</span><br><span class="line">            <span class="keyword">int</span> longLength = longestWord.length();</span><br><span class="line">            <span class="keyword">int</span> currentLength = str.length();</span><br><span class="line">            <span class="keyword">if</span> (longLength &gt; currentLength || (longLength == currentLength &amp;&amp;</span><br><span class="line">                longestWord.compareTo(str) &lt;= <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">// 不符合题目要找的最长要求，直接pass</span></span><br><span class="line">            <span class="keyword">if</span> (isSequence(s, str))</span><br><span class="line">                longestWord = str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSequence</span><span class="params">(String s, String current)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = s.length() - <span class="number">1</span>, j = current.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;<span class="comment">// 双指针检测是否为subsequence</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == current.charAt(j)) </span><br><span class="line">                j--;<span class="comment">// 二者相同，j指针移动</span></span><br><span class="line">            i--;<span class="comment">// 不管相同与否，i指针都要向前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j &lt; <span class="number">0</span>;<span class="comment">// 如果i，j从0开始，这里的判定就是 j == current.length()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八-LeetCode-88-归并两个有序数组"><a href="#八-LeetCode-88-归并两个有序数组" class="headerlink" title="八. LeetCode 88. 归并两个有序数组"></a>八. LeetCode 88. 归并两个有序数组</h3><p><strong><em>88.Merge Sorted Array (Easy)</em></strong></p><p><a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><p><strong>题目描述</strong>：把归并结果存到第一个数组上。</p><p><strong>分析</strong>：这道题的难点在于，不适用额外的存储空间，直接存储到nums1数组上。虽然可以直接偷懒，偏要用额外空间，那么题目也能很快完成，只是这样失去了很多意义，毕竟如果只为了AC，直接一句System.arraycopy，然后Arrays.sort就可以AC了，但这又何必。这道题的核心思想首先是归并，归并实际上就是对两个数组同时操作，也就是使用双指针操作。同时关键又是有序数组，更没有理由放弃双指针了。值得注意的是，需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。(从m + n - 1开始存放数据，这样刚好可以存放m + n个数据，避免了多余的0影响了结果。虽然LeetCode的所有测试用例都没有考虑0数量大于n的情况，默认等于n，但显然题目并没有这个意思。总而言之，严谨一点~)</p><p><strong>总结</strong>：归并，有序数组，双指针很合适。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从尾部开始进行遍历即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span> || index2 &gt;= <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">if</span> (index1 &lt; <span class="number">0</span>) </span><br><span class="line">                nums1[current--] = nums2[index2--];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (index2 &lt; <span class="number">0</span>) </span><br><span class="line">                nums1[current--] = nums1[index1--];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt;= nums2[index2]) </span><br><span class="line">                nums1[current--] = nums1[index1--];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums1[current--] = nums2[index2--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九-LeetCode-141-判定链表中是否含有环"><a href="#九-LeetCode-141-判定链表中是否含有环" class="headerlink" title="九. LeetCode 141. 判定链表中是否含有环"></a>九. LeetCode 141. 判定链表中是否含有环</h3><p><strong><em>141.Linked List Cycle (Easy)</em></strong></p><p><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">力扣</a></p><p><strong>题目描述</strong>：RT</p><p><strong>分析</strong>：直接循环查看是否到达null，肯定不行，因为会超时。当然，如果你能解决传说中的停机问题，你可以试试。这道题应该是大部分人第一次接触到”双指针“概念的题，快慢指针。使用双指针，一个slow指针每次移动一个节点，一个fast指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。证明应该很直观，如果存在环，两个指针最后一定会在环里同时移动，一个快一个慢，最后一定会在某个时刻二者相遇。如果没有环，slow指针永远不会追上fast指针，并且fast指针会到达end，结束循环。</p><p><strong>总结</strong>：链表的快慢指针，也是巧妙解决链表问题的好办法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123; <span class="comment">// fast只要不为null, slow一定不为null</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十-LeetCode-142-判定链表中是否含有环，如果有，返回环的入口"><a href="#十-LeetCode-142-判定链表中是否含有环，如果有，返回环的入口" class="headerlink" title="十.  LeetCode 142. 判定链表中是否含有环，如果有，返回环的入口"></a>十.  LeetCode 142. 判定链表中是否含有环，如果有，返回环的入口</h3><p><strong><em>142.Linked List Cycle Ⅱ (Medium)</em></strong></p><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">力扣</a></p><p><strong>题目描述</strong>：RT</p><p><strong>分析</strong>：这题仍然是用快慢双指针解决。只是当我们判断二者相遇的时候，如何获得环的入口？答案是，把其中一个指针放到head处，然后两个指针以同样的速度（每次行走1个单位）前进。当它们第二次相遇的时候，所在的地方就是环的入口。因为这样并不直观，因此我们可以给出一个证明。</p><p><strong>证明</strong>：假设链表在进入环之前的长度为<strong><em>a</em></strong>，环的长度为<strong><em>b</em></strong>。（<strong><em>a</em></strong>，<strong><em>b</em></strong>均为未知数）</p><p>假设当<strong><em>slow指针</em></strong> 走了<strong><em>s</em></strong> 距离的时候，二者<strong><em>相遇</em></strong>，此时显然可得：</p><p><strong><em>fast指针</em></strong> 走的距离：<strong><em>f = 2s</em></strong></p><p>又易知，<strong><em>fast指针</em></strong> 肯定比<strong><em>slow指针</em></strong> 多走了<strong><em>n圈环</em></strong> 的距离，所以可得： <strong><em>f = s + nb</em></strong>    （<strong><em>n</em></strong> 为正整数）</p><p>两式结合可得： <strong><em>s = nb</em></strong></p><p>同时由定义可得，当指针处于<strong><em>环入口</em></strong>，那么此时指针一定走了 <strong><em>a + mb</em></strong> 的距离 （<strong><em>m</em></strong>为非负整数），所以现在<strong><em>slow指针</em></strong> 已经走了<strong><em>nb</em></strong> 的距离，只要它再走<strong><em>a</em></strong> 距离，便能到达环入口。但在a是未知数的情况下，如何确定<strong><em>slow</em></strong> 再走<strong><em>a</em></strong> 距离？</p><p>答案是：<code>将fast指针重置在head处，因为head距离环入口的距离就是a，此时fast指针跟slow指针距离环入口的距离相同，那么只要二者以相同的速度（1个单位）前进，再次相遇的地方就是环入口。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)  <span class="comment">// 无环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        fast = head;            <span class="comment">// 将fast重置在head</span></span><br><span class="line">        <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;    <span class="comment">// fast与slow同等速度前进，再次相遇则为环入口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十一-寻找链表的中点，寻找链表的倒数第k个元素"><a href="#十一-寻找链表的中点，寻找链表的倒数第k个元素" class="headerlink" title="十一. 寻找链表的中点，寻找链表的倒数第k个元素"></a>十一. 寻找链表的中点，寻找链表的倒数第k个元素</h3><p>寻找中点： <a href="https://leetcode.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">LeetCode</a> | <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">力扣</a></p><p>寻找倒数第k个元素： <a href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/" target="_blank" rel="noopener">力扣</a></p><p><strong>题目描述</strong>：RT。因为比较简单，就放在一起</p><p><strong>分析</strong>：寻找中点直接使用快慢指针，显然当fast指针到达结尾，slow指针就是指向中点。如果链表的长度是奇数，那么slow就停在中点位置。如果链表的长度是偶数，slow停在两个中间元素的后者，同样符合中点的含义。</p><p>对于寻找链表的倒数第k个元素，同样可以用双指针。先让其中一个指针走k步，然后两个指针同时移动，当第一个指针到达结尾，第二个指针便到达了倒数第k个元素的位置。</p><p>寻找中点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找倒数第k个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            fast = fast.next;       <span class="comment">// 先让fast走k步</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow.val;      <span class="comment">// 当fast到达end(此时fast为null), slow到达倒数第k个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十二-滑动窗口Sliding-Windows类题目"><a href="#十二-滑动窗口Sliding-Windows类题目" class="headerlink" title="十二. 滑动窗口Sliding Windows类题目"></a>十二. 滑动窗口Sliding Windows类题目</h3><p><strong><em>简述</em></strong>：LeetCode有一类题型叫<strong><em>Sliding Windows</em></strong>，实际上就是用双指针维护一个范围的数据，然后按照需要移动两个指针，就像一个大小变化的窗口。这类题目也是典型的双指针题目。这类题目在LeetCode有一个非常好的讲解，这里就不讲述滑动窗口的具体思路，可以到这个<a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-suan-fa-tong-yong-si-xiang-by-/" target="_blank" rel="noopener"><strong><em>参考链接</em></strong></a> 阅读。这里直接给出Java代码。</p><p><strong><em>题目①： LeetCode 76. 最小覆盖字串</em></strong>           <a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener"><strong><em>题目链接</em></strong></a></p><p><strong><em>题目描述</em></strong>：给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。</p><p><strong><em>分析</em></strong>：双指针的典例。值得注意的是，如果使用HashMap，Integer在大于127之后，不能使用 ”==“来判定，简单地说，就是Integer范围只有在[-128, 127]，才从常量池里拿，否则就是一个对象，需要使用equals方法来判定。具体可以参考<a href="https://my.oschina.net/miwang/blog/730343" target="_blank" rel="noopener"><strong>这篇文章</strong></a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;</span><br><span class="line">输出: &quot;BANC&quot;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] map1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">58</span>];<span class="comment">// 字母包含大小写，中间还有6个特殊符号</span></span><br><span class="line">        <span class="keyword">int</span>[] map2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">58</span>];</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 用于check最后是否整个字符串s都无法覆盖</span></span><br><span class="line">        String current = s;<span class="comment">// 表示当前的最小覆盖子串，初始化为s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: t.toCharArray())</span><br><span class="line">            map2[c - <span class="string">'A'</span>]++;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;<span class="comment">// 滑动窗口双指针</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            map1[s.charAt(right) - <span class="string">'A'</span>]++;</span><br><span class="line">            right++;<span class="comment">// 先移动right指针</span></span><br><span class="line">            <span class="keyword">boolean</span> flag1 = <span class="keyword">false</span>;<span class="comment">// 用于判断是否到达了内层while，再改变current的值</span></span><br><span class="line">            <span class="keyword">while</span> (helper(map1, map2)) &#123;<span class="comment">// 直到满足覆盖，开始移动left指针</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                flag1 = <span class="keyword">true</span>;</span><br><span class="line">                map1[s.charAt(left++) - <span class="string">'A'</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag1 &amp;&amp; current.length() &gt; (right - left + <span class="number">1</span>))</span><br><span class="line">                current = s.substring(left - <span class="number">1</span>, right);<span class="comment">// 更小的覆盖字串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)<span class="comment">// 如果flag为false，说明一次也没有进入内层while，无法覆盖</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] m1, <span class="keyword">int</span>[] m2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m1.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (m1[i] &lt; m2[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong><em>题目②：LeetCode 438. 找到字符串中所有字母异位词</em></strong>        <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener"><strong><em>题目链接</em></strong></a></p><p><strong><em>题目描述</em></strong>：给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p><strong><em>分析</em></strong>： 这题比上一题简单很多，因为它无须“滑动”，窗口的大小是固定的，我们只需要同时移动双指针即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] s1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">// 小写字母，直接数组就可以替代HashMap</span></span><br><span class="line">        <span class="keyword">int</span>[] s2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = p.length(), length = s.length();</span><br><span class="line">        <span class="keyword">if</span> (length &lt; p.length())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right; i++) &#123;</span><br><span class="line">            s1[s.charAt(i) - <span class="string">'a'</span>]++;<span class="comment">// 初始化，二者都是前right个字符</span></span><br><span class="line">            s2[p.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &lt;= length) &#123;<span class="comment">// 因为循环里的break条件是 right + 1，所以这里有等号</span></span><br><span class="line">            <span class="keyword">if</span> (check(s1, s2))</span><br><span class="line">                res.add(left);</span><br><span class="line">            s1[s.charAt(left++) - <span class="string">'a'</span>]--;<span class="comment">// 移动过程，减去第一个字符</span></span><br><span class="line">            <span class="keyword">if</span> (right + <span class="number">1</span> &gt; length)<span class="comment">// 提前考虑是否有下一个字符</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            s1[s.charAt(right++) - <span class="string">'a'</span>]++;<span class="comment">// 移动过程，加上下一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] s1, <span class="keyword">int</span>[] s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (s1[i] != s2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong><em>题目③：无重复字符的最长子串</em></strong>            <strong><em><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">题目链接</a></em></strong></p><p><strong><em>题目描述</em></strong>：给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong><em>分析</em></strong>：这题跟第一题很像，也是典型的滑动窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right++);<span class="comment">// 移动right指针,直到有重复</span></span><br><span class="line">            <span class="keyword">while</span> (set.contains(c)) </span><br><span class="line">                set.remove(s.charAt(left++));<span class="comment">// 移动left指针,直到无重复</span></span><br><span class="line">            set.add(c);</span><br><span class="line">            res = res &gt;= (right - left) ? res : right - left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十三-其他"><a href="#十三-其他" class="headerlink" title="十三. 其他"></a>十三. 其他</h3><p>双指针还有一个很重要的应用，就是二分查找。但二分查找也是一个专门的题型，所以决定在二分查找篇章再写。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一.  前言&quot;&gt;&lt;/a&gt;一.  前言&lt;/h3&gt;&lt;p&gt;​        LeetCode的题目还是挺多的，但漫无目的地刷题其实意义不大，更多的还是需要在适量的题目之后，进行归纳总结，比如这篇文章就是对“双指针”相关的题目进行归纳总结。&lt;/p&gt;
&lt;p&gt;​        参考：①&lt;a href=&quot;https://github.com/CyC2018/CS-Notes/tree/master/notes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/CyC2018/CS-Notes/tree/master/notes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​                    ②&lt;a href=&quot;https://leetcode-cn.com/circle/article/GMopsy/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/circle/article/GMopsy/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="https://hongscar.cn/categories/algorithm/"/>
    
      <category term="interview" scheme="https://hongscar.cn/categories/algorithm/interview/"/>
    
    
      <category term="LeetCode" scheme="https://hongscar.cn/tags/LeetCode/"/>
    
      <category term="algorithm" scheme="https://hongscar.cn/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud笔记(六)</title>
    <link href="https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E5%85%AD.html"/>
    <id>https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E5%85%AD.html</id>
    <published>2020-02-19T01:35:06.000Z</published>
    <updated>2020-02-19T03:48:20.490Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​        上一部分添加了网关Zuul，这时候微服务架构已经基本成型，后续要增加其他功能就添加其他服务组件。但是随着微服务的数量越来越多，配置文件就越需要管理。尽管目前项目只有5-6个配置文件，都已经感觉到有点乱了。所以这部分讲述的是<strong><em>Spring Cloud Config</em></strong>，以及最后<strong><em>docker</em></strong> 简要的部署。</p><a id="more"></a><h3 id="二-使用Spring-Cloud-Config"><a href="#二-使用Spring-Cloud-Config" class="headerlink" title="二.  使用Spring Cloud Config"></a>二.  使用Spring Cloud Config</h3><p>使用Spring Cloud Config的好处：集中管理配置，可以实现不同环境不同配置，可以在运行时动态调整配置。</p><p>组成：一个Config Server，一个Config Client。很好理解，Server集中管理所有配置，然后Client调用</p><p><strong><em>使用步骤:</em></strong></p><h4 id="构建Server："><a href="#构建Server：" class="headerlink" title="构建Server："></a>构建Server：</h4><p><em>①在git仓库创建一些配置文件（作为server的仓库）</em></p><p><em>②新建module，添加依赖：</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>③编写启动类，使用注解<code>@EnableConfigServer</code>，声明为Config Server</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>④编写配置文件yml：</em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-config-server</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line"><span class="attr">config:</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">git:</span></span><br><span class="line"><span class="attr">uri:</span> <span class="string">https://gitee.com/itmuch/spring-cloud-config-repo</span></span><br><span class="line"><span class="attr">search-paths:</span> <span class="string">config-repo</span></span><br><span class="line"><span class="attr">username:</span></span><br><span class="line"><span class="attr">password:</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>之后可以通过Config Server的端点来获取配置文件的内容，端点与配置文件的规则如下：</p><p><strong><em>The HTTP service has resources in the following form:</em></strong></p><p><code>/ {application} / {profile} [/{label}]</code></p><p><code>/ {application} - {profile}.yml</code></p><p><code>/ {label} / {application} - {profile}.yml</code></p><p><code>/ {application} - {profile}.properties</code></p><p><code>/ {label} / {application} - {profile}.properties</code></p><p>不知所以，仔细记录一下：</p><p>application：项目名，仓库名</p><p>profile：属性名    （默认是default）</p><p>label：分支名（默认是master）</p><p>关于端点如何分割：localhost:8080/xxx/yyy/zzz</p><p>yyy/zzz，表示yyy微服务里的zzz属性。</p><p>那么有一个疑惑，一个配置文件名为：aaa-bbb-ccc.properties，如何区分微服务名为aaa，</p><p>还是aaa-bbb？测试了一下，并不需要区分。如果找不到，也不会报错，此时会返回：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_46.png" alt="sb_46"></p><p>也就是说，会默认生成一个名为default的profile，属性值为1。</p><p>接着我们分别测试其余的情况，比如，我们的配置文件之一叫：microservice-foo-test.properties，那:</p><p>①localhost:8080/microservice-foo-test.properties</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_47.png" alt="sb_47"></p><p>②<a href="http://localhost:8080/microservice-foo/test：" target="_blank" rel="noopener">http://localhost:8080/microservice-foo/test：</a></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_48.png" alt="sb_48"></p><p>可以看到，就是name为“microservice-foo”，profile名为test，属性值为default-1.0。除此之外，还有自动生成的属性值名为default的profile。</p><p>③<a href="http://localhost:8080/microservice/foo-test" target="_blank" rel="noopener">http://localhost:8080/microservice/foo-test</a></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_49.png" alt="sb_49"></p><p>name为microservice，profile名为foo-test。但因为这个是不存在的，所以只有default属性。</p><p>④给②，③增加other branch。发现此时label要放在最后，而不是最前面。如：</p><p><a href="http://localhost:8080/microservice-foo/dev/config-label-v2.0" target="_blank" rel="noopener">http://localhost:8080/microservice-foo/dev/config-label-v2.0</a></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_50.png" alt="sb_50"></p><p>这也印证了官方文档前面那晦涩难懂的rules：</p><p><strong>对于第2，第5点，表示配置文件的具体后缀，yml，properties，yaml都是等价的（yaml等同yml）</strong></p><p><strong>对于第4点，表明label是可以缺省的，此时默认为master分支。</strong></p><p><strong>对于第3点，和第2点一比较就可以发现，当我们指定了具体的文件（xxx.yml,xxx.properties)，此时会把第一个/后的值视为label。</strong></p><p><strong>对于第1点，我们没有指定具体的文件，只是表明获取微服务名为{application}的属性名为{profile}的值，此时会把最后一个/的值视为label。</strong></p><p>中间遇到的问题：<strong><em>Read Time out</em></strong>。使用GitHub地址的时候，可能会出现Read Time out的情况，过一段时间又可以。然后可能再放了几天又无法读取，再过几个小时又可以读取。而Gitee不会存在这个错误。目前比较合理的解释，就是<strong><em>墙</em></strong>的问题了。</p><h4 id="构建Client："><a href="#构建Client：" class="headerlink" title="构建Client："></a>构建Client：</h4><p>步骤：</p><p><em>①导入依赖包</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>②普通的启动类，@SpringBootApplication即可</em></p><p><em>③编写application.yml，包括端口号即可。</em></p><p><em>④编写 <code>bootstrap.yml</code>配置文件：</em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-foo</span><span class="comment"># 对应config server所获取配置文件的&#123;application&#125;</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line"><span class="attr">config:</span></span><br><span class="line"><span class="attr">uri:</span> <span class="string">http://localhost:8080/</span></span><br><span class="line"><span class="attr">profile:</span> <span class="string">dev</span><span class="comment"># 对应config server所获取配置文件的&#123;profile&#125;</span></span><br><span class="line"><span class="attr">label:</span> <span class="string">master</span><span class="comment"># git repository的branch</span></span><br></pre></td></tr></table></figure><p>这个bootstrap叫<strong><em>引导上下文</em></strong>。具体为什么要写在这里，而不是application.yml，以后再细看，可参考：<a href="https://www.cnblogs.com/niechen/p/8968204.html" target="_blank" rel="noopener">https://www.cnblogs.com/niechen/p/8968204.html</a></p><p><em>⑤ Controller</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;profile&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String profile;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/profile"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> profile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现得还是很顺利的，通过localhost:8081/profile就能调用8080端口的server的dev属性。</p><p>唯一中间出现过的问题是，maven导入包没有写版本号，然后IDEA又不懂得报错，于是yml里就无法识别出这些配置。<strong><em>记得出错的时候先去看一下maven包有没有导入失败，IDEA很多时候都不会显示。</em></strong></p><p>Spring Cloud Config自带了一个health结点，用于查询当前的健康状态。</p><p>例子：<a href="http://localhost:8080/health/microservice-config-server/config-label-v2.0" target="_blank" rel="noopener">http://localhost:8080/health/microservice-config-server/config-label-v2.0</a></p><p>xxx / health / {application} / {label}            (profile默认是default，label是master）</p><p>加密相关：可以安装JCE，使用<strong><em>对称加密和非对称加密</em></strong>。</p><p><strong><em>Symmetric-key algorithm</em></strong>     <strong><em>asymmetric cryptography</em></strong></p><p>关于这两者到底是什么，二者的区别，有一篇比较通俗的文章：<a href="https://segmentfault.com/a/1190000004461428" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004461428</a></p><p><strong><em>对称加密的步骤：</em></strong></p><p>安装好JCE，创建bootstrap.yml（只有一个encrypt-key的属性，推测根据这个来进行hash）</p><p>加密，解密的命令：</p><p>curl <a href="http://localhost:8080/encrypt" target="_blank" rel="noopener">http://localhost:8080/encrypt</a> -d mysecret</p><p>会返回一串<strong><em>神秘代码</em></strong>：例如：sd23u89yw8fywe9823u92u9</p><p>解密：</p><p>curl <a href="http://localhost:8080/decrypt" target="_blank" rel="noopener">http://localhost:8080/decrypt</a> -d sd23u89yw8fywe9823u92u9</p><p>然后就会返回mysecret。（为什么不截图，因为写的时候已经改写为非对称了，懒得搞）</p><p>存储加密内容到git仓库：</p><p>创建一个配置文件<code>encryption.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">dbuser</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">'&#123;cipher&#125;a69cfa909cbbb012b9a09c41ddf428463'</span>  <span class="comment"># 只是举例</span></span><br></pre></td></tr></table></figure><p><strong>单引号，{cipher}都是必不可少的，如果是使用properties文件则不能加单引号。</strong></p><p>之后使用  localhost:8080/encryption-default.yml 就可以获取明文解密后的结果。</p><p>如果不想返回明文，那么就配置： <code>spring.cloud.config.server.encrypt.enabled = false</code></p><p><strong><em>非对称加密：</em></strong></p><p>使用keytool生成一个<em>Key Store</em>：    （右边的图省略了）</p><p><code>keytool -genkeypair -alias mytestkey -keyalg RSA -dname &quot;CN=Web    Server, OU=Unit, O=Organization, L=City,S=State,C=US&quot; -keypass change me -keystore server.jks -storepass letmein</code></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_51.png" alt="sb_51"></p><p>创建bootstrap.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line"><span class="attr">key-store:</span></span><br><span class="line"><span class="attr">location:</span> <span class="string">classpath:server.jks</span><span class="comment"># jks文件的路径</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">letmein</span><span class="comment"># storepass</span></span><br><span class="line"><span class="attr">alias:</span> <span class="string">mytestkey</span><span class="comment"># alias</span></span><br></pre></td></tr></table></figure><p>然后理论上调用curl url -d xx就可以获取加密后的结果，但一直报错，是500错误，<strong>“message”:”Cannot load keys from store: class path resource [server.jks]”。</strong>仔细看了一下，应该是因为上面图中写的忽略-keypass的原因，于是就把secret注释掉，确实就可以了：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_52.png" alt="sb_52"></p><p>可以看到，每一次返回的结果都不一样，非对称的安全性更强。</p><hr><p>使用refresh端点。</p><p>在server对配置文件进行改变之后，client并不会更新（更过分的是，即使重启client，也不会更新）。所以需要刷新操作。一种方法是手动刷新，通过导入<code>spring-boot-starter-actuator</code>依赖，使用refresh端点进行刷新。</p><p>当配置文件发生改变之后，使用curl命令发送POST请求到client，进行刷新（是client）</p><p>例如：   curl  -X POST <a href="http://localhost:8081/actuator/refresh" target="_blank" rel="noopener">http://localhost:8081/actuator/refresh</a></p><p>遇到的问题：一直显示404，也就是没有这个端点。</p><p>解决：其实404就应该想到，应该是路径的问题，因为没有这个端点路径。然后最先想到了2.x开始的actuator路径改变：从/xxx变成  /actuator/xxx，于是把书上的/refresh改成了/actuator/refresh，发现仍然不行。接着继续想到了2.x开始并不是所有端点都会exposure出来，于是还要在yml里配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">endpoints:</span></span><br><span class="line"><span class="attr">web:</span></span><br><span class="line"><span class="attr">exposure:</span></span><br><span class="line"><span class="attr">include:</span> <span class="string">'*'</span></span><br><span class="line"><span class="comment"># 2.x只暴露很有限的端点，需要手动配置暴露，才能使用refresh端点。</span></span><br></pre></td></tr></table></figure><p>由于手动刷新比较麻烦，尤其当微服务数量增加的时候，所以需要自动刷新，也就是需要</p><p>spring-cloud-bus，也就是加入一个RabbitMQ作为消息队列，当其中一个client发生refresh操作时，其他client也会进行refresh。但这增加了耦合度，因为client本身不应该考虑配置刷新的职责。于是应该将bus编织到server，使得server发现变化时，相应的client就像是接收广播一样，进行改变。</p><p>PS：但是这部分没有实现，因为RabbitMQ又各种错误，回头再看吧。</p><p>Spring Cloud Config与Eureka配合使用。</p><p>由于前面都是直接在Client里硬编码server的URI，这失去了微服务的灵活性，因此应该将二者都注册到Eureka，然后进行服务发现。本来应该不难，二者先增加eureka-client-serviceUrl-defaultZone属性，然后唯一特别一点的就是client的cloud-config-uri去掉，改成 <code>cloud-config-discovery</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-foo</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line"><span class="attr">config:</span></span><br><span class="line"><span class="attr">uri:</span> <span class="string">http://localhost:8080/</span></span><br><span class="line"><span class="attr">profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">label:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>可是却一直无法发现到Server实例，只好先注释回原来的版本了。</p><p>（对于application.yml和bootstrap.yml的理解还没有，然后这些配置属性应该都写好在代码 / 文档里的，还是需要慢慢看一遍源码&amp;文档，不然这个能解决，还会有很多不懂。）</p><p>碎碎念，毕竟也快结束了：</p><p>感觉学微服务的时候一直这样，因为版本的变更，各种配置，url，包名都发现了改变，于是也就有了很多的坑。有时候也在想是否就应该直接跳过了？确实很费时间，可是，在当中也学到了很多。比如，现在一看到无法注册到Eureka，就能立刻想到是认证的问题，然后就知道去启动类那里添加那个认证方法。还有，对于yml的各种配置，也是越来越熟悉，不再是只敢抄书，稍微做一点改动这种。更重要的是，对微服务架构的认知真的是深刻了很多。虽说微服务确实就是一个项目分成多个，但到底怎么分，为什么要这样分，各个之间的作用，如何连接？这些是只看知乎那个回答所不能解答的。总而言之，并不是说一定要把书中的每一个遗留的问题都解决，毕竟不可能，最后都一定要看文档跟源码才能弄懂的。但还是要尽量努力吧，实在搞了很久也不行就算了，时间宝贵。over。</p><h3 id="三-其他"><a href="#三-其他" class="headerlink" title="三. 其他"></a>三. 其他</h3><p>依赖下载不完整的解决方法：使用<code>mvn clean package -Dmaven.test.skip=true</code>，可以确保依赖的完整性。 （那个参数是为了跳过单元测试，不然有一些module会报错。。但确实可以运行）</p><p><strong><em>最后：把项目用Docker布置。</em></strong></p><p>书中最后的一部分，确实也是很实用且重要的部分，项目是以前面Spring Cloud为例的。首先，需要为每个module分别制作成image。可选的方法有多种，包括：</p><p>①分别通过<code>mvn clean package</code>命令，把module打包成jar，然后传输到服务器，通过Dockerfile和这个jar文件来制作image。（主要用到了ADD命令，ADD在添加jar文件的时候，会自动解压，所以项目就被解压到了image中）优点是比较清晰简单，缺点是当微服务数量较多的时候，比较繁琐。</p><p>②使用maven的plugin进行<strong><em>image-build</em></strong>操作。但遇到了问题，也没有时间仔细研究。</p><p>所以最终就直接使用方法一了。方法一也出现了问题，就是Provider服务跟Consumer服务，因为之前我在Consumer的pom.xml中设置了依赖Provider，希望能简化配置。但这就导致了打包成jar的时候还需要一些额外的操作，否则它提示无法找到依赖包。这个问题也暂时没有解决，直接取消了依赖，然后在Consumer服务里单独添加了部分依赖，于是打包就成功了。然后在Linux服务器里，编写了Dockerfile，以此来制作image，Dockerfile如下（三个服务，Eureka，Provider，Consumer，我都用了同样的代码)</p><p>启动的时候，看到不仅是Consumer，而且Provider服务也无法连接到Eureka。其实当时就觉得localhost肯定要改，一看书，确实如此。首先在Dockerfile里，代码是给Eureka取了一个<strong><em>Alias</em></strong>，然后Provider这些服务，直接把<strong><em>localhost</em></strong>改成那个<strong><em>Alias</em></strong>即可。然后测试了一下，确实再Eureka就检测到Provider服务了。至于外网连通Eureka，同样也是在腾讯云开通8761端口即可。可是我再在腾讯云开通8001端口（Provider服务的端口），却无法访问。这是因为Docker的容器网络机制默认是<strong><em>bridge</em></strong>，所以每一个服务的IP地址是不相同的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;​        上一部分添加了网关Zuul，这时候微服务架构已经基本成型，后续要增加其他功能就添加其他服务组件。但是随着微服务的数量越来越多，配置文件就越需要管理。尽管目前项目只有5-6个配置文件，都已经感觉到有点乱了。所以这部分讲述的是&lt;strong&gt;&lt;em&gt;Spring Cloud Config&lt;/em&gt;&lt;/strong&gt;，以及最后&lt;strong&gt;&lt;em&gt;docker&lt;/em&gt;&lt;/strong&gt; 简要的部署。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/tags/Spring-Cloud/"/>
    
      <category term="Spring Boot" scheme="https://hongscar.cn/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud笔记(五)</title>
    <link href="https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%BA%94.html"/>
    <id>https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%BA%94.html</id>
    <published>2020-02-18T14:26:38.000Z</published>
    <updated>2020-02-19T03:37:52.958Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​        随着微服务的数量越来越多，外部客户端调用起来也就越来越麻烦。一个大型的项目一般都有上百个微服务，如果像我们之前的调用方法去调用，对于客户来说是很难接受的。所以这时候需要一个微服务的网关，作为一个中间层，简化这些操作。这部分讲述的是Zuul。</p><a id="more"></a><h3 id="二-使用Zuul构建微服务网关"><a href="#二-使用Zuul构建微服务网关" class="headerlink" title="二. 使用Zuul构建微服务网关"></a>二. 使用Zuul构建微服务网关</h3><p>由于不同的微服务会有不同的网络地址/端口号（比如上面的各种微服务，虽然有相同的地址，但端口号各不相同），当微服务数量很多时，外部客户端调用起来就比较麻烦。所以这时候需要一个<strong>网关</strong>，作为客户端与服务端的中间层，由网关层负责转发，这样客户端就只需要记住网关一个地址。同时网关还有其他的作用，比如统一认证（上面的Security都是东一个西一个，比较杂乱）。下面是具体的Zuul的作用列表：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_33.png" alt="sb_33"></p><p>可以看到，<strong><em>它整合了Ribbon实现了负载均衡，也整合了Hystrix实现了监控，同时也具备Security，Spring MVC（Dynamic Routing）的作用。</em></strong></p><hr><p><strong><em>使用Zuul微服务网关的步骤：</em></strong></p><p>（Zuul作为一个新的子module）</p><p><strong><em>①导入依赖：</em></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong><em>②启动类上加上<code>@EnableZuulProxy</code></em></strong></p><p>（这里还有的两个方法，一个是添加hystrix.stream结点，一个是用于注册到Eureka的认证，都是前面的内容了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DiscoveryClient.<span class="function">DiscoveryClientOptionalArgs <span class="title">discoveryClientOptionalArgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>③编写yml（都是端口号，服务名，注册到哪个Eureka等等的基础）</em></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8040</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-gateway-zuul</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>这时候理应就完成了，确实很简单，唯一特别的就是一个注解<code>@EnableZuulProxy</code>。该注解是声明一个Zuul代理，该代理会使用Ribbon来定位注册在Eureka上的所有微服务。所以，使用该注解的Zuul，如果不添加其他配置，就是默认监控所有的其他注册在Eureka的服务。</p><p>但是还是出现了bugs，也进行了很长时间的排查。遇到的问题：</p><p>Zuul理应是已经代理了所有的微服务，这时候直接使用Zuul的地址，然后加上被代理的服务名，还有后面的路径应该就可以成功，比如： localhost:8040/micro…/user/1。但是显示<strong><em>404错误</em></strong>。</p><p>这个错误表明没有注册成功，可是@EnableZuulProxy是默认注册的，根本不需要手动配置。一开始猜想是不是又是版本的原因？所以还尝试了一下比较含糊不清的手动配置。但由于一键配置都没搞好，于是手动配置也出错，也可能是因为这个注册就是一键配置的，手动配置的都会被discard。然后到了最后，发现错误竟然是！</p><p><strong><em>①url区分大小写。</em></strong>其实直到目前为止，我都没有配置url大小写敏感的问题。这个并不是在zuul里配置，而是在整个的Spring boot，Spring MVC里配置，因为url一只是case sensitive的。</p><p><strong><em>②我把服务名字记错了。。</em></strong>类名是……movie，结果yml里写成了……user</p><p>把这个问题解决之后，确实就不再是404，而是<strong><em>401，也就是认证的问题。</em></strong>关于认证，也存在一个很严重的问题。无论我如何配置security，如何配置Configuration类，都无法通过认证。具体表现为，打开8040端口（Zuul端口），这时候会弹出认证框，因为我需要访问8011（Consumer服务端口）。我可以传递一次参数给8011，使得它通过认证，但是8011后续访问8001（Provider服务端口）也需要认证，而<strong>这个参数是不会继续传递的</strong>。这也很好理解，如果8011需要访问多个端口的集成，那么参数该如何传递？所以不继续传递参数应该是一个正确的设定。那么问题来了，应该如何解决这个问题？</p><p>最后的解决方案是，直接把provider里的Security内容去掉。看起来很tricky，但其实很合理。因为上面就已经提到了，<strong><em>Zuul的作用之一便是Authentication。所以服务的安全性问题，应该放在Zuul里处理，而Eureka仍然是特殊独立的存在，不需要更改。所以去掉 Service的 Security是合理的。</em></strong></p><p>自此，就可以通过Zuul端口来访问其他服务了。据说整合了Ribbon，但懒得测试负载均衡了。而Hystrix，应该是版本问题了，所以还是要自己手动添加了hystrix.stream端点，然后跟Dashboard等等的整合也是可以，唯一奇怪的点是，使用Dashboard的时候，Circuit的显示数据都是正常的，但Thread Pools没有数据（之前使用Turbine都有的）,看了一下书，刚好图只截到了Circuit，到了Thread Pools就没了，但这部分在后面的部分会解决，这里暂时不考虑.</p><p>由于Zuul作为一个网关，管理了比较多的服务，所以使用actuator管理端点就比较重要了。</p><p>导入了依赖之后，在ymll直接暴露所有的端点：（<strong>注意，不能直接用*，也不能用双引号</strong>）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">endpoints:</span></span><br><span class="line"><span class="attr">web:</span></span><br><span class="line"><span class="attr">exposure:</span></span><br><span class="line"><span class="attr">include:</span> <span class="string">'*'</span></span><br></pre></td></tr></table></figure><p>还可以添加exclude，此处略。</p><p>比较重要的端点都有routes，filters，caches等等。同时还能自定义endpoints。具体的可以参考这篇文章：<a href="https://www.cnblogs.com/baidawei/p/9183531.html" target="_blank" rel="noopener">https://www.cnblogs.com/baidawei/p/9183531.html</a></p><p>关于routing的一些配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">routes:</span></span><br><span class="line"><span class="attr">microservice-simple-consumer-user:</span> <span class="string">/user111/**</span></span><br><span class="line"><span class="attr">ignored-services:</span> <span class="string">microservice-simple-consumer-user</span></span><br><span class="line"><span class="attr">ignored-patterns:</span> <span class="string">/**/user/**</span><span class="comment"># 忽略所有包含user的路径</span></span><br></pre></td></tr></table></figure><p>此处就是， /user111 就相当于 /microservice-simple-consumer-user。/**是指可能有多个路径。值得注意的是，虽然ignored了consumer，但其实只是ignored了这个默认的映射，而我们手动配置了它的映射路径别名，所以仍然可以通过user111来映射到consumer服务。而且可以通过<code>ignored_patterns</code>，忽略掉包含xxx的路径，比如把敏感信息放到admin，这样忽略掉之后，就无法通过zuul访问该admin路径了。这里我用的是忽略user，可以看到下面的效果图，对于访问user1没有影响，却无法访问user。如图：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_34.png" alt="sb_34"></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_35.png" alt="sb_35"></p><p>还有一些关于actuator的端点：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_36.png" alt="sb_36"></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_37.png" alt="sb_37"></p><p>filters端点包含了error，post，pre，route四种类型的过滤器，并且包含执行顺序order，可以用于定位Zuul问题。</p><p>关于routes，还可以通过<code>/routes/details</code>来获取更具体的信息</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_38.png" alt="sb_38"></p><h3 id="三-Zuul的一些其他配置"><a href="#三-Zuul的一些其他配置" class="headerlink" title="三. Zuul的一些其他配置"></a>三. Zuul的一些其他配置</h3><p>Zuul的安全与Header。由于Zuul是一个代理网关，因而它可以使得同一个系统的服务之间共享Header。但有一些敏感的Header不应该外泄，因此需要指定敏感的Header列表，下面是默认的配置：（users是一个服务名）所有的服务都默认将Cookie，Set-Cookie，Authorization设为敏感。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">routes:</span></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/myusers/**</span></span><br><span class="line"><span class="attr">sensitiveHeaders:</span> <span class="string">Cookie,Set-Cookie,Authorization</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://downstream</span></span><br></pre></td></tr></table></figure><p>如果需要取消所有敏感Header，比如服务只在内部传递，为了共享所有的Header，包括Cookie，可以将sensitiveHeaders设为空。    （之前看过这种写法，还以为是错误的写法）</p><p>上面的是对单个服务的配置，可以直接用 zuul-sensitiveHeaders 来进行全局配置。</p><p><code>zuul-ignored-headers</code>。忽略Header。</p><p><strong><em>ignored-headers与sensitive-headers的区别：</em></strong></p><p>一个很清晰的答案：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_39.png" alt="sb_39"></p><p><code>sensitive-headers</code>是指明敏感headers，避免数据泄漏。而<code>ignored-headers</code>是直接指明要忽略的headers，使得不仅是zuul传递到下游服务的request，还是下游服务的response，都会忽略掉该headers（作用不同，目的也不同，但据说sensitive也会默认添加到ignored，所以区别不大）</p><p>多层路由：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">routes:</span></span><br><span class="line"><span class="attr">first:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/first/**</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://first.example.com</span></span><br><span class="line"><span class="attr">second:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/second/**</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">forward:/second</span></span><br><span class="line"><span class="attr">third:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/third/**</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">forward:/3rd</span></span><br><span class="line"><span class="attr">legacy:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/**</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://legacy.example.com</span></span><br></pre></td></tr></table></figure><p>看起来legacy会跟另外三个冲突，但由于另外三个更complex，所以当第一个url为first/second/third，就会优先调用前三个，其他的url才会调用legacy，很好理解。官方文档称之为：<strong><em>strangle patterns</em></strong></p><hr><p>实现上传文件功能：</p><p><strong><em>①Controller：</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/upload"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">handleFileUpload</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @RequestParam(value = <span class="string">"file"</span>)</span> MultipartFile file) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = file.getBytes();</span><br><span class="line">        File fileToSave = <span class="keyword">new</span> File(file.getOriginalFilename());</span><br><span class="line">        FileCopyUtils.copy(bytes, fileToSave);</span><br><span class="line">        <span class="keyword">return</span> fileToSave.getAbsolutePath();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>② yml：</em></strong>（不加单位默认是KB，单位必须两个都大写，当前版本2.2.0.RELEASE）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8050</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-file-upload</span></span><br><span class="line"><span class="attr">servlet:</span></span><br><span class="line"><span class="attr">multipart:</span></span><br><span class="line"><span class="attr">max-file-size:</span> <span class="string">200MB</span><span class="comment"># default 1M</span></span><br><span class="line"><span class="attr">max-request-size:</span> <span class="string">300MB</span><span class="comment"># default 10M</span></span><br></pre></td></tr></table></figure><p>需要用到的依赖包是netflix-eureka-client，启动类需要的是@SpringBootApplication, @EnableEurekaClient注解。</p><p><strong><em>③使用curl测试：</em></strong></p><p>（1）直接通过FileUpload服务的端口调用</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_40.png" alt="sb_40"></p><p>（2）使用Zuul代理：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_41.png" alt="sb_41"></p><p>值得注意的是，使用Zuul代理时，当传输超过1MB（默认）的文件时，需要增加zuul路径，否则会报错（即使没有超过yml里设定的大小）。而无论是否使用zuul，传输的文件都不能超过yml里设定的大小。而直接调用FileUpload服务时，则不需要该路径。</p><p><strong><em>关于为什么要这个zuul路径，官方文档的解释：</em></strong></p><p><strong><em>If you use @EnableZuulProxy, you can use the proxy paths to upload files and it should work, so long as the files are small. For large files there is an alternative path that bypasses the Spring DispatcherServlet (to avoid multipart processing) in “/zuul/</em>“. In other words, if you have zuul.routes.customers=/customers/**, then you can POST large files to /zuul/customers/<em>. The servlet path is externalized via zuul.servletPath. If the proxy route takes you through a Ribbon load balancer, extremely large files also require elevated timeout settings, as shown in the following example:</em></strong></p><p>意思就是，使用zuul代理时，传递大文件时的路径会转换为<code>/zuul/xxx</code>，所以就需要/zuul路径了。</p><p><strong><em>Zuul is implemented as a Servlet.For the general cases,Zuul is embedded into the Spring Dispatch mechanism.This lets Spring MVC be in control of the routing.In this case,Zuul buffers requests.If there is a need to go through Zuul without buffering requests (for example,for large file uploads), the Servlet is also installed outside of the Spring Dispatcher.By default,the servlet has an address of <code>/zuul</code>.This path can be changed with the <code>zuul.servlet-path</code>property.</em></strong></p><p>关于<strong><em>查询参数的编码和解码</em></strong>，直接看官方文档:</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_42.png" alt="sb_42"></p><p>简单的说就是，使用Zuul传递参数的时候，参数可能会发生变化（比如使用了JS的encodeURIComponent方法），这可能会导致一些奇怪的错误。如果需要禁止参数变化，保持查询参数不会在传递时发生改变，就需要设定<code>forceOriginalQueryStringEncoding</code>参数为true。</p><p>关于这个参数，默认是false的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> forceOriginalQueryStringEncoding = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>GitHub上有人提出了issue，认为应该默认是true，否则容易出现奇怪的问题。管理员也认同这个观点，但项目已经进入了<strong>Maintenance Mode</strong>，所以基本不会再维护了。所以只能手动配置参数。</p><p>（同理的还有Request URI Encoding，是否对URI进行decode，默认是true。而URI包含“/”的时候，decode会出现意想不到的错误，此时可以设定zuul-decodeUrl为false，避免decode。）</p><p><strong><em>关于@EnableZuulServer与@EnableZuulProxy</em></strong></p><p>二者区别：</p><p>Spring Cloud Netflix installs a number of filters,depending on which annotation was used to enabled Zuul.<strong>@EnableZuulProxy</strong> is a superset of <strong>@EnableZuulServer</strong>.In other words,<strong>@EnableZuulProxy *<em>contains all the filters installed by *</em>@EnableZuulServer</strong>.The additional filters in the “proxy” enable routing functionality.If you want a “blank” Zuul,you should use <strong>@EnableZuulServer</strong>.</p><p>二者都可以启用Zuul，并且都会包含以下过滤器：</p><p><strong><em>① Pre filters：</em></strong></p><p><strong>ServletDetectionFilter</strong>: Detects whether the request is through the Spring Dispatcher.Sets a boolean with a key of <code>FilterConstants.IS_DISPATCHER_SERVLET_REQUEST_KEY</code>.</p><p><strong>FormBodyWrapperFilter</strong>: Parses form data and re-encodes it for downstream requests.</p><p><strong>DebugFilter</strong>: If the debug request parameter is set,sets<code>RequestContext.setDebugRouting()</code>and <code>RequestContext.setDebugRequest()</code>to true.</p><p><strong><em>② Route filters:</em></strong></p><p><strong>SendForwardFilter</strong>: Forwards requests by using the Servlet <code>RequestDispatcher</code>.The forwarding location is stored in the <code>RequestContext</code> attribute,<code>FilterConstants.FORWARD_TO_KEY</code>.This is useful for forwarding to endpoints in the current application.</p><p><strong><em>③ Post filters:</em></strong></p><p><strong>SendResponseFilter</strong>: Writes responses from proxied requests to the current response.</p><p><strong><em>④ Error filters:</em></strong></p><p><strong>SendErrorFilter</strong>: Forward to <code>/error</code> (by default) if <code>RequestContext.getThrowable()</code>is not null.You can change the default forwarding path (<code>/error</code>) by setting the ``error.path` property.</p><p><strong><em>而EnableZuulProxy还包含以下过滤器：</em></strong></p><p><strong><em>① Pre filters：</em></strong></p><p><strong>PreDecorationFilter</strong>: Determines where and how to route,depending on the supplied <code>RouteLocator</code>.It also sets various proxy-related headers for downstream requests.</p><p><strong><em>② Route filters:</em></strong></p><p><strong>RibbonRoutingFilter</strong>: User Ribbon,Hystrix,and pluggable HTTP clients to send requests.Service IDs are found in the <code>RequestContext</code> attribute,<code>FilterConstants.SERVICE_ID_KEY</code>.This filter can user different HTTP clients:</p><p>​    (1) Apache <code>HttpClient</code>: The default client.</p><p>​    (2) Squareup <code>OkHttpClient</code> v3: Enable by having the <code>com.squareup.okhttp3:okhttp</code> library on the classpath and setting<code>ribbon.okhttp.enabled = true</code>.</p><p>​    (3) Netflix Ribbon HTTP client: Enabled by setting <code>ribbon.restclient.enabled=true</code>.This client has limitations,including that it does not support the PATCH method,but also has built-in retry.</p><p><strong>SimpleHostRoutingFilter</strong>: Sends requests to predetermined URLs through an Apache HttpClient.URLs are found in <code>RequestContext.getRouteHost( )</code>.</p><p>测试，本来想把@EnableZuulProxy注解换成@EnableZuulServer的，理论上项目不会有任何出错，确实也没有出错，但是却找不到filters端点。一开始以为是没有启动actuator端点，但实际上其他的各种env，health，caches，beans等等的都有，唯独只少了一个filters端点。而且我在yml里是有配置具体的URL映射的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">routes:</span></span><br><span class="line"><span class="attr">microservice-simple-consumer-user:</span> <span class="string">/user111/**</span></span><br></pre></td></tr></table></figure><p>使用EnableZuulServer的时候，没有报错，如果映射失败，应该会出现404错误。但是没有报错，也没有任何界面。所以还是用Proxy吧。</p><hr><p>禁用filters：</p><p>Zuul for Spring Cloud comes with a number of <strong>ZuulFilter</strong> beans enabled by default in both proxy and server mode.See the Zuul filters package for the list of filters that you can enable.If you want to disable one,set<code>zuul.\&lt;SimpleClassName&gt;.\&lt;filterType&gt;.disable=true</code>.By convention,thepackage after <code>filters</code>is the Zuul filter type.For exapmple to disable <code>org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter</code>,set <code>zuul.SendResponseFilter.post.disable=true</code>.</p><p>包括自定义的filters和系统预定义的filters都可以，类型就是pre，post，route，error。</p><p>（PS：具体的过滤器内容，还是得看源码才能更清晰，现在大概直到是什么个情况就好。关于过滤器这一块，还能配合Spring的过滤器机制一起看，毕竟像BeanPostProcessor等等的，一直没有去研究，到时可以专门再写一个叫做《阅读Spring&amp;Spring boot的interceptor机制源码》）</p><p>关于Zuul的高可用：创建多个Zuul实例，并且使用Nginx，F5等等的负载均衡器来实现负载均衡。</p><p>给Zuul的hystrix添加fallback方法：</p><p>创建一个FallbackProvider的Bean（也就是这个接口/抽象类的具体类），然后注入（@Component)即可。书上1.5用的是ZuulFallbackProvider，2.x应该是没有这个东西了，直接换成<code>FallbackProvder</code>。</p><p><strong><em>Providing Hystrix Fallbacks For Routes</em></strong></p><p>When a circuit for a given route in Zuul is tripped,you can provide a fallback response by creating a bean of type <strong>FallbackProvider</strong>.Within this bean,you need to specify the route ID the fallback is for and provide a <strong>ClientHttpResponse</strong> to return as a fallback.The following example shows a relatively simple <strong>FallbackProvider</strong> implementation.</p><p>需要指明要为哪个/哪些服务进行fallback功能，以及回退的逻辑。这里就是简单地几个文字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFallbackProvider</span> <span class="keyword">implements</span> <span class="title">FallbackProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"*"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">(String route, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientHttpResponse() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> HttpStatus.OK;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getStatusCode().value();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.getStatusCode().getReasonPhrase();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(<span class="string">"用户微服务不可使用"</span>.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">                MediaType mt = <span class="keyword">new</span> MediaType(<span class="string">"application"</span>, <span class="string">"json"</span>, Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">                headers.setContentType(mt);</span><br><span class="line">                <span class="keyword">return</span> headers;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子之后，当调用的service出现问题，会显示：用户微服务不可使用。</p><p>关于Dashboard监控Zuul的Hystrix。</p><p>前面有提到Zuul的Hystrix，在Dashboard并没有Thread pools的数据，一开始还以为是作者偷懒，其实是把坑留到后面了。因为Zuul里的Hystrix的隔离策略默认是SEMAPHORE，所以自然就没有Thread pools的数据了。可以使用：<code>zuul.ribbon-isolation-strategy = thread</code>设置为THREAD。</p><p>（PS：这样默认会所有的服务都公用一个线程池，需要额外的配置来使得每一个路由/服务使用一个独立的线程池，<code>zuul.threadPool.useSeparateThreadPools : true</code></p><p>关于Zuul整合非JVM服务。上文提到的Zuul管理的服务，都是基于JVM的服务，在一些特定的情况可能不太方便，比如我们可能需要一些其他的诸如python，node.js等等的webservice。然而Zuul是可以整合非JVM服务的，只需要使用Sidecar，这样除了JVM服务，还能注册非JVM服务。</p><p>步骤：</p><p>①先写一个非JVM微服务，这里用<strong>Node.js</strong>为例。(即使不懂Node，也能大致看懂功能)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 创建Server</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求的路径</span></span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(req.url).pathname;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span> : <span class="string">'application/json; charset=utf-8'</span>&#125;);</span><br><span class="line">    <span class="comment">// 访问http://localhost:8060/, 将会返回&#123;"index": "欢迎来到首页"&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (pathname === <span class="string">'/'</span>) &#123;</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="string">"index"</span> : <span class="string">"欢迎来到首页"</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问http://localhost:8060/health,将会返回&#123;"status": "UP"&#125;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pathname === <span class="string">'/health.json'</span>) &#123;</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="string">"status"</span> : <span class="string">"UP"</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">"404"</span>);<span class="comment">// 其他情况返回404</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 创建监听，并打印日志</span></span><br><span class="line">server.listen(<span class="number">8060</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listening on localhost:8060'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>②给Zuul添加<strong>Sidecar</strong>的依赖包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-sidecar<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>③启动类添加<strong>@EnableSidecar</strong>注解。<strong><em>This annotation includes @EnableCircuitBreaker, @EnableDiscoveryClient, and @EnableZuulProxy。</em></strong></p><p>④yml里配置sidecar参数，表示要代理的sidecar（非JVM）的uri地址和端口号等等：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sidecar:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8060</span></span><br><span class="line"><span class="attr">health-uri:</span> <span class="string">http://localhost:8060/health.json</span></span><br></pre></td></tr></table></figure><p>⑤controller里写一下调用该sidecar服务的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">testController</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test/&#123;string&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findById</span><span class="params">(@PathVariable string string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://localhost:8060/"</span> + string,String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test11/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">test</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://localhost:8001/"</span> + id, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑥启动node.js的微服务，启动Eureka，Zuul等等，使用：localhost:8040/test/health.json，调用成功.</p><p>中途遇到的问题：其实对于web的基本架构都很了解了，所以虽然书上是在IDEA里一起写的非JVM服务，但我确信在cmd也是一样的，结果却不行。后来发现只是controller的注解，不小心写成了@Controller，导致无法处理JSON数据，因为Node.js里写的返回数据类型是JSON。所以一切其实都很顺理成章。虽然这里调用的是简单的非JVM微服务，但调用其他的webservice其实也是如此罢了。</p><p>关于使用Zuul整合多个微服务，其实就是客户端一次调用，然后Zuul端会调用多个微服务。书上使用了RxJava，但我现在还不会，先搁置吧。其实我觉得这个需求直接在service层里编写逻辑也可以完成。当然，至于RxJava的异步优势，后面再考虑。</p><p>最后还学习了一下<strong>OkHttp3。OkHttp3是一个优秀的HTTP客户端，可以更加高效地使用HTTP。</strong></p><p>写了两个简单的GET例子和POST例子，感觉都可行。</p><p>依赖包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>GetExample:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder().url(url).build();</span><br><span class="line">        <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.requireNonNull(response.body()).string();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        GetExample example = <span class="keyword">new</span> GetExample();</span><br><span class="line">        String response = </span><br><span class="line">            example.run(<span class="string">"https://github.com/Hongscar/blog/blob/master/README.md"</span>);</span><br><span class="line">        System.out.println(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PostExample:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType JSON = MediaType.get(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">post</span><span class="params">(String url, String json)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RequestBody body = RequestBody.create(JSON, json);</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder().url(url).post(body).build();</span><br><span class="line">        <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.requireNonNull(response.body()).string();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bowlingJson</span><span class="params">(String player1, String player2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;'winCondition':'HIGH_SCORE',"</span></span><br><span class="line">                + <span class="string">"'name':'Bowling',"</span></span><br><span class="line">                + <span class="string">"'round':4,"</span></span><br><span class="line">                + <span class="string">"'lastSaved':1367702411696,"</span></span><br><span class="line">                + <span class="string">"'dateStarted':1367702378785,"</span></span><br><span class="line">                + <span class="string">"'players':["</span></span><br><span class="line">                + <span class="string">"&#123;'name':'"</span> + player1 + <span class="string">"','history':</span></span><br><span class="line"><span class="string">            [10,8,6,7,8],'color':-13388315,'total':39&#125;,"</span></span><br><span class="line">                + <span class="string">"&#123;'name':'"</span> + player2 + <span class="string">"','history':</span></span><br><span class="line"><span class="string">        [6,10,5,10,10],'color':-48060,'total':41&#125;"</span></span><br><span class="line">                + <span class="string">"]&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        PostExample example = <span class="keyword">new</span> PostExample();</span><br><span class="line">        String json = example.bowlingJson(<span class="string">"Jesse"</span>, <span class="string">"Jake"</span>);</span><br><span class="line">        String response = example.post(<span class="string">"http://www.roundsapp.com/post"</span>, json);</span><br><span class="line">        System.out.println(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑也是很清晰，GET方法就是最简单的，获取指定URL的内容，然后把Response的body转换成字符串作为return值。POST方法，需要先传递一个RequestBody到服务端，可以看到在post方法里是先构造了一个RequestBody，再把这个body设置到Request当中，最后再返回Response。服务端获取到了RequestBody之后（在这里是一个JSON字符串），它会根据这个JSON字符串进行生成页面操作（这里的代码是在服务端完成的），生成的结果就作为Response返回。GET方法就是获取了哪个github的README.md的内容，POST方法的结果如下:（可以看到内容就是根据RequestBody生成的</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_43.png" alt="sb_43"></p><p>中间还遇到了一个比较麻烦的问题（一开始认为是strange error）。</p><p>在使用OkHttp3的时候，其实Maven仓库的最新版本是4.2.2，理应使用最新版本。下载也没有问题，写代码也不会报错。但是当我写代码看到new Request.Builder ……其实我大概也知道这是一个内部类，但我就是很想去看一下它的代码，可是跳转过去之后的class文件，并没有代码。它每一个方法的内容都是complied code，还有open等我不认识的关键字，如下：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_44.png" alt="sb_44"></p><p>当时显示了一个错误，我没有在意，但后面问题就很大了。我点了run项目，然后项目右下角说没有找到xxx文件（其实就是Request.class文件），但console处没有任何输出，就像是run键没有任何反应。这时候更关键的是，其他的module也无法run。当时以为是IDEA抽风了，还打算从GitHub重新把项目导入一遍。结果不小心点到了debug，发现其他module的debug可用，而run不可用，其实这时候我大概就应该猜到是什么原因了。后面过了许久，其他项目的run也可行了。我再次对GetExample进行run，又是一样的毫无反应，然后其他项目也变得无法run，但可以debug。紧接着我对GetExample进行debug，也是毫无反应。这时候其他的项目不仅无法run，而且无法debug。那么这个看似是“IDEA抽风”的问题就找到了，<strong><em>这个Maven导入的依赖包有问题，虽然没有任何报错，但就是会出错，而且甚至把整个run / debug功能都会卡住。以往如果是项目卡住，好歹还是会有红色的running的显示符，这次真的就像是完全没有反应，不得不说确实还是算IDEA跟Maven的bug吧，但至少知道了是什么原因造成的。</em></strong>于是我就把OkHttp3的版本换成了3.11.0，因为网上有文章的源码解读是使用这个版本的。确实，改了版本之后，跳转到Request就有具体的代码了：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_45.png" alt="sb_45"></p><p>然后就不再出现问题，而且也成功运行。那么<strong><em>为什么4.2.2版本不可用？因为OkHttp是适用于Android，Kotlin和Java的HTTP客户端，而且在4.x版本开始，使用了Kotlin重写，从上面的4.2.2的源码其实就可以看到有Kotlin的字样。那么到底Java中能否使用Kotlin编写的OkHttp4.x？估计是可以的，但要配置一些其他东西，但已经超出太远的范围了，所以这里还是就用OkHttp3吧。而且看起来，3跟4的区别好像就只是用Kotlin重新写了一遍而已，并没有什么新的特性，只是更适用于Android开发而已，所以这里不需要考虑了。</em></strong></p><p>至此，Zuul章节完毕。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;​        随着微服务的数量越来越多，外部客户端调用起来也就越来越麻烦。一个大型的项目一般都有上百个微服务，如果像我们之前的调用方法去调用，对于客户来说是很难接受的。所以这时候需要一个微服务的网关，作为一个中间层，简化这些操作。这部分讲述的是Zuul。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/tags/Spring-Cloud/"/>
    
      <category term="Spring Boot" scheme="https://hongscar.cn/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud笔记(四)</title>
    <link href="https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E5%9B%9B.html"/>
    <id>https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E5%9B%9B.html</id>
    <published>2020-02-18T12:30:27.000Z</published>
    <updated>2020-02-19T03:25:05.384Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​        上一部分添加了熔断器Hystrix，并且了Dashboard和Turbine进行可视化。但是Turbine直接硬编码在yml上，与服务代码高度耦合，所以并不是一个良好的设计，还需要进行改进。</p><a id="more"></a><h3 id="二-使用RabbitMQ作为消息中间件"><a href="#二-使用RabbitMQ作为消息中间件" class="headerlink" title="二. 使用RabbitMQ作为消息中间件"></a>二. 使用RabbitMQ作为消息中间件</h3><p>使用Hystrix.stream可以让使用了Hystrix功能的Service得到监控，而Turbine与Dashboard可以很好地收集和可视化这些监控数据。但有一个问题是，Dashboard还好，与Hystrix.stream没有任何耦合，只需要输入待定URL即可。而Turbine在上文是直接硬编码到yml中，指定要获取哪个或者哪些Service的监控信息，已经属于高度耦合了。即使不考虑性能，这也会出现问题，当Service与Turbine网络不通，此时就无法进行工作。<strong><em>而增加一个MQ，可以使得Service只需把数据丢给MQ，然后Turbine从MQ上获取数据即可。</em></strong>如果出现问题，可以很好地定位到：Hystrix端的问题？Turbine端的问题？MQ的问题？Hystrix与MQ的连通问题？Turbine与MQ的连通问题？</p><hr><h4 id="RabbitMQ简要知识"><a href="#RabbitMQ简要知识" class="headerlink" title="RabbitMQ简要知识"></a>RabbitMQ简要知识</h4><p><code>RabbitMQ</code>是一个基于<code>Erlang</code>的消息队列，遵从<code>AMQP</code>协议（消息队列的一个协议）</p><p>Erlang是一种面向并发的编程语言。</p><p>RabbitMQ的管理方法有很多种，修改配置文件，命令行CTL，可视化管理界面。</p><p>常用的命令就是：<code>rabbitmqctl</code></p><p>顺手把rabbitmq也配置到了环境变量里，记录一下，是要配置到Path里，而不是ClassPath。。然后好像是用户变量跟系统变量是差不多的，反正这台电脑就一个用户。</p><p>使用可视化管理界面，先安装该插件：</p><p><code>rabbitmq-plugins enable rabbitmq_management</code></p><p>之后这个插件就会默认注册到15672端口，打开localhost:15672就可以看到。而且rabbitmq服务是自动启动的，无须自己手动启动，然后再使用。效果图：（默认账号密码： guest , guest）</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_21.png" alt="sb_21"></p><p>点一下Node：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_22.png" alt="sb_22"></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_23.png" alt="sb_23"></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_24.png" alt="sb_24"></p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><p><strong><em>①改写微服务Service</em></strong></p><p>之前的做法是，给Service添加一个Hystrix.stream结点，使用<code>@EnableCircuitBreaker</code>表示启动监控，并且把监控数据存储到Hystrix.stream结点。但现在我们要把数据存储到MQ，所以先导入MQ的依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-hystrix-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-binder-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.integration<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-integration-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rtifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">rtifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为什么需要导入这么多个依赖？书上跟网上的教程都只写了2~3个依赖。这也是最困惑我的地方，只能解释为版本的问题了。其实上面有一些依赖我认为是可以去掉的，但我去掉了之后会导致项目无法启动，所以就懒得去深究如何简化导入依赖了。</p><p>依赖这一块我排错了很久，一开始也只是导入了2~3个依赖，然后maven也没有报错，代码也没有报错，此时启动却失败，先看大概的错误信息：</p><p><strong><em>Fail to parse configuration class： xxxx/xxx/xx/RabbitAutoConfiguration …</em></strong></p><p>一开始没把这个当回事，其实一长串的错误，这个是第一个，应该好好研究一下的。最后找到了这个类，一点进去：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_25.png" alt="sb_25"></p><p>原来是<strong><em>还有一些包没导入完全</em></strong>，所以这个类当然会出错了，于是也就无法加载了。这时点进本地的maven仓库看了一下，这个包并没有下载完全（连完整的jar包都没有，只有.jar.part这种）。当时其实挺无语的，竟然还能偷懒？于是把它删了重下，才下好了完整的jar包。这时候依然报错，于是把依赖删掉了再写回去，就好了（算是认识到了，这就是IDEA的一个bug，当你的maven下载jar包的时候出现问题，但它可能会误以为你已经成功下载好了。然后你重新下载了之后，它还是无法识别，会显示错误，这时候把依赖去掉，再重写，可能就会解决）。</p><p>之后，关于依赖包这一块，感觉调用轮子最复杂的步骤估计就是依赖包的处理的。一个依赖包其实内嵌依赖了其他的包，并不仅仅是那一个包的。然后不同的包之间可能依赖版本不同，这时候就会导致冲突而报错。所以依赖包与版本管理确实是很麻烦的一个事情。</p><p>依赖包的版本冲突问题处理好之后，启动依然报错：</p><p><strong><em>A default binder has been requested, but there is no binder available</em></strong></p><p>然后网上都说要加依赖包<code>spring-cloud-stream-binder-rabbit</code>，可是查看maven管理，会发现它其下一个类也不需要用到。结果加上之后启动成功又用到了。。所以，IDEA的bug真的挺多的，有时候确实是代码存在问题，但也有可能是IDEA本身有问题。</p><p>依赖包问题彻底解决之后，启动类加上：</p><p><code>@EnableAutoConfiguration(exclude = RabbitAutoConfiguration.class)</code>启动成功。</p><p>（这个exclude可以不需要）</p><p><strong><em>②改写Turbine</em></strong></p><p>之前的Turbine也是硬编码来表示要监控哪些Service，然后通过配置也是指明要监控它的哪些结点，比如是hystrix.stream.为了解耦，需要给Turbine连接到MQ，作为Consumer的角色。</p><p>先导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-turbine-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>记住要去掉<code>spring-cloud-starter-netflix-turbine</code>，因为<code>turbine</code>与<code>turbine-stream</code>不兼容。</p><p>启动类的@EnableTurbine改成<code>@EnableTurbineStream</code>。</p><p>yml关于turbine的配置去掉（因为现在是使用TurbineStream，而非Turbine）</p><p>启动成功。</p><p>③测试，turbineStream确实在打印信息，但并没有任何有意义信息。再到RabbitMQ的管理界面一看，确实是Producer成功把信息提交到了MQ，但Consumer（也就是这里的TurbineStream）却没有读取，可以看到一共有3个Connections跟Channels（不明白为什么Producer的Connections的数量有两个），Queue有1个（就是用于存放和获取信息的队列），但显示是idle，因为Consumer没有去获取数据。</p><p>解决方法：显式指明Producer要提交到哪个Queue（可以自定义），然后显式指明Consumer要到哪个Queue去获取数据。可能是以前的版本都有一个默认，而新版本去掉了默认，或者二者默认不一致了（毕竟Turbine已经没有维护，而RabbitMQ还在维护），导致了失败。</p><p>Producer的yml：（关键在于增加一个<code>spring-cloud-stream-bindings-hystrixStreamOutput-destination</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-simple-consumer-user</span></span><br><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line"><span class="attr">stream:</span></span><br><span class="line"><span class="attr">bindings:</span></span><br><span class="line"><span class="attr">hystrixStreamOutput:</span></span><br><span class="line"><span class="attr">destination:</span> <span class="string">sixfly</span></span><br></pre></td></tr></table></figure><p>Consumer的yml:    (对应的，turbineStreamInput。 一开始错写成hystrixStreamInput。。。）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-hystrix-turbine</span></span><br><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line"><span class="attr">stream:</span></span><br><span class="line"><span class="attr">bindlings:</span></span><br><span class="line"><span class="attr">turbineStreamInput:</span></span><br><span class="line"><span class="attr">destination:</span> <span class="string">sixfly</span></span><br></pre></td></tr></table></figure><p>启动，看到RabbitMQ的queque状态不再是idle，而是running。再看turbine，确实已经获取到了Producer提交到MQ上的数据。完成。</p><h4 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h4><p><strong>Turbine启动就已经看到，连接到了RabbitMQ，且连接到了具体的Queue，获取到了数据：</strong></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_26.png" alt="sb_26"></p><p><strong>查看RabbitMQ Management UI：</strong></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_27.png" alt="sb_27"></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_28.png" alt="sb_28"></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_29.png" alt="sb_29"></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_30.png" alt="sb_30"></p><p><strong>Turbine获取到了数据：</strong></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_31.png" alt="sb_31"></p><p><strong>Dashboard没有任何更改，可以获取Turbine的信息并可视化：</strong></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_32.png" alt="sb_32"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;​        上一部分添加了熔断器Hystrix，并且了Dashboard和Turbine进行可视化。但是Turbine直接硬编码在yml上，与服务代码高度耦合，所以并不是一个良好的设计，还需要进行改进。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/tags/Spring-Cloud/"/>
    
      <category term="Spring Boot" scheme="https://hongscar.cn/tags/Spring-Boot/"/>
    
      <category term="RabbitMQ" scheme="https://hongscar.cn/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud笔记(三)</title>
    <link href="https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%B8%89.html"/>
    <id>https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%B8%89.html</id>
    <published>2020-02-18T08:48:11.000Z</published>
    <updated>2020-02-19T03:27:11.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​        上一部分添加了Ribbon实现了负载均衡，并且使用了Feign实现声明式的REST调用。微服务架构中还有很多其他组件，让我们继续学习其他有用的微服务架构的组件。</p><a id="more"></a><h3 id="二-使用熔断器Hystrix"><a href="#二-使用熔断器Hystrix" class="headerlink" title="二.  使用熔断器Hystrix"></a>二.  使用熔断器Hystrix</h3><p>微服务架构是由多个微服务组成的系统。虽然架构更加清晰，分工更加明确，但也存在相应的问题：出现问题难以排查（到底是哪个服务出现问题？）。而且还会存在微服务所特有的问题：<strong><em>雪崩效应</em></strong>。当其中一个微服务出现故障时，由于微服务之间会存在依赖关系，所以其他服务也会渐渐地受到影响，最后影响到整个系统。如果这时候放任不管，那么请求就会堆积，导致系统彻底瘫痪。（有理论分析，即使每个系统的正常运行时间是99.9%，仍然会因为雪崩效应导致很严重的效果）所以我们需要一个组件来管理微服务，监控微服务，当组件发现（认为）服务出现故障，会把系统调到<strong><em>降级模式</em></strong>，拒绝继续接受请求，避免请求堆积。等到一定时间之后再申请一个请求，如果请求通过，解除降级模式，否则，继续拒绝。这个就是Hystrix，熔断器。逻辑也很简单，其实就相当于电路里的断路器。</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_11.png" alt="sb_11"></p><p><strong><em>正常情况下，断路器关闭，可正常请求依赖的服务。</em></strong></p><p><strong><em>当一段时间内，请求失败率达到一定阈值（例如错误率达到50%，或100次/分钟等），断路器就会打开。此时，不会再去请求依赖的服务。</em></strong></p><hr><h4 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h4><p>①导入依赖包<code>spring-cloud-starter-netflix-hystrix</code></p><p>②启动类添加注解:<code>@EnableHystrix, @EnableCircuitBreaker</code></p><p>③给Controller里的RequestMapping方法添加一个<code>@HystrixCommand(fallback = &quot;xxx&quot;)</code>的注解，xxx就是一个fallback方法名。当降级模式触发的时候，停止请求，改为调用fallback方法。</p><p>（HystrixCommand上可以进行很多配置）</p><p>一两次失败的request并不会导致断路器打开，而多次之后可以看到断路器确实已经开启：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_12.png" alt="sb_12"></p><p>Hystrix的隔离策略：<strong><em>线程隔离</em></strong> 和 <strong><em>信号量隔离</em></strong>。</p><p>一般推荐HystrixCommand使用线程隔离，而HystrixObservableCommand使用信号量隔离。</p><p><strong>HystrixCommand和HystrixObservableCommand的区别：</strong></p><p>①HystrixCommand用在依赖服务返回单个操作结果的时候。有两种执行方式</p><p>　　  -execute():同步执行。从依赖的服务返回一个单一的结果对象，或是在发生错误的时候抛出异常。</p><p>　　  -queue();异步执行。直接返回一个Future对象，其中包含了服务执行结束时要返回的单一结果对象。</p><p>　　　　</p><p>②HystrixObservableCommand 用在依赖服务返回多个操作结果的时候。它也实现了两种执行方式</p><p>　　  -observe():返回Obervable对象，他代表了操作的多个结果，他是一个HotObservable</p><p>　　  -toObservable():同样返回Observable对象，也代表了操作多个结果，但它返回的是一个Cold Observable。</p><p>参考链接：<a href="https://www.cnblogs.com/happyflyingpig/p/8079308.html" target="_blank" rel="noopener">https://www.cnblogs.com/happyflyingpig/p/8079308.html</a></p><p><strong>线程隔离和信号量隔离的区别：</strong></p><p><em>THREAD —— it executes on a separate thread and concurrent requests are limited by the number of threads in the thread-pool</em></p><p><em>SEMAPHORE—— it executes on the calling thread and concurrent requests are limited by the semaphore count.</em></p><p>简单地说，就是线程隔离就是HystrixCommand会在单独的线程上执行（new一个线程），受到线程池的线程数量限制。</p><p>而信号量隔离，仍然在调用的线程上执行，隔离等级由线程缩小为信号量。</p><p>显然，线程更安全，开销也更高，而信号量可以更高效，开销较低，但限制也较大（信号量个数限制</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_13.png" alt="sb_13"></p><h4 id="Feign使用Hystrix："><a href="#Feign使用Hystrix：" class="headerlink" title="Feign使用Hystrix："></a>Feign使用Hystrix：</h4><p>前面使用Hystrix是手动定义一个fallback方法，如果需要为Feign整合Hystrix，那么也很简单，为自定义的FeignClient接口提供一个实现类，然后接口的定义@FeignClient增加一个fallback属性即可。</p><p>看起来是没有任何问题的，但却出错了，而且一直解决不了，差点直接弃坑。</p><p><strong>当中可能存在的问题：</strong></p><p><strong><em>①没有配置Hystrix？</em></strong></p><p>网上一堆互联网垃圾互抄都是说这个问题，但并不是，我第一时间就在yml里设置好了</p><p><strong><em>②Feign已经包含了Hystrix，所以把启动类的@EnableHystrix去掉？</em></strong></p><p>难得看到一个不是提①的帖子，表示了是这个问题，但我去掉了还是存在500的问题</p><p><strong><em>③CustomizeFeignClientImpl的问题？路径?另外两个方法？</em></strong></p><p>都无关</p><p><strong><em>④@EnableFeignClients注解的问题？@EnableHystrix的影响?</em></strong></p><p>没有影响。</p><p><strong><em>⑤primary = false ？ @primary等等的原因？</em></strong></p><p>都不是关键，如果是注入出错的时候，Spring启动的时候就会抛出注入失败的错误。显式给fallback类使用@primary其实就是直接调用它的方法了，那样虽然可以fallback但已经失去了意义。</p><p><strong><em>⑥上一章节Feign的decoder，encoder，contract的问题？</em></strong></p><p>有可能，换了一个全新的Controller（简化了各种东西），并且把自定义FeignConfiguration也去掉了，RequestLine也换回了RequestMapping。但这时报错无法Autowire，因为它不知道要注入的是CustomizeFeignClient，还是CustomizeFeignClientImpl（注入类型是CustomizeFeignClient，所以两个都是可行的）。这时候我不懂为什么之前没有这个问题，就因为之前有自定义FeignConfiguration?</p><p>但是这时候我给CustomizeFeignClient设置了primary = false（官方文档里的解法），还是不行。只能给Impl添加@Primary，可这时候又有问题了，因为优先是Impl，所以无论如何都是fallback，那么就失去了原本的意义。而如果是给接口设置@Primary，那么就是继续500错误。而且之前把Configuration去掉，那么Feign会直接失效的，也可能是这个问题。关于这部分，只好先用着Hystrix，而不是Feign整合Hystrix，具体还得看文档才能解决。</p><hr><h4 id="Feign使用Hystrix：（解决篇"><a href="#Feign使用Hystrix：（解决篇" class="headerlink" title="Feign使用Hystrix：（解决篇"></a>Feign使用Hystrix：（解决篇</h4><p>问题原因：</p><p><strong><em>①Feign依赖包已经包括了Ribbon包，所以需要把Ribbon包去掉。</em></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">    &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;</span></span><br><span class="line"><span class="comment">&lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>（Feign整合了很多内容，包括Eureka，Ribbon，Hystrix，但这里只有Ribbon起到了冲突，具体原因不明。其他的诸如spring-cloud-starter-netflix-hystrix等包，不去掉也没有影响。</p><p><strong><em>②上一节在创建FeignClient实例的时候，用到了Feign.builder( )，然后认证内容都直接写在里面了，导致后面fallback是没有认证的。从而会导致401错误，最后变成500错误。</em></strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">userUserFeignClient = HystrixFeign.builder().client(client).decoder(decoder).</span><br><span class="line">    requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"user"</span>, <span class="string">"password1"</span>)).</span><br><span class="line">    target(UserFeignClient.class, "http://microservice-simple-provider-user");</span><br><span class="line">adminUserFeignClient = HystrixFeign.builder().client(client).decoder(decoder).</span><br><span class="line">    requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"admin"</span>, <span class="string">"password2"</span>)).</span><br><span class="line">    target(UserFeignClient.class, "http：//microservice-simple-provider-user");</span><br></pre></td></tr></table></figure><p>改成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserFeignClient userFeignClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestController</span><span class="params">(Client client, Decoder decoder, UserFeignClient userFeign)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userFeignClient = userFeign;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user1/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userFeignClient.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（无须decoder，encoder等等，也不需要那版本烦人的xxx.FeignClientsConfiguration.class了。</p><p>如何确定是这里的关键问题？如何看到401错误？</p><p>把上述代码改了之后，访问URL，会返回401错误，因为这时候其实已经可以访问到fallback了，但因为是最后的findById的时候没有认证，所以导致出错。之前写Feign刚好有一个搁置的配置文件，用于对Feign的认证，把它加上，问题彻底解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// when we need to add Interceptor for Feign, we need it to add the Http Basic auth.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasicAuthRequestInterceptor <span class="title">basicAuthRequestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"admin"</span>, <span class="string">"password2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"microservice-simple-provider-user"</span>,</span><br><span class="line">            configuration = &#123;FeignConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">FooConfiguration</span>.<span class="title">class</span>&#125;</span></span><br><span class="line"><span class="class">            <span class="title">fallbackFactory</span> </span>= FeignClientFallbackFactory<span class="class">.<span class="keyword">class</span>, <span class="title">primary</span> </span>= <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestLine</span>(<span class="string">"GET /&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@Param(<span class="string">"id"</span>)</span> String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用fallbackFactory而不是fallback类，使得可以打印错误日志（fallback类实现FallbackFactory&lt;xx&gt;接口，实现create方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">UserFeignClient</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = </span><br><span class="line">        LoggerFactory.getLogger(FeiginClientFallbackFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserFeignClient <span class="title">create</span><span class="params">(Throwable meg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserFeignClient() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">                FeignClientFallback.LOGGER.info(<span class="string">"fallback;reason was "</span> + meg.toString());</span><br><span class="line">                meg.printStackTrace();</span><br><span class="line">                User user = <span class="keyword">new</span> User();</span><br><span class="line">                user.setId(<span class="string">"-1"</span>);</span><br><span class="line">                user.setName(<span class="string">"Default user"</span>);</span><br><span class="line">                user.setAge(-<span class="number">1</span>);</span><br><span class="line">                user.setBalance(-<span class="number">111</span>);</span><br><span class="line">                user.setUsername(<span class="string">"default"</span>);</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当前消费者service也能通过printStackTrace查看提供者service的错误信息（值得注意的是直接LOGGER.info(throwable)并没什么用，不会打印出任何东西。。至此，问题解决。</p><hr><h4 id="对某个Feign禁用Hystrix："><a href="#对某个Feign禁用Hystrix：" class="headerlink" title="对某个Feign禁用Hystrix："></a>对某个Feign禁用Hystrix：</h4><p>（先编写一个配置类，然后在@FeignClient中导入即可）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignDisableHystrixConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">feignBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Feign.builder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要禁用Hystrix的@FeginClient引用该配置类即可，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"user"</span>, configuration = FeignDisableHystrixConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">UserFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接全局禁用Hystrix，在yml里，一般不会使用。</p><h3 id="三-使用Hystrix的监控"><a href="#三-使用Hystrix的监控" class="headerlink" title="三. 使用Hystrix的监控"></a>三. 使用Hystrix的监控</h3><p>Hystrix除了实现容错，还有强大的实时监控功能。</p><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><p><strong>①首先，给Consumer服务添加Hystrix监控节点。</strong></p><p>并不需要再导入依赖包了，因为<code>spring-cloud-starter-netflix-hystrix</code>就已经足够。另外，书上的例子是根据<code>@HystrixCommand</code>的继续的，它直接就拥有了hystrix.stream节点，不清楚为何。但我觉得可能是版本的原因，也可能是@HystrixCommand和Feign的区别，总而言之，上网查了一下，发现最可靠的办法还是：自己亲手创建者一个节点。这个过程很简单，而且也能对节点有更具体的认识，而不是像之前的，为什么会有info节点，health节点，到现在的hystrix.stream节点？都是系统自带的么?最好还是自己创建。</p><p>参考:<a href="https://blog.csdn.net/dangshushu/article/details/80416042" target="_blank" rel="noopener">https://blog.csdn.net/dangshushu/article/details/80416042</a></p><p>当然，这里添加的是``/actuator/hystrix.stream`，自己改一下就好，很简单。</p><p>这里当时遇到过问题，无法打开这个节点，忘了是什么原因了。一开始以为是@EnableHystrix或者@EnableCircuitBreaker跟@EnableHystrixDashboard冲突，因为删掉前面两个就可以了。但其实并不是，主要原因是，我没有导入Hystrix依赖包！可能是一开始以为Hystrix依赖包跟Hystrix-dashboard依赖包冲突，然后去掉了Hystrix依赖包。所以当时的原因是：没有加Hystrix依赖包，导致前两个注解出现问题而已，这同属一个包的注解如果不兼容，那一般不可能。</p><p>然后无论是打开浏览器查看hystrix.stream节点，还是直接查看hystrix查看dashboard界面，都可行了。这里又有一个问题，hystrix.stream一直ping，但没有内容。因为需要先在服务里执行至少一次操作，这里才会有信息，所以使用服务一次，比如xxx:8010/user/1，然后再看hystrix.stream节点就好。</p><p><strong>②关于可视化监控Dashboard</strong></p><p>首先需要导入依赖的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只需要在启动类加上<code>@EnableHystrixDashboard</code>即可。</p><p>对了，这里没有把Dashboard注册到Eureka上，一开始想着就在本身上监控，所以不注册也OK。</p><p><strong>③Dashboard可以监控多个服务实例，但当存在很多个实例的时候，只能一次一次地在hystrix节点上修改url，比较麻烦，而且不能对比。这时候就需要Turbine来聚合监控数据，其实也就是一次显示所有的/hystrix.stream节点，更方便，而且可以横向对比了。</strong></p><p>然后这时候发现前面的错了，我的架构搞错了，因为之前无论是Ribbon还是Feign等都直接在Consumer上添加，所以我也就直接都加到Consumer上了。原来Consumer上只需要添加一个Hystrix.stream节点即可（就是那个只有文字的Hystrix监控信息），然后对于dashboard跟Turbine，最好另外分别起两个modules，所以现在的项目架构应该是这样的：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_14.png" alt="sb_14"></p><p>这时就遇到了一个问题，太久没有创建子module，都忘了哪些是必须要添加的了，大概如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS：我觉得&lt;dependencies&gt;这部分应该是要放到父项目的，但现在懒得搞，后面重构再说。但h2数据库为什么也要导入我也不是很清楚。而且&lt;dependencyManagement&gt;也是必须的。还有启动类记得不能放在默认的package，不然无法scan。</p><p>然后Dashboard项目还好，其实跟上面说的是一样的，只是我们把consumer的那些内容都去掉了而已。然后刚刚又不小心解除了技能，之前在project左方找文件的时候，尤其是External Libraries，一堆文件找得头疼，各种快捷键也没有。刚刚才发现，无须快捷键，指到那个区域，直接输入便是搜索，无语了，一下就能把什么jackson，commonxxx揪出来了。</p><p>整个Dashboard项目结构：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_15.png" alt="sb_15"></p><p>Dashboard启动类前除了@SpringBootApplication，还要增加一个<code>@EnableHystrixDashboard</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixDashboardApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yml只需要配置一个端口号即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8030</span></span><br></pre></td></tr></table></figure><hr><p>Turbine项目的结构同理，只是除了上面Dashboard要导入的资源，还有：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yml：（这个Turbine需要注册到Eureka，所以还要配置一下Eureka相关属性。但Eureka的依赖包前面是直接放在父项目了，所以是无须在这个module特别导入的）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8031</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-hystrix-turbine</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">turbine:</span></span><br><span class="line"><span class="attr">app-config:</span> <span class="string">microservice-simple-consumer-user</span></span><br><span class="line"><span class="attr">cluster-name-expression:</span> <span class="string">"'default'"</span></span><br><span class="line"><span class="attr">instanceUrlSuffix:</span> <span class="string">/hystrix.stream</span><span class="comment"># 没有的话会出现异常</span></span><br></pre></td></tr></table></figure><p>这里的app-config就是指定要监控哪些服务，可以指定多个，逗号分隔开即可，甚至同一个实例的不同端口号启动也可以一起监控。由于我没有编写多个consumer，后面就直接拿双端口号实例来测试了。</p><p>而且，因为Turbine需要注册到Eureka，所以启动类应该是这样的：（exclude也是必须的，否则它会去yml里找，找不到就又生成了默认密钥了！ PS：去掉Turbine的security就不需要exclude了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(exclude &#123;org.springframework.boot.autoconfigure.security.</span><br><span class="line">    servlet.SecurityAutoConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">boot</span>.<span class="title">actuate</span>.</span></span><br><span class="line"><span class="class">        <span class="title">autoconfigure</span>.<span class="title">security</span>.<span class="title">servlet</span>.<span class="title">ManagementWebSecurityAutoConfiguration</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">EnableTurbine</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TurbineApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DiscoveryClient.<span class="function">DiscoveryClientOptionalArgs <span class="title">discoveryClientOptionalArgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DiscoveryClient.DiscoveryClientOptionalArgs discoveryClientOptionalArgs = </span><br><span class="line">            <span class="keyword">new</span> DiscoveryClient.DiscoveryClientOptionalArgs();</span><br><span class="line">        List&lt;ClientFilter&gt; additionalFilters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        additionalFilters.add(<span class="keyword">new</span> HTTPBasicAuthFilter(<span class="string">"hong"</span>, <span class="string">"root"</span>));</span><br><span class="line">        discoveryClientOptionalArgs.setADditionalFilters(additionalFilters);</span><br><span class="line">        <span class="keyword">return</span> discoveryClientOptionalArgs;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TurbineApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h4><p>然后启动类加上@EnableTurbine，启动，理论上应该就OK了，但果然还是踩坑了，然后下面开始讲述<strong><em>填坑</em></strong>的过程：</p><p>①首先必须清晰这几个项目之间是如何工作的，不能只知道它这样写work，而不清楚为何这样写，不求甚解的结果都懂的，后面稍微出现了点状况你也不知道是哪里出现问题，错误得不到正确的定位，就会花费极多的事件去做无用功（这里又要吐槽一次前面的Feign使用Hystrix，定位错误两天，解决一小时）</p><p>首先，给Consumer添加了<code>Hystrix.stream</code>节点。这个节点就是可被后面的Dashboard跟Turbine检测的，而且我们看一下配置节点的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">    ServletRegistrationBean regisBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">    regisBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    regisBean.addUrlMappings(<span class="string">"/hystrix.stream"</span>);</span><br><span class="line">    regisBean.setName(<span class="string">"HystrixMetricsStreamServlet"</span>);</span><br><span class="line">    <span class="keyword">return</span> regisBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使不清楚它的源码，但看了也大概知道是啥了，addUrlMappings就是添加节点的URL路径，然后设置了一个BeanName。而且这个Bean也不是瞎创建的，使用了HystrixMetricsStreamServlet来创建，所以很自然地，我们在8010/hystrix.stream里就可以看到一些关于Hystrix监控的信息了，尽管现在还不清楚到底是啥。</p><p>然后，Dashboard是一个单独的结点，不需要配置Eureka信息，它也确实无须注册到Eureka，毕竟它是在主页里手动输入url来获取Hystrix信息的（如localhost:8010/hystrix.stream)。PS：启动的时候可能会报错，说无法注册到服务器，不需要管，因为本来就不打算注册到Eureka，不影响。</p><p>最后，Turbine是需要注册到Eureka的，因为它不是单独地输入一个URL，然后就检测这一个，它是检测Eureka里所有具备了某个结点的服务（一开始以为默认就是hystrix.stream结点），然后Turbine本身又是一个结点，/turbine.stream,最后只需要把这个结点放到Dashboard里查询，那么就可以在Dashboard里显示所有的Turbine检测到的Hystrix.stream结点。总体逻辑就是这样。</p><p><strong><em>②Dashboard can not connect xxx：</em></strong></p><p>输入了某个hystrix.stream的URL之后，发现无法connect。这时候看一下日志就知道：401，未授权。所以这里也直接很简单粗暴了，URL前面加上xxx:yyy@即可 （这个好像叫OAuth协议，后面再说）。前面最开始为什么没有这个问题？因为当时Dashboard直接就在Consumer服务里，而Consumer服务是有配置这个认证的代码的，所以自然它也自动认证了。</p><p><strong><em>③在Dashboard里输入turbine.stream的时候，一直loading。</em></strong></p><p>一开始直接打开turbine.stream，发现一直在打印:”reportingHostsLast10Seconds”:0 ……</p><p>很显然，它没有发现到任何的Host，自然也没有信息。这时候再回看turbine的yml配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">turbine:</span></span><br><span class="line"><span class="attr">app-config:</span> <span class="string">microservice-simple-consumer-user</span></span><br><span class="line"><span class="attr">cluster-name-expression:</span> <span class="string">"'default'"</span></span><br><span class="line"><span class="attr">instanceUrlSuffix:</span> <span class="string">/hystrix.stream</span><span class="comment"># 没有的话会出现异常</span></span><br></pre></td></tr></table></figure><p>我当时consumer偷懒，一直没有给它加名字，所以consumer服务在Eureka里是叫UNKNOWN的。于是我把这里改成了UNKNOWN，确实就找到了。然后我给consumer加回这个正常的名字：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-simple-consumer-user</span></span><br></pre></td></tr></table></figure><p>发现是发现到了，但仍然是loading，这时候日志就看到错误原因了:401</p><p>仍然是未授权。这时候应该怎么解决？我前面是直接在Dashboard里的URL添加了认证信息，但这里显然是不行的，为什么？因为Dashboard里的URL直接就是我要监控的那个URL的地址，它具体地调用了某个Provider，然后这个Provider需要认证信息，所以我直接在URL里添加认证信息就可以了。但这里我在Dashboard里输入的URL是turbine.stream的URL，如果我在这个URL里加入了认证信息，那么只是传递给了Turbine。但后续Turbine还要自己去监控各种的服务，显然因为Turbine是连接多个服务的，如果不同的服务认证信息不一致，那么这种在URL前缀加认证信息其实就没必要，所以Turbine也很聪明地直接就不会把这个参数传递到服务（尽管我这里用的是同一个服务实例，如果它传是可以通过认证的，但显然它直接不这么尝试，我认为这个设计是合理的）</p><p>最标准的解法应该是，<strong><em>给Turbine增加一个配置类，然后通过认证</em></strong>，但我前面的认证都是针对注册到Eureka 的，而Consumer里的认证是使用Feign的，不可能给Turbine为了认证也加这么一个不需要的东西吧。不清楚如何解决，最后直接在源头：在Provider上配置例外，这样Turbine就不需要认证了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.configure(web);</span><br><span class="line">        web.ignoring().</span><br><span class="line">            antMatchers(<span class="string">"/hystrix.stream"</span>, <span class="string">"turbine.stream"</span>, <span class="string">"/actuator/hystrix.stream"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果还是不行，一开始说找不到/actuator/hystrix.stream。然后加上了这个ignoring也不行。其实当时就猜到了，默认路径应该是/actuator/hystrix.stream，而不是/hystrix.stream（可能是2.x改的）</p><p>所以正确的做法，<strong><em>给yml手动配置Turbine要监控的结点</em></strong>（不知道默认是什么，最好就直接自己配置)：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">turbine:</span></span><br><span class="line"><span class="attr">app-config:</span> <span class="string">microservice-simple-consumer-user</span></span><br><span class="line"><span class="attr">cluster-name-expression:</span> <span class="string">"'default'"</span></span><br><span class="line"><span class="attr">instanceUrlSuffix:</span> <span class="string">/hystrix.stream</span><span class="comment"># 没有的话会出现异常(验证了这个不可或缺)</span></span><br></pre></td></tr></table></figure><p>这里的turbine:instanceUrlSuffix: 就是配置了要监控的后缀。果然401问题解决了，就全部都解决了。</p><h4 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h4><p><strong>①Eureka：一共启动了6个项目。其中一个Provider，两个Consumer（通过不同端口启动的），一个Turbine，剩下的就是Eureka，还有没注册到Eureka的Dashboard。</strong></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_16.png" alt="sb_16"></p><p><strong>②Turbine.stream可以监控到数据：</strong></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_17.png" alt="sb_17"></p><p><strong>③Dashboard的界面：</strong></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_18.png" alt="sb_18"></p><p><strong>④给Dashboard输入我们要访问的URL，随便起一个Title（URL可以是单个的hystrix.stream，也可以是监控多个的turbine.stream，这里直接看turbine.stream）</strong></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_19.png" alt="sb_19"></p><p><strong>可以看到监控了两个Host，说明成功了。如果是多个不同的实例，会有多个图：</strong></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_20.png" alt="sb_20"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;​        上一部分添加了Ribbon实现了负载均衡，并且使用了Feign实现声明式的REST调用。微服务架构中还有很多其他组件，让我们继续学习其他有用的微服务架构的组件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/tags/Spring-Cloud/"/>
    
      <category term="Spring Boot" scheme="https://hongscar.cn/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud笔记(二)</title>
    <link href="https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%BA%8C.html"/>
    <id>https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%BA%8C.html</id>
    <published>2020-02-18T03:29:39.000Z</published>
    <updated>2020-02-19T03:20:51.737Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​        上一部分对Spring Boot跟Spring Cloud有了基本的认识，同时也添加了Eureka注册中心，使得最基本的服务注册，服务发现都可以实现。但这肯定不够，所以这里继续补充关于Spring Cloud的知识。</p><a id="more"></a><h3 id="二-添加Ribbon实现负载均衡"><a href="#二-添加Ribbon实现负载均衡" class="headerlink" title="二. 添加Ribbon实现负载均衡"></a>二. 添加Ribbon实现负载均衡</h3><p>关键点：当Client可以用Eureka Server定位到多个服务列表，应该选择哪一个？比如这里的例子，我们启动两个Provider，注册到Eureka Server上。此时Consumer去调用Provider（不再直接调用某一IP，端口，而是符合的服务列表，在这里只要是Provider服务即可）。此时我们需要实现负载均衡，避免某一个Provider服务过载，导致出错。</p><p>步骤：</p><p>先引入依赖，Ribbon。据说引入了<code>spring-cloud-starter-netflix-eureka-client</code>就可以，因为client已经包含了Ribbon，但我前面不需要引入client也可以实现，所以这里直接引用Ribbon，应该引用Client也行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（单独取其一即可）</p><p>然后给RestTemplate添加一个@LoadBalanced注解，表明该RestTemplate要使用负载均衡算法（这里当然就是直接默认的负载均衡算法，具体的参数配置后面再说）值得一提的是，<strong>@LoadBalanced只能用于setter方法处，所以是不能在构造方法上使用该注解的。</strong></p><p>然后改了一下Controller，主要是增加了一个LoadBalancerClient，还有RestTemplate的获取地址不再是硬耦合IP+端口，而是具体的服务名即可。同时还增加了一个log-user-instance，但这个主要是用于记录日志，方便观察到底是哪个Provider被调用了，所以这个并不是关键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MovieController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieController</span><span class="params">(DiscoveryClient discoveryClient, LoadBalancerClient lbc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.discoveryClient = discoveryClient;</span><br><span class="line">        <span class="keyword">this</span>.loadBalancerClient = lbc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，RestTemplate不能改成构造注入，否则加不了@LoadBalanced。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://microservice-provider-user/"</span>) + id, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user-instance"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ServiceInstance&gt; <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> discoveryClient.getInstances(<span class="string">"microservice-simple-provider-user"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/log-user-instance"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logUserInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="string">"microservice-simple-provider-user"</span>);</span><br><span class="line">    MovieController.LOGGER.info(<span class="string">"&#123;&#125;:&#123;&#125;:&#123;&#125;"</span>, serviceInstance.getServiceId(),</span><br><span class="line">                               serviceInstance.getHost(), serviceInstance.getPort());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getForObject里原本是直接写上了IP+端口的，成为了具体的服务名即可。而user-instance是上一章的遗留问题，当时没能查看到这个网页，原来是忘记写GetMapping了。最后一个log-user-instance就是拿来记录日志的，不用管。</p><p>然后测试，先启动Eureka，再启动两个Provider（先启动一个，修改yml里的端口号再启动一个。这样就相当于通过两个端口启动了两个Provider。当然这种做法有点蠢，<strong>如何在不修改配置的情况下启动多个？</strong><a href="https://blog.csdn.net/forezp/article/details/76408139" target="_blank" rel="noopener">https://blog.csdn.net/forezp/article/details/76408139</a></p><p>最后启动Consumer，这时候调用localhost:8010/user-instance等等的都是可行的，但在调用localhost:8010/user/1 的时候出现了问题，表示找不到该hostname：</p><p><strong><em>I/O error on GET request for “<a href="http://user-service/hi&quot;" target="_blank" rel="noopener">http://user-service/hi&quot;</a>: user-service; nested exception is</em></strong></p><p><strong><em>java.net.UnknownHostException: microservice-provider-user</em></strong></p><p>显然，就是调用/user/{id}的时候，下面的getForObject找不到那个host。找了很多解决方法，比如是不是hostname写错了，但其实这个逻辑并不通。因为user-instance都可行了，说明确实就是这个hostname。然后网上说要导入client包，导了也不行。接着又想是不是不能同时使用构造注入跟设值注入？发现也不是，看我上面的代码，就是同时使用两种注入方式。</p><p>最后的解决方法是一个我很早就看到了的错误，需要加入@LoadBalanced注解。这个参数我当然知道有何作用，而且我第一时间就加了，错在哪？因为我最后才发现，我在Application启动类就已经注入了RestTemplate，然后我改Ribbon的时候是在Controller里再注入一次RestTemplate，然后@LoadBalanced等等都是在Controller里进行的。所以，<strong>由于先启动的肯定是Application启动类，这时候就已经进行了@RestTemplate的注入操作了，后面在Controller里的其实已经是废设，自然那个@LoadBalanced也是没有任何效果的。</strong>于是我把Controller里的RestTemplate去掉了注入，在Application启动类里的注入增加了@LoadBalanced，就成功了。然后再测试了一下把Application启动类的注入彻底去掉，在Controller里重新加回注入跟@LoadBalanced，也成功。</p><p>负载的效果可能不是很明显，因为我测试的方式比较stupid，就是一次一次调用，看是不是轮流调用两个Provider，确实如此。当然肯定不是严格按照1：1的，在数据很大的时候应该会有小许偏差，但总体上比例就会是在1：1左右。</p><p>chapter5剩下的内容：Ribbon负载均衡的配置，包括Java类配置和属性配置（yml）两种方式。其中Java类需要注意不能放在@ComponentScan所能scan的包，不然就公用配置了。一般来说yml更简洁更方便。还有脱离Eureka使用Ribbon的方法（其实就是client包改成了ribbon，然后yml里增加一下ribbon的属性参数）。最后还有一个Lazy加载跟Hungry加载（即只要项目启动就加载，避免第一次调用时响应过慢）这些内容看起来都不难，而且现在不关键，就先不敲代码尝试了.</p><h3 id="三-使用Feign实现声明式的REST调用"><a href="#三-使用Feign实现声明式的REST调用" class="headerlink" title="三.  使用Feign实现声明式的REST调用"></a>三.  使用Feign实现声明式的REST调用</h3><p>使用Feign实现声明式的REST调用，并且配置REST的部分参数。</p><p>使用RestTemplate虽然已经可以满足所有功能，但比较繁琐（url高度耦合到每一个Mapping处，比如要写一遍Service名，多个参数的时候url会更加的臃肿）</p><p><strong>使用Feign的好处：让编写Web Service客户端更加简单，因为它支持Spring MVC注解，JAX-RS注解，整合了Eureka，Ribbon。也就是说，只要使用Feign注解来替代，那么就能在实现Spring MVC的同时，也自动实现负载均衡。</strong></p><p>使用步骤：</p><p>①添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>②创建一个Feign接口，添加@FeignClient（这个FeignClient，用于注入到Controller中，替代RestTemplate进行Restful API的映射设计，以及自动实现负载均衡）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"microservice-simple-provider-user"</span>,</span><br><span class="line">            configuration = &#123;FeignConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">FooConfiguration</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">UserFeignClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestLine</span>(<span class="string">"GET /&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③注入到Controller中：（值得注意的是，由于是接口对象，那么就没办法实现一个setter去注入了，会报错但其实是可行的，因为是通过注解自动生成的FeignClient对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserFeignClient userFeignClient;</span><br></pre></td></tr></table></figure><p>④最后就是调用：url都已经被封装到接口里了，使得URL更加的简洁，同时后面多参数的时候会更加明显。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">    turn userFeignClient.findById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于配置，只需要定义一些Feign的配置类，然后在接口的@FeignClient的configuration属性指明即可。</p><p>（PS：配置类最好不写@Configuration注解，如果写了，那么不要放在@ComponentScan所扫描的包中，否则会成为全局配置，被所有@FeignClient共享，除非你确实想要成为全局配置。但是由于@FeignClient的configuration属性就可以直接指明，一般没有必要写这个注解）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contract <span class="title">feignContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> feign.Contract.Default();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BasicAuthRequestInterceptor <span class="title">basicAuthRequestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"user"</span>, <span class="string">"password"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的两个配置类都已经被添加到UserFeignClient中，第一个把contract改成了feign的原生默认契约，使得可以使用feign自带的注解（如@RequestLine），第二个相当于为Feign添加拦截器，这样当一些接口需要进行给予Http Basic认证才能调用，就需要上面的认证信息。</p><p>同时上面还有Spring cloud官网文档上写的Feign的配置属性，可以学习。</p><p>除了使用Java类配置，用yml配置也是可以的，跟Ribbon一样，用yml配置更加的简洁。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">config:</span></span><br><span class="line"><span class="attr">feignName:</span><span class="comment"># 改成default就是全局配置</span></span><br><span class="line"><span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">loggerLevel:</span> <span class="string">full</span></span><br><span class="line"><span class="attr">decode404:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>果不其然。。目前还没看出Feign的好处，因为我们这里只是相当于用feign替代了RestTemplate的Restful设计，然后还能增加一些超时，日志的配置而已，关键还是要自定义feign，可以彻底增强Restful API的操作，比如相同的API，不同角色的用户会发生不同的行为。</p><p>话说中间在Console看到了一个错误：<strong><em>Batch update failure with HTTP status code 401; discarding 1 replication tasks</em></strong>，显然就是注册服务到Eukera Server失败，网上的解决方法是在Server处的yml配置还是要在defaultZone增加那个user，password，增加了之后就可以了。</p><h3 id="四-手动创建Feign"><a href="#四-手动创建Feign" class="headerlink" title="四. 手动创建Feign"></a>四. 手动创建Feign</h3><p>前面对Consumer使用了Feign，感觉也只是替代了RestTemplate的Restful设计，稍微加了一些日志配置，意义不大。但如果是手动创建，将能完成更强的逻辑。</p><p>接下来对Provider服务手动创建Feign。</p><p>首先，导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之前对于Security包，我只在Eureka Server处添加了该依赖包，但在其他地方添加感觉没有必要，不仅需要同样的用户密码，而且如果密码不同，还可能导致无法注册到Eureka的情况。所以这次需要对Provider额外再增加一个security，感觉会在认证这里出现问题，事实也是如此的。但主要问题在于对Security的配置不熟悉，知道了哪些属性起到什么作用就好。</p><p>首先我们需要给Provider的Security添加配置（其实之前Eureka的Security也有配置，不过只是禁用了一下CSRF：</p><p>之前的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable();</span><br><span class="line">        <span class="keyword">super</span>.configure(http);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（可以看出来主要是注解@EnableWebSecurity。然后配置的导入，要么@Configuration，要么在启动类里Import(xxx.class)，都是一样的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// all request need HTTP Basic auth</span></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated().and().</span><br><span class="line">            formLogin().and().httpBasic();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// A password encoder that does nothing Useful for testing with plain text</span></span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomUserDetailsService userDetailsService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CustomUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"user"</span>.equals(username))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SecurityUser(<span class="string">"user"</span>, <span class="string">"password1"</span>, <span class="string">"user-role"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"admin"</span>.equals(username))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SecurityUser(<span class="string">"admin"</span>, <span class="string">"password2"</span>, <span class="string">"admin-role"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这里的配置类，具体说一下。<code>configure</code>方法，这个其实就是登录功能。不要看起来很复杂，其实and就是起连接作用。然后authorizeRequests就是要验证request的意思，anyRequest就是每一个请求都要验证，没有例外。authenticated：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ExpressionUrlAuthorizationConfigurer&lt;H&gt;.ExpressionInterceptUrlRegistry</span><br><span class="line">    authenticated() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.access(<span class="string">"authenticated"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概也就是通过验证的意思，其他的还有denyAll，rememberMe等等的功能。formLogin就是以一个登录界面显示，而不是弹窗。最后就是表明要基于HTTP Basic来验证。</p><p>至于<code>passwordEncoder</code>方法，这是一个明文编码器，因为涉及密码的时候都是要加密的，但这里只是测试，所以就用一个不作任何操作的密码编辑器就好。</p><p>验证的过程需要我们根据用户账号和密码，如果通过了就返回一个<code>UserDetails</code>的对象，这是一个接口，所以我们需要手动创建一个实现类，重写相关方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurityUser</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityUser</span><span class="params">(String username, String password, String role)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.role = role;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        Collection&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        SimpleGratedAuthority authority = <span class="keyword">new</span> SimpleGrantedAuthority(role);</span><br><span class="line">        authorities.add(authority);</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（下面还有一些setter，getter就省略了。。虽然我中途有一个错误就是写错了getter，当时自动生成的getPassword方法竟然返回的是null，而不是password，使得我一直密码登录不通过。最后还是一步一步调试才发现是getter出现了问题）</p><p>其实关键的方法也没什么，<code>getAuthorities</code>主要是对role的配置而已，因为这是需要返回Collections对象，所以看起来不太一样，其实就是一个getter。但下面这4个方法其实挺关键的，看方法名就大概知道是什么作用，是否锁定账号，是否允许登录。IDEA默认生成的这4个方法是返回false的，这会导致：即使账号密码一致，也会一直卡在登录的界面。</p><p>接着的内部类<code>CustomUserDetailsService</code>就是注入一个自定义的Bean。这里就是登录验证的地方，首先获取登录界面的user参数（loadUserByUsername)，然后根据账号密码去进行匹配，生成一个UserDetails的对象并返回。如果这里出错（即没有预设的Username），那么就会返回一个null，登录直接失败。当我们通过了验证，返回一个UserDetails之后，这时候我们会再调用第二个configure方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.userDetailsService(<span class="keyword">this</span>.userDtailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，就是将登录界面的密码与UserDetails进行匹配。如果密码一致，则登录成功。否则会显示：Not granted any authorities(我就是因为getter写错了导致一直显示Not granted any authorities)</p><p>最后一切成功，Provider成功注册到Eureka，没有因为多增加一个Security而导致无法注册。同时Provider服务本身也增加了认证机制，使得可以根据不同的账号密码（一般应该是根据用户名，获取role，然后做出不同的工作，但这里只是为了演示Feign的根据情况做出不同处理的作用，所以只是print了一下role。）</p><p>两个Security的配置信息关键在于：</p><p>Eureka Server的配置无须做出改变：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-discovery-eureka-ha</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line"><span class="attr">user:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">hong</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8761</span></span><br></pre></td></tr></table></figure><p>而对于Provider服务，为了注册到Eureka的认证，还是注入Bean的方法比较好（其实yml好像也是一样的，但不要在defaultZone里乱写）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DiscoveryClientOptionalArgs <span class="title">discoveryClientOptionalArgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DiscoveryClientOptionalArgs discoveryClientOptionalArgs = </span><br><span class="line">        <span class="keyword">new</span> DiscoveryClientOptionalArgs();</span><br><span class="line">    List&lt;ClientFilter&gt; additionalFilters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    additionalFilters.add(<span class="keyword">new</span> HTTPBasicAuthFilter(<span class="string">"hong"</span>, <span class="string">"root"</span>));</span><br><span class="line">    discoveryClientOptionalArgs.setAdditionalFilters(additionalFilters);</span><br><span class="line">    <span class="keyword">return</span> discoveryClientOptionalArgs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后Provider服务的自身认证机制，就直接写在自己的Security配置类里就好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CustomUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"user"</span>.equals(username))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SecurityUser(<span class="string">"user"</span>, <span class="string">"password1"</span>, <span class="string">"user-role"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"admin"</span>.equals(username))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SecurityUser(<span class="string">"admin"</span>, <span class="string">"password2"</span>, <span class="string">"admin-role"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>给consumer service也使用自定义Feign Client。</p><p>改成了使用FeignClient的默认配置，然后创建了两个Feign Client（一个UserClient，一个AdminClient），绑定到同一个service（Provider），但使用不同的账号去访问（User/Admin)，于是也会得到不同的效果，在Provider控制台也会显示出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MoviewController</span><span class="params">(DiscoveryClient discoveryClient, Decoder decoder,</span></span></span><br><span class="line"><span class="function"><span class="params">                        LoadBalancerClient loadBalancerClient, Client client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.discoveryClient = discoveryClient;</span><br><span class="line">    <span class="keyword">this</span>.loadBalancerClient = loadBalancerClient;</span><br><span class="line">    userUserFeignClient = Feign.builder().client(client).encoder(getEncoder()).</span><br><span class="line">        decoder(decoder).requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"user"</span>,</span><br><span class="line">        <span class="string">"password1"</span>)).target(UserFeignClient<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">                                 "http://microservice-simple-provider-user");</span><br><span class="line">    adminUserFeignClient = Feign.builder().client(client).encoder(getEncoder()).</span><br><span class="line">        decoder(decoder).requestInterceptor(<span class="keyword">new</span> BasicAuthRequestInterceptor(<span class="string">"admin"</span>,</span><br><span class="line">        <span class="string">"password2"</span>)).target(UserFeignClient<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">                                 "http://microservice-simple-provider-user");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user-user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findByIdUser</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userUserFeignClient.findById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"admin-user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findByIdAdmin</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> adminUserFeignClient.findById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于decoder，encoder这部分纠结了好久，最后甚至用到了阿里巴巴的JSONObject包自实现了一个（当然，是上网cv下来的，但搞依赖包也烦了一小会）。可是最后才发现，这部分就没意义，反正都能映射到provider服务就好了，然后在provider的控制台也是会把结果打印出来的。所以关键在于：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestInterceptor(new BasicAuthRequestInterceptor("xxx", "xxxx")).target(xx.class, "x");</span><br></pre></td></tr></table></figure><p><code>requestInterceptor</code>传入 一个<code>BasicAuthRequestInterceptor</code>，表示账号密码，target就是目标服务。</p><p>PS:中途还把id改成了String，其实没什么影响，不过懒得改回去了，万物皆可String</p><p>之后的日志配置跟多参数，我感觉一开始是头脑清醒的，结果中间就不知道做什么了。</p><p>首先，前面是要先把自定义的FeignClient给注释掉的，然后再在controller里定义了两个，直接在controller里调用相应的FeignClient。结果我改成多参数的时候，首先要先把那个原本的FeignClient弄回来，其实那时候是注释掉了三个地方，结果我只改回了两个，然后启动类的注释忘记去掉了，于是一直在莫名其喵。最后还是还原成之前的代码，然后对比了一下才发现忘记一个注释了，所以前面做的很多就是无用功。</p><p>本章节剩下的部分，主要是多参数Feign跟上传文件。其实我觉得还蛮重要的，但我认为作者这里偷懒了，它的代码根本就不能实现，只是画个饼。更关键的是，由于版本的原因，它的代码存在1.x的代码（与2.x不兼容），而我导入2.x的包却没有相关的jar包，搞得我还得上网找一个自实现的Decoder。然后也尝试就这个包换成1.x，发现更恐怖了，整个项目不兼容。总而言之，这部分真的只能搁置。但好歹，最后总算解决了那个不能识别注解的问题。网上都说是Feign默认注解有问题，那个@RequestLine不行。我怀疑他们用的都是1.x。而2.x恰恰相反，就是要使用这个默认注解，然后使用@RequestLine而不是@RequestMapping。总而言之，烦了一整天这个问题。但我觉得主要还是，一开始没有耐心地考虑问题，主要一开始我用@RequestLine确实不可行，于是我也想着改。但其实我当时出错的原因不是这个，而是其他。。所以，一开始对错误的范围认知有误，导致后面也一直错，确定问题的范围真的很关键！不过还好，最后虽然无法生成User，但还是成功将多参数传到了Provider服务。说明Feign多参数的传递还是可行的，而且多次的尝试也让我对整个微服务的架构有了更多的认识（Provider跟Consumer真的是很关键的两个角色）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;​        上一部分对Spring Boot跟Spring Cloud有了基本的认识，同时也添加了Eureka注册中心，使得最基本的服务注册，服务发现都可以实现。但这肯定不够，所以这里继续补充关于Spring Cloud的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/tags/Spring-Cloud/"/>
    
      <category term="Spring Boot" scheme="https://hongscar.cn/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud笔记(一)</title>
    <link href="https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%B8%80.html"/>
    <id>https://hongscar.cn/Spring-Cloud%E7%AC%94%E8%AE%B0-%E4%B8%80.html</id>
    <published>2020-02-18T01:37:59.000Z</published>
    <updated>2020-02-19T07:09:56.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​        Spring已经渐渐地成为了Java程序员的必备技能，尤其是Java Web方向。同时，Spring也一直在发展，由于Spring存在配置臃肿的问题，所以就出现了Spring Boot框架，用于简化新Spring应用的初始搭建以及开发过程。近年来微服务架构也越来越火，所以在Spring Boot的基础上又出现了Spring Cloud。如果你是常年使用Spring的Java Web程序员，那么Spring Boot跟Spring Cloud很值得一学。</p><p>​        本系列文章并非是完整的教程，我阅读的是<strong><em>”<a href="http://www.ityouknow.com/spring-cloud.html" target="_blank" rel="noopener">纯洁的微笑</a>“的博客</em></strong>：。以及书籍<strong><em>《Spring Cloud与Docker微服务架构实战》by周立</em></strong>。相信每一位学习编程的朋友都遇到过一个问题，跟着书上/教程上一步一步走，结果却不一样。有的时候是版本的问题，有的时候是自己的操作出现纰漏，也可能是教程本身也存在纰漏。无论如何，学习是一个挖坑再填坑的过程，在这个过程中我们的技术也会快速提高。所以这篇文章就是记录我在学习Spring Cloud过程中所遇到的问题，以及如何解决（虽然也有构建步骤，但目前写得比较简单，建议结合上面推荐的博客，书籍使用）。如果有朋友也遇到了类似的问题，可以参考一下。</p><a id="more"></a><p>​        此处使用的<strong><em>Spring Boot版本：2.2.1.RELEASE，Spring Cloud版本：2.2.0.RELEASE</em></strong>。虽然我阅读的主要教程是上面的书籍，但我自己敲的demo项目跟书上有一点不同。书上把每一个章节的项目都分开，比如一个章节是学Feign，一个章节是Hystrix，并没有把它们都结合在一起，我认为这样缺少了一个很重要的工作：整合。然而整合却是必不可少的，既然都使用到了微服务架构，那么自然是要使用多个模板组件。所以我一共只写了一个项目，代码依次在上一个章节代码的基础上继续增加，既要保证功能完好，又要保证功能之间可以兼容。除此之外，书上目前的版本还是Spring Cloud 1.x，毫无疑问已经过时，所以我也改成了2.x。虽然我认为做出的这两个改变是值得的，但确实在学习过程中也遇到了不少的坑，所以也特地记录了下来。</p><h3 id="二-前置知识"><a href="#二-前置知识" class="headerlink" title="二. 前置知识"></a>二. 前置知识</h3><p>​        Spring Boot是Spring的一套快速配置框架，而Spring Cloud是一个基于Spring Boot实现的云应用开发工具。所以，Spring Boot可以离开Spring Cloud独立使用开发项目，而Spring Cloud不能离开Spring Boot，属于依赖的关系。所以如果你还是使用Spring，而非Spring Boot，那么至少要了解Spring Boot与Spring的区别。可以参考这篇文章入门：<a href="http://www.ityouknow.com/springboot/2016/01/06/spring-boot-quick-start.html" target="_blank" rel="noopener">http://www.ityouknow.com/springboot/2016/01/06/spring-boot-quick-start.html</a></p><p>​        可以看到，Spring Boot项目的构建非常简单，无须再考虑各种诸如xml，数据库，配置文件的配置，更多的只需要注解，达到了非常简便的效果。项目的结构也跟Spring相差无几：</p><p><code>src / main / java ：</code> 主程序入口</p><p><code>src / main / resources ：</code> 配置文件</p><p><code>src / test / java ：</code> 测试</p><p>​        在java / com / xx / xxx里的主目录（即与model，service，controller等packages同级的目录），要有一个Application.java，这个其实就是Spring Boot框架的入口，相当于Spring里的XML配置。不过这里抛弃了XML，使用了注解的方式：<strong>@SpringBootApplication</strong>。目前要引入jar包所需要的Maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实大部分在Maven默认项目里都已经添加好了，剩下的只需要添加支持web的模块：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来对于Controller层的开发也很简单：@RestController，@RequestMapping即可（方法返回String类型，不需要什么ModelAndView）</p><p>@RequestMapping是指Controller里的方法都以JSON格式输出，无须再写Jackson等配置了。</p><p>对于测试：@Test，@BeforeEach （对于JUnit5，@Before and @After no longer exists； use @BeforeEach and @AfterEach instead）</p><p> PS：主要是原本的Before跟After注解就是在每一个Test方法执行时都会执行，改得更加符合其作用</p><hr><p>​         微服务架构需要有多个modules，如果你愿意的话，你可以把一个modules当作一个项目来操作，但到了微服务这一块，这种做法就比较愚蠢，<strong>于是最好是尝试把多个modules放到同一个project中（使用的是IDEA）</strong>。参考网址:<a href="https://blog.csdn.net/sinat_30160727/article/details/78109769" target="_blank" rel="noopener">https://blog.csdn.net/sinat_30160727/article/details/78109769</a></p><p>遇到的问题：</p><p><strong><em>①子module跟父module的pom.xml有什么异同？</em></strong></p><p>父module的pom如下，可以看到包含了Spring Boot的基本信息，还有子modules的构成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span><span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hongscar<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>microservicesimpleprovideruser<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>microservicesimpleconsumermovie<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至于子module，之前该怎么样就怎么样，但parent元素无须做出改动，即：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hongscar<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>microservice-simple-provider-user<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>②写好src/main/java之后，程序无法运行，显示错误：<strong><em>Your ApplicationContext is unlikely to start due to a @ComponentScan of the default package.</em></strong></p><p>解决:因为之前错误的父子module关系，导致我的子modules其实还是有默认package的，比如之前的package都是<em>com.hong.microservice-xxxx-provider</em>之类的。但实际上正确的操作，这时候子module的src/main/java，是没有任何package的，即在java目录下创建一个A.java，会没有package语句。而SpringBoot的Application.java确切地说，并不是要放在根目录，而是要放在所有其他类/包的同级/父级目录，是不能够直接放在src/main/java目录下的，必须手动创建一个包把它放进去。<strong>SpringBoot在写启动类的时候如果不使用@ComponentScan指明对象扫描范围，默认指扫描当前启动类所在的包里的对象，如果当前启动类没有包，则在启动时会报错</strong>。（因为默认并没有包，所以就报错了）</p><p>解决方案也很显然，自己手动创建了一个basic的package，然后其他的package跟Application.java都放进去，如下图：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_1.png" alt="img"></p><p><strong><em>③Test无法通过，但直接运行可以通过</em></strong></p><p>解决：看清楚是@Before还是@BeforeEach。至于其他的，目前其实可以直接运行，但如果测试代码出错，后面会踩坑，可以尝试到时候解决，也可以提前把测试代码删掉了避免踩坑（但你知道是测试代码哪里出错了吗）</p><p>④创建第二个MicroService的时候，Test又无法通过，而且不是@BeforeEach的问题。报错：</p><p><strong><em>java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration, you need to use @Context</em></strong></p><p>解决：可能是因为存在了多个service，无法默认指定等等的（毕竟多个module的配置其实我还不是很熟悉），这时候最好就是直接在测试类上面显示指明要测试的是哪个类，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpirngBootTest</span>(classes = MicroserviceSimpleConsumerMovieApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MicroserviceSimpleConsumerApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextsLoad</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加之后，测试也可以运行了，但还是不通过。然后才知道，test目录下的包默认是要跟java下的是一样的。所以，既然java目录下的Application.java的路径是 basic/Application.java (basic是我们自己添加的package），所以test下也需要添加一个名为basic的package（必须名字也为basic）</p><p>⑤<strong><em>Caused by: java.lang.IllegalArgumentException: Not a managed type</em></strong></p><p>无论是哪个服务，对于domain层的配置都要重复编写。@Entity等等的。</p><p>over，运行通过（尽管第一个service的测试还是存在问题，但毕竟我对MockMvc的语法一无所知(问题③))</p><h3 id="三-添加Eureka"><a href="#三-添加Eureka" class="headerlink" title="三. 添加Eureka"></a>三. 添加Eureka</h3><p>​        微服务架构的核心思想就是分离各个服务，每一个服务单独作为一个module/project。那么服务如何被其他项目/服务调用？这时候就要用到Eureka，服务注册中心。服务把自己注册到Eureka上，然后其他服务可以在Eureka上发现并调用，这就是微服务的基本机制。</p><p>步骤：</p><p>pom.xml添加Eureka依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种maven依赖直接去<em>maven repository</em>查找就能找到，还能找到每一个版本。这里值得注意的是，添加的是server，不要错误地添加了client包。同时Spring Cloud的版本号比较特别，使用英语记录版本 ，以下是<strong><em>Spring Cloud英语版本对应的Spring Boot版本</em></strong>：</p><table><thead><tr><th>Spring Cloud版本</th><th>Spring Boot版本</th></tr></thead><tbody><tr><td>Hoxton</td><td>2.2.x</td></tr><tr><td>Greenwich</td><td>2.1.x</td></tr><tr><td>Finchley</td><td>2.0.x</td></tr><tr><td>Edgware</td><td>1.5.x</td></tr><tr><td>Dalston</td><td>1.5.x</td></tr></tbody></table><p>添加完依赖包，其实就可以运行了。然后要把服务注册到Eureka。这时候才是版本冲突的地方。<strong><em>ERROR org.springframework.boot.SpringApplication - Application run failed</em></strong></p><p>一般这种<strong><em>Application run failed</em></strong>，基本就是<strong><em>版本号冲突</em></strong> 的问题了。看了一下，我写的还是书上的Edgware.RELEASE，参考官网的改成了<strong>HOXTON.RELEASE</strong>，就解决了这个问题。</p><p>然后又有其他的错误， <strong><em>Failed to start component [NonLoginAuthenticator [StandardEngine[Tomcat] .StandardHost[localhost] .TomcatEmbedded。。。</em></strong></p><p>网上查到的也是更加奇怪，说是<strong>SDK里的servlet-api.jar与log4j.jar起冲突了</strong>。其实关于前面的版本号为什么非要添加到Eureka才出问题已经挺奇怪了，这里就更奇怪了，怎么突然就两个jar起冲突了？唯一的解释只能是Eureka毕竟是带有记录功能的，所以就包含了log4j.jar，然后就与servlet-api.jar冲突了。可是我的SDK里却没有这个东西，去External libraries找到了这个东西，然后去掉，竟然真的就可以了。所以说，编程还是需要多积累经验。</p><p>效果图：可以看到MicroService已经注册到了Eureka上</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_2.png" alt="img"></p><h3 id="四-把多个服务注册到Eureka上"><a href="#四-把多个服务注册到Eureka上" class="headerlink" title="四. 把多个服务注册到Eureka上"></a>四. 把多个服务注册到Eureka上</h3><p>看起来很简单，但却遇到了非常多的问题。首先打开consumer服务的时候，发现pom.xml报错了。想当然的以为又只是IDEA抽风了而已，因为直接运行是可行的，但后来发现确实不是如此。</p><p>maven之前欠下的债算是要还了，每当我有一个知识点掌握得含糊不清，得过且过，也许我可以安逸地度过很久，甚至是几年，但总会有再栽跟头的一天。之前我对maven，真的就是把它当作了一个简单的eclipse的import path的功能了，目的实现了就行了，什么&lt;dependencyManagement&gt;，完全不想去弄清楚。之前创建子module之间的依赖，我其实就搞不懂为什么能直接用cn.hongscar.xx来引用依赖？难道因为是项目内部就可以直接引用？没有去想。</p><p>首先项目一直会出现今天早上的那个错误，显然就是servlet-api.jar的问题，才发现这东西会一直存在，即使删掉了，maven也会把它自动下载回来。很显然，删掉是很愚蠢的操作，但当时毕竟只想立竿见影，我一直以来都是这么做的，显然正确的操作是添加一个maven的例外。所以正确的操作是添一个&lt;exclusions&gt;在&lt;dependency&gt;里。这确实就可行了，但真的是如此吗？首先，确实是添加了&lt;exclusions&gt;就可以工作了，但为什么maven会 自动把servlet-api.jar下回来，难道这还需要时机？得看你手速快不快，在它把servlet-api.jar下回来之前运行？实际上，就是因为项目本身就存在问题，所以每次rebuild，reimport的时候就把jar包搞回来了。无论如何，&lt;exclusions&gt;显然是更好的选择。</p><p>关于我要的目标，其实<strong><em>Maven的基本命令</em></strong>就已经包括了：</p><p>-v :查询Maven版本</p><p>compile： 编译，把Java源文件编译成.class文件</p><p>test：测试项目，测试test目录下的测试用例</p><p>package：将项目打包成jar包</p><p>clean：删除target文件夹（删除缓存，重新生成）</p><p><strong><em>install：将当前项目放到Maven的本地仓库中，供其他项目使用</em></strong></p><hr><p>我想要的就是把项目安装到本地仓库里，总不能把项目delete了重新创建一次吧。然后在install的过程中查看到底出现了什么问题，这才是解决问题的核心。而不是，clean，complie统统乱点一遍。</p><p>然后在install的过程中就能看到问题了：</p><p><strong><em>Failure to … in … was cached in the local repository, resolution will not be reattempted until the update interval of nexus has elapsed or updates are forced.</em></strong></p><p>首先是Hoxton.RELEASE文件已经缓存了，并且还在使用，就不能update了。这时候真的就是简单粗暴就好，删了，让它重新下载，这个问题就解决了。</p><p>接下来的问题更离谱，说是<strong><em>测试代码有问题，所以不能成功build</em></strong>。想起来昨天不懂测试语法，想着项目能正常运行就好，测试代码就没管，没想到就这里埋下了大坑。于是把测试代码全部注释掉，同时rebuild一次（更新classes文件夹），果然，build就成功了。maven本地仓库也就成功出现了该模块。所以，项目到底如何加到maven本地仓库，为什么之前出错，都是有迹可循的，真的不仅仅就是奇怪的经验那么简单。当然，经验是否有用？至少从中能知道，测试代码并不是那么的人畜无害，在正式的build，install（项目打包过程），测试代码也是关键的一环，它有权终止整个过程，尽管你的主程序没有出错，只是测试代码写错了。</p><p>其实很多时候，把很多东西都归结于经验，确实有种给自己诡辩的嫌疑。就像是看到pom.xml报错了，第一时间想的是不是IDEA抽风了，完全不去想到底什么原因。诚然，”奇怪“的情况是存在的，但并不能一概而论，很多时候，经验不能成为一个完美的借口。</p><p>结果图：    可见两个service都成功添加到Eureka中。</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_3.png" alt="img"></p><h3 id="五-构建高可用的Eureka-Server"><a href="#五-构建高可用的Eureka-Server" class="headerlink" title="五. 构建高可用的Eureka Server"></a>五. 构建高可用的Eureka Server</h3><p>​        先从搭建两个Eureka Server互相注册复制开始。根据书上的例子，首先需要修改<strong>hosts文件</strong>。然后先去了解了一下hosts文件是什么（位置：C:\Windows\System32\drivers\etc，如果是Linux，是在/etc/hosts)，主要就是平时我们上网都要输入域名，然后传递到DNS服务器再进行映射，而DNS服务映射到具体的IP地址是需要时间的。这时候我们可以在hosts文件里自定义一些domain name（可以是自定义，可以是公开的），以及对应的IP地址，那么当我们下次输入这个domain name的时候，就直接映射到IP地址，跳过了DNS，因此速度也就更快。比如GitHub.com的IP地址是192.30.255.113。那么添加一行：</p><p><code>192.30.255.113          github.com</code></p><p>即可使得下次输入GitHub.com就能自动映射到对应的IP addr。</p><p>平时我们用的localhost跟127.0.0.1也是如此。127.0.0.1默认就是本地的IP地址，而localhost就是写在hosts里的域名。但在hosts里可以看到这一行是被注释掉的，为什么？因为下面还有一行注释：</p><p># localhost name resolution is handled within DNS itself. </p><p>也就是说，DNS服务器内部已经把这个写好了，成为了约定，这样就避免了你把localhost乱搞成了其他东西。所以并不是说注释是无效的，而是这一行直接成为了DNS的默认约定配置吧。</p><p>OK，然后修改hosts是要给127.0.0.1新增几个新域名（peer1跟peer2）</p><p>然后在application.yml里的配置，使用— 可以将yml文件分成多段，由一个spring:profiles来决定（在后续启动的时候传入这个参数，表示要使用哪段yml文件），如果没有指定spring:profiles，则无论是传入哪个参数，都会生效。</p><p>启动的时候需要：<code>java  -jar  xxx.jar  --spring.profiles.active=peer1  /  peer2</code></p><p>显然，首先我们需要将项目打包成jar文件，然后再分别启动（spring.profiles参数分别为peer1和peer2)</p><p>这时就出现了第一个问题，如何打包成jar文件？</p><p>联想到昨天吃的亏，印象中maven里就包含了这个操作，确实如此。但成功打包之后，却无法运行，显示：<strong><em>xxx没有主清单属性</em></strong></p><p>那么到底是什么是主清单属性？其实也很好猜，就是找不到主类。网上看的大致说法是，maven的打包jar操作是有点特殊的，跟普通的java方式打包生成的目录是不太一致的。于是又尝试了一下mvn install，mvn clean等等命令，都不行。</p><p>但在中途也学到了一手：<strong>给mvn的命令增加一个-e参数，可以显示详细的错误信息</strong>：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_4.png" alt="img"></p><p>比如这里的错误信息是can’t not delete，那是因为我打开了几个cmd，然后文件正在使用，无法进行mvn clean，把cmd窗口关闭了之后重新clean就可以了。</p><p>之后添加了一个叫maven-shade-plugin的插件，还是不行（为什么要添加这些额外的插件，还是有思考的，基本就是要把MainClass的路径也写进入，一并打包）</p><p>这时候感觉maven的plugins操作还是不太好用，直接用mvn install -e查看为什么出错，发现是：</p><p><strong><em>Caused by: org.codehaus.plexus.component.configurator.ComponentConfigurationException: Cannot find ‘resource’ in class org.apache.maven.plugins.shade.resource.ManifestResourceTransformer</em></strong></p><p>完全没有头绪，但在网上有一个很好的帖子：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_5.png" alt="img"></p><p>简单概括就是：<strong>SpringBoot本身是存在一个打包插件，而这个另外加的shade反而形成了冲突。</strong>那么就好办了，把SpringBoot的打包插件去掉？一看，pom.xml并没有该插件，但该service是依赖了provider service的，看了一下provider service的pom.xml，确实存在这个插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>于是想着那就删掉这个！但结果还是不行？可能是别的地方还存在这个插件的导入？毕竟我在最初对maven的版本管理是很混乱的。但我确实暂时不想深究这个问题，直接换了另一种做法：那就不用这个shade插件了，直接使用springboot自带的打包插件。然后给当前pom.xml加上了上述插件（看来依赖是不会继承plugins的），这时候<code>mvn clean &amp;&amp; mvn install</code>，成功，如图：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_6.png" alt="img"></p><p>PS：此时我并没有立刻启动Eureka Server节点，而是查看了一下MANIFEST.MF文件，发现确实增加了大概的“主清单属性”，如图：（之前是没有Spring-Boot-Classes等等属性的）</p><p>PPPS：对了，vs code打开了MF文件之后就死机了。。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Manifest-Version:</span> <span class="number">1.0</span></span><br><span class="line"><span class="attr">Created-By:</span> <span class="string">Maven</span> <span class="string">Archiver</span> <span class="number">3.4</span><span class="number">.0</span></span><br><span class="line"><span class="attr">Build-Jdk-Spec:</span> <span class="number">12</span></span><br><span class="line"><span class="attr">Implementation-Title:</span> <span class="string">microservice-eureka</span></span><br><span class="line"><span class="attr">Implementation-Version:</span> <span class="number">1.0</span><span class="string">-SNAPSHOT</span></span><br><span class="line"><span class="attr">Main-Class:</span> <span class="string">org.springframework.boot.loader.JarLauncher</span></span><br><span class="line"><span class="attr">Start-Class:</span> <span class="string">basic.EurekaApplication</span></span><br><span class="line"><span class="attr">Spring-Boot-Version:</span> <span class="number">2.2</span><span class="number">.1</span><span class="string">.RELEASE</span></span><br><span class="line"><span class="attr">Spring-Boot-Classes:</span> <span class="string">BOOT-INF/classes/</span></span><br><span class="line"><span class="attr">Spring-Boot-Lib:</span> <span class="string">BOOT-INF/lib/</span></span><br></pre></td></tr></table></figure><p>这时候已经猜到成功了，然后按照很前面的命令启动了两个Eureka Server节点，确实如此：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_7.png" alt="img"></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_8.png" alt="img"></p><p>peer1看起来一开始报错，但其实很正常，因为peer2还没开始运行，后面peer2运行起来之后，二者就成功互相复制了。效果如图：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_9.png" alt="img"></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/sb_10.png" alt="img"></p><p>虽然启动成功了，似乎也成功复制了，但与预期有一点不同（peer1复制了peer2，但peer2没有复制peer1，仍然复制的peer2，配置文件似乎没有写错）</p><p><strong><em>DS Replicas</em></strong>有点奇怪，但<strong>*Instances currently8</strong>确实都是二者成功复制了。</p><p>有说法是。DS Replicas是指从哪里同步数据，测试先启动peer2，再启动peer1会不会发生改变。（这也是我的个人想法，所以按理说，peer2处的DS Replicas应该是peer1才对）</p><p>可是较换peer1跟peer2的启动顺序，Instances currently依然是复制了，但DS Replicas依然二者都是peer2，所以与启动顺序无关。(可能是根据yml的顺序来决定，后面的就是最后的DS，毕竟这两个peer其实都指向同一个IP）。<strong>可能是peer1和peer2的复制顺序真的不是简单的顺序复制吧</strong>，网上说如果真的是那样，那就变回了中心化组件，跟微服务架构背道而驰。</p><h3 id="六-给Eureka-Serer增加一个认证"><a href="#六-给Eureka-Serer增加一个认证" class="headerlink" title="六. 给Eureka Serer增加一个认证"></a>六. 给Eureka Serer增加一个认证</h3><p>首先添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实只要添加了这个依赖，那么此项目在运行时就需要登录。（如果是Server，那么登录Server控制台需要登录，其他服务想注册到此Server也要登录。如果是Service，那么使用Service的时候也要登录）如果不在yml里配置用户名跟密码，默认用户名就是user，密码会在运行时随机生成，打印在控制台。</p><p>然后一开始在yml的配置里出现了问题，其实不用查也可以猜到，是版本的原因，2.x换成下面的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line"><span class="attr">user:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">user</span><span class="comment"># Default user name.</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">aaa</span><span class="comment"># Password for the default user name.</span></span><br><span class="line"><span class="attr">roles:</span> <span class="string">xxx</span><span class="comment"># Granted roles for the default user name.</span></span><br></pre></td></tr></table></figure><p>所以最后的yml配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-discovery-eureka-ha</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line"><span class="attr">user:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">hong</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">kk111</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">serviceUrl:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8761</span></span><br></pre></td></tr></table></figure><p>值得注意的是，前面是否需要加 xx:yy@localhost:8761/eureka/ ，好像加不加都无所谓。。</p><p>然后一开始遇到了奇怪的错误，最后把密码删掉了也不行。最后翻GitHub以前的记录，才发现，我连两个false还有port都没有配置，所以最基本的配置一定要记忆清楚。。</p><p>接下来是要将服务注册到需要认证的Eureka Server。一开始遭遇到了问题：<strong><em>com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server</em></strong></p><p>很显然，就是说不能注册到任何已知的服务器。网上搜到的答案都是针对Eureka Server本身不需要注册（最开始那两个false参数），但显然这里我的错误就是service无法通过Eureka Server的认证。</p><p>尝试了几次都不行，最后通过“内华达穷举法”，才发现问题是<strong>CSRF</strong>。只要把CSRF禁用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable();</span><br><span class="line">        <span class="keyword">super</span>.configure(http);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于到底是在yml里设置security参数，然后在defaultZone里增加${…}:${…}@local…，还是直接注入一个<strong><em>DiscoveryClientOptionalArgs的Bean</em></strong>，都可以达到认证的效果，如下：</p><p><strong><em>方法①：</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.netflix.discovery.DiscoveryClient.DiscoveryClientOptionalArgs;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DiscoveryClientOptionalArgs <span class="title">discoveryClientOptionalArgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DiscoveryClientOptionalArgs discoveryClientOptionalArgs = </span><br><span class="line">        <span class="keyword">new</span> DiscoveryClientOptionalArgs();</span><br><span class="line">    List&lt;ClientFilter&gt; additionalFilters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    additionalFilters.add(<span class="keyword">new</span> HTTPBasicAuthFilter(<span class="string">"hong"</span>, <span class="string">"kk111"</span>));</span><br><span class="line">    discoveryClientOptionalArgs.setAdditionalFilters(additionalFilters);</span><br><span class="line">    <span class="keyword">return</span> discoveryClientOptionalArgs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>方法②：</em></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">microservice-simple-provider-user</span></span><br><span class="line"><span class="attr">jpa:</span></span><br><span class="line"><span class="attr">generate-ddl:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">hibernate:</span></span><br><span class="line"><span class="attr">ddl-auto:</span> <span class="string">none</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">platform:</span> <span class="string">h2</span></span><br><span class="line"><span class="attr">schema:</span> <span class="string">classpath:schema.sql</span></span><br><span class="line"><span class="attr">data:</span> <span class="string">classpath:data.sql</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line"><span class="attr">user:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">hong</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">kk111</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">serviceUrl:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">$&#123;xxx.name&#125;:$&#123;xxx.password&#125;@localhost:8761/eureka/</span> </span><br><span class="line"><span class="comment"># xxx是 spring.security.user</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>二者无论是单独使用，还是一起使用，都可以达到认证的效果。</p><h3 id="七-关于Eureka的元数据metadata"><a href="#七-关于Eureka的元数据metadata" class="headerlink" title="七. 关于Eureka的元数据metadata"></a>七. 关于Eureka的元数据metadata</h3><p>metadata包括标准元数据（自带的，可在服务之间传递信息），还有自定义元数据（一般不会改变客户端的行为，相当于参数传递，给一个参考值）</p><p>其实这部分的工作并不多，但主要是让我意识到了，版本控制真的不容易，即便是引入了Maven。之前我在主项目里没有引入spring-boot，然后在provider跟Eureka中都分别引入了。其实没有必要，在主项目引入，然后provider就不必引入了，即使引入了也会被视为duplicate。</p><p>同时我需要解决@RestController返回的是XML而不是JSON的问题，发现问题是因为Eureka-Server引入了<strong><em>Jackson-dataformat-xml</em></strong>这个包，所以自然地去<strong><em>exclude</em></strong>掉就好（需要在maven里慢慢找这个包到底从属于哪个包，当然如果记忆好的话，确实是引入Eureka之后才出现这个问题，自然也就是在Eureka-Server的包里了）</p><p>然后发现Provider跟Consumer的返回类型都正常了，但Eureka下的apps（测试自定义metadata的入口）依然是XML类型。一看发现项目仍然存在Jackson-dataformat-xml，应该是Eureka Server也自己引入了spring-cloud-eureka-server的原因，所以我把它去掉了（想着这样直接获取主项目的就好），但这时项目却无法运行了。原因是找不到Jackson-dataformat-xml，猜测是因为Eureka  Server没有导入这个包了，于是主项目的exclude就出现了问题（现在回想这个逻辑是不对的，为什么?)。但并不是，把exclude删掉了也不行。才发现哪个找不到Jackson-dataformat-xml，是指项目需要这个，但却不存在。所以说，其实项目还是需要这个包的，尤其是在使用metadata的时候？于是我把这个给彻底去掉了，这样就不可运行了。所以只好主项目依旧exclude，Eureka Server依然导入spring-cloud-eureka-server，但不exclude（此时子项目跟父项目存在不同，当然就以子项目的来覆盖）</p><p>所以最后provider等服务是返回JSON了，但apps却仍然是XML。不过想想，毕竟我对apps还不太了解，也不是我自己手动写的@RestController，所以返回XML其实也无可厚非。</p><p>PS：最后有一个点，Consumer注入了Provider的依赖，这两个之间是不能同时注入同一个Bean的（会冲突），而且其实只要Provider存在这个依赖，那么Consumer也就存在。所以Consumer没有注入注册Bean，也没有在yml里编写认证用户密码，同样是可以注册到Eureka的。相反，在Provider已经写了认证机制，在Consumer再写一遍，会使得Consumer无法认证，无法注册到Eureka。</p><p>Eureka部分到此结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;​        Spring已经渐渐地成为了Java程序员的必备技能，尤其是Java Web方向。同时，Spring也一直在发展，由于Spring存在配置臃肿的问题，所以就出现了Spring Boot框架，用于简化新Spring应用的初始搭建以及开发过程。近年来微服务架构也越来越火，所以在Spring Boot的基础上又出现了Spring Cloud。如果你是常年使用Spring的Java Web程序员，那么Spring Boot跟Spring Cloud很值得一学。&lt;/p&gt;
&lt;p&gt;​        本系列文章并非是完整的教程，我阅读的是&lt;strong&gt;&lt;em&gt;”&lt;a href=&quot;http://www.ityouknow.com/spring-cloud.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;纯洁的微笑&lt;/a&gt;“的博客&lt;/em&gt;&lt;/strong&gt;：。以及书籍&lt;strong&gt;&lt;em&gt;《Spring Cloud与Docker微服务架构实战》by周立&lt;/em&gt;&lt;/strong&gt;。相信每一位学习编程的朋友都遇到过一个问题，跟着书上/教程上一步一步走，结果却不一样。有的时候是版本的问题，有的时候是自己的操作出现纰漏，也可能是教程本身也存在纰漏。无论如何，学习是一个挖坑再填坑的过程，在这个过程中我们的技术也会快速提高。所以这篇文章就是记录我在学习Spring Cloud过程中所遇到的问题，以及如何解决（虽然也有构建步骤，但目前写得比较简单，建议结合上面推荐的博客，书籍使用）。如果有朋友也遇到了类似的问题，可以参考一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="https://hongscar.cn/tags/Spring-Cloud/"/>
    
      <category term="Spring Boot" scheme="https://hongscar.cn/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>大学流水账</title>
    <link href="https://hongscar.cn/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E6%80%BB%E7%BB%93.html"/>
    <id>https://hongscar.cn/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E6%80%BB%E7%BB%93.html</id>
    <published>2020-02-17T22:57:36.000Z</published>
    <updated>2020-02-19T03:56:53.990Z</updated>
    
    <content type="html"><![CDATA[<p>​     时光荏苒，大学毕业的瞬间，给我的感觉便只有四个字，恍如隔世。毕业已经有一段时间，其实答辩结束的时候就已经可以开始写这篇总结，但还是各种因素，迟迟未能动手，最终还是拖到了今天。无论如何，习惯总结的我，对于大学毕业这么一个里程碑，肯定是不能错过的。而且自己的大学，真的有太多的话想说，这篇总结会好好地回顾了我四年的大学生活，自我评价，当然还有未来的展望。</p><a id="more"></a><p>​     我很想把大学，再一次地拿去和高中比较一番，因为高中给我留下了很多深刻的经历，而大学也一样，这两段经历又给了我截然不同的感受。高中时代的很多记忆碎片我大抵都还记得，只是没有必要在这里仔细述说。印象中高中三年的我，基本就是一直坐在课室，坚持走着课室饭堂宿舍的三点一线，偶尔参加一些小活动而已。当时的我大概是自然而然的，而高中毕业之后才发现那个能一直专注的愣头青般的我已经渐渐远去。当时的自己也没有太多的迷茫，大概只有对大学的憧憬，因此即使高中有很多遗憾，我还是很快就投入到大学生活中去。到了大学，再也没有人管，感觉自己一下子变得很自由。即便是上课，也不是固定的课室固定的座位，衣服也不必再穿校服。突然想到了大一最开始的时候，觉得一切都是那么的不可思议，甚至在有一次去课室的途中，心中感慨了一句，大学真的自由，自由真好啊！可惜这个自由的生活，我还是没有适应好。我大部分的时候还是宅在了宿舍，并且在宿舍也没有进行有效的学习。制定过不少的计划，基本都是开头坚持了几天就结束。这真的导致了我整个大学过得是很失败的。如果可以重来，那该多好呢？可惜，一切都没有重来。</p><p>​     大一的我还处于懵懂状态，上学期还保留有挺大的学习热情，只是制定了不少的学习计划却没有好好执行。大一没有什么专业课，只有一门C++。老师确实讲得很烂，但自己也努力得不够。还记得大一的寒假，我在家还在努力地学习C++，如果当时都再坚持一下就好了。大一下学期基本就是萎靡的一个学期，基本整个学期都在玩LOL。上学期积累下来的C++基础，优势也不复存在。下学期各种重要的知识，诸如继承，多态等等的东西，都没有学会，这也为后续放弃C++埋下了伏笔。还记得刚入学的时候还想过要转专业，最后也是在怠惰中放弃。倒不是说转专业是好是坏，但这肯定是一次奋斗的经历，就这么失去了其实也是有点可惜的。总的来说，大一就是迷糊，课程就是按部就班地完成，课余也尝试听了一些讲座，编程比赛的总结会等等。还记得那时候也有过豪言壮志，大学一定要参加一次比赛，不然大学不就浪费了么！回首，只剩下唏嘘。都说大一应该好好放松，不要太着急，其实这才是最大的骗局吧，有多少人就这么一直放松到毕业呢？还记得大一上学期，我就一直觉得自己太懒了，也不好好学习，心理上也一直强制自己去学习。所以也有过让自己早起去湖边读英语的经历，这也让我的四级考了很高的分数。只是这种那种的热情，在后面也慢慢地消散罢了。</p><p>​     大二，课程比较繁多。大二确实是很累的一年，因为要接触到很多的专业课，而且大都很重要。然而我基本也就是按部就班地完成了专业课的学习，并没有深入理解。考试成绩还挺好的，不仅没有挂科，而且大部分都是85分以上，我也是从那时候开始觉得自己比较适合考试的。其实大二的时候，相比大一的懵懂，自己也开始想得更多的事情。比如，我开始接触手机软件编程，又或者是web编程。大一的时候基本就是在玩，并且顺便学了一下c++，但大二的时候就开始觉得自己要接触一些实用性的东西，比如切实地投入到有意义的开发当中（手机/网页端的开发）。然后同样也是半途而废吧，没有坚持到最后。当时自我的批判是，看完了书，却没有自己切实地实践一下。比如我看完了一整本web开发的书籍，我应该跟着书上的例子来写一遍的，但我并没有，这使得我在后续再接触web的时候，跟没有学过web是没有太大区别的。如果是用高中的东西来类比，大概就是，看完了一章数学，却一道题也没有做，没有及时巩固？其实大二这一年，自己学习的时间是多了的，玩游戏的时间也少了。也可能是内容太多了，然后自己没有选择一个方面认真钻研，这也是导致失败的原因之一。比如数据结构大作业，一开始我想做一个爬虫软件，然后学习了一下爬虫，同样地也只是但当涉猎，没有深入。后来做一个管理系统，又想学qt，中途觉得困难又去研究了一下mfc，结果也是都没有好好掌握。操作系统和编译原理那种课程我倒是连想法都没有，可能是太难，因而都是做完作业便了事。下学期的专业课就更多了，而且甚至每一门都有实验课，导致印象中，3月开学，从4月开始便是每周至少3天要在实验室。大二下学期我也挺认真学的，数据库，离散数学，算法，UML我都有认真去学，不过同样地也只是完成课业的程度。比如数据库，当时仅仅是完成了老师给的实验，用sql server来进行数据的插删改查，然后就没有继续下去，也就是没有巩固。当时大概应该至少的，将自己大一的C++的大作业进行改进，比如数据从本地存储，改为数据库存储。这样在后续的数据库操作中印象都会更加深刻。同时还有很多种数据库也值得去深入学习，比如mysql，redis，MongoDB等等。大三的时候，有一次中学同学来学校找我聊天，说到他最近的一个项目用了三种数据库，因为他觉得这样可以分别利用不用数据库的优点，但面试官认为这样会使得程序太过臃肿。当时我比较感慨的一点就是，数据库对于计算机软件的必不可缺的，然而当时的我只掌握了mysql（sql server已经被我搁置了）。就觉得自己很多东西都学了，却没学精，然后该学的也没有学，大概是我自己也没有静下来想自己应该学哪些东西？或者是哪些东西重要性很高，最好就应该去学？同样的，算法也只是看懂了考试题，也没有说去OJ刷题，也没有想过在自己写的程序里用算法优化。还有OS，一直说要学习一下linux，同样也只是完成了实验课便结束了。总而言之，大二下学期就这么按部就班地过去了，不能说没有认真学习，每门专业课都能达到学校的要求（不仅仅是及格），但就是没有进一步的自我思考自我反馈。而且看到成绩挺好的时候还会有膨胀感，自己对大学考试的套路模式也渐渐了如指掌，考试真的就是填表放假般的轻松了，但这种膨胀感显然没有让我感觉到危机感。不过，大二下的自己还遇到了其他的问题，所以当时能坚持下来已经算是不错的结果。大二的自己感觉学了挺多东西，打算暑假巩固一波，也就是切实地去写点手机软件，网页等。然后被家里赶去学车了，整个暑假基本也就在驾校渡过，因此大二就这么结束了。</p><p>​     大三，其实是最难过的一年。刚开学就说要分方向，然而自己前面埋下的隐患，自己对所有专业课都只是能够考好试的水平，然后自己课外学习的东西也没有学得比较好。反复再三，就报了数字媒体和手机开发。数字媒体是自己直觉上应该是最感兴趣的方向，而手机开发和数字媒体是互相选择的，因此就选了两个方向。然而第一节课就让我产生了挫败感，老师第一节课讲的内容我就完全听不懂，讲了一堆什么小波分析，傅立叶变换。而且其实事先就知道数媒是最难的方向之一，当时跟室友都在犹豫要不要放弃换方向，但最后还是没有换。然后就开始了一个学期的数媒煎熬时期。我现在还清楚地记得，数媒一共两门课，一门就叫数字媒体，一门叫计算机图形学。计算机图形学要求一个大作业，而数媒要求4个大作业。而且事后我觉得，每一个数媒大作业的难度都比图形学的要难。也不知道是不是老师的问题，还是这个方向的确要学的东西太多太难。第一个大作业，我和两个同学钻研了两个星期，竟然连其中的一个功能都实现不出来。我还记得要求是做一个图形处理软件，可以选择一个图片，然后点按钮就可以进行相应的图片操作，比如旋转，放大缩小，降噪等等。反正有很多功能，底层都是对图片的像素点，通过算法进行处理。总而言之，我们三个人从头到尾就一直卡在了旋转这一部分。后来，后面的一些功能倒是可以实现出来，只是实现的方式有点stupid，但旋转最终实现的效果还是不尽人意。更恐怖的是，第一个大作业还没完成，第二个大作业就来了。第二个大作业好像是研究GPU对图形处理的效率等等，然后学习什么CUDA。然后当时我们三个稍微了解了一下，就回去继续做第一个大作业。当时其实已经都第二个大作业了，但看到同学，见面还是调侃，“你今天旋转了吗？”。之后，第二个大作业没过两个星期，老师就布置下来第三个大作业，自己制作一个视频，情节场景等都是自己设计。这个制作视频并不是所谓的用手机拍下来然后对视频处理，而是完完全全地用代码来生成。首先就是用软件建模，构建出各种的物体，人物，设置场景，每个动作设定等等，然后再连接起来等等。这个的难度当时在我看来就比前两个大作业都要难得多了，横向对比一下图形学的大作业，图形学的大作业是要求建模，构建物体，然后构建场景，将物体布置在场景中，然后调整比例等等。构建物体当中还有很多细节我也忘记了，反正就是什么色彩，光照，渲染，设置光源等。最终的成果就是一个多彩的场景。这个其实工作量已经不多不少，而制作一个视频相当于就是制作一个场景的数十倍吧，而这仅仅是数媒的四个大作业之一。然后也就稍微学了一下unity3D和3ds，但想想那个工作量，还是望而却步。这个时候时间大概来到了11月，我觉得一整个学期都只学数媒，大概也是很累人的吧。然而大三还是有别的课程需要去搞的，软件架构，项目管理，安卓，ios开发，每一个都需要大作业。现在回想当时是真的煎熬，到底是如何熬过来的。图形学大作业也是teamwork，不过全部都是我一个人做的便是。临近寒假，数媒的第四个大作业也分发下来，看来是要我们寒假的时候好好把四个大作业都做了。第四个是将传感器连接到软件中，当时好像是用leapmotion。大致就是要我们开发一个游戏，可以用外接传感器来操控的。寒假的时候真的很短，反正转眼就开学，四个倒是都做完了，不过质量感人，我甚至答辩都不敢去了。我跟室友说，我不去了，挂科就挂科，这学期也不学数媒这个方向了，再也不想接触数媒老师。不过最后还是没有挂科，甚至不是最后一名。至此数媒噩梦到此结束，然后新的噩梦又到来，那便是找实习。找实习其实有一个很麻烦的点就是，我刚刚放弃了数媒，却又要找实习，那么数媒的影响到底有多大呢？大二上学期的时候学了java，当时就开始放弃了c++，决定将java当作主语言。而数媒是要用c/c++/c#这种语言的，然后大三上的时候基本都是在写c++，但现在找实习，又不是找数媒相关的，c++又难。于是我便又要重新把java捡了回来，并且是搁置了半年的情况下。大三上的课程对于找实习的重要性实在太高，选了web方向的同学，对于java web的知识又了解，大作业中又有锻炼，而我这种重新来的，甚至需要复习一遍java，然后再重学web，然后学各种诸如ssh的框架等。错过了最佳的找实习时间段，然后就要兼顾学校的课程压力。最终搞完一个麻烦的手机开发实训便结束了大三。</p><p>​     大四，大学的最后一年。找实习找得太久，当中也想过很多事情。我也是事后才发现，自己整个大学一直就在错过。大一其实是最该好好放松的一年，同时也应该大一就大致想一下整个大学的路。结果我大一只有无所事事的上学期还有沉迷游戏的下学期。大二其实应该要具体地掌握些什么，事实上我也开始学了，然而并没有深入，使得大二真的只能用按部就班来形容。大三分方向，真的应该提前就了解好，如果我提前了解多一点数媒，读一下数媒的课本，知道他真的这么难，也许我就换了一个更值得的方向，大三下找实习的时候也就不至于因为掌握得不够好而没有找到好实习。因为学的方面挺多，却没有学精，唯一一个花了很久时间钻研的方向，最终还是不敢继续下去而放弃。大三刚开始的时候，我还有很多突然心血来潮般的想法。比如如果当初没有学软件就好了，还不如直接选个数学靠谱（因为自己大二对离散数学也很喜欢）。比如大学还是应该多学点东西啊，比如考点什么证，结果自己还是只稍微涉猎。又比如突然觉得出国真的很好啊，如果早一点想到这些，大一的时候就更努力一点去提一下绩点了。感觉自己整个大学，没有很好的规划。最终还是找到了一个不错的实习，虽然并没有学到太多东西，但也是第一次社会经历。也是因为没学到太多东西，感觉自己的大学太遗憾了，于是希望毕设能改变自己，学到东西，然后选择了区块链为题目。我也不可以说没学到东西，只是这东西真的挺烦人的，使得我毕设虽然没太多体力活，但还是耗到了最后一刻。中间也想过很多事情，最终决定了考研，于是也就安心地放下了找工作的念头，然后准备毕设的事情。毕设结束前夕，一直在为毕设而烦恼。然而毕设结束的那一刻，每个人都会有一个念头，“啊，这样就毕业了吗？”是的，毕设这门大学最后一课，就这么结束了。答辩完的那天是6月8号，正好是高考的最后一天。我还记得那天早上早早地就出发，一路上狂风暴雨，去到课室的时候，裤子都快要湿到膝盖那里了，更不用说鞋子。那几天刮台风，似乎从小到大，我从来没有见过这么大的台风。答辩完的时候已经是下午2点，我原本想回宿舍睡觉，但发现并不能睡着，结果只是在床上小憩了10来分钟便下床。我走到阳台看着外面的狂风暴雨，心境在渐渐地变化。我很想回家，但又不想回家。答辩完到离校的这段日子，是我在学校里最无所事事的一段时光。我每天习惯地打开电脑，但发现什么都不想做，只是看一下论坛，看一下直播，等待吃饭的时间，和交心的朋友一起去饭堂吃饭。大学毕业的伤感远远超出我的想象，那是高中的时候完全无法体会到的情绪。我很喜欢在微博上发一些感慨，并不是想给谁看，我只想给我自己看。离别的日子匆匆而来，然而校园里依旧那么宁静。在华工的最后一个晚上，我们宿舍三个人都不约而同地失眠。第二天似乎还是和往常一样，看直播，吃饭，只是下午多了个拿毕业证的事情。然后我们就各奔东西，有人没有感觉，有人悲痛欲绝，有人还在等待释怀，但我们都不能回头。我走的时候宿舍只剩下一个人了，室友说要送我到楼下，我说不用了。他静静地站在门口看着我离开，而我不敢回头，就这么离开。最后跟我大学最重要的朋友在地铁里分别，带着信物，我终究还是回到了家，于是，大四也就这么结束了。</p><p>​     四年的大学生活转瞬即逝，回顾了一整遍，感觉也没有想象中的混，但最终的结果自己肯定是不太满意。比如从大一的时候没有制定好整个大学的基本规划，对于考研出国考公务员等事情，我都是后知后觉，没有事先考虑好，以至于错过了最好的时机。对于学习，也没有很好的规划，没有确定好自己的方向，导致大学似乎学了很多，但又没有深入，然后又好像什么都没有学过。对于做人，我曾经试过无数次想要改变自己的性格，比如内向型人格的我，总是被教导要开朗外向一点，而我也想过很多次要变得开朗，但最后我才发现，做我自己就好，没必要为了谁而改变什么。其实我在大学里，真的变了很多，至少我自己是这么觉得的。我觉得我的大学，似乎也没有那么的不堪，继续向前就好。</p><p>​     当然，大学里也养成了很多坏习惯，比如拖延症，作息不规律，做事拖拉，不能坚持等，希望早点成为更好的自己吧。这就是我的大学。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​     时光荏苒，大学毕业的瞬间，给我的感觉便只有四个字，恍如隔世。毕业已经有一段时间，其实答辩结束的时候就已经可以开始写这篇总结，但还是各种因素，迟迟未能动手，最终还是拖到了今天。无论如何，习惯总结的我，对于大学毕业这么一个里程碑，肯定是不能错过的。而且自己的大学，真的有太多的话想说，这篇总结会好好地回顾了我四年的大学生活，自我评价，当然还有未来的展望。&lt;/p&gt;
    
    </summary>
    
    
      <category term="life" scheme="https://hongscar.cn/categories/life/"/>
    
    
      <category term="life" scheme="https://hongscar.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>验证docker的例子</title>
    <link href="https://hongscar.cn/%E9%AA%8C%E8%AF%81docker%E7%9A%84%E4%BE%8B%E5%AD%90.html"/>
    <id>https://hongscar.cn/%E9%AA%8C%E8%AF%81docker%E7%9A%84%E4%BE%8B%E5%AD%90.html</id>
    <published>2020-02-17T15:50:35.000Z</published>
    <updated>2020-02-17T15:01:46.559Z</updated>
    
    <content type="html"><![CDATA[<p>根据前面的docker知识点，可以使用这些知识点，结合例子来实际操作一遍。</p><p>其实最开始看阮一峰大佬博客的时候，就已经遇到了一个问题：需要用浏览器访问。而我之前一直都直接在命令行里操作，一时间不知道该怎么办。当然了，没有浏览器就真的不行吗，也许不是，根据网上的说法，直接使用curl命令也可以，只是没那么方便，于是还是先下定决心要搞一个可视化界面。这里用到的是VNC。</p><a id="more"></a><p>关于VNC的环境配置，其实也遇到了很多问题，但当时忘记总结了，现在回过头来发现当时的浏览器记录没了（不要问我为什么浏览器记录会没了= =），只能凭印象地稍微说几句。一开始想着直接给服务器安装GNOME桌面，设置了优先使用桌面启动而非控制台，然而一点用处也没有。于是我又回归到VNC上，VNC其实也有很多种，但似乎不同版本之间都是可通的。这里值得一提的是，VNC也是简单的C-S架构，所以我们不能仅仅在本地安装了VNC-Client，就觉得可以连上了，更关键的还要在服务端也安装一个VNC-Server。当时随便找了一个TigerVNC，在CentOS上直接用yum install就可以安装的，建议先用<code>yum list | grep tigervnc</code>，然后把tigervnc跟tigervnc-server都安装了就好。</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_1.png" alt="img"></p><p>第一次启动vncserver的时候，会让我们设置client登录到server需要的密码，需要输入两次，密码不会显示出来，都是常见的情况。然后是最关键的一步，需要指定端口。tigervnc-server默认开启的是5901端口，可以用netsta -tlnp查看是否存在该端口。这时候我在vncviewer（client）仍然无法ping通，一直显示time-out，其实就是没有连接到。找了很多方法都不行，后来突然想到了之前配置redis的时候也是如此，防火墙，配置文件全都到位了，就是不行，结果直接去腾讯云服务器上的端口管理设置了一下就可以了。于是我也就过去尝试地添加了一个5901端口，竟然就连通了，吃惊，如下：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_2.png" alt="img"></p><p>连接上了之后就好办了许多，看阮一峰大佬的例子也一直水到渠成，包括他使用docker安装WordPress的例子，看评论里还有部分朋友是前两个方法无法ping通，而我成功三个方法都完美无差错，感觉还是可以的。于是VNC的部分到此结束。</p><p>可是仅仅靠一个博客的例子也太简单了，于是继续按照书上的例子来加深印象。书上用的是nginx的例子，各种参数我大概都理解是什么意思，–volume其实就是-v，-p是端口映射等等的。然后就遇到了一个老生常谈的问题，在映射目录下加了一个html文件，确实可以访问，可是出现了中文乱码。中文乱码真的是经典问题，那么接下来就来具体诉说如何解决这个中文乱码的问题。（题外话，如果前面偷懒直接用curl而不用vnc，就会忽略掉中文乱码这个错误）</p><p>以往解决中文乱码，很简单，修改配置文件，mysql等数据库就是这样处理的。那么，我们现在的本机（其实就是localhost，有一些翻译成宿主机），完全就没有安装nginx，全靠一个仓库提供的nginx image，然后在docker里运行，那么哪里找到配置文件呢？</p><p>我主要参考的是这篇文章：<a href="https://blog.csdn.net/wangfei0904306/article/details/77623400" target="_blank" rel="noopener">https://blog.csdn.net/wangfei0904306/article/details/77623400</a></p><p>很显然， 主要用到的就是-v参数，第一个是映射到nginx的默认目录，使得当前的html页面就可以直接被nginx访问到。第二个是把主配置文件nginx.conf映射过去，第三个是子配置文件目录conf.d。我还是先把话说在前面了，这段代码是有问题的，不然也没必要特意开一篇文章：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_3.png" alt="img"></p><p>然后另一个问题又来了，那位博主是在宿主机也安装了nginx，所以他能直接拿现成的nginx.conf，conf.d来用，可我并没有。我可选的操作有：①直接上网，比如把博主的这两个配置文件下过来。②那就安装一次nginx。③把nginx image里的配置文件拿出来，然后改造。显然，前两种虽然也能解决问题，但有点蠢，显然不是最优解，第三种方法才是最合适的。用到的命令也很简单，首先启动container，然后进入container：（参数似乎不能乱）</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_4.png" alt="img"></p><p>然后就是复制文件的命令docker cp：（当时学的时候没看得是什么用处，现在彻底懂了）</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_5.png" alt="img"></p><p>于是成功把配置文件都拿出来了，然后呢？按照代码运行，出错，预期之内。下面是排错过程：</p><p>①把后面两个-v都去掉，看能否运行。结果是可以的，说明，错误确实就在后面两个-v的映射过程。</p><p>②加上后面的参数，又报错。这里值得一提的是，启动一般不会有报错信息，除非你把image名写错了，那么如何查看容器是否启动出错了？docker container ls -all。这可以列出所有的container，包括隐藏的container。而且有一项关键的属性是，status，可以根据该属性的值判断是否启动成功。当status为UP，说明容器启动成功。如果status是exited，说明启动了一下就退出，那自然就是出错了。还有一种情况，status是created，这也被我遇到了，直觉地想就是一直卡在了创建阶段，自然也是出错的时候。</p><p>③把所有的容器都关闭了，并且也删除了，再访问该IP地址（在这之前都是通过浏览器访问的），竟然还可行？这一点有点匪夷所思，因为container确实已经关闭了，甚至都已经删掉了，可在VNC的browser上却可以访问。一开始以为是缓存的问题，后来换成无痕浏览也有这个问题（换成无痕浏览倒是减少了这个情况）。这其实让我很无语，所以浏览器也不是万能的，它不仅卡，还可能本身就有问题！那么此时应该怎么办？curl。</p><p>④接下来就是具体地看代码哪里出错的地方了。首先有一个有趣的地方，目录映射是通过一个冒号完成的。然后冒号前后似乎不能加空格，加了会报错。（虽然直觉上不会，但我测试的时候，只有第一个-v，是应该可以正常运行的，可有空格就会报错，没有就不会报错，也许还有其他干扰我没注意到，但我懒得继续测试了）第二个错误的点，幸好我当时选择的是第三种解决方法，所以我刚刚进入了容器内部，查看了文件目录结构，我发现它的目录是 /etc/nginx/nginx.conf，而非/etc/nginx/nginx.conf:ro，这可能是版本的原因，也许以后还会变，但只要知道如何操作就行。同时由于我懒，我用的是参数”$PWD/…”，所以记得一定要在正确的目录调用该命令。不然后面就遇到了这种错误，我进入了conf.d目录，修改了配置文件，然后直接就在那里启动命令，PWD是错的，那么命令自然也会错了，最终的命令如下：（还是顺便提一下吧，”&quot;真的就是最简单的换行符而已，所以如果你喜欢，你可以全部写在一起，都是可行的，只是可读性不高）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker run \</span><br><span class="line"></span><br><span class="line"> --name myNginx \</span><br><span class="line"></span><br><span class="line"> -d -p 96:80 \</span><br><span class="line"></span><br><span class="line"> -v <span class="string">"<span class="variable">$PWD</span>/"</span>:/usr/share/nginx/html \</span><br><span class="line"></span><br><span class="line"> -v <span class="string">"<span class="variable">$PWD</span>/nginx.conf"</span>:/etc/nginx/nginx.conf \</span><br><span class="line"></span><br><span class="line"> -v <span class="string">"<span class="variable">$PWD</span>/conf.d/"</span>:/etc/nginx/conf.d  \</span><br><span class="line"></span><br><span class="line">nginx:my</span><br></pre></td></tr></table></figure><p>⑤这时候可以成功启动，通过docker container ls -all就可以看到status是UP。可是，还是乱码。关于配置文件的修改，我是在default.bak里增加了一行 charset: utf-8。结果，原来最后的原因就是错误三。我把整个容器重新关了删了再启动，然后无痕浏览，总算没有乱码了。至此，解决Docker中的nginx中文乱码问题到此解决。</p><p>⑥PS：中间还遇到一些非常weird的错误，比如WARNING: IPv4 forwarding is disabled. Networking will not work.原因可能是前面操作docker不当，导致“ default the ipv4 forwarding is not turned on in the image from docker to prevent any security vulnerabilities. ”即Docker处于安全考虑默认关闭该设置。解决方法是：<a href="https://blog.csdn.net/Kohang/article/details/85125054" target="_blank" rel="noopener">https://blog.csdn.net/Kohang/article/details/85125054</a> 好吧，实际上只要你上网搜一下上面的WARNING，你就会看到无数篇一模一样的解决方法。还好，这次是可行的答案，不然。</p><p>其实这个例子也不是简单的中文乱码问题，因为跟乱码相关的东西，其实就一行charset: utf-8。从这个例子中，学到的不仅仅是如何解决中文乱码，更多的是：如何获取container中的文件到宿主机，-v映射具体是什么，如何查看container是否正常运行等等。关于-v映射，我在修改default.conf的时候，先进行了备份：cp default.conf default.conf.bak，然后再对default.conf进行修改，如果出错了可以直接删掉，把default.conf.bak改回原名即可。最后我进入container内部查看的时候，发现对应的映射目录，存在的就是两个文件，default.conf和default.conf.bak。所谓的映射，其实就是把宿主机的文件放入容器的指定路径。</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_6.png" alt="img"></p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_7.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据前面的docker知识点，可以使用这些知识点，结合例子来实际操作一遍。&lt;/p&gt;
&lt;p&gt;其实最开始看阮一峰大佬博客的时候，就已经遇到了一个问题：需要用浏览器访问。而我之前一直都直接在命令行里操作，一时间不知道该怎么办。当然了，没有浏览器就真的不行吗，也许不是，根据网上的说法，直接使用curl命令也可以，只是没那么方便，于是还是先下定决心要搞一个可视化界面。这里用到的是VNC。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://hongscar.cn/categories/Docker/"/>
    
    
      <category term="Debug" scheme="https://hongscar.cn/tags/Debug/"/>
    
      <category term="Docker" scheme="https://hongscar.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>JSON笔记</title>
    <link href="https://hongscar.cn/JSON%E7%AC%94%E8%AE%B0.html"/>
    <id>https://hongscar.cn/JSON%E7%AC%94%E8%AE%B0.html</id>
    <published>2020-02-17T15:28:29.000Z</published>
    <updated>2020-02-17T16:01:24.280Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章是阅读《JSON必知必会》所做的笔记。虽然JSON的内容比较少，但做成记录也是极好的。</p><p>JSON是一种数据交换格式。JavaScript Object Notation</p><p>JSON独立于编程语言。</p><p>JSON需要用双引号包裹key-value。当值是字符串时，必须使用双引号。如果是<strong>数字，布尔值，数组，对象，null</strong>等其他数据类型，则不应该被双引号包裹。多个key-value之间用逗号来分割。</p> <a id="more"></a><p>可以在双引号内部使用单引号，空格等特殊字符(即英文数字以外的其他字符).但这不是一种好的选择，因为使用空格和特殊字符忽略了可移植性。</p><p>PS：JSON的key<strong>必须用双引号包裹</strong>。如果没有双引号，那这并不是一个JSON对象，而是一个JavaScript对象。而且在JavaScript中，可以使用单引号来代替双引号，但JSON必须使用双引号。</p><p>在传递数据时，需要提前告知接收方数据是什么类型，这就涉及到媒体类型。（又称，互联网媒体类型，内容类型Content-type，MIME类型）它使用”类型/子类型”这种格式来表示，比如text/html。</p><p>JSON的MIME类型是：application/json</p><p>JSON的对象数据类型可以嵌套。比如一个JSON可以作为另一个JSON的key-value</p><p>\用作转义。</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/json_1.png" alt="">          </p><p>（上面的例子： \n表示换行，而\n就是普通的字符串\n）</p><p>JSON的布尔类型只允许小写形式<strong>true或false</strong>。用1和0，TRUE,FALSE都会报错。</p><p>(PS：用1和0不是报错，但这时候变成了数字类型，而不是布尔类型。而用大写的TRUE跟FALSE，True等，则会直接报错) </p><p><strong>对于JSON的null属性，也必须是小写。（而且JSON没有undefined，那是JS的）</strong></p><p>JSON的数组类型，用[ ]包裹。数组的每一项用逗号隔开，而且，数组里可以是任意合法的JSON数据类型。比如同时具备字符串和数字。[“qqq”, 234, null, “rrr”]</p><p>但最好不要这样做，<strong>应该使得数组的每一项都是相同的数据类型</strong></p><p>（因为在大多数编程语言里，都是如此的。提高可移植性）</p><p>JSON Schema：定义JSON数据的数据要求。比如哪些字段是必填的，哪个字段有哪些要求，最大长度为多少，哪个字段必须是什么数据类型等等。</p><p>PS：JSON Schema同样需要用双引号包裹。</p><p>例子：</p><p> <img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/json_2.png" alt=""></p><p>这就是一个Schema文件。</p><p>在验证JSON的时候，JSON Schema Lint。</p><p>一方面输入JSON Schema，一方面输入JSON。</p><p>预防网络攻击：</p><p>1.JSON中存储的数组，应该放在对象中，使其成为非法的js，否则一个JSON只存储了一个数组，这时候它既是合法的JSON，也是合法的js，进行CSRF攻击则可以运行js，获取JSON里的敏感信息。CSRF，cross-site request forgery，（sea-surf）跨站请求伪造。</p><p>例子：不好的做法：(虽然最外面没加花括号，但它是合理的，这称为顶层JSON数组)</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"user"</span>: <span class="string">"bobbarker"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"phone"</span>: <span class="string">"555-555-5555"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>正确的做法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"info"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"user"</span>: <span class="string">"bobbarker"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"phone"</span>: <span class="string">"555-555-5555"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>XSS，cross-site scripting</em></strong>，跨站脚本攻击（注入攻击，通过向网站注入恶意代码来实现）</p><p>JSON是一个脚本，要代表对象再进行操作，需要将其转换成对象，并装入内存中。</p><p>在JavaScript中，使用eval( )函数可以将文本转换成对象。</p><p>当JSON被拦截并修改成恶意代码，用eval函数会直接变成调用JSON的脚本。比如JSON被修改成alert方法，eval方法本该是把JSON文本变成对象，但这里会直接调用了alert方法，即JSON如果被修改成一个脚本，eval方法就会变成执行该脚本。</p><p>正确的方法是，使用JSON.parse( )函数来替代eval。该函数仅会解析JSON，而不会执行脚本。所以如果JSON被修改成脚本，该parse就不会通过，报错并且不会执行脚本。</p><p>当用户之间的信息传递是用JSON传递的时候，必须要用eval，这个时候就可能出现，JSON里存在脚本，进行注入攻击。</p><p>可以使得信息中不能包含HTML，或者把HTML字符转码，比如把&lt;div&gt;转成&amp;lt;div&amp;gt;等</p><p>抵御注入攻击的关键：找出可能的注入点，并加入一些额外的步骤来加以防范。</p><p> JSON本身不构成什么威胁，它只是文本。</p><p><strong><em>在定位JSON安全问题的时候，应该记住以下三件事。</em></strong></p><p>①不要使用顶级数组。顶级数组是合法的Javascript脚本，它们可以用&lt;script&gt;标签链接并使用。</p><p>②对于不想公开的资源，仅允许使用HTTP POST方法请求，而不是GET方法。GET可以通过URL来请求，甚至可以放在&lt;script&gt;标签链接中。</p><p>③使用JSON.parse()来代替eval()。eval()函数会将传入的字符串编码并执行，这会使你的代码易被攻击。</p><p> 尽管Javascript的XMLHttpRequest对象看上去和XML有关，但实际上我们使用它来发起HTTP请求。在它包含XML的名字命名时，XML是在发起这类请求时最常用的数据交换格式。然而XMLHttpRequest并不仅限于使用XML，用于请求JSON是完全可以的。</p><p>从Web Api上获取JSON数据：（一个例子）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myXMLHttpRequest = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"http://api.openweathermap.org/data/2.5/weather?lat=35&amp;lon=139"</span>;</span><br><span class="line"></span><br><span class="line">myXMLHttpRequest.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myXMLHttpRequest.readyState === <span class="number">4</span> &amp;&amp; myXMLHttpRequest.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> myObject = <span class="built_in">JSON</span>.parse(myXMLHttpRequest.responseText);</span><br><span class="line">        <span class="keyword">var</span> myJSON = <span class="built_in">JSON</span>.stringify(myObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myXMLHttpRequest.open(<span class="string">"GET"</span>, url, <span class="literal">true</span>);</span><br><span class="line">myXMLHttpRequest.send();</span><br></pre></td></tr></table></figure><p>序列化：将对象转换成文本的过程。    反序列化：将文本转换成对象的过程</p><p>序列化：JSON.stringify( )                 反序列化：JSON.parse( )</p><p>浏览器一般对资源共享有限制，只允许来自同一域名的资源。</p><p>CORS，cross-origin resource sharing，跨域资源共享。</p><p>可以在响应头加上Access-Control-Allow前缀的属性，来控制，哪些HTTP方法可用，哪些域名可用等等。（在对抗CSRF时，设置只允许POST，则避免了CSRF的恶意GET方法。而且设置只允许同一域名可以获取资源，这样可以避免外部获取资源）</p><p>CORS,JSON-P</p><p> JSONP（JSON with Padding）是资料格式JSON的一种使用模式，可以让网页从别的网域索要资料。由于同源策略，一般来说位于server1.example.com的网页无法与不是server1.example.com的服务器沟通，而HTML的&lt;script&gt;元素是一个例外。利用&lt;script&gt;元素 的这个开放策略，网页可以得到从其他来源动态产生的JSON资料，而这种使用模式就是所谓的JSONP。用JSONP抓到的资料并不是JSON，而是任意的JavaScript，用JavaScript直译器执行而不是用JSON解析器解析。</p><p>JSON-P的padding（内联），就是将JavaScript加入JSON文档。如：</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getTheAnimal(</span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">"animal"</span>: <span class="string">"cat"</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>内联于JSON文档的JavaScript调用了一个函数，函数参数是JSON。函数参数提供了一个将数据传递给函数的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章是阅读《JSON必知必会》所做的笔记。虽然JSON的内容比较少，但做成记录也是极好的。&lt;/p&gt;
&lt;p&gt;JSON是一种数据交换格式。JavaScript Object Notation&lt;/p&gt;
&lt;p&gt;JSON独立于编程语言。&lt;/p&gt;
&lt;p&gt;JSON需要用双引号包裹key-value。当值是字符串时，必须使用双引号。如果是&lt;strong&gt;数字，布尔值，数组，对象，null&lt;/strong&gt;等其他数据类型，则不应该被双引号包裹。多个key-value之间用逗号来分割。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://hongscar.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JSON" scheme="https://hongscar.cn/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>docker笔记</title>
    <link href="https://hongscar.cn/docker%E7%AC%94%E8%AE%B0.html"/>
    <id>https://hongscar.cn/docker%E7%AC%94%E8%AE%B0.html</id>
    <published>2020-02-17T15:02:23.000Z</published>
    <updated>2020-02-17T15:24:58.428Z</updated>
    
    <content type="html"><![CDATA[<p>记录docker学习的笔记。本文主要是参考了阮一峰的Docker教程，：<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html。在阅读完这篇Docker教程的过程中所做的笔记，用我自己的语言整理了一遍。" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html。在阅读完这篇Docker教程的过程中所做的笔记，用我自己的语言整理了一遍。</a></p><a id="more"></a><h3 id="Docker出现的原因，解决了哪些问题，如何解决的，有哪些应用？"><a href="#Docker出现的原因，解决了哪些问题，如何解决的，有哪些应用？" class="headerlink" title="Docker出现的原因，解决了哪些问题，如何解决的，有哪些应用？"></a>Docker出现的原因，解决了哪些问题，如何解决的，有哪些应用？</h3><p>软件开发的一个大难题，就是环境配置，经常出现各种因为环境配置而出现的错误。（我相信你在编写maven项目的时候就已经被各种依赖包的版本给困扰到了，环境变量同样如此）比如安装一个python应用，计算机必须要有python引擎，还要有各种依赖，可能还要配置环境变量。除此之外，随着软件的迭代还有运行环境的升级，一些老旧的模块可能与当前环境不兼容。开发者常常会说：“它在我的电脑上是没有问题的”（It works on my machine)，换言之，在其他电脑能不能运行，我不确定，我也不想管。环境变量如此麻烦，换一台机器就要重来一次，十分浪费时间。于是有人在想，能不能从根本上解决问题，比如软件可是带着环境变量一起安装？也就是说，在安装的时候，把原始环境一模一样地复制过来。</p><p>一种可行的解决方法，虚拟机。直接去现场对机器进行配置，或者去客户家配置电脑环境，并不现实，但使用虚拟机就可以达到模拟运行系统的效果，直接把开发时的最终环境一起打包，就可以彻底还原软件的原始环境。</p><p><strong>但这个方案存在一些缺点：</strong></p><p>①资源占用多。一个虚拟机是需要一定的内存和磁盘空间的，所以即使你的项目只有1MB，续集你依然要几百MB才能运行。</p><p>②冗余步骤多。一个虚拟机是一个完整的操作系统，所以一些系统级别的操作步骤，往往都不能跳过，比如用户登录。</p><p>③启动慢。启动的时候就跟启动一台电脑的时间一样。</p><p><strong>显然，为了保存运行环境，直接copy一个虚拟机，并不可取，因为我们需要的只是一些必要的环境变量，一些组件，而非一个彻底完整的操作系统。</strong>所以，我们需要的是一个虚拟的“小型虚拟机”，里面只包含我们的程序所需要的组件即可。这种东西就叫做：Linux容器(Linux Containers,LXC)</p><p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。因为的进程级别的，相比虚拟机就有很多的优势，比如：启动快，资源占用少，体积小。因为它只需要占用需要的资源，包含要用到的组件。总而言之，有点像轻量级的虚拟机。</p><p>Docker，就是一种LXC的封装，提供了简单易用的容器使用接口。Dockers将应用程序与该程序的依赖，一起打包在一个文件里面(image)。运行这个文件，就会生成一个虚拟容器(container)。程序在这个虚拟容器里运行，就好像在真实的物理机器上运行。有了Docker就无须担心环境问题。用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理，复制，分享，修改，就像管理普通的代码一样。</p><p><strong><em>Docker的主要用途：</em></strong></p><p>①提供一次性的环境。无论是开发环境，单元测试环境，还是其他，都可以轻松提供。</p><p>②提供弹性的云服务。因为Docker容器可以随开随关，很适合动态扩容和缩容。</p><p>③组建微服务架构。容器可以存放多个服务，还有它们的各种依赖。所以一台机器就可以跑多个服务，在本机就可以模拟出微服务架构。</p><h3 id="Docker重要概念："><a href="#Docker重要概念：" class="headerlink" title="Docker重要概念："></a>Docker重要概念：</h3><p>image文件：Docker把应用程序及其依赖，都打包在image文件里面。一个image文件可以通过继承另一个image文件，进行拓展。这是一个二进制文件</p><p>container：容器文件，通过image文件生成的实例，本身也是一个文件，称为容器文件。</p><p>（二者的关系，image就像class，container就像是具体的对象）</p><p>Dockerfile：它是一个文本文件，用于配置image。Docker根据该文件生成二进制的image文件（也就是说，我们要生成image文件，实际上是通过生成Dockerfile文件来指定依赖）</p><p>(而且，Dockerfile的文件名必须就叫Dockerfile，这样也使得后续用Dockerfile构建image的时候，直接指定Dockerfile的路径即可，那个参数是【path】，所以无法指定具体的文件名）</p><p>编写Dockerfile文件的过程：</p><p>1.在项目的根目录，新建一个文件 .dockerignore    (就是忽略的路径），（可选）</p><p>.git node_modules npm-debug.log</p><p>2.创建一个文本文件Dockerfile，写入：    （举例）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FROM node:8.4 COPY . /app WORKDIR /app RUN npm install --registry=https://registry.npm.taobao.org EXPOSE 3000</span><br><span class="line"></span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure><p>每一行的含义：</p><p>FROM：表明要继承哪个image，这里继承的官方的node image，版本号是8.4（默认library/…)</p><p>COPY：将当前目录下的所有文件，（除了.dockerignore里提到的），都copy到image文件里的/app目录</p><p>WORKDIR：指定工作路径</p><p>RUN……：启动成功之后会运行的命令，这里是运行npm install安装依赖</p><p>EXPOSE：将容器暴露特定的端口号，允许外部连接这个端口</p><p>CMD：在容器成功启动后，会自动执行该命令</p><p>（ps：RUN和CMD有什么区别？RUN命令是在image文件的构建阶段执行，执行的结果都会打包进入image文件。而CMD命令则是在容器启动成功后执行。另外，一个dockerfile可以包含多个RUN命令，但只能有一个CMD命令。同时，指定了CMD命令之后，docker container run命令就不能附加命令，否则它会覆盖掉CMD命令，也就是docker run的CMD命令把dockerfile里的覆盖了。）</p><h3 id="Docker常用命令："><a href="#Docker常用命令：" class="headerlink" title="Docker常用命令："></a>Docker常用命令：</h3><p>①列出本机的所有image</p><p><code>docker image ls    /     docker images</code></p><p>删除image文件</p><p><code>docker image rm 【imageName】</code></p><p>从Docker仓库抓取具体image到本地（默认是官方仓库，可配置国内的镜像文件）</p><p><code>docker image pull 【path/.../imageName】</code>    （前面默认的path是 library/，是官方仓库的默认组）</p><p>②通过image生成container实例，并运行该实例</p><p><code>docker container run 【imageName】</code>        （如果本地无法找到，会自动去仓库抓取，即pull）</p><p>列出本地的container：</p><p><code>docker container ls    [ -all ]        /    docker ps</code></p><p>删除container：    </p><p><code>docker container rm 【containerID】</code></p><p>docker container run的一些参数：</p><p>例子：<code>docker container run -p 8000:3000 -it koa-demo /bin/bash</code></p><p>-p：容器的3000端口，映射到本机的8000端口</p><p>-it：容器的Shell映射到当前的Shell，然后你在本机窗口输入的命令，就会传入容器中</p><p>/xxx：容器启动之后，内部第一个执行的命令。这里是启动Bash，保证用户可以使用Shell</p><p>退出容器：先ctrl+c停止进程，在ctrl+d退出容器。</p><p><code>docker contain kill</code>：终止容器运行</p><p>退出之后，容器文件并不会删除，所以需要手动rm，但应该删除，下次再由image创建。可以在运行时增加一个参数–rm，表明容器终止运行后自动删除容器文件。</p><p>③使用Dockerfile文件，创建image文件：</p><p><code>docker image build -t xxx .</code>(docker image build，-t表明image文件的名字，  “.”表示当前路径）</p><p>（xxx可以指定版本号，格式为 xxx:yyy，放在冒号之后。如果不指定版本号，默认为latest）</p><p>（ps：   docker image build == docker build）</p><p>④一些有用的命令</p><p><code>docker container start</code></p><p>（docker container run命令是新建容器，每运行一次，就会新建一个容器，如果同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器（当然，没有–rm参数了），那么就要使用docker container start命令，用于启动已经生成，已经停止运行的容器文件。</p><p><code>docker container stop</code></p><p>（docker contain kill是向容器里面的主进程发出SIGKILL信号，而docker container stop是发出SIGTERM信号，然后过一段时间再发出SIGKILL信号。这两个信号的的差别是，如果进程收到SIGTERM信号，可以自行进行收尾清理工作，但也可以不理会这个信号。而如果收到SIGKILL信号，就会强行立即终止，那么正在进行中的操作会全部丢失。也就是说，kill是强制性立即关闭，而stop会给一定的时间让container把收尾工作完成，如果超出一定时间后还没完成收尾，那么才强制结束）</p><p><code>docker container logs</code></p><p>用于查看容器的输出，即容器里Shell的标准输出。如果容器docker run的时候没有使用-it参数，就要用这个命令查看输出。（或者是显式指定要运行在后端的时候）</p><p><code>docker container exec</code></p><p>docker container exec命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令.</p><p><code>docker container cp</code></p><p>用于从正在运行的Docker容器里面，将文件拷贝到本机。</p><p>写法：<code>docker container cp 【containerID】:【/path/to/file】</code></p><p>-—-</p><h3 id="实例：使用Docker架设WordPress网站（需要WordPress容器和MySQL容器）"><a href="#实例：使用Docker架设WordPress网站（需要WordPress容器和MySQL容器）" class="headerlink" title="实例：使用Docker架设WordPress网站（需要WordPress容器和MySQL容器）"></a>实例：使用Docker架设WordPress网站（需要WordPress容器和MySQL容器）</h3><p>方法一：自己自建WordPress容器</p><p>步骤：</p><p>①通过官方的PHP image，构建一个PHP container    例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">--rm \// 停止运行后，自动删除容器文件</span><br><span class="line">--name wordpress \// 容器的名字  </span><br><span class="line">--volume <span class="string">"<span class="variable">$PWD</span>/"</span>:/var/www/html \</span><br><span class="line">// 将当前目录（<span class="variable">$PWD</span>)映射到/var/www/html（即Apache对外访问的默认目录）  </span><br><span class="line">php:5.6-apache// image名，说明装的是PHP 5.6版本，并且自带apache服务器</span><br></pre></td></tr></table></figure><p>②之后在当前目录下创建的文件，都会直接被Apache服务器提供给外界访问，所以直接把WordPress安装包拷贝到此处，就可以通过容器访问到WordPress的安装界面</p><p>所以这一步很简单，wget下载，然后tar -xvf解压即可。</p><p>（遇到的小问题，由于太多国人使用WordPress了，大概是导致别人服务器都炸了，于是WordPress已经默认屏蔽了大陆的IP，所以直接wget是不可行的。解决就是在windows自己找资源，再传）</p><p>③使用MySQL image来构建MySQL container，例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">-d \  </span><br><span class="line">--rm \  </span><br><span class="line">--name wordpressdb \  </span><br><span class="line">--env MYSQL_ROOT_PASSWORD=123456 \ </span><br><span class="line">--env MYSQL_DATABASE=wordpress \  </span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p>每行参数的含义：</p><p>-d：容器启动后，在后台运行（这时候要查看输出就需要用logs</p><p>–rm， –name：自动删除，容器名</p><p>–env：向容器进程传入一个环境变量MYSQL_ROOT_PASSWORD，该变量会作为MySQL的根密码，同时还传入一个MYSQL_DATABASE，容器里面的MySQL会根据该变量创建一个同名的数据库</p><p>④定制Container，也就是Dockerfile</p><p>此时WordPress容器和MySQL容器都已经有了，但二者并没有链接到PHP Container中。我们需要先在PHP image的基础上，安装mysqli的拓展，然后启动Apache。Dockerfile文件如下：</p><p><code>FROM php:5.6-apache RUN docker-php-ext-install mysqli CMD apache2-foreground</code></p><p>然后再基于Dockerfile创建一个image文件（包含了mysqli拓展的PHP image）</p><p><code>docker build -t phpwithmysql .</code>    （该image文件名为phpwithmysql）</p><p>⑤WordPress容器链接mysql</p><p>PHP container已经增加了mysqli的拓展，而对于WordPress，在启动的时候连接即可。启动命令如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">--rm \  </span><br><span class="line">--name wordpress \  </span><br><span class="line">--volume <span class="string">"<span class="variable">$PWD</span>/"</span>:/var/www/html \// --volume  == -v  </span><br><span class="line">--link wordpressdb:mysql \  </span><br><span class="line">phpwithmysql</span><br></pre></td></tr></table></figure><p>新加的那行，表示WordPress容器要连接到wordpressdb容器，冒号表示该容器的别名为mysql。最后还要修改一下wordpress目录的权限，让容器可以将配置信息写入这个目录（/var/www/html)</p><p><code>chmod -R 777 wordpress</code></p><p>接着，在启动PHP container的时候，命令行会返回一个对外开放的IP地址，比如172.17.0.2,直接访问即可出现WordPress的安装界面。</p><p>总结：PHP image（web server） + wordpress.tar.gz(到/var/www/html) + mysql链接</p><p>方法二：</p><p>方法一需要自己创建WordPress容器，还是有点麻烦，实际上Docker已经提供了官方的WordPress image，直接用那个即可。</p><p>步骤：</p><p>①新建并启动MySQL Container（跟方法1一样）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">-d \  </span><br><span class="line">--rm \  </span><br><span class="line">--name wordpressdb \  </span><br><span class="line">--env MYSQL_ROOT_PASSWORD=123456 \  </span><br><span class="line">--env MYSQL_DATABASE=wordpress \  </span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure><p>②然后基于官方的WordPress image，创建WordPress Container</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">-d \  --rm \  </span><br><span class="line">--name wordpress \  </span><br><span class="line">--env WORDPRESS_DB_PASSWORD=123456 \  </span><br><span class="line">--link wordpressdb:mysql \ </span><br><span class="line">wordpress</span><br></pre></td></tr></table></figure><p>（方法一，我们需要给php image增加mysqli拓展，然后启动php container，作为我们自己创建的WordPress image，然后再link数据库，实际上，直接一个wordpress即可（调用官方Docker）</p><p>但是，上面指定了-d，也就是在后台运行，所以前台看不到输出，此时需要inspect命令查看输出。</p><p><code>docker container inspect wordpress</code></p><p>找到IPAddress字段，那就是对外开放的IP地址，直接访问即可。</p><p>此时虽然用了官方的WordPress image，简化了很多不必要的步骤，但还是存在一些问题。比如，每次新建容器，返回的IP地址不能保证相同，导致需要更换IP地址来访问WordPress。WordPress安装在容器里面，本地无法修改文件。解决方法如下:</p><p>创建WordPress Container的命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker container run \  </span><br><span class="line">-d \  </span><br><span class="line">-p 127.0.0.2:8080:80 \  </span><br><span class="line">--rm \  </span><br><span class="line">--name wordpress \  </span><br><span class="line">--env WORDPRESS_DB_PASSWORD=123456 \  </span><br><span class="line">--link wordpressdb:mysql \  </span><br><span class="line">--volume <span class="string">"<span class="variable">$PWD</span>/wordpress"</span>:/var/www/html \  </span><br><span class="line">wordpress</span><br></pre></td></tr></table></figure><p>只新加了两行参数：</p><ul><li>-p 127.0.0.2:8080:80：将容器的 80 端口映射到127.0.0.2的8080端口。</li><li>–volume “$PWD/wordpress”:/var/www/html：将容器的/var/www/html目录映射到当前目录的wordpress子目录。</li></ul><p>这样我们就固定了IP地址，同时还指定了一下端口的映射，还有容器的文件目录映射。（容器会把文件默认放到Apache的默认路径，然后再映射到wordpress子目录，使得本地也可以修改文件）</p><p>方法三：</p><p>方法二主要是，分别启动两个容器，然后在启动时，在命令行里提供容器之间的连接信息。还有一种更简单的方法，就是使用Docker Compose。关键点：定义一个YAML格式的配置文件，在里面写好多个容器之间的调用关系，只需要一个命令就可以同时启动/关闭这些容器。</p><p>步骤：</p><p>①安装，pass</p><p>②创建yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysql:</span>    </span><br><span class="line"><span class="attr">image:</span> <span class="string">mysql:5.7</span>    </span><br><span class="line"><span class="attr">environment:</span>     </span><br><span class="line"><span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span>     </span><br><span class="line"><span class="bullet">-</span> <span class="string">MYSQL_DATABASE=wordpress</span> </span><br><span class="line"><span class="attr">web:</span>    </span><br><span class="line"><span class="attr">image:</span> <span class="string">wordpress</span>    </span><br><span class="line"><span class="attr">links:</span>     </span><br><span class="line"><span class="bullet">-</span> <span class="string">mysql</span>    </span><br><span class="line"><span class="attr">environment:</span>     </span><br><span class="line"><span class="bullet">-</span> <span class="string">WORDPRESS_DB_PASSWORD=123456</span>    </span><br><span class="line"><span class="attr">ports:</span>    </span><br><span class="line">    <span class="bullet">-</span> <span class="string">"127.0.0.3:8080:80"</span>    </span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/var/www/html</span>    </span><br><span class="line">    <span class="attr">volumes:</span>     </span><br><span class="line">    <span class="bullet">-</span> <span class="string">wordpress:/var/www/html</span></span><br></pre></td></tr></table></figure><p>（显然，一个是mysql容器，一个是web容器）</p><p>启动：<code>docker-compose up</code>        （同时启动两个容器，此时就可以访问127.0.0.3到安装界面）</p><p>关闭：<code>docker-compose stop</code></p><p>关闭之后，容器文件还是存在的，写在里面的数据也不会丢失。下次再启动的时候，还可以复用。如果要删除，需要先暂停两个容器，然后调用删除命令：</p><p><code>docker-compose rm</code></p><p>首先是自定义image，然后启动，连接。后续的改进是，可以直接用官方或者别人写好的image来进行启动，连接。最后的方法是，直接使用docker-compose，不需要在启动命令的时候写一堆参数，直接写到yml文件里即可，同时还能保存容器信息，进行复用。自此，Docker的基本示例到此结束。</p><p>参考：<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p><p>PS：    （很多情况下可以省略image ， container等关键字）</p><p>docker image build  == docker build</p><p>docker container run == docker run（即使是run image，也是构建出container）</p><p>docker container rm = docker rm</p><p>docker container stop = docker stop</p><p>进入容器，除了exec，还可以用attach：</p><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20200217/new_images/docker_8.png" alt="img"></p><p>删除所有容器（包括已经结束了的）：</p><p><code>docker rm -f $(docker ps -a -q)</code></p><p>删除所有image：</p><p><code>docker rmi -f $(docker images)</code></p><p>导出容器为压缩包：</p><p><code>docker export 【options】 container_id &gt; xxx.tar</code>    (&gt; xxx其实不是必须的）</p><p>导入容器：</p><p><code>docker import xxx.tar container_name</code></p><p>Dockerfile一些常用指令：</p><p>FROM：表示基本的image（一般是Docker Hub或者其他仓库别人制作好的image），在此基础上进行修改调整。FROM必须在其他指令之前。</p><p>RUN：启动成功之后会执行的命令</p><p>CMD：容器启动成功之后执行的（区别上面看RUN与CMD的区别，记住多条CMD只会执行一条，所以如果启动时docker run存在CMD命令，那么会直接把Dockerfile的CMD命令全部忽略掉）</p><p>ADD：添加源文件到目的路径。如果路径不以斜杠结尾，被视为文件。如果源文件是可识别的压缩包格式，docker还会自动解压</p><p>ARG：设置构造参数    ENV：设置环境变量</p><p>（ARG与ENV的区别：ARG设置的是构建时的环境变量，在容器运行时是不会存在这些变量的。ENV主要就是运行时的环境变量）</p><p>COPY：与ADD类似，但不支持URL和压缩包（ADD除了文件，还可以是URL或压缩包）</p><p>EXPOSE:声明暴露的端口</p><p>LABEL：为镜像添加元数据metadata</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录docker学习的笔记。本文主要是参考了阮一峰的Docker教程，：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html。在阅读完这篇Docker教程的过程中所做的笔记，用我自己的语言整理了一遍。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html。在阅读完这篇Docker教程的过程中所做的笔记，用我自己的语言整理了一遍。&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://hongscar.cn/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://hongscar.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码阅读</title>
    <link href="https://hongscar.cn/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html"/>
    <id>https://hongscar.cn/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB.html</id>
    <published>2020-02-17T03:51:39.000Z</published>
    <updated>2020-02-19T06:53:53.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言："><a href="#一-前言：" class="headerlink" title="一. 前言："></a>一. 前言：</h3><p>​        在准备面试的过程中，发现HashMap源码是很常见的考点，于是进行了仔细的学习。以前都说读源码是快速提高Java水平的好途径，在阅读了HashMap的部分重要源码之后真的是深有体会，于是写下此篇文章做记录。具体内容包括，HashMap的构造方法，put，get方法，以及put&amp;get所需要的hash方法，还有扩容时所需要的resize方法。我们将对这几个方法的源码进行阅读，理解它的逻辑，以及一些巧妙的设计。</p><a id="more"></a><h3 id="二-HashMap原理："><a href="#二-HashMap原理：" class="headerlink" title="二. HashMap原理："></a>二. HashMap原理：</h3><p>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。<br><strong>常用的方法有</strong>：<br>构造方法，可以定义initialCapacity初始容量，factor负载因子。<code>threshold = initialCapacity * factor</code><br>put，get，二者需要用到hash方法，也就是散列函数。<br>resize：放数组容量不足时，元素个数大于threshold时，就要扩容。<br>HashMap使用数组链表来存储数据（数组的每一项都是一个链表），JDK1.8开始，当链表的长度到达一定程度，就会把该链表转换成红黑树。</p><hr><h3 id="三-①-构造方法："><a href="#三-①-构造方法：" class="headerlink" title="三. ① 构造方法："></a>三. ① 构造方法：</h3><p>构造方法一共有4个：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_1.png" target="_blank" rel="noopener" title="HashMap构造方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_1.png" alt="HashMap构造方法" title="HashMap构造方法"></a><br>显然，第一个就是没有参数，此时会设置默认的负载因子factor。<br>对于第二个，实际上就是将float参数设置为默认的负载因子default_factor。<br>对于第四个，是传入一个Map对象进行初始化。我们重点看第三个构造方法：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_2.png" target="_blank" rel="noopener" title="第三个构造方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_2.png" alt="第三个构造方法" title="第三个构造方法"></a><br>前面的都是判断一下边界值，就省略了。<br>HashMap有几个关键的成员属性：<br><strong>initialCapacity</strong>：初始容量大小（数组大小，但后面会改变）<br><strong>factor</strong>：负载因子<br><strong>threshold</strong>：initialCapacity * factor（到达这个值的时候，哈希数组会扩容）<br>（初始化之后，后续用size表示哈希数组里的元素个数，当size超过threshold之后，扩容）<br>然后我们发现一行关键的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br></pre></td></tr></table></figure><p>点进入看<em>tableSizeFor</em>的函数逻辑：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_3.png" target="_blank" rel="noopener" title="tableSizeFor"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_3.png" alt="tableSizeFor" title="tableSizeFor"></a><br>可以看到这个方法的目的：<strong>returns a power of two size for the given target capacity</strong></p><p>也就是说，<strong>哈希数组的长度，永远是2的幂次方</strong>，至于为什么，请看后面的<strong>question1</strong>.<br>关于这个算法的逻辑，用下图可以说明：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_4.png" target="_blank" rel="noopener" title="tableSizeFor算法的逻辑"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_4.png" alt="tableSizeFor算法的逻辑" title="tableSizeFor算法的逻辑"></a><br>连续的n |= n &gt;&gt;&gt; 1, 2, 4, 8, 16，通过这样，最多可以让连续32位为1.不管capacity是多少，比如它是1011，减去1之后是1010，第一个不为0的位是第4位，那么这个算法会返回10000.<br>（这里的关键是<strong>或运算</strong>，因为第一位是1，1和任何数字进行或运算都为1，因此，n&gt;&gt;&gt;1，会使得n的前2位变为2，然后再执行n&gt;&gt;&gt;2，就是前4位，再执行n&gt;&gt;&gt;4，就是前8位。）如果数字没有那么高位，那么高位全是0，并且n&gt;&gt;&gt;x全部都为0，因而或运算为0，高位没有任何影响，看下图例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_5.png" target="_blank" rel="noopener" title="高位运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_5.png" alt="高位运算" title="高位运算"></a><br>这个算法，巧妙地通过了位运算，返回了一个不小于capacity 的最小2的幂次方。至于为什么要-1，是防止capacity已经是2的幂次方的情况，比如是10000，如果不减1，那么返回的将会是100000.减去1，使得初始的capacity改为1111（1111和1001，1101等都是一样的）。<br>以上的情况都是在capacity不为0的情况考虑的，而当capacity为0的时候，无论经过几次运算，都为0，那么最后的capacity将为1（最后有一个n+1的操作），所以也是符合预期结果的。<br>这样，我们就得到了一个2的幂次方的capacity，即哈希数组的长度（所以比如，当我们传入的capacity为12，最终生成的数组长度会是16.）<br>结果：<br> // 如果没有指定initialCapacity, 则不会给threshold赋值, 该值被初始化为0<br> // 如果指定了initialCapacity, 该值被初始化成不小于initialCapacity的最小的2的次幂</p><hr><h3 id="四-②put方法："><a href="#四-②put方法：" class="headerlink" title="四. ②put方法："></a>四. ②put方法：</h3><p>可以看到，put方法其实还有两个参数，但put方法并没有重载方法，所以如果我们需要改变后两个参数，应该使用putVal方法自己修改，但一般不需要，在下文看putVal的方法里我们就知道着两个参数是什么作用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接下来关键是看putVal的方法实现：（逐行分析，中文注释）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">//创建一些后面需要的变量，略</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"><span class="comment">//如果哈希数组为空，即还没初始化，先resize一次，resize后面再看，这里只需要知道</span></span><br><span class="line"><span class="comment">//会创建一个默认长度的哈希数组即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//如果哈希数组该index没有元素，即没有发生碰撞，直接插入一个newNode即可。</span></span><br><span class="line"><span class="comment">//这里的(n - 1) &amp; hash的原理，查看后面的question2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//说明已经有元素，发生了碰撞，然后我们就沿着链表/红黑树去插入Node</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"><span class="comment">//我们首先会查看第一个元素（在第一个元素时就能确定它是链表还是数组）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"><span class="comment">//这里的p是上文的p = tab[i = (n - 1) &amp; hash]，即第一个元素，如果第一个元素跟待插入</span></span><br><span class="line"><span class="comment">//的元素是相同的，即key相同（hash肯定是已经相同的了），然后我们只需要更改p的值</span></span><br><span class="line"><span class="comment">//即可。这里的逻辑是，把p赋值给新创建的Node e，然后跳出整个循环之后，再判断e</span></span><br><span class="line"><span class="comment">//是否位null，如果e为null，那么直接进行value的替换即可，否则，往后看。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"><span class="comment">//判断该index项是链表还是红黑树，如果是红黑树再进入putTreeVal，此处略</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//说明是链表，并且第一个元素也不相等，所以我们就遍历链表，然后插入到链表的最</span></span><br><span class="line"><span class="comment">//后，并且，如果链表长度过长，还会引起链表树化的操作。如果是整个数组的长度过</span></span><br><span class="line"><span class="comment">//大，那么还要对数组进行resize。（PS：这里的元素相等是指key，链表里的key都是互</span></span><br><span class="line"><span class="comment">//不相等的，只是它们发生hash冲突导致都放在数组的同一个index上。所以如果在中间</span></span><br><span class="line"><span class="comment">//发现了相同的key，那么就跟前面一样，其实也是e = p的逻辑，然后在后续直接覆盖</span></span><br><span class="line"><span class="comment">//value即可。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//p.next为null，那么直接将p.next新建一个newNode即可。即已经到达链表的最后。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line"><span class="comment">//这是指链表长度大于等于TREEIFY_THRESHOLD的时候，进行树化。默认是8.注意这</span></span><br><span class="line"><span class="comment">//里为什么是&gt;= THREIFY_THRESHOLD，看起来是7个就可以树化，但实际上还是8个</span></span><br><span class="line"><span class="comment">//的。具体的看后面的question4.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="comment">//如果遇到了相等的key，那么就是覆盖value。注意此时并未到链表的最后，所以这里的</span></span><br><span class="line"><span class="comment">//e不等于null。而上面的(e = p.next) == null，上面逻辑的e会是null。这个e后面马上用到</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line"><span class="comment">//这里的p = e实际上就是 p = p.next，因为并没有执行for循环里的两个if，如果执行了其</span></span><br><span class="line"><span class="comment">//中一个，都会直接break跳出循环。（个人觉得这个p = e放在for判定语句里可读性更好</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line"><span class="comment">//这就是前面一直说的e，如果存在相同的key，那么e就不是null，此时直接覆盖value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line"><span class="comment">//这就是第三个参数，表示已有相同的key时是否更新。onlyIfAbsent默认是false，所以这</span></span><br><span class="line"><span class="comment">//里的if是一定会触发，即一定会覆盖value。如果手动将onlyIfAbsent改为true，那么就是</span></span><br><span class="line"><span class="comment">//只有当oldValue为null的时候，才能改变key的value，否则都不会改变。</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line"><span class="comment">//这个在HashMap是空方法，在LinkedHashMap的时候才会被重写并使用。</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line"><span class="comment">//覆盖了value（或者不覆盖），就把oldValue返回，方法结束。因此插入一个相同key的</span></span><br><span class="line"><span class="comment">//元素，实际上是更新该key的value，方法的逻辑在这里已经完成，不会改变HashMap的</span></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//最外层的if-else循环结束</span></span><br><span class="line">    ++modCount;</span><br><span class="line"><span class="comment">//到达了这里，说明不存在相同的key，所以插入了一个新的key，改变modCount以及</span></span><br><span class="line"><span class="comment">//哈希数组的元素个数size</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line"><span class="comment">//如果改变了之后，哈希数组的元素个数大于threshold，此时发生碰撞的概率较大，因此</span></span><br><span class="line"><span class="comment">//进行resize，即对哈希数组进行扩容，后面会讲到。</span></span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">//同样是LinkedHashMap的东西，此处为空方法。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要是这么几个步骤：</strong><br><strong><em>①如果当前table为空，先进行初始化</em></strong><br><strong><em>②查找插入的键值对是否存在，存在的话，先进行赋值，后续将更新旧的键值对</em></strong><br><strong><em>③不存在，插入链表尾部，如果链表长度大于一个阈值，进行链表转化树的操作</em></strong><br><strong><em>④如果size大于一个阈值，进行扩容</em></strong><br>PS：threshold在初始化的时候，值为2的幂次方（在tableForSize那里可以看到），但threshold应该是capacity * factor，当size大于threshold的时候才执行resize。那么会不会因此而导致初始化的时候threshold并不受factor的影响？<br>（比如我们初始化的时候，capacity传参是10，factor是0.75，在tableForSize里，我们知道threshold会被赋值为不小于10的2的幂次方，即16.然后根据put的逻辑，应当是++size &gt; threshold的时候才扩容，那么初始化的threshold是16，而不是预期的值16 * 0.75 = 12？）<br>实际上并不是的，上面的threshold实际上就不应该是哈希数组的长度（所以JDK源码在构造方法里，把2的幂次方赋值给threshold确实有迷惑的意思）。在put方法的第一个步骤，即“如果当前table为空，先进行初始化”。那么我们再看一下这一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure><p>当table为空，那么要先resize，即数组是在这里才进行建立的。在resize里面，是把threshold赋值给了另一个叫newCap的变量（看变量名可知，显然就是新的哈希数组的长度），然后threshold又会被改变为newCap * factor。所以threshold虽然确实是2的幂次方，但确实并不是代表哈希数组的长度，仍然是作为扩容的判断点（<strong>虽然是个无聊的问题，但感觉是JDK源码的变量具有迷惑性！</strong>）至于resize的源码，继续看。</p><hr><h3 id="五-③get"><a href="#五-③get" class="headerlink" title="五. ③get"></a>五. ③get</h3><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_6.png" target="_blank" rel="noopener" title="get方法的源码"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_6.png" alt="get方法的源码" title="get方法的源码"></a><br>get方法显然简单很多。<strong>首先判断是否存在该key，如果不存在，返回null。</strong><br>getNode的逻辑体也是比较简单，先查找第一个元素，看key值是否相等。至于为什么需要“always check first node”，显然，因为<strong>JDK1.8可能是链表，可能是红黑树，需要进行判断</strong>。<br>如果当第一个first就是相等的，那么就直接返回。如果不在，判断是否是红黑树，如果是，使用另一套逻辑，如果不是，就是简单的链表遍历，对比，e = e.next，应该很好理解，此处略。</p><hr><h3 id="六-④hash"><a href="#六-④hash" class="headerlink" title="六. ④hash"></a>六. ④hash</h3><p>首先给出<strong>HashMap计算哈希码的整体步骤</strong>：<br><strong><em>1.获取key的hashCode</em></strong><br><strong><em>2.对hashCode进行处理（hash方法），主要是高16位不变，而低16位与高16位进行异或操作</em></strong><br><strong><em>3.对capacity进行取模（使用了 hash &amp; (n - 1)进行优化）</em></strong><br>在put和get方法中，可以看到都需要对key进行hash运算：</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_7.png" target="_blank" rel="noopener" title="put方法的hash运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_7.png" alt="put方法的hash运算" title="put方法的hash运算"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_8.png" target="_blank" rel="noopener" title="get方法的hash运算"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_8.png" alt="get方法的hash运算" title="get方法的hash运算"></a></p><p>因为<strong>hashcode就是为了HashMap而生的</strong>，在学习重写equals时为何要重写hashCode的时候我们就已经知道了。那么HashMap里到底如何重写hashCode方法呢，如下：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_9.png" target="_blank" rel="noopener" title="HashMap中的hashCode方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_9.png" alt="HashMap中的hashCode方法" title="HashMap中的hashCode方法"></a><br>嗯。。。很简单的异或运算，结合了key和value的hashCode，没什么特别的。结合value同样是减少碰撞。这个就是步骤1.</p><p>那么接下来看一下步骤2，HashMap自定义的hash方法：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_10.png" target="_blank" rel="noopener" title="HashMap中自定义的hash方法"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_10.png" alt="HashMap中自定义的hash方法" title="HashMap中自定义的hash方法"></a><br>从逻辑上看，就是hash本身与hash右移16位的结果进行异或。<br>h &gt;&gt;&gt; 16的结果：高16位全部变成0，原本高16位的处于低16位。<br>h ^ ( h &gt;&gt;&gt; 16)的结果：<br>1.高16位不变。<strong>因为0与任何数进行异或，返回的都是那个数本身</strong>。0 ^ 1 = 1, 0 ^ 0 = 0<br>2.低16位于原本的高16位进行异或。<br>步骤3对capacity取模，很好理解，不能超出哈希数组的范围。第二步的意义何在？看<strong>question3</strong>.</p><hr><h3 id="七-⑤resize"><a href="#七-⑤resize" class="headerlink" title="七. ⑤resize"></a>七. ⑤resize</h3><p>在put的过程中，当size超出了threshold，那么就需要进行resize扩容。逻辑比较复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//oldCap表明，table里原本已经存在key-value</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">//如果oldCap都已经扩容到最大了，那么就直接将threshold设为最大值，只好任你碰撞</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line"><span class="comment">//没有超出最大值，那么就安心扩容为原来的 2倍。值得注意的是newCap跟newThr都扩</span></span><br><span class="line"><span class="comment">//容为 2倍，仔细看 if 语句的判定。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line"><span class="comment">//这个就是我们前面所说的，当初始化的时候，会将threshold仅仅作为一个变量赋值给</span></span><br><span class="line"><span class="comment">//newCap，然后后面又把newCap*factor赋值给threshold</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line"><span class="comment">//这里就是调用new HashMap( )的情况，一个构造参数也没有的时候，直接赋默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//当上面第一个if里面没有执行里面的两个子if语句时，newThr仍然没有变化，即为0.需要在这里再对threshold进行修改。</span></span><br><span class="line"><span class="comment">//（比如上面的： else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span></span><br><span class="line"><span class="comment">//                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)，此时newCap可能超出了MAX，那么</span></span><br><span class="line"><span class="comment">//newThr就仍然为0.又或者是 else if (oldThr &gt; 0)  newCap = oldThr;中，即初始化带int参数的时</span></span><br><span class="line"><span class="comment">//候，这里仍然没有对threshold进行赋值。）</span></span><br><span class="line"> <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"><span class="comment">//这段代码就是普通地判断threshold是否会超出MAX而已</span></span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"><span class="comment">//我们已经将新数组的各种参数（capacity，threshold等）都设置好了，接下来需要将原</span></span><br><span class="line"><span class="comment">//本的数组元素放入到新的哈希数组中。显然，因为这个操作，使得resize方法是一个极</span></span><br><span class="line"><span class="comment">//其耗费时间的方法，所以在大概知道元素个数的时候，不应该使用默认值16，而是显式</span></span><br><span class="line"><span class="comment">//定义HashMap的初始容量，减少resize次数，可以显著地提高效率</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//这里table中存放的只是Node的引用, 将oldTab[j]=null只是清除旧表的引用, 但是真正的</span></span><br><span class="line"><span class="comment">//node节点还在, 只是现在由e指向它。所以这里主要是提醒JVM，这里可以被GC清理了</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 如果该存储桶里面没有元素, 就直接将它放到新表的目标位置</span></span><br><span class="line">    </span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果是树，则根据红黑树的逻辑拆分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line"><span class="comment">// 不是红黑树，那么就是链表。因此我们需要把该链表放入新的哈希数组的位置。</span></span><br><span class="line"><span class="comment">//主要是获取整条链表（即使只有 1个元素，结构仍然是链表）。</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//设置了两个链表，原因是根据不同情况，插入到不同的链表，最后再根据结果赋值</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;<span class="comment">//第n位为0</span></span><br><span class="line"><span class="comment">// 我们知道hash &amp; (n - 1)就是原本的位置，那么hash &amp; n是什么？原本的哈希值为n - 1</span></span><br><span class="line"><span class="comment">//位，当它扩容之后，它的哈希值位n - 1或者n位，即第n位要么是0，要么是1，而</span></span><br><span class="line"><span class="comment">//hash &amp; n就是能获取第n位的值，在后面我们会解释为什么</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;<span class="comment">//第n位为1</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);<span class="comment">//此处do-while刚好使得循环至少执行1次</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;<span class="comment">//根据0还是1决定赋值哪个</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于resize的最后那一部分：<br>在JDK1.7之前，都是直接再计算一次hash，然后放入新的哈希数组位置（index,bucket）。<br>但在JDK1.8中，代码得到了改进，看一下官方注释：<br><strong><em>Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</em></strong><br>大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。（n - 1位哈希码，变成n - 1位或 n位）<br>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_11.png" target="_blank" rel="noopener" title="resize时hash位置的变化"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_11.png" alt="resize时hash位置的变化" title="resize时hash位置的变化"></a><br>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_12.png" target="_blank" rel="noopener" title="resize后index的变化"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_12.png" alt="resize后index的变化" title="resize后index的变化"></a><br>因此，<strong>我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</strong>可以看看下图为16扩充为32的resize示意图：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_13.png" target="_blank" rel="noopener" title="resize整个示意图"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_13.png" alt="resize整个示意图" title="resize整个示意图"></a><br>那么，<strong>为什么 hash &amp; n就是可以获得第n位的值呢？</strong><br>首先我们必须知道，n是一个2的幂次方数，它的二进制i形式是00……1000……<br>易知，0 &amp; x = 0，1 &amp; x = x，而我们就是想要hash值的第n位的x值。<br>因此，hash &amp; n，刚好就是取到了新的hash值的第n位的x值。<br>故得出结论:    （最后的if，else判断）<br>如果<code>(e.hash &amp; oldCap) == 0</code> 则该节点在新表的下标位置与旧表一致都为 j<br>如果 <code>(e.hash &amp; oldCap) == 1</code>则该节点在新表的下标位置 j + oldCap</p><hr><hr><h3 id="八-中间遗留出来的questions："><a href="#八-中间遗留出来的questions：" class="headerlink" title="八. 中间遗留出来的questions："></a>八. 中间遗留出来的questions：</h3><p><strong>question1：哈希数组的长度为什么需要是2的幂次方？</strong><br>ans：因为在映射的时候，需要执行(n - 1) &amp; hash，当n不为2的幂次方的时候，n的个位为1，(n - 1)的个位则为0，又因为0 &amp; x = 0，因此使得最后一位必定是0，即浪费了1个位的空间，碰撞的几率也会增大。而如果n是2的幂次方，那么(n - 1)的个位必定是1，1 &amp; x = x，即根据hash的个位来决定，而不是一定返回0，因此能降低碰撞几率，充分利用每一个位。</p><hr><p><strong>question2： （n - 1 ) &amp; hash的原理？</strong><br>ans：因为n是2的幂次方，因而(n - 1)的值位000……1111（若干个1.(n - 1) &amp; hash，即返回hash的低<br>⌈log2(n - 1)⌉ （2为底）位的值，即hash &amp; n。如下图：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_14.png" target="_blank" rel="noopener" title="hash &amp; (n - 1)"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/hashmap_14.png" alt="hash &amp; (n - 1)" title="hash &amp; (n - 1)"></a><br>使用(n - 1) &amp; hash而不使用hash % n的好处：<br>位运算是计算机最快的运算，因此效率更高。同样因为n是2的幂次方，因而该算法也不会出现超出取模范围的错误。</p><hr><p><strong>question3：为什么要将低16位与高16位进行异或操作？</strong><br>ans：先看一下源码的代码注释：<br><strong><em>Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don’t benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</em></strong><br>设计者认为<strong>(n - 1) &amp; hash很容易发生碰撞</strong>，因为如果不对hash进行其他处理，那么hash起作用的仅仅是⌈log2(n - 1)⌉，比如当n为16的时候，hashCode起作用的仅仅是低4bit的有效位，那么当然容易碰撞了。因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是<strong>把高16bit和低16bit异或了一下</strong>。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。（即通过h ^ (h &gt;&gt;&gt; 16)，<strong>间接让高16位也参与计算，从而让键值对分布均匀，降低hash碰撞</strong>）</p><p>如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞<strong><em>(we use trees to handle large sets of collisions in bins)</em></strong>，在JEP-180中，描述了这个问题：<br><strong><em>Improve the performance of java.util.HashMap under high hash-collision conditions by using balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class.</em></strong><br>之前已经提过，在获取HashMap的元素时，基本分两步：<br>首先根据hashCode()做hash，然后确定bucket的index；<br>如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。<br>在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是<strong>O(1)+O(n)</strong>。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。<br>因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了<strong>O(1)+O(logn)</strong>了，这样在n很大的时候，能够比较理想的解决这个问题。</p><hr><p><strong>question4：为什么判定条件是”binCount &gt;= TREEIFY_THRESHOLD - 1”，但树化的条件仍然是bitCount &gt;= TREEIFY_THRESHOLD - 1?</strong><br>ans：这里：<code>binCount &gt;= TREEIFY_THRESHOLD - 1</code>，看起来是大于等于7就会树化，但其实并不是的。因为在刚执行完<code>p.next = newNode(...);</code>此时binCount仍然还没有执行完++。所以仍然是链表中元素的个数大于等于<code>TREEIFY_THRESHOLD</code>（默认是8），才会树化。<br>举例：当元素个数为1的时候，即只有p，此时binCount为0，然后执行<code>p.next = newNode(...)</code>。if判断失效，然后才执行binCount++（即添加完p.next之后，里面已经有k个元素了，但if判断的时候的binCount值为k - 1，只有到下一轮循环才改成k。<br>当链表一共有6个元素的时候，此时binCount为6（已经是下一轮循环），执行p.next = newNode,一共有7个元素。if判断（6 &lt; = 7)，所以不会树化，循环结束，binCount为7.然后下一轮循环，添加元素，为8，此时 7 &lt;= 7，为真，树化。<br>PS：Hash冲突是指不同对象的hashCode通过hash算法后得出了相同定位的下标，这时候采用链地址法，会将此元素插入至此位置链表的最后一位，形成单链表。当存在位置的链表长度 大于等于 8 并且当前数组容量超过64时，HashMap会将链表 转变为 红黑树，这里要说明一点，往往后者的条件会被大多数人忽略，当桶数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长。这个时候应该优先扩容，而不是立马树化。毕竟高碰撞率是因为桶数组容量较小引起的，这个是主因。容量小时，优先扩容可以避免一些列的不必要的树化过程。</p><hr><h3 id="九-其他一些常见问题："><a href="#九-其他一些常见问题：" class="headerlink" title="九. 其他一些常见问题："></a>九. 其他一些常见问题：</h3><p><strong>1. 什么时候会使用HashMap？他有什么特点？</strong><br>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p><p><strong>2. 你知道HashMap的工作原理吗？</strong><br>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。HashMap是非线程安全的，在多线程的操作下会存在异常情况，可以使用HashTable或者ConcurrentHashMap进行代替</p><p><strong>3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</strong><br>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p><p><strong>4. 你知道hash的实现吗？为什么要这样实现？</strong><br>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p><p><strong>5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong><br>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p><p><strong>6. JDK1.8之前，HashMap在并发的情况下会出现问题，比如同时put的时候甚至会引起死循环，导致CPU使用率100%，为什么？</strong><br>因为JDK1.8之前的resize方法是需要rehash的，导致在旧链表迁移到新链表的时候，如果在新链表的数组索引相同，会导致链表元素倒置，在JDK1.8中不需要rehash，直接根据新增的1bit是0还是1，决定是在原本位置还是增加capacity的位置，不会倒置。<br>而JDK1.8之前的transfer，以JDK1.7为例，当两个线程同时resize的时候，由于链表倒置，有可能出现循环链表的情况，导致无限循环，耗尽CPU算力。具体看这里：<a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a><br>HashMap是非线程安全的，在多线程的操作下会存在异常情况，比如类似于数据库的更新丢失（两个线程同时put，可能会导致其中一个put失效）。可以使用Hashtable或者ConcurrentHashMap进行代替。（Hashtable的效率太低，不推荐使用）<br>PS：回到本题的主干：<strong><em>存放数据时发现正在扩容会怎么样。</em></strong><br>对于JDK1.7，应该就是同时resize，导致死循环。对于JDK1.8，则不会出现死循环。（1.7是头插法，导致会倒置，形成循环链表。而<strong>1.8增加了tail指针，使用尾插法</strong>，时间复杂度仍然是O(1)，但不会倒置，因而不会出现死循环。）。1.8中hashmap的确不会因为多线程put导致死循环，但是依然有其他的弊端，比如数据丢失等等。因此多线程情况下还是建议使用concurrenthashmap。</p><p>参考网站：<br><a href="https://segmentfault.com/a/1190000015812438" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015812438</a><br><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a><br><a href="https://juejin.im/post/5a7719456fb9a0633e51ae14" target="_blank" rel="noopener">https://juejin.im/post/5a7719456fb9a0633e51ae14</a><br><a href="https://juejin.im/post/5c7f69dff265da2dea054fdc" target="_blank" rel="noopener">https://juejin.im/post/5c7f69dff265da2dea054fdc</a><br><a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="noopener">https://blog.csdn.net/fan2012huan/article/details/51097331</a><br><a href="https://blog.csdn.net/zhuqiuhui/article/details/51849692" target="_blank" rel="noopener">https://blog.csdn.net/zhuqiuhui/article/details/51849692</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言：&quot;&gt;&lt;a href=&quot;#一-前言：&quot; class=&quot;headerlink&quot; title=&quot;一. 前言：&quot;&gt;&lt;/a&gt;一. 前言：&lt;/h3&gt;&lt;p&gt;​        在准备面试的过程中，发现HashMap源码是很常见的考点，于是进行了仔细的学习。以前都说读源码是快速提高Java水平的好途径，在阅读了HashMap的部分重要源码之后真的是深有体会，于是写下此篇文章做记录。具体内容包括，HashMap的构造方法，put，get方法，以及put&amp;amp;get所需要的hash方法，还有扩容时所需要的resize方法。我们将对这几个方法的源码进行阅读，理解它的逻辑，以及一些巧妙的设计。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://hongscar.cn/categories/Java/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁的判断</title>
    <link href="https://hongscar.cn/MySQL%E9%94%81%E7%9A%84%E5%88%A4%E6%96%AD.html"/>
    <id>https://hongscar.cn/MySQL%E9%94%81%E7%9A%84%E5%88%A4%E6%96%AD.html</id>
    <published>2020-02-17T03:50:57.000Z</published>
    <updated>2020-02-19T07:06:54.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>本文的最终解决的问题：<strong>如何判断一条SQL语句用到了哪些锁？</strong><br>（特别地，这里考虑的是<em>MySQL</em>数据库的锁机制）</p><p>首先，我们需要先对<em>MySQL</em>的事务机制，锁机制，索引机制都总结一遍。</p><a id="more"></a><hr><h3 id="二-事务隔离级别："><a href="#二-事务隔离级别：" class="headerlink" title="二. 事务隔离级别："></a>二. 事务隔离级别：</h3><p><strong>RU：Read UnCommitted<br>RC：Read Committed<br>RR：Repeatable Read （default）<br>Serializable</strong></p><p>总结：<br>RU可以读取未提交的数据，因此存在脏读的问题。<br>RC只能读取已经提交的数据，因而解决了脏读的问题，但存在不可重复读的问题<br>RR保证了可以重复读的问题。<br>RR与Serializable都解决了大部分的问题，因此默认就是RR。（当然，在需求高性能的情况下，会使用RC）</p><p>查看MySQL的隔离级别：<br><code>select @@tx_isolation</code> 查看当前会话的事务隔离级别<br><code>select @@global.tx_isolation</code> 查看系统全局的隔离级别<br>设置隔离级别：<br><code>set session/global transaction isolation level xx;</code><br>(xx can be <strong>read uncommitted, read committed, repeatable read, serializable</strong>)</p><hr><h3 id="三-锁机制："><a href="#三-锁机制：" class="headerlink" title="三. 锁机制："></a>三. 锁机制：</h3><p>MySQL锁的类型：（有多种分法）<br><strong><em>①根据锁的兼容情况，可以分为4种：</em></strong><br><strong><em>Shared locks，Exclusive locks</em></strong>（共享锁，排他锁，即S锁，X锁，在其他数据库也有这两种）<br><strong><em>Intention Locks</em></strong>：意向锁，分为共享意向锁IS，共享排他锁IX锁。（作用后续说，<strong>针对MySQL的行锁而出现</strong>）</p><p><strong><em>②根据锁的锁定范围，可以分为三种：</em></strong><br><strong><em>表锁 Table Locks，行锁 Record Locks，页锁 Page Locks</em></strong><br>（在MyISAM中为Table Locks，而在<strong>InnoDB中只有Record Locks</strong>。Page Locks存在于BerkeleyDB）<br>表锁和行锁的区别：<br><strong>表锁的开销较小，不会产生死锁，锁定范围大，但并发度最低<br>行锁的开销较大，可能产生死锁，锁定范围较小，并发度更高</strong><br>页锁此处不解释（我也不会）</p><p><strong><em>③InnoDB下的Lock Type：</em></strong><br>由于目前重点使用的MySQL引擎一般是InnoDB，因此对InnoDB进行更细致的了解。<br><strong>InnoDB的行级锁（InnoDB不存在表级锁，只是在特定情况下看起来像是表级锁的形式而已）：</strong><br><em>1.Record Locks：A record lock is a lock on an index record.</em> 即锁定一个index的record。<br><em>2.Gap Locks：A gap lock is a lock on a gap between index records, or a lock on the gap before the first or after the last index record.</em> 即锁定record之间的的间隙。<br>（Gap Locks存在于RR与Serializable，不存在于RC。RU一般不会用，不考虑，而且也没有）<br><em>3.Next-Key Locks:A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.(3 = 1 + 2)</em><br><del>PS：此处有一个小test，事务隔离级别是与系统全局的设置有关的（即使两个Session transaction isolation level都设置为RC，但如果Global transaction isolation level设置为RR，那么就按照RR的情况来执行，即此时存在Gap Locks。所以不清楚Session level有何作用）</del></p><hr><p>不同情况的加锁情况：<br>要考虑这个问题，先整理一些基础知识：</p><p><strong><em>①首先要了解锁之间的兼容性（S锁，X锁，IS锁，IX锁）：</em></strong></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_1.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_1.png" alt="MySQL中InnoDB引擎中锁的兼容性"></a><br>PS：这是<strong>仅限于Table-level的compatibility</strong>，网上传的很多都忽略了这个。</p><p><strong>关于意向锁：主要是用于解决行锁和表锁的冲突。</strong>试想一下，当事务A锁住了表中的一行（假设为S锁)，而事务B需要申请整个表的X锁。那么事务B需要做的事情：<br>1.判断表是否被其他表锁锁住（无论X,S），这个很简单.<br>2.判断表中的每一行是否被行锁锁住（无论X,S，因为X与二者均不兼容）。<br><strong>如果只有X,S锁，那么我们需要逐行检查，如果有1个亿的data，那么就需要查询1亿行。</strong><br>如果添加了意向锁呢？意向锁的作用方式：<br>当一个事务需要获取一个<strong>行锁</strong>的X锁，先获取一个IX锁。<br>当一个事务需要获取一个<strong>行锁</strong>的S锁，先获取一个IS锁。<br>（记住，<strong>上面的表格是仅限表锁的情况</strong>，如果需要获取表锁的X/S锁，那么不需要获取IX,IS锁。另外，<strong>IX,IS锁是数据库后台自动获取的，无须我们显式调用</strong>）<br>这个时候，当另一个事务，要申请X锁，第一步依然是判断是否被其他表锁锁住。<br>第二步就改成了，判断该表是否存在IX,IS锁。（如果存在IX，IS锁，说明该表存在X，S锁，不管是哪一行）<strong>仅仅通过判断是否存在意向锁，就省去了遍历所有行的操作。</strong><br>（PS：如果另一个事务要申请的是S锁，同样如此，只是不需要判断IS锁，而是判断IX锁）<br>记住：<strong>意向锁与表级的X锁不兼容，但与行级的X锁是兼容的</strong><br>（不然你先获取了IX锁，如何继续获取X锁呢？）</p><hr><p><strong><em>②数据库的并发控制协议</em></strong></p><p><em>MVVC：Multi-Version- Concurrency Control。</em>即基于多版本的并发控制协议。<br>它最大的好处：读操作不加锁，读写不冲突，可以极大地增强并发性。<br><em>Lock-Based Concurrency Control。</em>即基于锁的并发控制。<br>（如果我们每一种操作都需要获取lock，由lock来完全实现并发控制，那么并发性会相当地差。其实也就是相当于Serializable，完全串行化执行。所以<strong>现阶段，大部分的数据库都不会是完全的基于lock去实现并发控制，而是实现了MVVC模式</strong>）</p><p>在MVVC并发控制中，读操作可以分为两种；<strong>snapshot read</strong>(快照读）,<strong>current read</strong>(当前读）<br>所谓snapshot，就是系统在某一个时刻的印象，所以此时读取到的不一定是最新的数据，可能是某个历史版本的数据，那么这时候就不需要加锁。（因为本来就不一定是最新的数据，那么两次snapshot read不一致也是很正常的，所以怎么能算是脏读幻读呢（滑稽）！）<br>current read就不一样了，它就是要读取系统最新的数据，所以此时需要对读操作进行加锁，然后再基于Lock-Based去进行并发控制。</p><p><strong>在MySQL InnoDB中，snapshot read又称简单的select</strong>，一般形式为：<br><code>select *from table where ？;</code> # 存在例外，后面分析<br>current read：<br><code>select* from table where ? lock in share mode || for update || for share</code>(8.0之后的版本)<br>(如果直接显式要lock了，那么都lock了，当然就是要current read，而不是读取snapshot了）<br>insert，update，delete（这些操作当然不能读snapshot，不然你update一个已经被delete掉的数据吗)<br>(从底层源码来说，update，delete都包含一个current read，而insert，需要检查unique key冲突）</p><hr><p><strong><em>③聚簇索引（cluster index）：</em></strong></p><p>这是由MySQL<strong>自动生成</strong>的一个index（无法人为控制），它一般是直接把主键设置为<strong><em>cluster index</em></strong>，所以又称主键index。<br>（如果表没有创建主键？那么按照以下规则来创建cluster index：（一般还是要显式给表一个PK）<br>1.会用一个唯一的非空的index列，作为cluster index<br>2.如果没有这样的index，那么InnoDB会隐式生成一个主键来作为cluster index<br>其他人为定义的索引，称为辅助索引（<strong><em>secondary index</em></strong>），也可以称为非聚簇索引。<br>关于这两个index的具体区别，查找时的路径有何不同，可以参考这篇文章：<br><a href="https://www.cnblogs.com/rjzheng/p/9915754.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9915754.html</a><br>关键点：每创建一个index，那么就会生成一个B+树，因此index不能乱加，会导致index的时候需要同时维护多个index，导致效率低下）</p><p>PS：这里有一个关键点，就是<strong>cluster index是无论如何都会存在的。</strong>（不管你有没有创建其他index，每个表都会存在一个cluster index）<br>根据网上很多的文章，都提及到一个内容：InnoDB只有在使用index的时候才是使用行锁，否则会变成表锁。<strong>这句话是错误的</strong>。因为即使我们没有创建index，在select的时候也没有使用index列，那么一样会使用一个隐式创建的cluster index去寻找数据，所以<strong>InnoDB只存在行锁，不存在表锁。</strong><br>官方文档：<br><strong><em>Record Locks<br>A record lock is a lock on an index record. For example, SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE; prevents any other transaction from inserting, updating, or deleting rows where the value of t.c1 is 10.<br>Record locks always lock index records, even if a table is defined with no indexes. For such cases, InnoDB creates a hidden clustered index and uses this index for record locking. See Section 15.6.2.1, “Clustered and Secondary Indexes”.</em></strong><br>可是很多人表示自己亲自测试过，发现确实是整个表都锁住了呀，难道不是表锁吗？这主要是因为对底层了解不足，只开了两个session发现无法同时select就感觉是整个表都锁起来，是不正确的。这时候最正确的做法是：查看MySQL的状态表，查看当前存在的锁，然后<strong>直接查看锁的类型</strong>。毕竟网上说的都不权威，但MySQL它自己创建的表是最权威的！<br>我们这里创建两个session，发现存在lock，waiting的情况，这时候在另一个无须waiting的session执行： <strong>use information_schema;</strong> 进入到MySQL自带的information_schema数据库中<br>然后执行： <strong>select* from innodb_locks;</strong> 即可找到当前存在的locks。<br>（也可以使用 <strong>show engine innodb status;</strong>查看，不过可读性较差，需要仔细观察）<br>下面给出两个命令的结果：（第一个是select* from innodb_locks;)</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_2.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_2.png" alt="select* from innodb_locks的显示结果"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_3.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_3.png" alt="show engine innodb status的显示结果"></a></p><hr><p>PS：<strong>MySQL8.0与之前的版本不一致（5.7及以前）</strong>。如下：（如果不是使用8.0可以跳过）<br>MySQL5.7及之前，可以通过<code>information_schema.innodb_locks</code>查看事务的锁情况，但，只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。<br>MySQL8.0删除了information_schema.innodb_locks，添加了<code>performance_schema.data_locks</code>，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁，也就是说即使事务并未被阻塞，依然可以看到事务所持有的锁（不过，正如文中最后一段所说，performance_schema.data_locks并不总是能看到全部的锁）。表名的变化其实还反映了8.0的performance_schema.data_locks更为通用了，即使你使用InnoDB之外的存储引擎，你依然可以从performance_schema.data_locks看到事务的锁情况。<br>那么为何RECORD LOCKS会表现出类似于表锁的形式？这是因为InnoDB在没有使用index的时候，会使用cluster index（所以依然是行锁）此时会生成record locks和gap locks，并且是把每一个record，每一个gap都锁住，表现形式就像是整个表都被锁住的情况（但仍然是行锁）。<br>有的人可能觉得，这不是在挑文字游戏？并不，因为只有在特定情况下，才会出现这种情况，当我们修改一些其他参数，或者使用不同的index，都会出现不同的情况，到那时候就不再是整个表都锁住了。这个在最后的时候会详细说明，现在只需要知道，<strong>InnoDB，绝对不存在Table locks。</strong></p><hr><hr><h3 id="四-不同情况的加锁处理分析"><a href="#四-不同情况的加锁处理分析" class="headerlink" title="四. 不同情况的加锁处理分析"></a>四. 不同情况的加锁处理分析</h3><p>有了这些准备，我们开始讨论不同情况的加锁处理分析（加不加锁，加哪种锁）</p><p>此处参考了大佬的文章：<strong><em><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">http://hedengcheng.com/?p=771</a></em></strong><br><strong>情况①：简单的snapshot read: select* from table where id = 1;</strong><br>这时候<strong>一般不加锁</strong>。但上文也说了，存在例外，那就是当事务隔离级别为Serializable的情况下，由于每一个操作都完全串行化，因而也不存在snapshot了，该操作会升级为current read，因而需要加锁。（同时，Serializable的情况下，MySQL的并发控制协议会从MVVC降级为Lock-Based。一般除非系统冲突非常严重，否则不采用Serializable）</p><p>有了第一个情况，可以发现<strong>加锁的情况是要考虑其他因素的，不能仅仅是给一个SQL语句就问获得了什么锁，还要考虑很多种情况</strong>。一般而言，需要考虑以下几种情况：（假设搜寻的字段为id）<br><strong>1.id是否为主键？<br>2.当前系统的隔离级别是什么？<br>3.id如果不为主键，那么它是否存在index？<br>4.如果id存在secondary index，那么这个index是否是unique index？<br>5.两个SQL的执行计划是什么，索引扫描？全表扫描？</strong>（这里我是参照大佬的文章来写的，但个人认为第五点其实跟前面的重叠了。如果id为主键，那么就是采用了cluster index，即全表扫描。如果id不存在index，同样是采用cluster index。如果id存在index，无论是否是unique，都为索引扫描。）</p><p>现在给定一个表：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_4.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_4.png" alt="测试所用的表结构"></a><br>对于上面的几种情况，不一定每一种都排列组合一遍，把关键的点get到即可。<br>下面通过<strong>8种情况</strong>来考虑：</p><hr><p><strong>①~④：RC级别<br>⑤~⑧：RR级别</strong></p><hr><h4 id="①搜寻字段是主键-PK）"><a href="#①搜寻字段是主键-PK）" class="headerlink" title="①搜寻字段是主键(PK）"></a>①搜寻字段是主键(PK）</h4><p><code>delete from testN where id = 10;</code><br>此时其他事务无法访问id = 10这一行记录<br>情况最简单，直接在主键上id = 10的记录上加上X锁即可（在id字段上锁）。</p><hr><h4 id="②字段不是主键，但存在一个unique-index。"><a href="#②字段不是主键，但存在一个unique-index。" class="headerlink" title="②字段不是主键，但存在一个unique index。"></a>②字段不是主键，但存在一个unique index。</h4><p><code>delete from testN where name = &#39;abc&#39;;</code><br>同样无法访问name = ‘abc’这一行记录，但同时在id和name1字段上锁。<br>这种情况下，由于存在index，所以会在index上查询，这时候会给unique index加上X锁。同时当select的时候，如果没有指定secondary index的字段（*号也不行），那么还会到cluster index里去顺序查找。具体看图：（在上面最开始讲到cluster index里的文章就有具体说明）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_5.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_5.png" alt="聚簇索引"></a><br>所以这个时候，除了给secondary unique index进行加锁，还会对cluster index进行加锁。<br>所以此处是给id，name1字段都加上了锁。（当然，被加锁的record依然是那一条，因为unique）</p><p>为什么聚簇索引上的记录也要加锁？试想一下，如果并发的一个SQL，是通过主键索引来更新：<code>update t1 set id = 100 where name = ‘d’;</code>此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。</p><hr><h4 id="③字段不是主键，而且字段存在一个index，但并不是unique-index"><a href="#③字段不是主键，而且字段存在一个index，但并不是unique-index" class="headerlink" title="③字段不是主键，而且字段存在一个index，但并不是unique index"></a>③字段不是主键，而且字段存在一个index，但并不是unique index</h4><p><code>delete from testN where number = 12;</code><br>这种情况其实跟第②种情况是类似的，只是可能锁住多个record（因为不是unique index）<br>同样也是对number（index列）进行了加锁，然后还会对cluster index列加锁。<br>PS：看起来②和③可以归并在一起，但在RR的时候可以看到很大的不同。</p><hr><h4 id="④字段不是主键，而且不存在index。"><a href="#④字段不是主键，而且不存在index。" class="headerlink" title="④字段不是主键，而且不存在index。"></a>④字段不是主键，而且不存在index。</h4><p>此时会使用cluster index进行扫描，即全表扫描。而且会把所有的record都锁住。因为该条件无法通过索引快速过滤（暂且把cluster index视为很特殊的index吧，不然你都不需要自己创建index了），这时候在存储引擎层面就会将所有的记录加锁后返回，然后由MySQL Server层进行过滤。这是由于MySQL的实现所决定的。（在实际的实现中，进行了一些优化，在过滤条件中，如果发现不满足条件，那么在中途就会把不满足条件的记录释放锁。这样避免了把所有record都锁住导致的低并发，但也违背了二阶段锁的约束。这样最终持有锁的，会是满足条件的记录。但那大概是在事务提交执行的过程中，所以本地编写事务但不commit，依然会表现为全部记录加锁）</p><hr><h4 id="⑤搜寻字段是主键-PK）"><a href="#⑤搜寻字段是主键-PK）" class="headerlink" title="⑤搜寻字段是主键(PK）"></a>⑤搜寻字段是主键(PK）</h4><p>跟①没有区别</p><hr><h4 id="⑥字段不是主键，但存在一个unique-index。"><a href="#⑥字段不是主键，但存在一个unique-index。" class="headerlink" title="⑥字段不是主键，但存在一个unique index。"></a>⑥字段不是主键，但存在一个unique index。</h4><p>跟②没有区别</p><hr><h4 id="⑦字段不是主键，而且字段存在一个index，但并不是unique-index"><a href="#⑦字段不是主键，而且字段存在一个index，但并不是unique-index" class="headerlink" title="⑦字段不是主键，而且字段存在一个index，但并不是unique index"></a>⑦字段不是主键，而且字段存在一个index，但并不是unique index</h4><p>有区别了，为什么？RR相对于RC，解决的问题是幻读，不可重复读。为何⑤跟⑥的加锁却没有任何改变？幻读，不可重复读是指当前事务，连续执行两次current read，返回了不同的数据。而⑤和⑥都是unique index，能够保持唯一性，不用担心值会发生改变（改变值需要X锁，与S锁不兼容）。<br>那么在⑦的时候，字段存在了index，但该index并不是unique index，这时候问题就出现了，如果还是按照③的做法，那么就可能出现幻读跟不可重复读的情况。<br>举一个例子，按照我们上面给的table的来示例：（假设采用③的只对record进行加锁的模式）<br>字段名为： id， name1，number1， age (PK为id）<br>执行的current read的语句为：<br><code>select *from testN where number1 = 18 for update;</code>(number1是非unique index列)<br>那么假如当我们在另一个session执行：<code>insert into testN values(xx,xx,18,xx); commit;</code><br>这时候该session中的 transaction是可以成功提交的，因为并没有gap lock，而只是把原本符合条件的 record给锁住了，而不是把所有number1=18的都锁住。<br>这时候再次执行 <code>select* from testN where number1 = 18 for update;</code>就会出现<strong><em>幻读</em></strong>。</p><p>因此，<strong><em>此时会锁住符合记录与相邻记录的间隔。这个就称为间隔锁：gap locks</em></strong><br>假如：字段的取值是：12，32，18，18，20，24，30.选择的条件是 id = 18<br>那么除了锁住两个18的记录，还会锁住12与18，18与20之间的间隔（有序性）<br>所以此时锁住的范围：record locks： 18， 18<br>gap locks： [12, 18) ∪ [18, 20)所以整体锁住的范围就是： <strong>[12, 20)</strong></p><hr><h4 id="⑧字段不是主键，而且不存在index。"><a href="#⑧字段不是主键，而且不存在index。" class="headerlink" title="⑧字段不是主键，而且不存在index。"></a>⑧字段不是主键，而且不存在index。</h4><p>⑧跟⑦不一样的地方是，⑦会把符合条件的record的与前后record的间隔都给锁住，而⑧由于是全表搜索（无index，只有cluster index），因此⑧首先是把所有的records都锁住，然后再把所有records的间隔都锁住（包括±∞）。假如age列（非index列）一共有20，22，30等三个值，那么由行锁record locks和间隔锁gap locks锁住的范围为：<br><strong>(-∞, 20) ∪ [20, 22) ∪ [22, 30) ∪ [30, +∞）（因为表现为整个表都锁住了，所以容易误以为是表锁）</strong><br>（虽说误以为是表锁是错误的理解，但确实要<strong>尽量避免</strong>这种情况，因为这种情况需要加很多锁。当该非index列有n个records的时候，需要加<strong><em>n个record locks，(n+1)个gap locks，一共需要（2n+1)个锁，开销是极其大的。</em></strong>所以尽量通过index来查询，避免加入过多的锁，影响性能。</p><hr><h3 id="附：测试"><a href="#附：测试" class="headerlink" title="附：测试"></a>附：测试</h3><p>数据以上面的testN的数据为例，事务自动提交设置为否：<code>set autocommit = 0</code>（除了在阐述③如何引起幻读的情况下，需要commit，其余都无须commit，只需要显示到被锁住即可。并且这一步会放到最后执行，前面的每一项测试，在测试完毕之后，都执行rollback，避免事务对数据的更改）<br>初始数据：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_6.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_6.png" alt="初始数据"></a><br>确保环境：（1~4在RC，5~8在RR。虽说应该是global才生效，但直接把session跟global都设置一遍) （两个终端都设置）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_7.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_7.png" alt="初始环境(1~4RC,5~8RR)"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_8.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_8.png" alt="初始环境(1~4RC,5~8RR)"></a></p><hr><h4 id="情况①："><a href="#情况①：" class="headerlink" title="情况①："></a>情况①：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_9.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_9.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_10.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_10.png" alt="B终端"></a><br><strong><em>结论：①确实只锁住了id为10的那条记录，其他所有都没有锁。</em></strong></p><hr><h4 id="情况②："><a href="#情况②：" class="headerlink" title="情况②："></a>情况②：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_11.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_11.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_12.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_12.png" alt="B终端"></a><br><strong><em>结论：②确实也是只把name1=’abc’该列锁住了。没有其他任何的锁。</em></strong></p><hr><h4 id="情况③："><a href="#情况③：" class="headerlink" title="情况③："></a>情况③：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_13.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_13.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_14.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_14.png" alt="B终端"></a><br><strong>结论：③，number1为20有两个记录，这两个确实都被锁住了。而且其他都没有锁住，没有gap locks</strong></p><hr><h4 id="情况④："><a href="#情况④：" class="headerlink" title="情况④："></a>情况④：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_15.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_15.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_16.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_16.png" alt="B终端"></a><br><strong>结论：④理论上是锁住所有record，但在判定不符合之后就把锁释放了（即那个违背了二阶段锁的优化操作），所以最后只把age为22的锁住了。</strong></p><hr><p>RC环境转RR环境：<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_17.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_17.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_18.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_18.png" alt="B终端"></a></p><hr><h4 id="情况⑤："><a href="#情况⑤：" class="headerlink" title="情况⑤："></a>情况⑤：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_19.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_19.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_20.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_20.png" alt="B终端"></a><br><strong>结论：⑤与①相同，没有任何变化。</strong></p><hr><h4 id="情况⑥："><a href="#情况⑥：" class="headerlink" title="情况⑥："></a>情况⑥：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_21.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_21.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_22.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_22.png" alt="B终端"></a><br><strong>结论：Ⅵ与②相同，没有任何变化。</strong></p><hr><h4 id="情况⑦："><a href="#情况⑦：" class="headerlink" title="情况⑦："></a>情况⑦：</h4><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_23.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_23.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_24.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_24.png" alt="B终端"></a><br><strong>锁住18，与预期相同。</strong>18相邻的元素为12，20，因而把 [12, 18)∪ [18, 20)给锁住了。（锁的范围是左闭右开，因而12无法insert，但20是可以insert的）</p><p><strong>下面再测试锁住20的情况。</strong><br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_25.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_25.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_26.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_26.png" alt="B终端"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_27.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_27.png" alt="B终端"></a><br><strong>锁住20，同样跟预期相同，会把[18, 20) ∪ 20 ∪ [20, 40)都锁住</strong></p><p><strong>假设选择的值是最小/最大，是否也像no index的情况下，锁住±∞？</strong><br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_31.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_31.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_32.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_32.png" alt="B终端"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_33.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_33.png" alt="B终端"></a><br>答案是会的。所以也跟预期一样。</p><p><strong>结论：⑦与③不同，在RR的情况下会使用gap locks，锁住间隔。</strong></p><hr><h4 id="情况⑧："><a href="#情况⑧：" class="headerlink" title="情况⑧："></a>情况⑧：</h4><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_28.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_28.png" alt="A终端"></a><br>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_29.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_29.png" alt="B终端"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_30.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_30.png" alt="B终端"></a><br>表就像完全锁住一样，因为record locks &amp; gap locks 把整个表都锁住了。<br><strong>结论：⑧在RR的情况下，会把所有的record都锁住，也会把所有的gap锁住。</strong></p><hr><p>最后，测试RC环境下，③可能会导致<strong>幻读</strong>的情况：（RR已经确定不会出现幻读）<br>环境参数：（RR改回RC）<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_34.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_34.png" alt="A终端"></a></p><p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_35.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_35.png" alt="B终端"></a></p><p>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_36.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_36.png" alt="A终端"></a></p><p>中间，在另一个终端B执行：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_37.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_37.png" alt="B终端"></a><br>可见session1的lock并没有锁住session2创建number1为18的值。只要unique行没有duplicate，那么就可以insert，insert更多例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_38.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_38.png" alt="B终端"></a></p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_39.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_39.png" alt="A终端"></a></p><p>PS：<strong>以上讨论的是什么时候加锁</strong>。至于加什么锁，应该很好判断。如果是select lock in share mode，那就是加S锁，select for update，就是加X锁。</p><hr><hr><p><strong><em><code>当范围比较的时候，又有所不同！当范围比较的时候，又有所不同！</code></em></strong></p><p>(上面考虑的都是等值筛选的情况） 以下就不考虑等值的情况<br>使用数据：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_40.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_40.png" alt="使用数据"></a></p><hr><h4 id="①使用PK的情况（cluster-index）"><a href="#①使用PK的情况（cluster-index）" class="headerlink" title="①使用PK的情况（cluster index）"></a>①使用PK的情况（cluster index）</h4><p>SQL句子： （用4个句子来解释）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select* from testf where pid &gt; 30 for update;</span><br><span class="line">select* from testf where pid &gt; 33 for update;</span><br><span class="line">select* from testf where pid &gt; 50 for update;</span><br><span class="line">select* from testf where pid &lt; 30 for update;</span><br></pre></td></tr></table></figure><p><strong>对于RC：</strong><br>句子1：首先符合条件的记录为pid = 33， pid = 47.对这两个records加上X锁。<br>句子2：首先符合条件的记录为pid = 47，对着一个record加上X锁。<br>句子3：没有符合条件的记录。<br>句子4：两个符合，加锁。<br>此时执行select：句子1可以获取pid = 11，12，的记录，句子2可以获得11，12，33，句子3全部可以<br>此时执行insert：除了相同的pid（duplicate），没有任何限制。(但insert相同的pid时，还是会起冲突哦。先是waiting获得lock，然后获得了之后才发现，duplicate，insert失败。即添加被record lock锁住的记录，仍然要waiting，而其他就无须获取锁的就直接duplicate。下同）<br><strong>对于RR：（增加gap locks）</strong><br>句子仍然对符合的records加上X锁，之后，开始增加gap locks：<br>句子1：<br>gap locks：对于 pid &gt; 30，因而需要找一个左边界，找一个左边最接近30的record，在这里即为22.因此，gap locks的范围：<strong><em>[22, 33) ∪ [33, 47) ∪ [47, ＋∞)</em></strong><br>对于insert，不能insert record locks &amp; gap locks范围里的pid。合理。<br>对于select，也还是跟RC情况一样。因为被record locks锁住的在RC就不能访问，而被gap locks锁住的范围无法insert，因而select也肯定是empty set。那么，就不会出现幻读。<br>句子2：<br>与句子1的唯一区别是，33刚好就在表里，那么左边界到底是22还是33？<br>好的，答案是33，因为判定条件≠33啊。剩下的也就一样了，<strong><em>gap locks：[33, 47)∪[47, +∞)</em></strong><br>句子3：<br>这个有点特别的是，没有record。但其实是一样的，找边界，因而这里这里的边界显然就是47，<strong><em>gap locks： [47, +∞)</em></strong><br>句子4：<br>值得注意的是，左边界是无穷，右边界显然是33.但这里的右边界竟然是闭合的！<br>所以此处<strong><em>gap locks：(-∞, 33]</em></strong>,因而只能insert 34之后的pid。所以select的时候就只能select 47了，33是不可以的。insert也不能包括33.</p><hr><h4 id="②不使用PK，使用unique-index"><a href="#②不使用PK，使用unique-index" class="headerlink" title="②不使用PK，使用unique index"></a>②不使用PK，使用unique index</h4><p>修改了一下表的结构跟数据：num具备一个unique index<br>测试了一下，<strong>发现跟PK一模一样。懒得说。（内部实现实际上有区别的，如果说要什么区别的话，那就是上面刚开始说的①和②的区别啊！②会先给unique index加锁再给cluster index加锁。</strong><br>(其实就是cluster index那一篇拓展文章)</p><hr><h4 id="③不使用PK，使用non-unique-index-从这里开始很特别。"><a href="#③不使用PK，使用non-unique-index-从这里开始很特别。" class="headerlink" title="③不使用PK，使用non-unique index 从这里开始很特别。"></a>③不使用PK，使用non-unique index 从这里开始很特别。</h4><p>直接讨论RR：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select* from testf where num &gt; 200 for update;</span><br><span class="line">select* from testf where num &gt; 150 for update;</span><br><span class="line">select* from testf where num &gt; 400 for update;</span><br><span class="line">select* from testf where num &lt; 250 for update;</span><br></pre></td></tr></table></figure><p>对于句子1：<br>终端A：<br><a href="hhttps://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_41.png"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_41.png" alt="A终端"></a></p><p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_42.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_42.png" alt="B终端"></a><br>显然，select还是只把符合的记录给锁住了，即只锁住了300，100跟200均可select。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_43.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_43.png" alt="B终端"></a><br>对于insert，依然是找到相应的边界值（这里显然是200），于是锁住了[200, +∞)，因而可以insert 199</p><p>对于句子2：（<strong>看起来应该会跟句子1一样，但结果……</strong>）<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_44.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_44.png" alt="A终端"></a></p><p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_45.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_45.png" alt="B终端"></a><br><strong>select竟然全部记录都获取不到了，除了不存在的空记录</strong>。那么insert呢？<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_46.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_46.png" alt="insert情况"></a></p><p>既然已经是所有record都上锁了（record locks），那么理应把record之间的间隔也上锁（RR），结果insert确实如此，全部都无法insert。<br>（而句子1跟句子2的区别，仅仅只有150跟200，200存在于里面，而150不在。<strong>推测：索引为B+树类型，所以当存在相同的元素时，就可以直接根据B+树的有序性进行合理上锁，即对符合条件的记录上锁</strong>。那么如果不存在相同的元素，即不存在150，而且又不是unique index，仅仅是使用了一个non-unique index并且被动地去cluster index中查找，这时候就会把所有记录上锁，因为cluster index是一个特殊的index，具体的细节我也不懂，得去看源码。但现在只需要知道，<strong>cluster index无法标记到相同的元素，就无法进行定位了，然后就直接把所有record都锁了，当然在RR下还有gap locks</strong>）</p><p>对于句子3：<br>终端A：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_47.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_47.png" alt="A终端"></a></p><p>终端B：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_48.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_48.png" alt="B终端"></a><br>可见，由于里面没有符合条件的记录，所以select没有被阻塞。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_49.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_49.png" alt="B终端"></a></p><p>可是，insert却是会被阻塞的。而且阻塞范围就是寻找边界。这里上锁的区域是[300, ＋∞)<br>（虽然400不存在于表中，但由于没有符合的记录，就没有把record给上锁了，所以也仅仅是添加了gap locks。但gap locks包含300，却只能search不能insert。看来只能看源码才能切实看懂了！先记住罢！）</p><p>对于句子4：<br>跟句子2是一样的，select全部锁住了，毫无意外的话，insert应该也会被全范围的gap locks给锁住。（// TODO = =！）<br>确实如此，就不贴图了。</p><p>本来不想测试RC的，但RR的结果有点出人意料，所以现在再把RC也测试一遍：<br>句子1：<strong>select还是一样，符合条件的锁住。insert没有任何阻塞</strong>（因为不存在gap locks）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_50.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_50.png" alt="B终端"></a><br>句子2：跟RR的不一样，并不会全部锁住，而且也不会把记录都锁住。<br>select依然是符合条件的才锁住。而insert依然是没有任何阻塞（没有gap locks）<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_51.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_51.png" alt="B终端"></a><br>句子3：还是一样。select该锁的锁，insert无阻塞。<br>句子4：一样。pass<br>（RC的insert无阻塞是毫不意外的，首先RC不存在gap locks，至于已经存在的record则会因为PK/cluster index而产生冲突，并不是因为gap Locks）</p><hr><h4 id="情况④：不使用PK，也不使用index"><a href="#情况④：不使用PK，也不使用index" class="headerlink" title="情况④：不使用PK，也不使用index"></a>情况④：不使用PK，也不使用index</h4><p>RC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select* from testf where num &gt; 200 for update;</span><br><span class="line">select* from testf where num &gt; 150 for update;</span><br><span class="line">select* from testf where num &gt; 400 for update;</span><br><span class="line">select* from testf where num &lt; 250 for update;</span><br></pre></td></tr></table></figure><p>句子1：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_52.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_52.png" alt="B终端"></a><br>select全部锁住了，而且不仅仅是记录，包括gap。而RC是不存在gap locks的。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_53.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_53.png" alt="B终端"></a><br>而insert却是依旧跟预期一样，毫无阻塞（因为RC没有gap locks）</p><p>句子2：select也是一样全部阻塞。而insert也是毫无阻塞</p><p>句子3：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_54.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/sql_54.png" alt="B终端"></a><br>select毫无阻塞，因为没有找到记录。insert也是毫无阻塞。</p><p>句子4：还是那样，select完全阻塞，insert没有阻塞。</p><p>RR：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select* from testf where num &gt; 200 for update;</span><br><span class="line">select* from testf where num &gt; 150 for update;</span><br><span class="line">select* from testf where num &gt; 400 for update;</span><br><span class="line">select* from testf where num &lt; 250 for update;</span><br></pre></td></tr></table></figure><p>句子1：<br>select依然全部被阻塞（RC都阻塞， RR岂有不阻之理？）<br>insert也是全部阻塞，因为RR多了gap locks，自然也就全部范围都锁住了。<br>句子2跟句子4显然结果也会是一样的。<br>那么再看句子3，竟然也是全部阻塞。</p><p>上面都是详细的推导环节，虽然还有所疑惑，但至少结果是没有错的，先总结了吧（关于insert并发这个，以后再说吧。这个应该满足了select/delete/update与insert之间的所有关系了，只差并发insert这一环节） PS : insert还有一个insert意向锁</p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>分两大类情况：等值筛选（id = x），范围筛选（id &gt; x)<br>以下操作只考虑select跟insert（delete跟update约等于select。）</p><p>先看<strong>等值筛选</strong>：</p><p><strong><em>① RC / RR + PK</em></strong></p><p>锁住该条记录的。select，insert均不能使用相同的字段值（insert是因为同名，select是因为锁）</p><p><strong><em>② RC / RR + Unique Index</em></strong></p><p>跟①一样，只是底层实现有所不同（先对Unique Index的记录加锁，再对cluster index的记录加锁）</p><p><strong><em>③ RC + Non-unique Index</em></strong></p><p>锁住所有符合条件的记录（因为不是unique，可能选出多条记录）</p><p><strong><em>④ RC + No index(无索引）</em></strong></p><p>锁住所有的记录（MySQL优化后，对判断不满足条件的记录，进行释放锁操作。违背了2PL协议）</p><p><strong><em>⑤ RR + Non-unique Index</em></strong></p><p>锁住符合条件的记录，并且新增gap locks。会锁住记录与其相邻记录的中间间隔（按照有序排列）<br>gap locks一般按照 左闭右开的原则。</p><p><strong><em>⑥ RR + No index</em></strong></p><p>锁住所有的记录，具备gap locks。因为所有记录都锁住，所以从-∞到＋∞其实都被锁住了。<br>n条记录时，n个Record Locks， n + 1 个gap locks，一共 2n+1 个锁。</p><p><strong>范围筛选</strong>：（PS：如果两个select都是S锁，那当然是可以同时存在的，S锁之间兼容）</p><p><strong><em>① RC + PK / Unique Index / Non-Unique Index</em></strong></p><p>(RC条件下，只要使用Index，无论是Unique Index还是Non-Unique）<br>锁住符合的记录，可以select没有锁的记录，insert无限制。</p><p><strong><em>② RR + PK / Unique Index</em></strong></p><p>锁住符合的所有记录，还有gap locks。同样是可以select没有锁的记录，insert无限制。</p><p><strong><em>③ RR + Non-unique Index</em></strong></p><p><strong>Ⅰ. 当表中存在比较的值（即id &gt; x, table存在 id = x的记录）</strong></p><p>同①</p><p><strong>Ⅱ. 当表中不存在比较的值（id &gt; x, table不存在id = x的记录）</strong></p><p>select全部阻塞（除了不存在的记录），insert全部阻塞（record已经阻塞，加上gap必然的结果)</p><p><strong>Ⅲ. 当select返回的是empty set （例子：where id &gt; 100，而table中不存在id大于100的记录）</strong></p><p>同① （其实跟 Ⅰ 也是等价的，只是符合的记录为empty set）</p><p><strong><em>④ RC + No Index</em></strong></p><p><strong>Ⅰ. select返回的值非空</strong></p><p>select完全阻塞（包括不存在的记录也无法select），insert无阻塞（RC不存在gap）</p><p><strong>Ⅱ. select返回的是empty set</strong></p><p>select跟insert都没有阻塞</p><p><strong><em>⑤ RR + No index</em></strong></p><p>select跟insert必定全部阻塞。</p><p>PS：在RR的情况下，对于并非全锁的情况，Gap Locks的边界值考量方法都是一样的（都是找左右相邻最近的，即使你是empty set，那么就找table中最大/最小的那个当边界，都是一样的，此处略）<br>并且，此处主要考虑的是RC跟RR级别下的情况。<strong>对RU跟Serializable并无太多讨论</strong>。而且只考虑了select与insert，select与select之间的冲突（据说select跟delete，update都是一个形式，那么就略了），还剩下的是Insert与Insert之间的冲突，即并发插入，TODO吧。</p><p>PPPS：写完之后再整理，想到了大佬文章里的第五点，<strong>SQL语句的执行计划是什么？是索引扫描还是全表扫描？</strong>我当时认为这点可以忽略，因为我认为cluster index必定存在，所以即使是全表扫描也是等同于索引扫描，只是扫描cluster index的时候存在一点特殊（就是上文提到的那点）现在看来，cluster index虽然是index，但确实是特殊的index，当我们需要使用全表扫描，<strong>即使是使用了cluster index，也是不能完全等同于索引扫描的</strong>。想想最后在范围搜索那里，出现的意外情况无法理解的，应该就是这一点了吧。（因为当时的注意力主要在考虑InnoDB是否存在表锁，然后最后的主要论据就是必定存在cluster index，所以必定有索引，表现出表锁的特征其实是行锁加间隔锁的作用等等……实际上，这一点倒是没有错，但cluster index是特殊的index也不可忽视！）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;本文的最终解决的问题：&lt;strong&gt;如何判断一条SQL语句用到了哪些锁？&lt;/strong&gt;&lt;br&gt;（特别地，这里考虑的是&lt;em&gt;MySQL&lt;/em&gt;数据库的锁机制）&lt;/p&gt;
&lt;p&gt;首先，我们需要先对&lt;em&gt;MySQL&lt;/em&gt;的事务机制，锁机制，索引机制都总结一遍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://hongscar.cn/categories/MySQL/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>JVM知识整理</title>
    <link href="https://hongscar.cn/JVM%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html"/>
    <id>https://hongscar.cn/JVM%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html</id>
    <published>2020-02-17T03:48:09.000Z</published>
    <updated>2020-02-17T14:51:51.277Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-类的生命周期：加载→连接→初始化→使用→销毁"><a href="#一-类的生命周期：加载→连接→初始化→使用→销毁" class="headerlink" title="一. 类的生命周期：加载→连接→初始化→使用→销毁"></a>一. 类的生命周期：加载→连接→初始化→使用→销毁</h3><h5 id="连接-包括："><a href="#连接-包括：" class="headerlink" title="连接 包括："></a>连接 包括：</h5><p>①验证（确保被加载的类的正确性）<br>②准备（为静态变量分配内存，并将其初始化为默认值（指0，false，null等），同时将static final值转换为具体的常量<br>③初始化：为静态变量执行赋值语句（static，非final），执行静态块<br>PS：初始化只有在对类主动使用时才会执行，包括以下：<br>①new<br>②访问静态域的时候<br>③反射（如Class.forName)<br>④初始化某个类时，其父类也会初始化<br>⑤运行main方法时，该类加载</p><a id="more"></a><hr><h5 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器:"></a>类加载器:</h5><p><em>①Bootstarp ClassLoader</em>（启动类加载器，由C++实现的类，无法获取实例）<br>负责加载JDK下/lib的类库（如java.*等关键类，是最底层的Class Loader)</p><p><em>②Extension ClassLoader</em>（拓展类加载器<br>负责加载JDK下 /lib/ext目录，即额外的类库</p><p><em>③Application ClassLoader</em>（应用程序类加载器负责加载用户类路径的类，即ClassPath</p><p><em>④其他自定义的类加载器    User Class Loader</em><br>PS：这里的加载器并不是通过继承组成的关系，而是组合。    ②③④都继承自java.lang.ClassLoader</p><hr><h4 id="question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）"><a href="#question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）" class="headerlink" title="question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）"></a>question1：为什么类加载机制是双亲委派模型（即优先加载父类加载器的类）</h4><p>ans：双亲委派模型：当一个Class loader收到了加载类的请求，它不会立刻加载，而是先交给父类加载器加载，但父类加载器找不到那个类，才传递回给子类加载器。即优先在Bootstarp中加载，然后是Extension，然后就才是Application。<br>这样做的好处：<br>①只有1个classloader加载了类，防止内存中会出现同样的字节码<br>②增强了安全性，避免用户自己定义了java预定义的类并成功覆盖。比如用户自定义了一个java.lang.Object的类，这时候它会优先从Bootstrap中加载，而Bootstrap中加载的是java预定义的Object类，而不是用户自定义的Object类，这样就避免了用户的Object类覆盖。如果是先从Application Class loader中加载，那么就是先加载用户自定义的Object类，而Java预定义的Object类被覆盖掉。</p><hr><hr><h3 id="二-JVM的内存结构："><a href="#二-JVM的内存结构：" class="headerlink" title="二. JVM的内存结构："></a>二. JVM的内存结构：</h3><p><strong>JDK1.6： Heap + PermGen（Method Area）永久区，方法区 + Stack + Program Counter Register</strong><br>同时：<strong>①Stack = JVM Stack + Native Method Stack</strong><br>Stack用于描述Java方法执行的内存模型，每个方法执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表，操作栈，动态链接，方法出口，基本类型和对象的引用等等。每一个方法从被调用直至执行完成的过程，就对应一个栈帧在JVM Stack中从入栈到出栈的过程。<br>（Native同理，只是作用与本地方法）<br>PS：如果线程请求的栈深度大于JVM所允许的深度，抛出StackOverflowError。<br>如果JVM Stack可以动态拓展，拓展时无法申请到足够的内存，抛出OutOfMemoryError</p><hr><p><strong>②Heap = Young Generation年轻代 + Old Generation 老年代</strong><br><strong>Young = Eden + From Survivor  + To Survivor</strong><br>通过各种参数可以控制各区域的内存大小，进而达到JVM调优效果<br>-Xms， -Xmx：设置Heap的最小，最大空间的大小<br>-XX:NewSize， -XX:MaxNewSize： 设置年轻代最小，最大空间的大小<br>-XX:PermSize, -XX:MaxPermSize： 设置永久区最小， 最大空间的大小<br>-Xss：设置每个JVM Stack的大小<br>（PS：Perm是永久区，要设置老年代只能通过 Heap - Young来间接控制）<br>PS：在Heap区中，有可能抛出OutOfMemoryError</p><hr><p><strong>③Program Counter Register</strong><br>较小的内存空间，是当前字节码的行号指示器（用于分支，跳转等待）<br>如果执行的是Java方法，记录正在执行的JVM字节码的指令地址。<br>如果是Native方法，那么为空（Undefined）<br>（此区域是JVM唯一无OutOfMemoryError的区域，因为一般不会在这里抛异常）</p><p><strong>④PermGen（Method Area）方法区，永久区</strong><br>用于存储已经被JVM加载的类信息，常量，静态变量，JNI编译后的代码·<br>（会抛出OutOfMemoryError）<br>PS：Heap 和Method Area在线程间是会共享资源的，而Stack和Counter是线程私有的。</p><hr><p><strong><em>JDK各版本的区别： (1.6 ~ 1.8)</em></strong><br>JDK1.6中，各种常量池是放在方法区中的<br>JDK1.7中，常量池放在Heap中，此时：Heap = Young + Old + 各种常量池<br>（PS：关于常量池，这里还有一个TODO，即intern那中问题，看《JVM入门到放弃》）<br>JDK1.8:常量池依然在Heap中，但永久区/方法区被移除，改为使用metaSpace（元空间）</p><hr><hr><h4 id="question2：移除永久区PermGen的原因"><a href="#question2：移除永久区PermGen的原因" class="headerlink" title="question2：移除永久区PermGen的原因"></a>question2：移除永久区PermGen的原因</h4><p>①永久区一直只存在于HotSpot JVM，而JRockit VM没有永久区，为了融合两个JVM而做出的调整，无须继续配置永久区<br>②永久区内存经常不够用，或者发生内存泄漏，抛出OutOfMemoryError：PermGen<br>③永久区会为GC带来不必要的复杂度，并且回收效率偏低</p><hr><h4 id="question3：元空间metaSpace和永久区的区别？"><a href="#question3：元空间metaSpace和永久区的区别？" class="headerlink" title="question3：元空间metaSpace和永久区的区别？"></a>question3：元空间metaSpace和永久区的区别？</h4><p>元空间并不在VM中，而是使用本地内存，默认情况下，仅受本地内存的限制。（可以通过配置参数来控制meta Space，默认情况下，最大空间没有限制，即内存的上限）。配置参数：<br>-XX：MetaspaceSize， -XX：MaxMetaspaceSize    初始空间大小，最大空间大小<br>-XX：MinMetaspaceFreeRadio， -XX：MaxMetaspaceFreeRadio：<br>在GC之后，最小/最大的Metaspace剩余空间容量的百分比</p><hr><h4 id="question4：常量池为什么要移动到Heap"><a href="#question4：常量池为什么要移动到Heap" class="headerlink" title="question4：常量池为什么要移动到Heap"></a>question4：常量池为什么要移动到Heap</h4><p>因为方法区的回收比较困难，会导致过多严重的bug，所以从1.7开始就把常量池移动到Heap，为后续移除PermGen做出准备（在JDK1.8已把PermGen移除）</p><hr><h3 id="三-GC算法："><a href="#三-GC算法：" class="headerlink" title="三. GC算法："></a>三. GC算法：</h3><p><strong>①标记-清除 Mark-Sweep</strong><br>缺点：效率不高，且会产生大量的内存碎片<br><strong>②复制算法 Copying</strong><br>缺点：会使内存缩小一半，不能直接用在Old，因为持续复制长生存期的对象会导致效率降低<br><strong>③标记-压缩 Mark-Compact</strong> （在①的基础上，清除完之后还对碎片进行压缩）<br><strong>④分代收集Generational Collection</strong> 即年轻代用 复制算法，老年代用标记清除/压缩</p><hr><p><strong>垃圾回收器</strong>：<br>①Serial，串行收集器。最古老，最稳定，效率高。但会产生较长的停顿<br>②ParNew，即Serial的多线程版本<br>③Parallel，于ParNew类似，但更关注系统的吞吐量<br>④CMS（Concurrent Mark Sweep）<br>重视服务的响应速度，希望系统停顿时间最短，但会产生大量的空间碎片，降低吞吐量。<br>⑤G1（Garbage-First）<br>满足了GC停顿时间要求，同时又具备高吞吐量的特征<br>（收集器之间可以组合使用，如Young使用A，Old使用B）</p><p>MinorGC：对年轻代进行GC。特点：频繁，回收速度快<br>MajorGC：对老年代进行GC。<br>FullGC：全堆范围的GC</p><hr><h4 id="question5：什么情况下会出现内存溢出-泄漏？"><a href="#question5：什么情况下会出现内存溢出-泄漏？" class="headerlink" title="question5：什么情况下会出现内存溢出/泄漏？"></a>question5：什么情况下会出现内存溢出/泄漏？</h4><p>虽说Java有GC，无须我们手动释放资源，但在运行时还是可能出现对象可达，但不会被使用的情况，这时候就会导致内存泄漏。例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/jvm_1.png" target="_blank" rel="noopener" title="Java内存泄漏例子"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/jvm_1.png" alt="Java内存泄漏例子" title="Java内存泄漏例子"></a><br>内存溢出的可能原因：<br>①内存泄漏导致Stack内存不断增大，引发OutOfMemory（Stack处）<br>②大量jar，class文件加载，装载类的空间不足，溢出 （Class Loader处）<br>③操作大量对象，导致Heap空间不足，溢出（Heap处）<br>④nio直接操作内存，内存过大导致溢出（内存处）<br>（同理应该MetaSpace溢出也是一样的）<br>解决方法：查看是否有内存泄漏，设置参数增大空间，代码是否存在死循环生成过多对象</p><hr><h4 id="question6：JVM从Young到Old的晋升条件是什么"><a href="#question6：JVM从Young到Old的晋升条件是什么" class="headerlink" title="question6：JVM从Young到Old的晋升条件是什么"></a>question6：JVM从Young到Old的晋升条件是什么</h4><p>①对象在Eden出生，经过一个MinorGC还存活，就被Survivor容纳，在From和to中复制交换。如果经过[MaxTenuringThreshold]（默认是15）次交换还存活，进入Old<br>②如果对象大小等于Eden的二分之一，直接分到Old。如果Old也分配不下，做一次MajorGC<br>（如果小于Eden的二分之一，但没有足够的空间，进行MinorGC）<br>③MajorGC之后，如果Survivor仍然放不下，则放到Old<br>④动态年龄判断。如果大于等于某年龄的对象超过survivor空间的一半，则这些对象全部都直接进入Old（无须达到MaxTenuringThreshold)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-类的生命周期：加载→连接→初始化→使用→销毁&quot;&gt;&lt;a href=&quot;#一-类的生命周期：加载→连接→初始化→使用→销毁&quot; class=&quot;headerlink&quot; title=&quot;一. 类的生命周期：加载→连接→初始化→使用→销毁&quot;&gt;&lt;/a&gt;一. 类的生命周期：加载→连接→初始化→使用→销毁&lt;/h3&gt;&lt;h5 id=&quot;连接-包括：&quot;&gt;&lt;a href=&quot;#连接-包括：&quot; class=&quot;headerlink&quot; title=&quot;连接 包括：&quot;&gt;&lt;/a&gt;连接 包括：&lt;/h5&gt;&lt;p&gt;①验证（确保被加载的类的正确性）&lt;br&gt;②准备（为静态变量分配内存，并将其初始化为默认值（指0，false，null等），同时将static final值转换为具体的常量&lt;br&gt;③初始化：为静态变量执行赋值语句（static，非final），执行静态块&lt;br&gt;PS：初始化只有在对类主动使用时才会执行，包括以下：&lt;br&gt;①new&lt;br&gt;②访问静态域的时候&lt;br&gt;③反射（如Class.forName)&lt;br&gt;④初始化某个类时，其父类也会初始化&lt;br&gt;⑤运行main方法时，该类加载&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://hongscar.cn/categories/Java/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>数据库三级封锁协议</title>
    <link href="https://hongscar.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.html"/>
    <id>https://hongscar.cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.html</id>
    <published>2020-02-17T03:46:44.000Z</published>
    <updated>2020-02-17T14:52:12.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>数据库并发会导致各种问题（即多线程下导致的同步问题），需要用lock来解决。</p><p>一般会导致的问题：<strong><em>脏读，不可重复读，第一类更新丢失，第二类更新丢失</em></strong></p><p>为了解决这些问题，需要使用锁机制，数据库一般有三级封锁协议。本文阐述了这些问题具体是什么，锁机制如何解决这些问题。</p><a id="more"></a><h3 id="二-数据库并发导致的问题"><a href="#二-数据库并发导致的问题" class="headerlink" title="二. 数据库并发导致的问题"></a>二. 数据库并发导致的问题</h3><hr><p>①<strong><em>脏读</em></strong>（<em>dirty read</em>）：事务A update了data，事务B读取了update后的data，此时事务A rollback，导致B读取的是错误的数据，即dirty data</p><hr><p>②<strong><em>不可重复读</em></strong>（<em>unrepeatable read</em>）：B读取了data，A读取了data并且进行了update，此时B再次读取data，两次获取到的data并不一致。</p><hr><p>③<strong><em>第一类更新丢失</em></strong>：A读取了data①，B读取了data并且进行update，commit。A同时又对data进行update，而这个update是在①的基础上操作的，最终B的更新就会被丢失。</p><hr><p>④<strong><em>第二类更新丢失</em></strong>：B读取了data，A读取了data。B对data进行update，然后commit。接着A又对data进行update，commit。同样的，B的更新会被丢失。</p><hr><h3 id="三-数据库的锁机制"><a href="#三-数据库的锁机制" class="headerlink" title="三. 数据库的锁机制"></a>三. 数据库的锁机制</h3><p>数据库有两种锁，S锁和X锁：<br><strong>S锁（shared）：事务可读不可写。（其他事务可以同时添加S锁）</strong><br><strong>X锁（exclusive）：事务可读可写。（其他事务不可以同时添加任何锁）</strong><br>锁之间的兼容性，设定有两个锁a1，a2，用f(a1, a2)来表示两个锁的兼容性，如果f = 1，则表示兼容。如果f = 0，则不兼容。<br>f(s, s) = 1;其他诸如：f(x, x)= f(x, s)= f(s, x) = 0;<br><strong><em>即X锁不能与其他锁同时存在。而s锁与s锁之间可以同时存在。</em></strong></p><hr><p><strong>1.一级锁协议：</strong>事务T修改数据R之前，先加X锁，直到事务结束时释放（无论是正常结束commit还是非正常结束rollback）<br>作用：可防止 更新丢失问题。<br>不能防止： 脏读，不可重复读，幻读等。<br>PS：任何数据库都至少满足一级锁的协议，因为更新丢失是不能接受的错误，所以更新丢失一般只存在于理论讨论中，实际应用中基本不会出现这个问题。</p><hr><p><strong>2.二级锁协议：</strong>在一级锁的条件下，T在读取R之前先加S锁，读完后释放。<br>作用：可防止更新丢失，脏读。<br>不能防止： 不可重复读，幻读。</p><hr><p><strong>3.三级锁协议：</strong>在一级锁的条件下，T在读取R之前先加S锁，事务结束后释放。<br>作用：可防止 更新丢失，脏读，不可重复读，幻读。</p><hr><hr><h3 id="四-具体例子来说明锁的作用机制："><a href="#四-具体例子来说明锁的作用机制：" class="headerlink" title="四. 具体例子来说明锁的作用机制："></a>四. 具体例子来说明锁的作用机制：</h3><h5 id="①不使用锁导致的更新丢失问题："><a href="#①不使用锁导致的更新丢失问题：" class="headerlink" title="①不使用锁导致的更新丢失问题："></a>①不使用锁导致的更新丢失问题：</h5><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_1.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_1.jpg" alt=""></a></p><h5 id="②使用一级锁解决更新丢失问题："><a href="#②使用一级锁解决更新丢失问题：" class="headerlink" title="②使用一级锁解决更新丢失问题："></a>②使用一级锁解决更新丢失问题：</h5><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_2.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_2.jpg" alt=""></a><br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_3.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_3.jpg" alt=""></a></p><h5 id="③为什么一级锁不能解决脏读问题："><a href="#③为什么一级锁不能解决脏读问题：" class="headerlink" title="③为什么一级锁不能解决脏读问题："></a>③为什么一级锁不能解决脏读问题：</h5><p>脏读例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_4.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_4.jpg" alt=""></a><br>用一级锁的情况：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_5.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_5.jpg" alt=""></a></p><h5 id="④使用二级锁解决脏读问题："><a href="#④使用二级锁解决脏读问题：" class="headerlink" title="④使用二级锁解决脏读问题："></a>④使用二级锁解决脏读问题：</h5><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_6.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_6.jpg" alt=""></a></p><h5 id="⑤为什么二级锁不能解决不可重复读问题："><a href="#⑤为什么二级锁不能解决不可重复读问题：" class="headerlink" title="⑤为什么二级锁不能解决不可重复读问题："></a>⑤为什么二级锁不能解决不可重复读问题：</h5><p>不可重复读例子：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_7.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_7.jpg" alt=""></a><br>使用二级锁的情况：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_8.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/mysql_8.jpg" alt=""></a></p><h5 id="⑥三级锁解决不可重复读："><a href="#⑥三级锁解决不可重复读：" class="headerlink" title="⑥三级锁解决不可重复读："></a>⑥三级锁解决不可重复读：</h5><p>三级锁相当于，完全串行化。即一个事务开始了，其他事务都完全不能开始进行，无论是读还是写。因此就上述的例子，一定是A完全执行完毕，才轮到B执行。那么就必定不会出现不可重复读的问题。（三级锁的完全串行化，也就是，为了解决并行化带来的问题，直接不使用并行，改为串行执行。）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;数据库并发会导致各种问题（即多线程下导致的同步问题），需要用lock来解决。&lt;/p&gt;
&lt;p&gt;一般会导致的问题：&lt;strong&gt;&lt;em&gt;脏读，不可重复读，第一类更新丢失，第二类更新丢失&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了解决这些问题，需要使用锁机制，数据库一般有三级封锁协议。本文阐述了这些问题具体是什么，锁机制如何解决这些问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://hongscar.cn/categories/MySQL/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>Github的简要操作</title>
    <link href="https://hongscar.cn/Github%E7%9A%84%E7%AE%80%E8%A6%81%E6%93%8D%E4%BD%9C.html"/>
    <id>https://hongscar.cn/Github%E7%9A%84%E7%AE%80%E8%A6%81%E6%93%8D%E4%BD%9C.html</id>
    <published>2020-02-17T03:14:58.000Z</published>
    <updated>2020-02-17T06:17:42.730Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下IDEA项目提交到GitHub的整体操作:（主要是清晰每一步的作用，而不是死记硬背）<br><strong>step1:</strong><br>IDEA的GitHub<strong>连通配置</strong>。（这个就在setting-git那里，但一般配置一次就不再需要了，pass）<br><strong>step2：</strong><br>将本地的项目连接到GitHub。 <em>VCS — Import into Version</em> Control （会让你创建一个仓库）<br>然后再将项目切实地与该仓库连接。<em>VCS — Import into Version Control — Create Git Repository</em><br>（有一次没有Create，右键项目甚至没有git操作）</p><a id="more"></a><p><strong>step3：</strong><br>连接了之后，就是提交操作了，提交其实一共有3个步骤，不要胡乱pull跟push就什么都不会了。<br><strong>PS：只要IDEA的项目已经成功执行了步骤1和2，那么之后其实就不需要前面两个步骤了。</strong><br>①<strong>VCS — Git — add</strong><br>作用，把本地发生改变了的代码添加到branch中，其实就是先把你的代码都commit到本地的一个分支了，但这里还没有提交。<br>②<strong>VCS — Git — Commit File</strong><br>第一步的操作只是add到工作环境，还没添加到本地仓库，这里把所有add的文件commit到本地操作<br>③最后就是提交到远程仓库。这个最后一步才是pull跟push的地方。<br><strong><em>先pull，再push即可</em></strong>。<br>pull的作用其实就是先跟远程仓库的代码对比，因为可能别人已经commit过，与你的代码产生冲突，这时候你需要解决这些冲突再commit，不然你把别人的代码覆盖了怎么办？<br>push就是最后的提交代码了，一般pull成功的话push也就没有问题。</p><p>但是，在第一次创建的时候，可能会存在问题，好像是因为不在同一个项目里，无论是change分支，还是git pull —allow-unrelated-histories啊等等的，都不行。<br>其实第一次创建，又不可能conflict（唯一可能conflict的地方只有一个readme文件而已。。）<br>所以干脆直接强制push即可: <strong>git push -u origin master -f</strong> (-f 很显然，就是force）</p><p>其他常用操作：<br>查看远程仓库： git remote -v (remote就是远程的意思）<br>添加远程仓库： git remote add (nick_name) (repository-url)<br>删除仓库（注意是删除与仓库的连接而已)：git remote remove nick_name<br>（一般nick_name都叫origin了，不知为何，先这样记着）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下IDEA项目提交到GitHub的整体操作:（主要是清晰每一步的作用，而不是死记硬背）&lt;br&gt;&lt;strong&gt;step1:&lt;/strong&gt;&lt;br&gt;IDEA的GitHub&lt;strong&gt;连通配置&lt;/strong&gt;。（这个就在setting-git那里，但一般配置一次就不再需要了，pass）&lt;br&gt;&lt;strong&gt;step2：&lt;/strong&gt;&lt;br&gt;将本地的项目连接到GitHub。 &lt;em&gt;VCS — Import into Version&lt;/em&gt; Control （会让你创建一个仓库）&lt;br&gt;然后再将项目切实地与该仓库连接。&lt;em&gt;VCS — Import into Version Control — Create Git Repository&lt;/em&gt;&lt;br&gt;（有一次没有Create，右键项目甚至没有git操作）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Github" scheme="https://hongscar.cn/categories/Github/"/>
    
    
      <category term="Github" scheme="https://hongscar.cn/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>阅读Servlet的源码</title>
    <link href="https://hongscar.cn/%E9%98%85%E8%AF%BBServlet%E7%9A%84%E6%BA%90%E7%A0%81.html"/>
    <id>https://hongscar.cn/%E9%98%85%E8%AF%BBServlet%E7%9A%84%E6%BA%90%E7%A0%81.html</id>
    <published>2020-02-17T03:14:10.000Z</published>
    <updated>2020-02-19T07:09:05.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>在写SSM项目的过程中，遇到了一些小问题，不知道如何解决。其实对于框架的很多问题，很多时候都是因为框架的封装性，然后自身没有理解框架的内部逻辑而导致的。于是这次想花点时间好好读一下Servlet的源码，这样可以更好地理解JavaWeb底层，遇到问题也能更加地游刃有余。当然此次阅读源码只是比较浅显的，先看官方文档，然后在有目的性地读一部分源码来感受文档的内容。如果要认真看那肯定要看很久，目前还没这个时间。<br>    <strong>首先是Servlet API包含了两个软件包，javax.servlet和javax.servlet.http</strong>，为什么会有两个呢，因为早先设计该规范的人认为Servlet是一种服务模型，不一定要依赖于某种网络协议之上，于是就抽象出了一个javax.servlet，同时再提供一个基于HTTP协议上的接口拓展。但目前看来，似乎还没有发现有其他协议上实现的Servlet技术。</p><a id="more"></a><hr><h3 id="二-HTTPServlet抽象类"><a href="#二-HTTPServlet抽象类" class="headerlink" title="二. HTTPServlet抽象类"></a>二. HTTPServlet抽象类</h3><p><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/1.jpg" alt="img">)](<a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/1.jpg" target="_blank" rel="noopener">https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/1.jpg</a>)<br>官方解析：<br>    <em>Provides an abstract class to be subclassed to create an HTTP servlet suitable for a Web site.A subclass of HttpServlet must override at leat one method usually one of these: doGet,doPost,doPut,doDelete.</em><br>    提供一个抽象类，使得它的子类可以更方便地创建一个标准HTTP Servlet。子类必须至少实现以下方法的其中一个：<strong>doGet，doPost，doPut，doDelete</strong><br>    <strong>标准Servlet接口有一个service方法</strong>，即service的标准服务方法。但是service方法没必要override，因为HTTPServlet已经把service方法写好了，把标准的HTTP请求通过它们的HTTP request类型(即请求的doXXX)，分别转发到具体的处理方法中。比如类型是doGet，就转发到doGet方法中。<br>HttpServlet里的service方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    String method = req.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// servlet doesn't support if-modified-since, no reason</span></span><br><span class="line">        <span class="comment">// to go through further expensive logic</span></span><br><span class="line">        doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">        <span class="keyword">if</span> (ifModifiedSince &lt; (lastModified / <span class="number">1000</span> * <span class="number">1000</span>)) &#123;</span><br><span class="line">            <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                    <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                    <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">            maybeSetLastModified(resp, lastModified);</span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">        <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        可以看到是通过Java反射的机制，获取了HttpServletRequest的方法，返回了一个method的字符串，根据method来判定到底是属于哪一个doXXX，再分别调用doXXX方法。这里我钻了一下牛角尖，HttpServletRequest里有多个方法，getMethod方法的内部逻辑是如何返回的呢。HttpServletRequest只是一个接口，寻找了很久只找到了一个实现类HttpServletRequestWrapper，然而还是没有具体的getMethod实现。最后知道了这个HttpServletRequest是由J2EE的容器来实现的，比如Tomcat，webLogic。看来我们是不能得知getMethod的具体逻辑了，只需要知道它可以返回HTTP报文头的method是什么就行。<br>​        然后如果是METHOD_XXX方法，就调用doXXX方法。好几个方法都没有特别，直接调用。但HEAD方法和GET方法多了一个逻辑，用于验证文件是否已经被修改。HEAD和GET都是获取服务器上的资源，但HEAD不需要返回消息体，只请求返回报文头，空的消息体，也就是说，它可以用于检测资源是否有效，是否存在，网站是否有篡改等。当需要这类操作的时候，就不需要用GET了，用HEAD即可。如果本地有缓存文件，和要GET的文件是相同的，没有修改过的，那么此时就会返回状态码304，表示文件没有被修改。虽然返回304的时候已经做了一次数据库查询，但可以避免接下来更多的数据库查询。对于HEAD方法，只返回HTTP报文头，更是降低了带宽的消耗。<br>​    最终到达了doXXX的方法，以GET方法为例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String protocol = req.getProtocol();</span><br><span class="line">    String msg = lStrings.getString(<span class="string">"http.method_get_not_supported"</span>);</span><br><span class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">"1.1"</span>)) &#123;</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里有个特别的地方是，虽然doXXX方法有具体的实现，但它是无论如何都会返回错误的，即sendError。这是避免了具体子类直接调用HttpServlet的doXXX方法。因此子类必须重写至少1个doXXX方法，然后再通过HTTP的method判断要调用哪个doXXX方法，进而调用子类重写的doXXX方法。</p><hr><h3 id="三-Servlet-ServiceConfig接口"><a href="#三-Servlet-ServiceConfig接口" class="headerlink" title="三. Servlet, ServiceConfig接口"></a>三. Servlet, ServiceConfig接口</h3><p>​    一个Java Servlet具有生命周期，这个生命周期定义了一个Servlet如何被载入并被初始化，如何接受请求并对请求的响应，如何从服务中被清除等等。Servlet的生命周期被javax.servlet.Servlet这个接口所定义。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/5.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/5.jpg" alt="img"></a><br>​    所有的Java Servlet都会直接或间接地实现javax.servlet.Servlet接口，这样它才能在一个servlet引擎中运行。servlet引擎是web服务器按照Java Servlet API定制的拓展。Servlet引擎提供网络服务，能够理解MIME请求，并提供一个运行Servlet的容器。<br>​    只有实现了Servlet接口的才是Servlet，然后才包含Servlet的生命周期。当然，继承了HttpServlet，就是继承了GenericServlet，就是实现了Servlet接口。<br>​    ServletConfig就是用于获取Servlet的配置，比如初始化参数，参数名等等，还可以获取该Servlet的ServletContext对象。</p><hr><h3 id="四-ServletContext接口"><a href="#四-ServletContext接口" class="headerlink" title="四. ServletContext接口"></a>四. ServletContext接口</h3><p>​    Servlet上下文，服务器会为工程建立一个全局唯一的ServletContext对象，工程内部所有的Servlet都共享这个对象，可以用于读取全局配置参数，搜索资源文件等等。</p><hr><h3 id="五-ServletRequest接口等"><a href="#五-ServletRequest接口等" class="headerlink" title="五. ServletRequest接口等"></a>五. ServletRequest接口等</h3><p>ServletRequest接口，请求时产生的对象，ServletResponse接口，响应时产生的对象。<br>SingleThreadModel接口，使得Servlet成为单线程。（只接受1个请求）<br>GenericServlet类，实现了Servlet接口，使得编写Servlet更方便。<br>ServletInputStream，ServletOutputStream抽象类，继承InputStream，OutputStream<br>ServletException，UnavailableException类，没什么好说的。</p><hr><h3 id="六-Filter接口"><a href="#六-Filter接口" class="headerlink" title="六. Filter接口"></a>六. Filter接口</h3><p>​    用于对request，response等任务进行过滤，一般是用doFilter方法来过滤，可以通过FilterConfig的对象来获取Filter的初始化参数。包含了destroy，init，doFilter方法。<br>生命周期：当有Servlet的service方法要被执行时，被init，直到所有的service方法已经执行完毕doFilter，或者过了一定的时间之后，就会执行destroy方法。<br>​    对具体实现类的基本要求：<br>①要对request进行验证检查。<br>②对request和response可以选择自定义实现类去包装<br>③当有多个过滤方法的时候，需要用到过滤链FilterChain，并且在当前的Filter没执行完之前，当前的数据都不会被通过。执行完之后会继续执行chain里的下一个filter<br>④在过滤链调用下一个filter的时候，就要直接设置当前的response header（避免窜数据）<br>FilterChain的多个filter执行顺序在web.xml的filter-mapping里控制<br>FilterConfig，对Filter的初始化配置参数等等。</p><hr><h3 id="七-RequestDispatcher接口"><a href="#七-RequestDispatcher接口" class="headerlink" title="七. RequestDispatcher接口"></a>七. RequestDispatcher接口</h3><p>​    直译就是请求分发器。具备两个方法，forward和include。<br>定义了一个对象，从客户端接受请求之后，需要将请求发给服务器。有的时候需要传递给另一个资源去响应。比如用户请求资源A，A可以在接受请求后，在A上面做一些准备工作，再从A转发转发大都B，由B去响应例子。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/2.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/2.jpg" alt="img"></a><br>第一个request就是A的准备工作，第二个就是转发到B，由B去响应。</p><p>include不是转发，是包含某个资源，比如Servlet，JSP，HTML页面<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/3.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/3.jpg" alt="img"></a></p><hr><h3 id="八-HttpServletRequest，HttpServletResponse接口"><a href="#八-HttpServletRequest，HttpServletResponse接口" class="headerlink" title="八. HttpServletRequest，HttpServletResponse接口"></a>八. HttpServletRequest，HttpServletResponse接口</h3><p>继承ServletRequest，ServletResponse接口，用于处理一个HTTP格式的请求/响应<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/4.jpg" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/4.jpg" alt="img"></a><br>主要方法，setAttribute，getAttribute(继承得来的),getSession等等。Response同理。</p><hr><h3 id="九-HTTPSession接口"><a href="#九-HTTPSession接口" class="headerlink" title="九. HTTPSession接口"></a>九. HTTPSession接口</h3><p>创建一个HTTP会话。<br>方法主要是获取Session的参数(ID，creationTime，最长存在时间等等),以及setAttribute。。</p><p>HttpSessionBindingListener接口。HTTPSession监听器，添加到Session中，监听Session，此处是监听binding，绑定事件。<br>还有其他的Session的Listener，比如Attribute，Activation监听器。（也就是HttpSessionAttributeListener,HttpSessionActivationListener）</p><p>HttpSessionBindingEvent类，实现了HttpSessionBindingListener接口。只多了两个成员属性。<br>HttpUtils类，收集HTTP Servlet使用的静态的有效方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h3&gt;&lt;p&gt;在写SSM项目的过程中，遇到了一些小问题，不知道如何解决。其实对于框架的很多问题，很多时候都是因为框架的封装性，然后自身没有理解框架的内部逻辑而导致的。于是这次想花点时间好好读一下Servlet的源码，这样可以更好地理解JavaWeb底层，遇到问题也能更加地游刃有余。当然此次阅读源码只是比较浅显的，先看官方文档，然后在有目的性地读一部分源码来感受文档的内容。如果要认真看那肯定要看很久，目前还没这个时间。&lt;br&gt;    &lt;strong&gt;首先是Servlet API包含了两个软件包，javax.servlet和javax.servlet.http&lt;/strong&gt;，为什么会有两个呢，因为早先设计该规范的人认为Servlet是一种服务模型，不一定要依赖于某种网络协议之上，于是就抽象出了一个javax.servlet，同时再提供一个基于HTTP协议上的接口拓展。但目前看来，似乎还没有发现有其他协议上实现的Servlet技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Servlet" scheme="https://hongscar.cn/categories/Servlet/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>在vscode配置Java环境遇到的问题</title>
    <link href="https://hongscar.cn/%E5%9C%A8vscode%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://hongscar.cn/%E5%9C%A8vscode%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html</id>
    <published>2020-02-17T03:13:59.000Z</published>
    <updated>2020-02-17T06:20:12.587Z</updated>
    
    <content type="html"><![CDATA[<p>​        之前一直把vscode当作一个sublime的强化版，仅仅把它当作一个编辑器而已。虽然一直也清楚这是一个很好的IDE，但却没有好好利用，可能是因为之前一直觉得IntelliJ IDEA已经满足了我的需求罢。直到最近，IDEA真的是变本加厉，只要一输入（拿着键盘随便乱敲），那么CPU就会暴增。cpu暴增一般情况下倒没什么所谓，反正没有超100就行吧（刚打开的时候还真的会升到100），可是我这破电脑只要CPU稍微高一点，风扇就开始呜呜呜地，像一台发电机。明天等待工具到了真的要把它拆开来除一下灰尘，但无论如何，IDEA过于臃肿已经是显而易见的问题了，还是需要认真考虑一下如何使用vscode吧。说实话，真的没想到我这么快就会想跟IDEA说再见，还记得当时刚开始学C++，非要听信那个菜比老师，用vs2010，体验极差，而我竟然用了两年多。大二的时候开始学Java，一开始是使用Eclipse，感觉也是比vs2010提升了一个档次。后来接触到了IDEA，真的是感觉神仙一样的软件，各种智能补全。当然了，中途还因为学数媒的原因，下载了一个vs2013，那个的体验其实也很好的，反正真的应该大一的时候就直接用vs2013，而不是那脑残的vs2010。总而言之，技术永远是在进步的，需求也是在增加的，对于用户，程序员，都是一样的。</p><a id="more"></a>        其实还考虑过优化IDEA，但参照了一下网上的做法，无论是修改JVM参数，还是关闭所有代码检查，都无济于事。说实话，一开始也不抱什么希望，因为我是只要键入就会飙升，那真的不太行。<pre><code>然后开始搞vscode，突然想到了以前也尝试过，未遂。当时遇到的问题就是，它说我的JDK指向路径是空的，是version 0，可我指向的确切就是我一直使用的JDK8，我的IDEA都是在使用这个的。其实比较麻烦的是，我对vscode的各种参数，各种setting，包括快捷键，真的是几乎一无所知。当时仅仅也只是下载了几个plugins，当个普通的编辑器就完事了。最无奈的是，一直显示我没有配置JDK，或者准确地说应该是配置失败，但我直接使用一个Code Runner的插件时，直接使用alt+B就能成功运行了，可即便如此，还是不能直接点最上方的运行/ 调试，点了就报错。如果这个插件可以调试我可能就这样先暂时用着了，可是它似乎真的只能run，那只好继续处理。既然说是这个JDK有问题，那我便直接去下一个JDK吧，我下载了一个JDK12，修改了JAVA_HOME，重启电脑。结果发现java -version仍然是1.8。经过了许久的处理才发现，我以前在配置JDK的时候太过不求甚解了，导致遗留下来了很多错误。就是说，虽然这样做可以运行，但并不是正确的做法。比如JAVA_HOME其实就是用于存放JDK的一个路径，之后如果要放到ClassPath，或者Path等等的，都可以引用这个参数，%JAVA_HOME%，后面紧接着/bin，/lib等等的，差不多也就是可重用可维护了，以后如果要换JDK，直接改JAVA_HOME就行了。可我当时在ClassPath里使用了这个参数，在Path里却没有，说明当时根本就没有理解这个参数的作用。然后我把Path的绝对路径改成了JAVA_HOME，发现仍然不行。再仔细一看，原来这个根本就没有用上，因为上面还有3个不知道是什么的JavaPath，有什么AdoptOpenJDK，有Oracle commons files等等。在一台电脑上如果存在多个JavaPath，那么是最上方（win7应该就是最左方）的生效。所以我一直以为整台电脑都使用了的E盘的library下的JDK，原来根本就没有，我的环境变量竟然一直是OpenJDK，也就是说classpath跟path使用了两个不同的JDK罢了。把以前的蜜汁path都去掉之后，再把自己新增的%JAVA_HOME%/bin移动到了最上方，这下总算就成功了，java -version也成功改成了12。那么IDEA里一直用的1.8，会不会因此不能运行？答案是不会，因为IDEA根本就不需要环境变量的那个Path参数，那个是在cmd里，全局里生效的，相当于IDEA是在本地自己使用了另一个JDK。我一开始觉得JDK有点奇怪，使用java -verbose查看JDK路径，我还好奇为什么会是在C盘的一个OpenJDK里，原来是当时留下的各种错误啊。JDK总算配置好了，但vscode依然不能运行，显示不能找到主类。这会我又没有动脑子，直接去改参数瞎搞。其实这个问题我在看编程思想的第一章就应该碰到过了，因为vscode毕竟不是传统的IDEA，它本体就是一个编辑器，非常轻量级，只有40M，但它可以通过各种plugins来增强功能罢了。因此，可能就是vscode确实就是直接使用环境变量里的ClassPath跟Path，直接命令行运行程序的，而IDEA这种还有更多的改进。那么直接在cmd里编译运行java程序会有一个什么经典的问题呢，就是package。最开始学java 的时候都尝试过cmd里编译运行，结果有一天会发现，自己明明第一个程序在cmd里是可行的，但在eclipse或者IDEA把代码复制过去便是找不到主类的。唯一的区别便是package，package其实就是一个文件夹，对于javac，java命令，这个还没智能到直接跳入到相应的位置去执行正确的文件，所以当时我们的解决方案是这样的，直接删掉package语句，然后就可以运行了，但显然并不是长远之计，难道以后写的程序都不加package了吗？于是正经的方案是这样的，给命令增加一个-d参数，还有一个什么什么的，忘记了，然后就可以根据package语句进入相应的路径去执行正确的文件了。所以，在vscode里也是要对基本的命令进行修改，比如默认是java test，那么就改成 java -d …… test。所以最后是在settings里增加这段代码：</code></pre><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/vscode_1.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/vscode_1.png" alt="settings代码"></a><br>        进入相应的$dir，然后再进行javac跟java，那么就大功告成（看起来还是跟-d有所区别的）至于其他的注释，便是针对其他的语言，这里无须理会。最后把vscode进行reload，程序就成功运行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        之前一直把vscode当作一个sublime的强化版，仅仅把它当作一个编辑器而已。虽然一直也清楚这是一个很好的IDE，但却没有好好利用，可能是因为之前一直觉得IntelliJ IDEA已经满足了我的需求罢。直到最近，IDEA真的是变本加厉，只要一输入（拿着键盘随便乱敲），那么CPU就会暴增。cpu暴增一般情况下倒没什么所谓，反正没有超100就行吧（刚打开的时候还真的会升到100），可是我这破电脑只要CPU稍微高一点，风扇就开始呜呜呜地，像一台发电机。明天等待工具到了真的要把它拆开来除一下灰尘，但无论如何，IDEA过于臃肿已经是显而易见的问题了，还是需要认真考虑一下如何使用vscode吧。说实话，真的没想到我这么快就会想跟IDEA说再见，还记得当时刚开始学C++，非要听信那个菜比老师，用vs2010，体验极差，而我竟然用了两年多。大二的时候开始学Java，一开始是使用Eclipse，感觉也是比vs2010提升了一个档次。后来接触到了IDEA，真的是感觉神仙一样的软件，各种智能补全。当然了，中途还因为学数媒的原因，下载了一个vs2013，那个的体验其实也很好的，反正真的应该大一的时候就直接用vs2013，而不是那脑残的vs2010。总而言之，技术永远是在进步的，需求也是在增加的，对于用户，程序员，都是一样的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IDE" scheme="https://hongscar.cn/categories/IDE/"/>
    
    
      <category term="IDE" scheme="https://hongscar.cn/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>记一次服务器CPU100%的问题</title>
    <link href="https://hongscar.cn/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8CPU100%%E7%9A%84%E9%97%AE%E9%A2%98.html"/>
    <id>https://hongscar.cn/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8CPU100%%E7%9A%84%E9%97%AE%E9%A2%98.html</id>
    <published>2020-02-17T03:13:34.000Z</published>
    <updated>2020-02-17T06:23:03.444Z</updated>
    
    <content type="html"><![CDATA[<p>PS：写在前面，这篇文章最后<strong>并没有解决</strong>服务器CPU100%的问题，仅仅是记录在尝试过程中学到的知识点。</p><p>​    今天原本打算使用redis连接项目，正好网站备案通过了，正打算先测试一下域名是否可用，结果反而整个项目都不可用了。想着应该又是tomcat那边的问题，先上服务器看了一下，感觉服务器的卡顿越来越厉害了，时不时就会卡住然后断开连接。想想腾讯云也不至于这么烂，于是查了一下原因。虽说最后没有解决，但当中的过程还是学习到了很多。目前先把出错的服务器保存了一个snapshot，然后对服务器进行重载。先把这个问题放下，以后再回去解决。（主要是我数据库没有进行备份，数据还在上面，而数据库也出问题了，完全无法connect，自然也无法备份了。但保存了snapshot，那么数据库文件还在里面，等到需要那部分数据的时候，就对snapshot进行载入，然后再修复错误去获取数据吧，现在先放下这个问题）</p><a id="more"></a>    首先就是先运行了一下top命令，意外地发现%id为0，即CPU idle space为0，也就是CPU使用率竟然是100？那肯定是出现问题了，而且这样的话断开连接也不足为奇了，那么CPU 100%到底是从什么时候开始的，先查看了一下腾讯云的监控记录：<p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_1.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_1.png" alt="腾讯云的监控记录"></a></p><p>​    （吃惊）竟然一直是100的？我服务器上也没运行几个程序，也就一个tomcat（而且因为网站备案的原因，甚至直接stop了），还有mysql跟redis，但又没有事务读写，怎么会出现问题呢？于是我调了一下时间，调到5月初直到现在，看看是否一直都是100，还是在什么时候变成了100：</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_2.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_2.png" alt="更久之前的监控数据"></a></p><p>把鼠标指到确切的转折点，可以看到，是8月30号这天开始飙升的，而且之后就一直高居不下，那么8月30那天我在服务器上做了什么呢。翻了一下日记，我在8.30这天学习了Redis，也就是在服务器上装了Redis。虽说没什么道理，但确实如此，没有任何其他理由。等一下我还要在我刚刚重装的服务器上安装mysql跟redis，看一下还会不会出现100的问题。如果会，再重装，只安装redis。虽说后面会换另一台服务器去单独做MySQL跟redis服务器，但这个问题肯定还是要解决的。</p><hr><p>那么在解决的过程我使用了哪些命令，又遇到了哪些子问题，继续去处理的，现在列一个清单。</p><p>①首先去查询top的用法<br>top命令虽然是我实习的时候用得最熟练的命令，但时间过去太久了，我也记不清它的很多数值是什么意思。然后知道了%Cpu就是CPU的使用情况，其中：%us表示用户空间程序的CPU使用率，%sy表示系统（Kernel）的CPU使用率，%ni表示用户空间且通过nice调度过的程序的CPU使用率。<br><em>CPU time = user space time + system space time</em><br>至于nice调度，其实就是进程的优先级，大致先知晓即可。<br>%id：空间的CPU（我就是这里一直是0，也就是idle space为0，CPU使用率100）</p><p>②除了CPU，还有可能是内存的问题<br>    对着top使用回车（刷新），发现CPU idle space很奇怪，会变化，而且要么是0，要么是100，显然是出现了一个错误的进程，然后突然导致100，而且还是一直生成，短暂过后又结束。最坑的是，使用top并找不到一个高CPU使用率的进程，所以完全不理解为何是100？可能是top显示的只是用户进程，不显示系统进程？<br>    于是继续对磁盘进行查看，使用了df -h命令。图片没有存，但大概是，磁盘空间大小是50G，已经使用了41G。虽然安装软件的时候没有想太多，但毕竟只安装了几个软件，不至于这么大的空间，因而对这块还是存有疑惑。然后再查看了腾讯云的磁盘监控（对了，腾讯云的监控出错了，然后还得执行一段命令才能查看，但就是很简单地copy执行一次即可，就在腾讯云官方上的代码）。最后的磁盘监控结果是这样的：</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_3.png" target="_blank" rel="noopener"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/cpu100_3.png" alt="磁盘监控结果"></a></p><p>当时的磁盘读写一直很大，我就猜测是MySQL出现了错误，然后一直在编写错误日志？</p><p>③处理MySQL中的问题<br>    首先，我当时安装MySQL并没有直接安装服务service，这确实不是一个好的选择，tomcat也是如此。平时偶尔想对服务进行处理，使用systemctl，结果显示没有此service。然后还得去安装路径里自己调用shell脚本，然后还得找到这个安装路径，又是locate又是find，又是whereis的。<br>    然后想先看一下错误日志在哪，以往每次打开文件都是vim，实际上用head跟tail是一个很好的选择。不然突然一下子出现一大串文字的体验也是很差劲的。<br>    不过尝试了很多次，都无法彻底关闭mysql。这也就是安装法的最差劲的地方吧。找到了mysqld进程，都直接kill -9了，依然没有用处。如果是安装服务，直接systemctl stop即可。</p><p>④其他命令<br>因为top没有看到高CPU利用率的进程，于是还尝试了一些其他命令。<br>vmstat：查看系统负载<br>pidstat：查看进程使用磁盘的情况<br>pidstat -d 1：<br>netstat -na | grep 80 查找<em>80</em> 的端口（看是否开放，正在使用）</p><p>⑤finally<br>    其实没有解决问题，所以只能用最笨的方法，重装系统。虽然重装系统很快，一分钟就结束了，但还是很不好。首先必须得对服务器进行snapshot备份，毕竟数据库的数据也取不出来（感觉出错的原因主要就是MySQL跟redis的错）。然后数据至少存在了snapshot当中，等到需要那部分数据或者有空的时候，再new一个服务器去尝试解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：写在前面，这篇文章最后&lt;strong&gt;并没有解决&lt;/strong&gt;服务器CPU100%的问题，仅仅是记录在尝试过程中学到的知识点。&lt;/p&gt;
&lt;p&gt;​    今天原本打算使用redis连接项目，正好网站备案通过了，正打算先测试一下域名是否可用，结果反而整个项目都不可用了。想着应该又是tomcat那边的问题，先上服务器看了一下，感觉服务器的卡顿越来越厉害了，时不时就会卡住然后断开连接。想想腾讯云也不至于这么烂，于是查了一下原因。虽说最后没有解决，但当中的过程还是学习到了很多。目前先把出错的服务器保存了一个snapshot，然后对服务器进行重载。先把这个问题放下，以后再回去解决。（主要是我数据库没有进行备份，数据还在上面，而数据库也出问题了，完全无法connect，自然也无法备份了。但保存了snapshot，那么数据库文件还在里面，等到需要那部分数据的时候，就对snapshot进行载入，然后再修复错误去获取数据吧，现在先放下这个问题）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://hongscar.cn/categories/Linux/"/>
    
    
      <category term="Debug" scheme="https://hongscar.cn/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>关于链表的一些疑惑</title>
    <link href="https://hongscar.cn/%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E6%83%91.html"/>
    <id>https://hongscar.cn/%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E6%83%91.html</id>
    <published>2020-02-17T03:13:20.000Z</published>
    <updated>2020-02-17T06:19:44.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>​        链表想通的时候，感觉很简单，比数组还简单，只需要维护一个next指针，然后对指针进行操作即可。但有的时候也会遇到想不通的情况，这时候即便是非常简单的问题，都很难解决。所以这篇文章总结一下链表可能遇到的疑惑，下次遇到的时候查阅即可，无须每次都进行艰难的debug。</p><a id="more"></a><h5 id="当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？"><a href="#当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？" class="headerlink" title="当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？"></a>当next指向一个对象的时候，该对象发生变化，那么原本的next指向的内容会不会也发生变化？</h5><p>出现这个疑惑是在一个非常简单的题目：<strong><em>反转一个链表</em></strong>。<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" target="_blank" rel="noopener" title="反转链表"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" alt="反转链表" title="反转链表"></a><br>当时就觉得很奇怪，理应是非常简单的，却感觉不会做，画了很久的图，最后还用了4个指针才完成了，代码也是略显复杂。然后一看标准答案，果然跟预期的一样，十分简洁，但当时没有深究，于是后面总是要还的。因为一个地方不明白，后面肯定还会出现，这时候只会更加麻烦。<br>接下来看一下当时看不懂的标准答案：<br><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" target="_blank" rel="noopener" title="答案"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_2.png" alt="答案" title="答案"></a></p><p>当时的疑惑很简单，curr.next指向了prev，但紧接着，prev就又发生了改变，那么curr.next不会改变吗？这看起来有点违反直觉，一开始觉得应该是二者指向了相同的地址，然后地址发生了改变，二者也就同时改变，但其实并不是这样的。这里最关键的就是引用的概念了。这里实际上是两个引用，curr.next跟prev，而curr.next = prev表示的是，curr.next指向了prev引用指向的对象。之后prev指向了其他的对象，并不会对curr.next造成影响。</p><hr><p>但是有的地方看起来是会发生改变，为什么？<br>首先要确定，到底改变的是对象，还是一个引用指向了其他的对象。<br>立刻想到的就是遍历，移除某个元素的例子：（移除所有val等于某个值的结点）</p><p><a href="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_1.png" target="_blank" rel="noopener" title="链表移除某个元素的例子"><img src="https://my-blog-1253941628.cos.ap-guangzhou.myqcloud.com/2020-02-14/images/20191108/linkedlist_3.png" alt="链表移除某个元素的例子" title="链表移除某个元素的例子"></a></p><p>这里对current操作，最后为什么head也会改变？<br>首先解答一个很简单的问题，为什么要有current，而不是直接在head上操作。因为我们在中间会将current后移（current = current.next)，这就导致了我们最后如果返回的是current，那么current已经移到了最后，即使前面的结果是正确的，也没有意义。<br>为什么要提这个问题？因为我一开始对于这个就想错了。我最开始对current引用的理解是，在current上操作，避免对head发生改变。但我们确实就是希望head发生改变啊，毕竟我们最后返回的就是改变后的head。所以我们确实就是通过current指向了head，然后改变current的中间结构，同时也成功地改变了head的中间结构，但我们要获取最终的链表，那么就需要获取头结点，所以才不对head进行操作。所以我们仅仅是保留了最初的头指针而已，如果上面的答案，是对head操作，最后返回的是current，作用也是一样的。<br>接下来就是问题的关键了，那么为什么会跟着改变？看起来current只是一个对象的引用罢了。这就是引用跟对象的区别了，这里的current确实是一个引用，但current.next却是一个实打实的存在于内存中的对象。所以，current.next = current.next.next，是直接在对象上发生改变，那么自然head.next(也就是现在的current.next）也会跟着改变了。而current = current.next，就是引用指向了其他的对象，也就是current引用指向了current.next。由于是引用指向了其他对象，那么显然也不会对head发生改变了。（所以关键就是确定到底是改变引用指向，还是改变对象）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;​        链表想通的时候，感觉很简单，比数组还简单，只需要维护一个next指针，然后对指针进行操作即可。但有的时候也会遇到想不通的情况，这时候即便是非常简单的问题，都很难解决。所以这篇文章总结一下链表可能遇到的疑惑，下次遇到的时候查阅即可，无须每次都进行艰难的debug。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Datastructure" scheme="https://hongscar.cn/categories/Datastructure/"/>
    
    
      <category term="interview" scheme="https://hongscar.cn/tags/interview/"/>
    
  </entry>
  
</feed>
